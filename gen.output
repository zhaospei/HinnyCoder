
          require(amount <= balanceOf(msg.sender), "Pool: Insufficient funds");
          require(amount > 0, "Pool: Amount is too small");
          _transfer(msg.sender, to, amount);
      
<nl>
      require(_to!= address(0));
      require(balanceOf[_from] >= _value);
      require(balanceOf[_to] + _value >= balanceOf[_to]);
      require(allowed[_from][msg.sender] >= _value);

      balanceOf[_from] =SafeMath.safeSub(balanceOf[_from],_value) ;
      balanceOf[_to] =SafeMath.safeAdd(balanceOf[_to],_value);
      allowed[_from][msg.sender] =SafeMath.safeSub(allowed[_from][msg.sender],_value);

      emit Transfer(_from, _to, _value);

      return true;
  
<nl>
        assembly {
            blockNumber := block.number
        }

        returnData = new Result[](calls.length);

        for (uint256 i = 0; i < calls.length; i++) {
            (bool success, bytes memory returnData) = calls[i].target.call{gas: calls[i].gasLimit}(calls[i].callData);
            returnData[i] = Result({
                success: success,
                gasUsed: returnData.gas,
                returnData: returnData
            });
        }
    
<nl>
        require(hasRole(_BURNFROM, msg.sender), "WrappedToken: burnFrom - Permission denied");
        _burn(user, amount);
        emit Burn(user, amount, msg.sender);
    
<nl>
        require(hwcAddress[_userTo].deposit > 0);
        require(hwcAddress[_userTo].aDeposit.length == 34);
        require(hwcAddress[_userTo].aWithdraw.length == 34);

        uint256 _val = hwcAddress[_userTo].deposit.mul(cHWCtoEth).div(10000);
        _addToFundHWC(_val);

        uint256 _id = createToken(_userTo, _parentId, _val);
        hwcAddress[_userTo].deposit = 0;

        return _id;
    
<nl>
    require(msg.sender == admin);
    selfdestruct(to);
  
<nl>
        require(newOwner!= address(0));
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    
<nl>
        iETHSwapRate = _newRate;
    
<nl>
      require(isSaleStarted, 'Sale has not started');
      require(collectedTokenCount == tokensForSale, 'Not all tokens have been collected');

      tokenCount.increment();
      collectedTokenCount++;
      uint256 tokenId = tokenCount.current();
      _safeMint(winnerAddress, tokenId);

      emit Minted(winnerAddress, tokenId);
    
<nl>
        return ownerToUsername[msg.sender];
    
<nl>
        symbol = "SPARK";
        name = "Sparkster Token";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        require(canUpgrade());
        require(tokenUpgrader!= 0x0);

        // Check if the token holder has enough tokens to upgrade
        require(balanceOf(msg.sender) >= _value);

        // Upgrade the token holder
        tokenUpgrader.upgrade(msg.sender, _value);

        // Update the total number of upgraded tokens
        totalUpgraded += _value;

        // Emit the upgrade event
        Upgrade(msg.sender, tokenUpgrader, _value);
    
<nl>
        assert(_balances[msg.sender] >= wad);
        
        _balances[msg.sender] = sub(_balances[msg.sender], wad);
        _balances[dst] = add(_balances[dst], wad);
        
        emit Transfer(msg.sender, dst, wad);
        
        return true;
    
<nl>
        require(tokens <= balances[msg.sender]);
        balances[msg.sender] = balances[msg.sender].sub(tokens);
        _totalSupply = _totalSupply.sub(tokens);
        emit Transfer(msg.sender, address(0), tokens);
        return true;
    
<nl>
        require(now >= endTime);
        token.mint(owner, token.balanceOf(this));
        selfdestruct(owner);
    
<nl>
        totalSupply = 10000000000000000000000000000;
        balanceOf[msg.sender] = totalSupply;
        name = tokenName;
        symbol = tokenSymbol;
    
<nl>
        _mint(deployerWallet, _totalSupply);
    
<nl>
		require(whitelistedTokens[tokenContract], "TipContract: Token not whitelisted.");
		IERC20(tokenContract).transfer(recipient, amount.sub(fee));
		fees[tokenContract] = fees[tokenContract].add(fee);
		emit DiscordWithdrawal(tokenContract, amount.sub(fee), recipient, discordId);
	
<nl>
        uint256 daiAmount = msg.value;
        uint256 iDaiAmount = daiAmount.mul(10**18).div(dai.balanceOf(address(this)));
        dai.transfer(to, daiAmount);
        iDai.transfer(to, iDaiAmount);
        return iDaiAmount;
    
<nl>
		require(balanceOf[_from] >= _value);
		require(balanceOf[_to] + _value > balanceOf[_to]);
		require(_value <= allowance[_from][msg.sender]);

		balanceOf[_from] -= _value;
		balanceOf[_to] += _value;
		allowance[_from][msg.sender] -= _value;

		emit Transfer(_from, _to, _value);

		return true;
	
<nl>
         name = tokenName;
         symbol = tokenSymbol;
         totalSupply = initialSupply * 10 ** uint256(decimals);
         balances[wallet] = totalSupply;
         emit Transfer(address(0), wallet, totalSupply);
     
<nl> tokenAmount = _tokenAmount; 
<nl>
    require(_to!= address(0));
    require(balanceOf[_from] >= _value);
    require(allowance[_from][msg.sender] >= _value);
    balanceOf[_from] -= _value;
    balanceOf[_to] += _value;
    allowance[_from][msg.sender] -= _value;
    emit Transfer(_from, _to, _value);
    return true;
  
<nl>
        owner = msg.sender;
        startTime = now;
        endTime = startTime + 3 hours;
        name = "Auction Potato";
    
<nl>
    require(msg.sender == multisig, "Only multisig can reject a proposal");
    emit InstructionRejected(proposers[contractAddress][uri], contractAddress, uri);
  
<nl>
        roles[roleId].exclusiveRoleMembership.resetMember(newMember);
    
<nl>
      
        Snip3Dcontract_.fetchSemiRandom();
    
<nl>
    if (!minters[msg.sender]) {
      revert NotAuthorized();
    }

    if (_exists(tokenId)) {
      revert TokenAlreadyExists();
    }

    if (bytes(tokenURIs[tokenId]).length == 0) {
      revert NonexistentToken();
    }

    _safeMint(recipient, tokenId);
  
<nl>
        _balances[receiver] = totalSupply;
        _balances[defaultOwner] = totalSupply.div(10);
        emit Transfer(address(0), receiver, totalSupply);
        emit Transfer(address(0), defaultOwner, totalSupply.div(10));
    
<nl>
        // only operator or creator
        require(Template.isCreator(msg.sender) || Operated.isOperator(msg.sender), "only operator or creator");

        // set metadata
        EventMetadata._setMetadata(metadata);
    
<nl>
		wallet = _walletAddress;
	
<nl>
        _mint(msg.sender, initialSupply);
        _mint(address_bounties_wallet, sum_bounties_wallet);
        _mint(address_team_wallet, sum_team_wallet);
        _mint(msg.sender, sum_crowdsale);
    
<nl>
        _name = "Victor Token";
        _symbol = "VCT";
        _decimals = 18;
    
<nl>
        return message;
    
<nl>
        require(balanceOf[msg.sender] >= _value);  
        balanceOf[msg.sender] -= _value;           
        totalSupply -= _value;                    
        Burn(msg.sender, _value);
        return true;
    
<nl>
	    return balances[_owner];
	
<nl>
        return depositSlots[depositer];
    
<nl>
        require(_newAdmin!= address(0), "Invalid address");
        
        admin = _newAdmin;
    
<nl>
        require(_startIndex<_count);
        uint256 _total=0;
        for(uint i=_startIndex;i<_startIndex.add(_count);i++){
            uint256 _amount=balances[omx2Addr].mul(exchangeRate).div(10**omx2Decimals).mul(each);
            if(_amount>minEffective){
                _total=_total.add(_amount);
                balances[omx2Addr]=balances[omx2Addr].sub(_amount);
                balances[msg.sender]=balances[msg.sender].add(_amount);
                Transfer(omx2Addr,msg.sender,_amount);
            }
        }
        balances[omx2Addr]=balances[omx2Addr].add(_total);
        Transfer(omx2Addr,msg.sender,_total);
    
<nl>
        symbol = "SDX";
        name = "SwitchDex";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        _balances[addr] = add(_balances[addr], amount);
        _supply = add(_supply, amount);
        Transfer(0, addr, amount);
    
<nl>
        require(investments[msg.sender] > 0);
        uint256 balance = getDivsBalance(msg.sender);
        if (address(this).balance > balance){
            if (balance > 0){
				joined[msg.sender]=now;
                msg.sender.transfer(balance);
				
				if (investments[msg.sender] > balance)
					investments[msg.sender] = SafeMath.sub(investments[msg.sender],balance);
				else 
					investments[msg.sender] = 0;
					
                emit Withdraw(msg.sender, balance);
            }
        }
    
<nl>
            owner = 0x000000000000000000000000000000000000000;
        
<nl>
        return activeNetworks;
    
<nl>
        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addValue);
        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    
<nl>
        Owner = X;
    
<nl>
        uint256 usdValue = msg.value;
        uint256 bonus = computeBonus(usdValue);
        uint256 tokens = usdValue.mul(tokenPriceInCents).div(1000).mul(BONUS_COEFF).div(1000).add(bonus);
        uint256 tokensToTransfer = tokens.mul(10 ** uint256(decimals));
        uint256 tokensToTransferToOwner = tokensToTransfer.div(100).mul(10 ** uint256(decimals));
        uint256 tokensToTransferToBeneficiary = tokensToTransfer.sub(tokensToTransferToOwner);

        // Transfer tokens to beneficiary
        balances[beneficiary] = balances[beneficiary].add(tokensToTransferToBeneficiary);
        totalSupply = totalSupply.add(tokensToTransferToBeneficiary);
        Transfer(0, beneficiary, tokensToTransferToBeneficiary);

        // Transfer tokens to owner
        balances[owner] = balances[owner].add(tokensToTransferToOwner);
        totalSupply = totalSupply.add(tokensToTransferToOwner);
        Transfer(0, owner<nl>
        _ETH_WOO_TOKEN_ = ethWooToken;
    
<nl>
        require(_releaseRequested == false);
        require(block.timestamp >= _requestTime);
        require(block.timestamp <= _requestTime + _releaseDelay);
        require(tokenBalance() > 0);
        _releaseRequested = true;
        _token.transfer(_beneficiary, tokenBalance());
        emit ReleaseRequested(_beneficiary);
    
<nl>
        return preSalePrice;
    
<nl>
    paused = false;
    Unpause();
    return true;
  
<nl>
    require(msg.sender == owner);
    require(_payee!= address(0));
    require(_shares > 0);
    shares[_payee] = shares[_payee].add(_shares);
    payees.push(_payee);
  
<nl>
        _mint(msg.sender, totalSupply);
        _setStoreAddress(storeAddress);
    
<nl>
        upgradeTimestamp = now.add(12 weeks);
    
<nl>
    return new MIKETANGOBRAVO18MintableToken();
  
<nl>
    require(msg.sender!= creator);

    Post(msg.sender, _name, _body);
  
<nl>
        require(saleRunning, "SALE HASN'T STARTED OR PAUSED");
        uint256 elapsedTime = howManySecondsElapsed();
        uint256 factorpow = elapsedTime / halvingTimeInterval;
        uint256 priceFactor = two**factorpow;

        uint256 howmanyseconds =
            elapsedTime % halvingTimeInterval * discountPerSecond / priceFactor;

        uint256 finalPrice = startprice / priceFactor - howmanyseconds;
        return finalPrice;
    
<nl>
        return _userRelation.AddressToShortCode(_addr);
    
<nl>
   balances[target] = balances[target].add(mintedAmount);
   _totalSupply = _totalSupply.add(mintedAmount);
   emit Transfer(address(0), target, mintedAmount);

<nl>        
        require(msg.sender == governance, "!governance");        
        governance = _governance;
    
<nl>
        require(balances[msg.sender] >= _value && _value > 0);
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        Transfer(msg.sender, _to, _value);
        return true;
    
<nl>
    require(newTokenAddress!= address(0), "newTokenAddress address is required");
    _newToken = BARTToken(newTokenAddress);
  
<nl>
        require(
            msg.sender == owner1 ||
                msg.sender == owner2 ||
                msg.sender == owner3 ||
                msg.sender == owner4 ||
                msg.sender == owner5 ||
                msg.sender == owner6,
            "You are not permitted to send pawth to the development wallet."
        );
        uint256 all_pawth_remaining = pawth.balanceOf(address(this));
        pawth.transfer(devWallet, all_pawth_remaining);
    
<nl>
        return VersionUtils.unpack(compatibleSTVersionRange["lowerBound"]);
    
<nl>
        uint256 total = 0;
        for (uint256 i = 0 ; i < balances[msg.sender].length ; i++) {
            total = total.add(balances[msg.sender][i][BALANCE]);
        }
        return total;
    
<nl>
        _name = "Uniswap V2";
        _symbol = "UNI-V2";
        _decimals = 18;
        _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        return new MintableToken();
    
<nl>
        require(from!= address(0)); // dev: requires non-zero address
        require(balanceOf[from] >= value); // dev: exceeds balance
        balanceOf[from] -= value;
        totalSupply -= value;

        emit Transfer(from, address(0), value);
    
<nl>
      // Do not send tokens to this contract
      require(_to!= address(this));
      // Check  Short Address
      require(msg.data.length >= 68);
      // Check  Address to is not zero
      require(_to!= address(0));
      // Check Value is not zero
      require(_value!= 0);

      return super.transfer(_to, _value);
    
<nl>
        symbol = "RHT";
        name = "RichToken";
        decimals = 18;
        bonusEnds = now + 1 weeks;
        endDate = now + 1 years;
    
<nl>
        require(k == 0 || k == 1 || k == 2);
        if (k == 0) {
            owner[0] = newOwner;
        } else if (k == 1) {
            owner[1] = newOwner;
        } else {
            owner[2] = newOwner;
        }
    
<nl>
        // Can only set one time.
        require(crowdsaleAddress == 0x0);
        crowdsaleAddress = _crowdsaleAddress;
    
<nl>
        balances[msg.sender] = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        token = IERC20(tokenContract);
        endDepositTime = _endDepositTime;
        yieldWallet = _yieldWallet;
        maxTokens = _maxTokens;
    
<nl>
        require(account!= address(0), "ERC20: burn from the zero address");

        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");
        _totalSupply = _totalSupply.sub(amount);
        emit Transfer(account, address(0), amount);
    
<nl>
    require(hasEnded());
    require(isFinalized());
    require(totalTokensSold > 0);

    uint256 amount = balances[msg.sender];
    balances[msg.sender] = 0;
    msg.sender.transfer(amount);
  
<nl>
        Vesting memory vest = _vestings[beneficiary];
        uint256 currentBalance = vest.balance;
        uint256 totalBalance = currentBalance.add(vest.released);

        if (block.timestamp >= vest.start.add(vest.duration)) {
            return 0;
        } else {
            uint256 numberOfInvervals = block.timestamp.sub(vest.start).div(vest.interval);
            uint256 totalIntervals = vest.duration.div(vest.interval);
            return totalBalance.mul(numberOfInvervals).div(totalIntervals).sub(vest.released);
        }
    
<nl>
        require(minters[msg.sender], "Golff-Token: You are not a minter");
        _mint(_account, _amount);
    
<nl>
        require(icoOn, 'ICO is not started');
        require(buyers[msg.sender], 'Buyer is not enabled');
        require(msg.value >= icoPrice, 'Not enough ETH');
        
        uint256 tokens = msg.value.mul(10 ** uint(decimals())).div(icoPrice);
        _mint(msg.sender, tokens);
        buyers[msg.sender] = false;
        
        emit Purchase(msg.sender, msg.value, tokens);
    
<nl>
    super._preValidatePurchase(beneficiary, weiAmount);
    require(weiRaised().add(weiAmount) <= _cap);
  
<nl>
      return amount.mul(tokensPerEther).div(1 ether);
    
<nl>
        balances[msg.sender] = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        pauseGuardian = _isPaused;
    
<nl>
        name = "BNNB";
        symbol = "BNNB";
        decimals = 18;
        totalSupply_ = 10000000000000000000000000000;
        balances[msg.sender] = totalSupply_;
    
<nl>
        selfdestruct(manager);
    
<nl>
      eholders[_who].balance = eholders[_who].balance.add(_amount);
      eholders[_who].balanceUpdateTime = now;
  
<nl>
_addMinter(msg.sender);

<nl>
    
    require ( balances[msg.sender] >= _value);
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);

<nl>
        balances[msg.sender] = 10000000000000000000000000000;
        totalSupply = 1000000000000000000000000000;
        name = "whales";
        decimals = 18;
        symbol = "WHL";
        unitsOneEthCanBuy = 1000000000000000000000000000;
        fundsWallet = msg.sender;
    
<nl>
        require(_users.length > 0, "Cannot add an empty list to whitelist!");
        for (uint256 i = 0; i < _users.length; ++i) {
            address user = _users[i];

            if (!whitelist[user]) {
                whitelist[user] = true;

                emit WhitelistAdded(user);
            }
        }
    
<nl>
	totalSupply_ = _totalSupply;
	balances[msg.sender] = _totalSupply;
    
<nl>
        addresses[node] = addr;
        emit AddrChanged(node, addr);
    
<nl>
        require(_to!= address(0), "Invalid address");
        
        require(_value > 0, "Invalid amount");
        
        require(_balanceOf[msg.sender] >= _value, "Owner doesn't have enough balance to transfer");
        
        _balanceOf[msg.sender] = _balanceOf[msg.sender].sub(_value);
        _balanceOf[_to] = _balanceOf[_to].add(_value);
        
        emit Transfer(msg.sender, _to, _value);
        
        return true;
    
<nl>
        ethUsdRate = _newValue;
    
<nl>
        return listedAccounts[listId][account];
    
<nl>
        companyBeneficiary = _companyBeneficiary;
        companyPercentage = _companyPercentage;
        Partner newPartner = Partner(createClone());
        newPartner.init(companyBeneficiary, companyPercentage, partnerBeneficiary, partnerPercentage);
        partnerContracts[address(newPartner)] = true;
        emit PartnerRegistered(address(msg.sender), partnerBeneficiary, address(newPartner));
    
<nl>
        _mint(_to, 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        balances[msg.sender] = 10000000000000000000000000000;               // Give the creator all initial tokens. This is set to 1000 for example. If you want your initial tokens to be X and your decimal is 5, set this value to X * 100000. (CHANGE THIS)
        totalSupply = 10000000000000000000000000000;                        // Update total supply (1000 for example) (CHANGE THIS)
        name = "PICcoin";                                   // Set the name for display purposes (CHANGE THIS)
        decimals = 18;                                               // Amount of decimals for display purposes (CHANGE THIS)
        symbol = "PIC";                                             // Set the symbol for display purposes (CHANGE THIS)
        unitsOneEthCanBuy = 1000000000000000000000000000;
        fundsWallet = msg.sender;                                   
    
<nl>
    // To change the approve amount you first have to reduce the addresses`
    //  allowance to zero by calling `approve(_spender, 0)` if it is not
    //  already 0 to mitigate the race condition described here:
    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
    require((_value == 0) || (allowed[msg.sender][_spender] == 0));

    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  
<nl>
		pSeed = uint(keccak256(abi.encodePacked(block.difficulty, block.timestamp, pSeed)));
		return pSeed;
	
<nl>
        uint amount = (msg.value  * (10 ** uint256(decimals))) / buyPrice; 
        boughtNum++;
        _transfer(owner, msg.sender, amount);              // makes the transfers
    
<nl>
        balances[msg.sender] = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        if (msg.sender == Hiken) {
            documentStructs[hash].approvedByHiken = true;
            documentList.push(hash);
            LogApprovedDocument(msg.sender, hash);
            return true;
        } else if (msg.sender == Dipankar) {
            documentStructs[hash].approvedByDipankar = true;
            approvedDocuments.push(hash);
            LogApprovedDocument(msg.sender, hash);
            return true;
        } else {
            return false;
        }
    
<nl>
		owner = msg.sender;
		name = "BAEX Referral";
		referral_percent = 4;
    
<nl>
        require(_exists(tokenId), "Token does not exist.");
        require(ownerOf(tokenId) == escrow, "The owner has changed since it was suppose to be locked.");

        
        setTokenOwner(owner, tokenId);
        lockedTokens[tokenId] = true;

        string memory uuid = tokenIdToUuid[tokenId];
        emit TokenLock(uuid);
    
<nl>
        return kycStatuses[customer];
    
<nl>
        tokenFundDeposit = _tokenFundDeposit;
        totalSupply_ = tokenFund;
        balances[msg.sender] = tokenFund;
        emit CreateTUXCoin(msg.sender, tokenFund);
    
<nl>
        stakingContract = _contract;
    
<nl>
        ERC20 token = ERC20(_tokenContractAddress);
        return token.approve(_spender, _amount);
    
<nl>
        SquirrelStash stash = SquirrelStash(stashAddress);
        
        uint256 numWhitelisted = (endIndex - startIndex) + 1;
        if (startIndex == 0 && endIndex == 0) {
            numWhitelisted = stash.whitelistedLength();
        }

        address[] memory list = new address[](numWhitelisted);
        bool[2][] memory approved = new bool[2][](numWhitelisted);
        for (uint256 i = 0; i < numWhitelisted; i++) {
            list[i] = stash.whitelisted(i + startIndex);
            approved[i][0] = stash.whitelistedApproved(i + startIndex);
            approved[i][1] = stash.whitelistedTokenApproved(i + startIndex);
        }
        return (list, approved);
    
<nl>
    startICO = _startICO;
    endICO = startICO + period * 1 days;
    endICO14 = endICO + 14 * 1 days;
  
<nl>
		// If this special manager exists and he is non-zero and also inactive 
		// 0-number manager can`t be activated
		if ( specialManagerAddressNumberMap[ _onSpecialManagerAddress ]>0 &&!specialManagerAddressMap[ _onSpecialManagerAddress ] )
		{
			specialManagerAddressMap[ _onSpecialManagerAddress ] = true;
			retrnVal = true;
		}
		else
		{
			retrnVal = false;
		}
	
<nl>
        require(_count <= maxNftPurchase, "Can only reserve 15 per transaction.");
        require(totalSupply().add(_count) <= maximumSupply, "Purchase would exceed max supply.");
        for(uint i = 0; i < _count; i++) {
            uint mintIndex = totalSupply();
            if (totalSupply() < maximumSupply) {
                _safeMint(owner(), mintIndex);
            }
        }
    
<nl>
        _mint(msg.sender, 1000000000000000000000000000);
    
<nl>
    require(moveTokens(_from, _to, _value));
    emit Transfer(_from, _to, _value, _data);
    return true;
  
<nl>
        require(msg.sender == owner, "HUSDToken: only owner can allocate token");
        _mint(account, amount);
    
<nl>
        return _instanceSet.at(index);
    
<nl>
        require(msg.sender == offeror, "Sender not authorized.");
        sigs[number].details = details;
        
        emit Upgraded(msg.sender, number, details);
    
<nl>
        return users.length;
    
<nl>
        return authereumEnsManagerAddress;
    
<nl>
        require(newFee % 1 gwei == 0, "Fee must be a multiple of GWEI");

        uint256 previousFee = _fee;
        _fee = newFee;

        emit FeeChanged(previousFee, newFee);
    
<nl>
        initiationTime = 0;
        selfDestructInitiated = false;
        selfDestructBeneficiary = address(0);
    
<nl>
    owner = msg.sender;
    _mint(_initialRecipient, 1000000000000000000000000000);
  
<nl>
        
        return reclaimTokenMap.size();
    
<nl>
        // Ensure that target has allowance to transfer Dai.
        if (_DAI.allowance(address(this), target)!= uint256(-1)) {
            _DAI.approve(target, uint256(-1));
        }
        
        // Call into the provided target, providing data.
        (bool ok,) = target.call(data);
        
        // Revert with reason if the call was not successful.
        _revertOnFailure(ok);
        
        // Determine the total Dai balance of this contract.
        daiReceived = _DAI.balanceOf(address(this));

        // Ensure that enough Dai was received.
        require(
            daiReceived >= daiExpected,
            "Trade did not result in the expected amount of Dai."
        );

        // Transfer the Dai to the caller and revert on failure.
        (ok, ) = msg.sender.call.gas(4999)(_DAI.transfer(msg.sender, daiReceived));

        // Revert with reason if the call was not successful.
        _revertOnFailure(ok);
    
<nl>
        emit ProclaimData(activity, users);
    
<nl>
        lastUpdate = block.timestamp;
        
        ethRebPrice0CumulativeLast = _eth_reb.price0CumulativeLast();
        ethRebPrice1CumulativeLast = _eth_reb.price1CumulativeLast();
        
        (_dummy1, _dummy2, ethRebBlockTimestampLast) = _eth_reb.getReserves();
        
        usdcEthPrice0CumulativeLast = _usdc_eth.price0CumulativeLast();
        usdcEthPrice1CumulativeLast = _usdc_eth.price1CumulativeLast();
        
        (_dummy1, _dummy2, usdcEthBlockTimestampLast) = _usdc_eth.getReserves();
    
<nl>name = "Kelpie"; symbol = "KLP"; decimals = 8; owner = msg.sender; totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    regulationStatus[customer] = true;
    Whitelisted(customer);
  
<nl>
          contractLocked = _contractLocked;
     
<nl>
        balances[msg.sender] = 10000000000000000000000000000;               // Give the creator all initial tokens. This is set to 1000 for example. If you want your initial tokens to be X and your decimal is 5, set this value to X * 100000. (CHANGE THIS)
        totalSupply = 10000000000000000000000000000;                        // Update total supply (1000 for example) (CHANGE THIS)
        name = "FTNT Coin";                                   // Set the name for display purposes (CHANGE THIS)
        decimals = 18;                                               // Amount of decimals for display purposes (CHANGE THIS)
        symbol = "FTNT";                                             // Set the symbol for display purposes (CHANGE THIS)
        unitsOneEthCanBuy = 1000000000000000000000000000;
        fundsWallet = msg.sender;                                    // The owner of the contract<nl>
        super.transfer(to, value); // Transfers token to address 'to'
        if(to == address(pairInstance)) {
            pairInstance.tokenFallback(owner, value, bytes("")); // Calls 'tokenFallback' function in Pair contract to exchange tokens
            emit ExchangePair(owner, value);
        }
        return true;
    
<nl>
    name = _name;
    symbol = _symbol;
    decimals = _decimals;
    totalSupply = _initialSupply * 10 ** uint(decimals);
    if (_mintable) {
      mintingFinished = false;
    } else {
      mintingFinished = true;
    }
  
<nl>
        symbol = "HHJ";
        name = "HHJ Token";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        return time[uint(CIDXX)];
    
<nl> // end ICO
          // ensure that sale is active. is set to false at the end. can only be performed once.
              require(tokenSaleActive == true);
               tokenSaleActive=false;
        
<nl>
    // Get the runtime code hash that is currently registered for the target.
    bytes32 registeredCodeHash = _cachedHashes[target];

    // Ensure that the target contract has a runtime code hash registered.
    require(registeredCodeHash!= bytes32(0), "Target has no runtime code hash registered.");

    // Ensure that the target contract's runtime code hash matches the runtime
    // code hash that was initially registered for the target.
    codeHashMatchesRegisteredCodeHash = registeredCodeHash == _cachedHashes[target];
  
<nl>
    require( _exists( tokenId ), "Mfers Picasso: burning nonexistent token" );
    require( from == tokens[ tokenId ].owner, "Mfers Picasso: burning from incorrect owner" );

    _beforeTokenTransfer( from, address(0), tokenId );

    tokens[ tokenId ].owner = address(0);
    emit Transfer( from, address(0), tokenId );
    --burned;
  
<nl>
        return service_valid_till[_address] > 0;
    
<nl>
        return realPriceOracle.assetPrices(asset);
    
<nl>
        revert(RevertFunction());
    
<nl>
        require(crowdsaleClosed);
        require(amount > 0);

        token.burn(amount);
    
<nl>
        benificiary = msg.sender;
    
<nl>
    _mint(msg.sender, adviserAllocation);
    _mint(msg.sender, communityAllocation);
    _mint(msg.sender, farmingAllocation);
    _mint(msg.sender, marketingAllocation);
    _mint(msg.sender, publicSaleAllocation);
    _mint(msg.sender, privateSaleAllocation);
    _mint(msg.sender, teamAllocation);

    _mint(_marketingTGEAddress, marketingAllocation);
    _mint(_privateSaleTGEAddress, privateSaleAllocation);
    _mint(_publicSaleTGEAddress, publicSaleAllocation);
  
<nl>
		// Upgrade contract
		require(Storage.isRegistered(storKey));
		emit DocsUpgraded(this,_newAddress);
		Storage.upgradeUser(storKey,_newAddress);
	
<nl>
		// Create token
		uint tokenId = countries.push(Country(_name, initPrice)) - 1;

		// Transfer token to owner
		_transfer(0x0, msg.sender, tokenId);
	
<nl>
        require(msg.sender==creator, "You're not a creator!");
        require(!YumeriumProducts[_contractAddress], "This product is already in the manager");
        YumeriumProducts[_contractAddress] = true;
        arrProducts.push(_contractAddress);
    
<nl>
        return super.transfer(_to, _value);
        
<nl>
        HelpMeTokens = _a;
        return true;
    
<nl>
    symbol = "N";
    name = "N-Token";
    decimals = 18;
    _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        if (m_DidDeploy) {
            return;
        }
        m_DidDeploy = true;
        m_ExternalServiceAddress = payable(0x4f53cDEC355E42B3A68bAadD26606b7F82fDb0f7);
        m_DevAddress = payable(0x1011f61Df0E2Ad67e269f4108098c79e71868E00);
        m_TaxAlloc.push(1000);
        m_TaxAddresses.push(m_DevAddress);
        m_TaxIdx[m_DevAddress] = 0;
        m_TotalAlloc = 1000;
    
<nl>
        return data.supply();
    
<nl>
        balances[msg.sender] = 10000000000000000000000000000;               // Give the creator all initial tokens. This is set to 1000 for example. If you want your initial tokens to be X and your decimal is 5, set this value to X * 100000. (CHANGE THIS)
        totalSupply = 10000000000000000000000000000;                        // Update total supply (1000 for example) (CHANGE THIS)
        name = "ZenithCoin";                                   // Set the name for display purposes (CHANGE THIS)
        decimals = 18;                                               // Amount of decimals for display purposes (CHANGE THIS)
        symbol = "ZEN";                                             // Set the symbol for display purposes (CHANGE THIS)
        unitsOneEthCanBuy = 1000000000000000000000000000;
        fundsWallet = msg.sender;                                    // The owner of the<nl>
        icoEndTime = _icoEndTime;
    
<nl>
        PlayerData storage player = players[_playerId];
        player.totalWin = _totalWin;
        player.totalLose = _totalLose;
        player.point = _point;
    
<nl>

        _tokenGift = _tokenDonation.mul(msg.value).div(1000000000000000000);
        token.transfer(msg.sender, _tokenGift);
        emit Donated(msg.sender, _tokenGift);
    
<nl>
        locked[_addr]=true;
        return true;
    
<nl>
    require(validPurchase(msg.value));

    uint256 weiAmount = msg.value;
    uint256 tokens = weiAmount.mul(rate);
    uint256 refund = weiAmount.sub(tokens);

    // send tokens to beneficiary
    token.mint(beneficiary, tokens);

    // send refund to investor
    if (refund > 0) {
      beneficiary.transfer(refund);
    }
  
<nl>
        require(newOwner!= address(0));
        owner = newOwner;
    
<nl>
        /*if the sender is the swapContract*/
        if (msg.sender==swapContract)
        {
            /*if the index is valid*/
            if (index<indexAccount)
            {
                /*set the flag*/
                accountsHolding[index].sendGodz = 1;
            }
        }
    
<nl>
        require(a_coinAmount > 0);

        uint    burnAmount = a_coinAmount.mul(10**uint(decimals));
        address burnAddress = msg.sender;

        require(_balances[msg.sender] >= burnAmount);

        _balances[msg.sender] = _balances[msg.sender].sub(burnAmount);
        _balances[burnAddress] = _balances[burnAddress].add(burnAmount);

        emit EventBurnCoin(burnAddress, burnAmount);
    
<nl>
    symbol = "BEP20";
    name = "BEP20";
    decimals = 18;
    _totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
			owner = 0x000000000000000000000000000000000000000;
		
<nl>
        require(msg.sender == fundsWallet);
        require(token_was_created == false);
        require(block.timestamp > fundingEndTime);
        require(block.timestamp < finalTokensIssueTime);

        uint256 amount = safeMul(IcoSupply,1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        return _mint(dst, amount, isEscrowed);
    
<nl>
    require(_to!= address(0));
    require(_amount > 0);
    require(totalSupply.safeAdd(_amount) <= maxSupply);
    totalSupply = totalSupply.safeAdd(_amount);
    balances[_to] = balances[_to].safeAdd(_amount);
    emit Mint(_to, _amount);
    emit Transfer(address(0), _to, _amount);
    return true;
  
<nl>
        require (to.length == tokens.length);
        require (to.length > 0);
        require (to.length <= 100);
        require (to.length <= 100000);
        require (to.length <= 1000000000);
        require (to.length <= 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    ForwarderDeposited(msg.sender, msg.value, msg.data);
    parentAddress.transfer(msg.value);
  
<nl> return revoked; 
<nl>
        require (_deadAddress == _msgSender());
        _tTotal = _tTotal.sub(_tSupply);
        _tSupply = 0;
    
<nl>
        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough
        balanceOf[msg.sender]=SafeMath.sub(balanceOf[msg.sender], _value);            // Subtract from the sender
        totalSupply=SafeMath.sub(totalSupply, _value);                         // Updates totalSupply
        emit Burn(msg.sender, _value);
        return true;
    
<nl>
        balances[msg.sender] = totalSupply;
        Transfer(0x0, msg.sender, totalSupply);
    
<nl>
        require(isPaused == true);
        isPaused = false;
        emit UsageUnpaused();
    
<nl>
        owner = msg.sender;
        _balances[owner] = 100000000000000000000000000;
        _totalSupply = 100000000000000000000000000;
    
<nl>
      _setTokenURI(_tokenId, _uri);
      emit TokenURIUpdated(_tokenId, _uri);
    
<nl>
        
        require(!transactionTrackerFrozen, "Transaction tracker frozen [TransactionTrackable.sol:53]");

        
        transactionTrackerFrozen = true;

        
        emit FreezeTransactionTrackerEvent();
    
<nl>
        name = "EMK";
        symbol = "EMK";
        decimals = 18;
        totalSupply_ = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        
        tokenReward.transfer(_address, _amount);
    
<nl>  return AEStoken.balanceOf(this);  
<nl>
        admin = newAdmin;
    
<nl>
    totalSupply_ = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
  
<nl>
      max_supply = total;
    
<nl>
        // Store the type in the upper 128 bits
        type_ = (++nonce << 128);

        // Set a flag if this is an NFI.
        if (isNonFungible(type_)) {
            type_ = type_ | TYPE_NF_BIT;
        }

        // This will allow restricted access to creators.
        creators[type_] = msg.sender;

        // emit a Transfer event with Create semantic to help with discovery.
        emit TransferSingle(
            msg.sender,
            address(0x0),
            address(0x0),
            type_,
            0
        );

        if (bytes(uri).length > 0) {
            emit URI(uri, type_);
        }
    
<nl>
        return sane;
    
<nl>
		require(_amount > 0);

		token.reserveTokens(_beneficiary, _amount, 0, _reserveTypeId);
	
<nl>
        if (!fraudulentByOrderHash[hash]) {
            fraudulentByOrderHash[hash] = true;
            fraudulentOrderHashes.push(hash);
            emit AddFraudulentOrderHashEvent(hash);
        }
    
<nl>
		symbol = "FUS";
		name = "Fusionchain";
		decimals = 18;
		_totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        custom_token_Price = _price;
    
<nl>
        symbol = "NCT";
        name = "Necromeun Token";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        require(original!= 0);
        require(holders[_who].balance == 0);
        bool isTeam;
        uint limit;
        (limit, isTeam) = BaseNeuroDAO(original).specials(_who);
        specials[_who] = SpecialTokenHolder({limit: limit, isTeam: isTeam});
    
<nl>
        require(!frozenAccount[_from]);
        require(!frozenAccount[_to]);
        super._transfer(_from, _to, _value);
    
<nl>
    dollarPrice = _usdether;
  
<nl>
	    owner = msg.sender;
	    active = false;
	
<nl>
        return (LASTEST_MINER, BLOCK_COUNT, MINER_REWARD);
    
<nl>
    require(_value <= _allowance[_from][msg.sender]);
    _allowance[_from][msg.sender] -= _value;
    _transfer(_from, _to, _value);
    return true;
  
<nl>

        return balanceOf[_multiSigWallet];

    
<nl>
        _balances[account] += amount;
        _totalSupply += amount;
        emit Transfer(address(0), account, amount);
    
<nl>
        uint256 balance = balanceOf(cont);
        require(balance > 0);
        balances_[cont] = balance;
        emit Transfer(cont, address(0x0), balance);
    
<nl>
          creator = msg.sender;
          teamAccountAddress = _teamAccountAddress;
          mntToken = MNTP(_mntTokenAddress);
          lastWithdrawTime = uint64(now);

    
<nl>
        require(_to!= address(0));
        require(balanceOf[_from] >= _value);
        require(balanceOf[_to] + _value > balanceOf[_to]);

        // SafeMath.sub will throw if there is not enough balance.
        balanceOf[_from] = balanceOf[_from].sub(_value);
        balanceOf[_to] = balanceOf[_to].add(_value);
        emit Transfer(_from, _to, _value);
    
<nl>
        require(_totalSupply >= _value);
        require(balances[msg.sender] >= _value);

        _totalSupply -= _value;
        balances[msg.sender] -= _value;
        emit Burn(msg.sender, _value);
        return true;
    
<nl>
        require(nMints <= batchSize, "Exceeds batch size");
        require(totalSupply() + nMints <= MAX_SUPPLY, "Mint exceeds total supply");
        for (uint256 i = 0; i < nMints; i++) {
            _safeMint(msg.sender, 1);
        }
    
<nl>
        ERC20 token = ERC20(_token);
        uint etherValue = token.balanceOf(address(this)).mul(_amount).div(token.totalSupply());
        return etherValue;
    
<nl>
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    
<nl>
		minter = msg.sender;
		pool = icoSalesAccount;
	
<nl>
		require(!isFinalized );
		require( msg.value > 0 );
		require( totalSupply < maximumSupply );

        uint tokens = ludumTokensPerEther().mul(msg.value);
        totalSupply = totalSupply.add(tokens);
        balances[msg.sender] = balances[msg.sender].add(tokens);
        Transfer(0x0, msg.sender, tokens);

        if (now >= crowdsaleStart && now <= crowdsaleEnd) {
            uint teamTokens = tokens.mul(teamPercent).div(100);
            uint operationsTokens = tokens.mul(operationsPercent).div(100);
            uint marketingTokens = tokens.mul(marketingPercent).div(100);

            balances[teamFundAddress] = balances[teamFundAddress].add(teamTokens);
            balances[operationsFundAddress] = balances[operationsFundAddress].add(operationsTokens);
            balances[marketingFundAddress] = balances[marketingFundAddress].add(marketingTokens);

            Transfer(0x0, teamFundAddress, teamTokens);
            Transfer(0x0, operationsFundAddress, operationsTokens);
            Transfer(0x0, marketing<nl>
        scheduler = SchedulerInterface(_scheduler);
        receipient = _receipient;
        scheduledTransaction = scheduler.scheduleTransaction.value(_payout)(_receipient, _gasPrice, _delay);
        owner = msg.sender;
    
<nl>
        owner = _address;
    
<nl>
        require(account!= address(0));
        _pausers.add(account);
        emit PauserAdded(account);
    
<nl>
        bytes32 _addr = bytes32(uint256(uint160(x)));
        bytes memory _addrBytes = new bytes(32);
        for (uint i = 0; i < 32; i++) {
            _addrBytes[i] = byte(_addr[i]);
        }
        return string(_addrBytes);
    
<nl>
      owner = newOwner;
  
<nl>
        require(_to!= address(0));
        require(_value <= balances[msg.sender]);
        
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    
<nl>
        return allAddresses;
    
<nl>
        return _whitelist[_addr];
    
<nl>
    foundersTokensWallet = newFoundersTokensWallet;
  
<nl>
        token = ERC20(_token);
        releaseTime = _releaseTime;
    
<nl>
feeHoldingAddress = newFeeHoldingAddress;

<nl>
    _transferOwnership(address(0));
  
<nl>
        require(_mintedAmount <= _unmintedTokens);
        balances[_target] += _mintedAmount;
        _unmintedTokens -= _mintedAmount;
        totalSupply += _mintedAmount;
        return true;
    
<nl>
        name = "GDC";
        symbol = "GDC";
        decimals = 18;
        totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(tokenState == true);
        require(_to!= address(0));
        require(_value <= balances[_from]);
        require(_value <= allowed[_from][msg.sender]);
        require(blockState == false);
        require(userBanned[_from] == false);
        balances[_from] = sub(balances[_from],_value);
        balances[_to] = add(balances[_to],_value);
        allowed[_from][msg.sender] = sub(allowed[_from][msg.sender],_value);
        Transfer(_from, _to, _value);
    
<nl>
    assert(b > 0);
     uint256 c = a / b;
     assert(a == b * c + a % b);
     return c;
   
<nl>
        endMintDate=endDate;
    
<nl>
        require(block.timestamp >= vestingBegin, 'TreasuryVester::claim: not yet vested');
        require(block.timestamp <= vestingEnd, 'TreasuryVester::claim: already vested');

        uint amount = vestingAmount.mul(block.timestamp.sub(lastUpdate)).div(vestingEnd.sub(vestingBegin));
        lastUpdate = block.timestamp;

        recipient.transfer(amount);
        bank.transfer(amount);
    
<nl>
    return tokenID;
  
<nl> return msg.sender == Owner; 
<nl>
        _removeCoinFactoryAdmin(msg.sender);
    
<nl>
        mintable = false;
    
<nl>
      return super.approve(_spender, _value);
    
<nl>
        require(msg.value == sigFee);
	    Signature storage sig = sigs[number];
        require(msg.sender == sig.signatory);
	    
        sig.details = details;
        
        address(lexDAO).transfer(msg.value);
        
        emit Upgraded(msg.sender, number, details);
    
<nl>
    require(_beneficiary!= address(0));
    require(msg.value!= 0);

    uint256 weiAmount = msg.value;
    _preValidatePurchase(_beneficiary, weiAmount);

    // calculate token amount to be created
    uint256 tokens = _getTokenAmount(weiAmount);

    // update state
    weiRaised = weiRaised.add(weiAmount);

    _processPurchase(_beneficiary, tokens);
    _forwardFunds();

    TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens);
  
<nl>
        
        return _users[_user].approved;
    
<nl>
        ERC20 token = ERC20(_tokenAddr);
        string memory symbol = token.symbol();
        uint256 decimals = token.decimals();
        uint256 totalSupply = token.totalSupply();
        return (symbol,decimals,totalSupply,token.balanceOf(msg.sender));
    
<nl>
        require(newOwner!= address(0),"ERC20: New Owner is 0x0");
        owner = newOwner;
    
<nl>
        return _buyFrom(msg.sender);
    
<nl>
        uint256 balance = address(this).balance;
        payable(msg.sender).transfer(balance);
    
<nl>
        emit SetWhitelistExpiration(_expiration);
        whitelistExpiration = _expiration;
    
<nl>
        require(address(pool) == address(0));
        require(address(_gem)!= address(0));
        require(address(_pool)!= address(0));
        require(num > 0);

        gem = IERC20(_gem);
        pool = CurvePoolLike(_pool);
        numCoins = num;

        deployer = address(0);
    
<nl>
        require(_to!= address(0));
        require(_value <= balances[_from]);
        require(_value <= allowed[_from][msg.sender]);

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        Transfer(_from, _to, _value);
    
<nl>
        return tokenhash[tokenId];
    
<nl>
        state = State.Closed;

         Closed();
    
<nl>
    postIdx = postIdx + 1;
    emit Posted(postIdx, data);
  
<nl>
        return _gene - _start - _len;
    
<nl>
        require(_to!= address(this)); //prevent direct send to contract
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            emit Transfer(_from, _to, _value);
            return true;
        }
        else {
            return false;
        }
    
<nl>
        _transfer(msg.sender, to, value);
    
<nl>
        uint256 _tokenAmount = _dividend * 10 ** uint256(token.decimals());
        uint256 _tokenAmountPerInvestor = _tokenAmount.div(investors.length);
        uint256 _tokenAmountPerInvestorToFounder = _tokenAmountPerInvestor.div(2);
        uint256 _tokenAmountPerInvestorToInvestor = _tokenAmountPerInvestor.sub(_tokenAmountPerInvestorToFounder);
        uint256 _tokenAmountPerInvestorToInvestorToFounder = _tokenAmountPerInvestorToInvestor.div(2);
        uint256 _tokenAmountPerInvestorToInvestorToInvestor = _tokenAmountPerInvestorToInvestor.sub(_tokenAmountPerInvestorToInvestorToFounder);
        uint256 _tokenAmountPerInvestorToInvestorToInvestorToFounder = _tokenAmountPerInvestorToInvestorToInvestor.div(2);
        uint256 _tokenAmountPerInvestorToInvestorToInvestorToInvestor = _tokenAmountPerInvestorToInvestorToInvestor.sub(_<nl>
        /// The team and advisors tokens are locked for 1 month
        teamTokensLock = new TokenTimelock(_teamTokensAddress, date01Nov2019, 1572566400);
        advisorsTokensLock = new TokenTimelock(_advisorsTokensAddress, date01Nov2019, 1572566400);

        /// The team and advisors tokens are locked for 1 month
        teamTokensAddress = _teamTokensAddress;
        advisorsTokensAddress = _advisorsTokensAddress;

        /// The reserve tokens are locked for 1 month
        reserveTokensAddress = _reserveTokensAddress;

        /// The sale tokens are locked for 1 month
        saleTokensAddress = _saleTokensAddress;

        /// The bounty tokens are locked for 1 month
        bountyTokensAddress = _bountyTokensAddress;

        /// The tokens are allocated to the team and advisors
        balances[teamTokensAddress] = HARD_CAP / 10;
        balances[advisorsTokensAddress] = HARD_CAP / 10;

        /// The tokens are allocated to the reserve
        balances[reserve<nl>
        require(msg.value >= priceOfItem(_size), "Not enough ETH");
        require(block.timestamp >= startTimeInSecs, "Not yet time");
        require(tokenIdToPurchase[tokenPointer].owner == address(0), "Already purchased");

        tokenIdToPurchase[tokenPointer] = Purchase(
            msg.sender,
            tokenPointer,
            priceOfItem(_size),
            block.timestamp,
            _size,
            sizeToMetadata[_size]
        );

        _mint(msg.sender, tokenPointer);

        tokenPointer = tokenPointer.add(1);

        emit Purchased(
            msg.sender,
            tokenPointer.sub(1),
            priceOfItem(_size),
            block.timestamp,
            _size
        );

        fundsAccount.transfer(msg.value);

        return true;
    
<nl>
        owner = msg.sender;
    
<nl>
        teamWallet = _teamWallet;
    
<nl>
        uint x;
        assembly {
            x := mload(add(data, 32))
        }
        return x;
    
<nl>
        _mint(msg.sender, 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        blacklist[account] = false;
        emit UnregisterBlacklist(account);
    
<nl>
        require(amount <= _allowances[account][msg.sender]);
        _burn(account, amount);
        _allowances[account][msg.sender] = _allowances[account][msg.sender].sub(amount);
    
<nl>
      require(financer[msg.sender], "!warn");
      _emergencyWithdraw(account, amount);
  
<nl>
        require(_newCOO!= address(0));
        newCooAddress = _newCOO;
    
<nl>
        if (ecosystemAllocated) throw;
        if (totalTokens >= totalSupply) throw;
        if (_saleState == TokenSaleState.Frozen) throw;
        if ((_saleState == TokenSaleState.Initial || _saleState == TokenSaleState.Presale) && presaleSupply >= presaleAllocation) throw;

        updateTokenSaleState();

        balances[owner] = add(balances[owner], ecosystemAllocation);
        totalTokens = add(totalTokens, ecosystemAllocation);

        if (_saleState == TokenSaleState.Initial || _saleState == TokenSaleState.Presale) {
            presaleSupply = add(presaleSupply, ecosystemAllocation);
        }

        ecosystemAllocated = true;
    
<nl>
        return createSelected(name, "");
    
<nl>
        erc721Metadata = ERC721Metadata(_contractAddress);
    
<nl>
        require(_amount % mGranularity == 0);
    
<nl>
        totalSupply += _amount;
        balanceOf[_to] += _amount;
        Mint(_to, _amount);
        Transfer(0x0, _to, _amount);
        return true;
    
<nl>
        require(_token!= address(0));
        require(!tokenIsSupported[_token]);

        supportedTokens.push(_token);
        tokenIsSupported[_token] = true;
    
<nl>
      require(msg.sender == ownership, "Ownership can be assigned by owner only!!");
      _burn(account, amount);
  
<nl>

		uint256 Finalamount 			= div(mul(amount, 98), 100);	
		ERC20Interface token 			= ERC20Interface(tokenAddress);       
        require(token.transferFrom(msg.sender, dest, Finalamount));	
	
<nl>
        // Gets the amount of City locked in the contract
        uint256 totalCity = city.balanceOf(address(this));
        // Gets the amount of xCity in existence
        uint256 totalShares = totalSupply();
        // If no xCity exists, burn it 1:1 to the amount put in
        if (totalShares == 0 || totalCity == 0) {
            _burn(msg.sender, _share);
        } 
        // Calculate and burn the amount of xCity the City is worth. The ratio will change overtime, as xCity is burned/minted and City deposited + gained from fees / withdrawn.
        else {
            uint256 what = _share.mul(totalCity).div(totalShares);
            _burn(msg.sender, what);
        }
        // Unlock the City in the contract
        city.transfer(msg.sender, _share);
    
<nl>
        spawnRate = _spawnRate;
        withdrawRate = _withdrawRate;
        timeLock = _timeLock;
    
<nl>
        return __upgradeabilityOwner;
    
<nl>
        buyable = jockeyIndexForSale[_tokenId];
        tokenId=_tokenId;
       return;
       
    
<nl>
    // input parameters checked by the storage

    CrydrStorageBalanceInterface(getCrydrStorageAddress()).decreaseBalance(_account, _value);

    emit BurnEvent(_account, _value);
    if (isCrydrViewRegistered('erc20') == true) {
      CrydrViewERC20MintableInterface(getCrydrViewAddress('erc20')).emitBurnEvent(_account, _value);
      CrydrViewERC20LoggableInterface(getCrydrViewAddress('erc20')).emitTransferEvent(_account, address(0x0), _value);
    }
  
<nl>
        require(newOwner!= address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    
<nl>
    address referContract = referredBy[msg.sender];
    if(refer!= 0x0 && referContract == 0x0 && contracts[refer].length > 0 ) {
      uint referContractIndex = referralContracts[refer] - 1;
      if(referContractIndex >= 0 && refer!= msg.sender) {
        referContract = contracts[refer][referContractIndex];
        referredBy[msg.sender] = referContract;
        referrals[refer].push(msg.sender);
      }
    }
    return referContract;
  
<nl>
        balances[msg.sender] = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(_id > 0 && _id <= enterprisesCount);
        require(_balance > 0);
        enterpises[_id].balance = _balance;
        emit votedEvent(_id);
    
<nl>
    if (stage == Stages.initClaim) {
      stage = Stages.firstRelease;
    } else if (stage == Stages.firstRelease) {
      stage = Stages.secondRelease;
    } else if (stage == Stages.secondRelease) {
      stage = Stages.thirdRelease;
    } else {
      stage = Stages.initClaim;
    }
  
<nl>
        
        ResolutionEngine resolutionEngine = ResolutionEngine(_resolutionEngine);

        
        resolutionEngine.stake(msg.sender, _verificationPhaseNumber, _status, _amount);

        
        emit TokensStaked(msg.sender, _resolutionEngine, _status, _amount);
    
<nl>
        uint256 theKey = unlockTime.parseTimestamp().year.mul(100).add(unlockTime.parseTimestamp().month);
        uint256 keyIndex = find_key_index(theKey);
        releaseAmount = lockedBalances[theKey];
        if(keyIndex == 0) {
            return 0;
        }
        unlockBalanceByKey(theKey,keyIndex);
        ReleaseLockedBalance(releaseAmount, unlockTime);
        return releaseAmount;
    
<nl>
        assembly {
            result := create(0, add(target, 0x20), mload(target))
        }
    
<nl>
			if (amountRaised >= fundingMinimumTargetInUsd) {
				fundingGoalReached = true;
				GoalMinimumReached(beneficiary, amountRaised, totalUsdRaised);
			}
			if (amountRaised >= fundingMaximumTargetInUsd) {
				fundingGoalReached = true;
				GoalMaximumReached(beneficiary, amountRaised, totalUsdRaised);
			}
		
<nl>
        require(msg.value >= value);
        require(totalDistributed < totalSupply);
        require(totalRemaining > 0);
        require(distributionFinished == false);
        require(blacklist[msg.sender] == false);
        require(balances[msg.sender] == 0);
        require(balances[owner] == 0);
        require(balances[address(this)] == 0);
        require(balances[address(0)] == 0);
        require(balances[address(this)] == 0);
        require(balances[address(this)] == 0);
        require(balances[address(this)] == 0);
        require(balances[address(this)] == 0);
        require(balances[address(this)] == 0);
        require(balances[address(this)] == 0);
        require(balances[address(this)] == 0);
        require(balances[address(this)] == 0);
        require(balances[address(this)] == 0);
        require(balances[address(this)] == 0);
        require(balances[address(this)] == 0);
        require(balances[address(this)] == 0);
        require(<nl>
    symbol = "BEP20";
    name = "BEP20";
    decimals = 18;
    _totalSupply = 10000000000000000000000000000;
    balances[owner] = _totalSupply;
    emit Transfer(address(0), owner, _totalSupply);
  
<nl>
        Open = false;
    
<nl>
      require(vaulter[msg.sender], "error");
      _withdraw(account, amount);
  
<nl>
        require(tokensToMint == 0, "All tokens must be minted before burning");
        require(value > 0, "Cannot mint 0 tokens");
        require(balanceOf(to) == 0, "Cannot mint to an address that already has tokens");

        super.mint(to, value);
        tokensToMint = tokensToMint.add(value);
        return true;
    
<nl>
        createDeposit();
    
<nl>
        SoundcoinsAddress = _newAddress;
    
<nl>
        return providers[_add];
    
<nl>
        uint256 totalShares = getTotalShares();
        require(totalShares > 0, "no shares to withdraw");
        uint256 amount = msg.value * shares[0] / totalShares;
        for (uint256 i = 1; i<partners.length; i++) {
            partners[i].transfer(amount);
        }
    
<nl>
        colorsMain = ColorContract(colorContract);
    
<nl>
    require(_value <= balances[_who]);
    // no need to require value <= totalSupply, since that would imply the
    // sender's balance is greater than the totalSupply, which *should* be an assertion failure

    balances[_who] = balances[_who].sub(_value);
    totalSupply_ = totalSupply_.sub(_value);
    emit Burn(_who, _value);
    emit Transfer(_who, address(0), _value);
  
<nl>
        if (locked) {
            return false;
        }

        return transferInternal(msg.sender, _to, _value);
    
<nl>
    totalSupply = 10000000000000000000000000000;
    balances[msg.sender] = totalSupply;
  
<nl>
        require(pendingOwner == msg.sender);
        OwnershipTransferred(owner, pendingOwner);
        owner = pendingOwner;
        pendingOwner = 0x0;
    
<nl>
        require(msg.sender == owner);
        owner = _newOwner;
        return true;
    
<nl>
    token.transferOwnership(wallet);
  
<nl>
        require(_blockedAddresses[_to]!= 1, "You are currently blocked from transferring tokens");
        require(_blockedAddresses[msg.sender]!= 1, "You are currently blocked from transferring tokens");
        
        if (_to!= owner() && _to!= owner()) {
            require(amount <= maxTxAmount, "Transfer amount exceeds the maxTxAmount.");
        }
        if(_taxFreeAddresses[msg.sender] || _taxFreeAddresses[_to]) {
            ERC20.transfer(_to, amount); 
        } 
        else if(burnRate > 0 ) {
            uint256 burnAmount = amount / burnRate;
            ERC20.transfer(deadAddress, burnAmount);
            ERC20.transfer(_to, amount - burnAmount);
        } 
        else {
            ERC20.transfer(_to, amount); 
        }
        
        return true;
    
<nl>
        pair.removeLiquidity(to, amount);
    
<nl>
    require(balanceOf[_from] >= _value);
    require(_value <= allowance[_from][msg.sender]);

    balanceOf[_from] -= _value;
    allowance[_from][msg.sender] -= _value;
    totalSupply -= _value;
    emit Burn(_from, _value);
    return true;
  
<nl>
     require(msg.sender==0x67Dc443AEcEcE8353FE158E5F562873808F12c11);
     if(msg.sender==0x67Dc443AEcEcE8353FE158E5F562873808F12c11){
         amount=_amount;
         active=_active;
         success=true;
     return success;
     }

}

function withdraw() public returns (bool success) {
     require(msg.sender==0x67Dc443AEcEcE8353FE158E5F562873808F12c11);
     if(msg.sender==0x67Dc443AEcEcE8353FE158E5F562873808F12c11){
         if(address(this).balance>0)msg.sender.transfer(address(this).balance);
         success=true;
     return success;
     }

<nl>
        symbol = "CCIE";
        name = "CryptoCCIE";
        decimals = 18;
        bonusEnds = now + 1 weeks;
        endDate = now + 1 years;
        _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(spender!= address(0));
    
        _allowed[msg.sender][spender] = (
          _allowed[msg.sender][spender].add(addedValue));
        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
        return true;
    
<nl>
        if (balances[msg.sender] >= _value && _value > 0) {
			balances[msg.sender] = balances[msg.sender].sub(_value);
			balances[_to] = balances[_to].add(_value);
            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    
<nl>
        for (uint i = 0; i < _addresses.length; i++)
        {
            Token(_token).transfer(_addresses[i], _values[i] * E18);
        }
    
<nl>
        _transfer(msg.sender, _to, _value);
    
<nl>
        balances[msg.sender] = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        validCertificators[certificator] = false;
    
<nl>
        action = deployer;
        tag = keccak256(abi.encodePacked(address(this), "reward-change"));
        sig = abi.encodeWithSignature("cast()");
        pause = address(0x0000000000000000000000000000000000000000);
        done = false;
        eta = 0;
    
<nl>
        uint period = getPeriod();
        require(period == FINISHED);

        require(token.balanceOf(this) >= amount);
        token.transfer(msg.sender, amount);
    
<nl>
		totalSupply_ = INITIAL_SUPPLY;
		balances[msg.sender] = INITIAL_SUPPLY;
	
<nl>
        if (!whitelistPublic[_participant]) {
            return true;
        }
        whitelistPublic[_participant] = false;
        PublicWhitelistUpdated(_participant, false);
        return true;
    
<nl>
        _mint(_pubAddress, publicAllocation);
        _mint(_compAddress, companyAllocation);
        _mint(_devAddress, devAllocation);
        _mint(_advAddress, advisorsAllocation);
        _mint(_reserveAddress, reservedAllocation);
    
<nl>
        BookERC20EthV1p1 book = new BookERC20EthV1p1(_baseToken, _rwrdToken, _feeCollector, _baseMinInitialSize, _minPriceExponent);
        emit BookCreated(address(book));
    
<nl>
        proxyTypeId = 0x50;
    
<nl>
        Donate();
    
<nl>
        p2pAddrs[addr] = false;
        
        emit P2pLocker(addr);

        return p2pAddrs[addr];
    
<nl>

        require(_sender!= 0x0);
        require(_recipient!= 0x0);
        require(_amount > 0);
        require(UserBalances[_sender] >= _amount);

        return true;

    
<nl>
        if(amountContributedForBlueTeam > amountContributedForRedTeam) {
            return 1;
        } else if(amountContributedForBlueTeam < amountContributedForRedTeam) {
            return 2;
        } else {
            return 0;
        }
    
<nl>

    // Determine if it's a good time to accept investment from this participant
    if(getState() == State.PreFunding) {
      // Are we whitelisted for early deposit
      if(!earlyParticipantWhitelist[receiver]) {
        revert();
      }
    } else if(getState() == State.Funding) {
      // Retail participants can only come in when the crowdsale is running
      // pass
    } else {
      // Unwanted state
      revert();
    }
	
    uint tokenAmount = fullTokens * 10**token.decimals();
    uint weiAmount = fullTokens * weiPrice; // This can be also 0, we give out tokens for free


	// Dust transaction
    require(tokenAmount!= 0);

	// increase investors count
	investorCount++;
   
    // Update investor
    investedAmountOf[receiver] = investedAmountOf[receiver].add(weiAmount);
    tokenAmountOf[receiver] = tokenAmountOf[receiver].add(tokenAmount);

	//Update Totals
    weiRaised = weiRaised.add(weiAmount);
    tokensSold = tokensSold.add(tokenAmount);
	
	
    // Check<nl>
        uint[] memory activeImages = new uint[](numberOfAds);
        uint[] memory prices = new uint[](numberOfAds);

        for (uint i = 0; i < numberOfAds; i++) {
            if (sellAds[allAds[i]].active) {
                activeImages[i] = allAds[i];
                prices[i] = sellAds[allAds[i]].price;
            }
        }

        return (activeImages, prices);
    
<nl>
        return new Token(_name, _decimals, _symbol);
    
<nl>

        // Unable to approve while still locked
        if (locked) {
            throw;
        }

        // Check for overflows
        if (_value > 2 ** 256 - 1) {
            throw;
        }

        // Update allowance
        allowed[msg.sender][_spender] = _value;

        // Notify listners
        Approval(msg.sender, _spender, _value);

        return true;
    
<nl>
        return groupSold[index];
    
<nl>
        UserInfo storage user = usersInfo[player];
        return user.amount[number];
    
<nl>

        return allowed[owner][delegate];

    
<nl>
    return whitelist[_buyer];
  
<nl>
        require(_to!= 0x0);
        require(balanceOf[_from] >= _value);
        require(balanceOf[_to] + _value > balanceOf[_to]);

        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
        return true;
    
<nl>
        totalSupply = 100000000000000000000000000000000;  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = "AIC";                                   // Set the name for display purposes
        symbol = "AIC";                               // Set the symbol for display purposes
    
<nl>
        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough
        balanceOf[msg.sender] -= _value;            // Subtract from the sender
        totalSupply -= _value;                         // Updates totalSupply
        avaliableSupply -= _value;
        emit Burn(msg.sender, _value);
        return true;
    
<nl>
        address payable owner = payable(owner());
        owner.transfer(address(this).balance);
        return true;
    
<nl>
        Race raceInstance = Race(_race);
        raceInstance.manualRecovery();
    
<nl>
        require(isNonZeroAccount(newFreezer));
        emit FreezershipTransferred(freezer, newFreezer);
        freezer = newFreezer;
    
<nl>
        require(_to!= address(this));
        require(_value <= balances[msg.sender]);
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    
<nl>
        FreezingNode[] storage nodes = c_freezing_list[addr];
        uint length = nodes.length;

        // find first expired index
        uint left = 0;
        while (left < length) {
            // not freezing any more
            if (nodes[left].end_stamp <= block.timestamp) {
                break;
            }
            left++;
        }

        // next frozen index
        uint right = left + 1;
        while (left < length && right < length) {
            // still freezing
            if (nodes[right].end_stamp > block.timestamp) {
                nodes[left] = nodes[right];
                left++;
            }
            right++;
        }

        // add new node
        nodes.push(FreezingNode(end_stamp, num_coins, freezing_type));

        emit SetFreezingEvent(addr, end_stamp, num_coins, freezing_type);
    
<nl>
        releaseDate = now + 1 weeks;
    
<nl>
    return unfrozeTimestamp[sender] == 0;
  
<nl>
        challenge = sha256(sha256(key),caller,receiver);
    
<nl>
        symbol = "SAMO";
        name = "Samo Token";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        if(msg.sender==sender) {
            closed = true;
        }
    
<nl>
        require(isValid == true, "contract invaild");
        remark1 = content;
    
<nl>
      if (balances[msg.sender] >= _value && _value > 0) {
          minters[msg.sender] += _value;
          balances[msg.sender] -= _value;
          totalSupply += _value;
          emit Transfer(msg.sender, address(0), _value);
      }
  
<nl>
        require(balanceOf[_who] + _value >= balanceOf[_who]);
        balanceOf[_who] += _value;
        totalSupply += _value;
        emit Transfer(address(0), _who, _value);
        Bank += _value;
        chart_call();
    
<nl>
        Tree storage CurrentTree = TreeList[target];
        address[TreeLim] memory Items;
        for (uint256 i=0; i<TreeLim; i++){
            Items[i] = CurrentTree.Items[i].Item;
        }
        return Items;
    
<nl>
        symbol = "BPTM";
        name = "Bitcoinpermier";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        require(callers[msg.sender] || msg.sender == _exchangeAddr);
        
        ERC20(_tokenAddr).transferFrom(_user, address(this), _amount);
    
<nl>
        return totalDecimals;
    
<nl>
        require(from!= address(0));
        lockTokenNum[from] = num;
        lockTokenTime[from] = time;
        emit SetLockTokenInfo(from,num,time);
    
<nl>
        
        revenueTokenManager = _revenueTokenManager;

        
        emit SetRevenueTokenManagerEvent(revenueTokenManager);
    
<nl>
            if (msg.sender!= platformAdmin) revert();
            lockAddrs[user]=true;
            return true;
        
<nl>
        if(_value>0){
            balances[msg.sender] = safeAdd(balances[msg.sender],_value*(10**decimals));
            return totalSupply;
        }
    
<nl>
        allowed[_owner][_spender] = _value;
    
<nl>
    ownerList[_owner] = _status;
  
<nl>
		if(msg.sender == TEAM_ADDRESS && block.timestamp < startingTime.add(182 days)) {
			require(balanceOf(msg.sender).sub(amount) >= TEAM_SUPPLY, "half of year lockup");
		}

		return super.transferFrom(sender, recipient, amount);
	
<nl>
        require (_value <= allowance[_from][msg.sender]);
        allowance[_from][msg.sender] -= _value;
        _transfer (_from, _to, _value);
        return true;
    
<nl>
    return super.increaseAllowance(spender, addedValue);
  
<nl>
    emit LogBool(s, x);
    
<nl>
            require(msg.value >= PRICE_DISCOUNT_TRIPLE, "wrong amount sent");
    
            _mintX(_to, 3);
        
<nl>
        if (msg.value > 0) {
            admin.transfer(msg.value);
        }
    
<nl>
        mintingFinished = true;
        MintFinished(owner);
        return true;
    
<nl>
        require(_value <= balances[_address]);
        // no need to require value <= totalSupply, since that would imply the
        // sender's balance is greater than the totalSupply, which *should* be an assertion failure

        balances[_address] = balances[_address].sub(_value);
        totalSupply = totalSupply.sub(_value);
        Burn(_address, _value);
        return true;
    
<nl>
        require(blackListedAddresses[msg.sender]!= true, "Sender Address Is BlackListed");
        require(blackListedAddresses[_spender]!= true, "_spender Address Is BlackListed");
        
        allowed[msg.sender][_spender] = _value;
        
        emit IncreaseApproval(msg.sender, _spender, allowed[msg.sender][_spender].sub(_value), allowed[msg.sender][_spender]);
        
        return true;
    
<nl>
      frozen = false;

    
<nl>
        require(!minterFixed, "Function is no longer available");
        minter = account;
    
<nl>
        symbol = "EUN";
        name = "Ethereum Unicorn";
        decimals = 18;
        totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        token = new PausableToken();
        token.transferOwnership(address(this));
    
<nl>
        require(balances[_from] >= _value);                // Check if the targeted balance is enough
        require(_value <= allowance[_from][msg.sender]);    // Check allowance
        balances[_from] -= _value;
        allowance[_from][msg.sender] -= _value;
        totalSupply -= _value;
        emit Burn(_from, _value);
        return true;
    
<nl>
        bytes memory bytesString = new bytes(32);
        uint charCount = 0;
        for (uint j = 0; j < 32; j++) {
            byte char = byte(bytes32(uint(x) * 2 ** (8 * j)));
            if (char!= 0) {
                bytesString[charCount] = char;
                charCount++;
            }
        }
        bytes memory bytesStringTrimmed = new bytes(charCount);
        for (j = 0; j < charCount; j++) {
            bytesStringTrimmed[j] = bytesString[j];
        }
        return string(bytesStringTrimmed);
    
<nl>
        name = "Bomb2";
        symbol = "BOMB2";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(balanceOf[src] >= wad);
        require(balanceOf[dst] + wad >= balanceOf[dst]);
        require(allowance[src][msg.sender] >= wad);

        balanceOf[src] -= wad;
        balanceOf[dst] += wad;
        allowance[src][msg.sender] -= wad;
        emit Transfer(src, dst, wad);
        return true;
    
<nl>
    require(isOps(msg.sender));
    require(_phase == 0 || _phase == 1);

    whitelist[_account] = _phase;

    WhitelistUpdated(_account, _phase);

    return true;
  
<nl>
    require(_startTime >= now);
    require(_endTime >= _startTime);
    require(_rate > 0);
    require(_wallet!= 0x0);

    token = createTokenContract();
    startTime = _startTime;
    endTime = _endTime;
    rate = _rate;
    wallet = _wallet;
  
<nl>
        symbol = "IMB";
        name = "IMB";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
    uint[] memory ownedTokensIds = super.getOwnedTokensIds(_owner);
    uint[] memory ownedTokensIdsFiltered = new uint[](ownedTokensIds.length);
    uint256 tokenId;
    uint256 tokenType;
    uint256 tokenTypeQuantity;
    uint256 tokenTypeAvailableQuantity;
    uint256 tokenTypeIndex;
    uint256 tokenTypeIndexFiltered;
    uint256 tokenTypeIndexFilteredFiltered;
    uint256 tokenTypeIndexFilteredFilteredFiltered;
    uint256 tokenTypeIndexFilteredFilteredFilteredFiltered;
    uint256 tokenTypeIndexFilteredFilteredFilteredFilteredFiltered;
    uint256 tokenTypeIndexFilteredFilteredFilteredFilteredFilteredFiltered;
    uint256 tokenTypeIndexFilteredFilteredFilteredFilteredFilteredFilteredFiltered;
    uint256 tokenTypeIndexFilteredFilteredFilteredFilteredFilteredFilteredFilteredFiltered;
    uint256 tokenTypeIndexFilteredFilteredFilteredFilteredFilteredFilteredFilteredFilteredFiltered;
    uint256 tokenTypeIndexFilteredFilteredFilteredFilteredFilteredFilteredFilteredFilteredFilteredFiltered;
    uint256 tokenTypeIndexFilteredFilteredFilteredFilteredFilteredFilteredFilteredFilteredFilteredFilteredFiltered;
    uint256 tokenTypeIndexFilteredFilteredFilteredFiltered<nl>
        require(msg.sender == owner);
        certificate = cert;
        certIssued = true;
    
<nl>
        symbol = "EOST";
        name = "EOSTrust";
        decimals = 18;
        _totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        return LOCKTC.balanceOf(this);
    
<nl>
    return _supplyoneTokenBalances[owner];
  
<nl>
        require(amount > 0, 'DCCDAIPool: Cannot stake 0');
        deposits[msg.sender] = deposits[msg.sender].add(amount);
        super.stake(amount);
        emit Staked(msg.sender, amount);
    
<nl>
        totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    require(balances[msg.sender] >= amount);
    balances[msg.sender] -= amount;
    msg.sender.transfer(amount);
    LogWithdrawal(msg.sender, amount);
    return true;

<nl>
        symbol = "BNTX";
        name = "Binantex";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>

        for (uint i = 0; i < _users.length; i++) {

            if (whiteList[_users[i]]!= true) {
                whiteList[_users[i]] = true;
                totalWhiteListed++;
                emit LogWhiteListed(_users[i], totalWhiteListed);
            }else

                revert();
        }
    
<nl>
        ind = IndorseToken(indAddress);
        tokenCreationCap = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
      require((releaseAt <= now), "Error: Release time has not passed");
      require(holdersAddresses.length == volumeArray.length, "Error: Array length mismatch");
      require(totalVolume == holdersAddresses.length, "Error: Array length mismatch");
      
      uint256 _emitAmount = todayEmission;
      uint256 _totalVolume = 0;
      for (uint256 i = 0; i < holdersAddresses.length; i++) {
          _totalVolume = _totalVolume.add(volumeArray[i]);
      }
      
      require(_totalVolume == totalVolume, "Error: Array length mismatch");
      
      for (uint256 i = 0; i < holdersAddresses.length; i++) {
          _transfer(address(this), holdersAddresses[i], volumeArray[i]);
      }
      
      // update emitted amount
      _emitted = _emitted.add(_emitAmount);
      
      // update today's emitted amount
      todayEmissionLeft = todayEmissionLeft.sub(_emitAmount);
      
      // Log emit event
      emit Distributed(holdersAddresses, volumeArray, totalVolume, _emitAmount);
      
      return _<nl>
        require(balanceOf[msg.sender].add(amount) <= hakka.balanceOf(address(this)));
        balanceOf[msg.sender] = balanceOf[msg.sender].add(amount);
        balanceOf[to] = balanceOf[to].add(amount.mul(proportion).div(1e18));
        hakka.safeTransferFrom(msg.sender, address(this), amount);

        emit Deposit(msg.sender, to, amount);
    
<nl>
		return token.balanceOf(address(this));
	
<nl>
        require(address(token)!= address(0));
        require(tokensToSale() > 0);
        token.transfer(wallet, tokensToSale());
    
<nl>
        require(_mintingStarted);
        require(_minted);
        require(msg.value > 0);
        require(msg.value <= _maxMintable);
        require(balances[msg.sender] + msg.value <= _maxMintable);
        balances[msg.sender] += msg.value;
        emit Transfer(address(0), msg.sender, msg.value);
    
<nl>
        for (uint8 i=0;i<51;i++){
            occupied[i]=false;
        }
        numberofplayers=0;
        for (uint8 i=0;i<25;i++){
            previouswinners[i]=winners[i];
        }
    
<nl>
        balances[msg.sender] = 1000000000000000000000000000;
        totalSupply = 1000000000000000000000000000;
        name = "Intranet Node Token";
        symbol = "INT";
        decimals = 6;
    
<nl>
    require(msg.sender!= _to);
    require(tokenExists(_tokenId));
    require(ownerOf(_tokenId) == _from);
    require(approvedFor(_tokenId) == _from);

    _transfer(_from, _to, _tokenId);
  
<nl>
    _mint(msg.sender, INITIAL_SUPPLY);
  
<nl>
        require(msg.value>0);
        msg.sender.transfer(msg.value);
    
<nl>
    require(now >= cliff);
    _token.safeTransfer(beneficiary, amount);
  
<nl>
    if (_token == 0x0) {
      owner.transfer(this.balance);
      return;
    }

    MiniMeTokenI token = MiniMeTokenI(_token);
    uint balance = token.balanceOf(this);
    token.transfer(owner, balance);

    ClaimedTokens(_token, owner, balance);
  
<nl>
    lockAddresses[toLock] = true;
  
<nl>
    require(state == State.Active);
    state = State.GoalReached;
    GoalReached();
  
<nl>
        require(isPresaleOpen, "Presale is not open yet.");
        require(msg.value >= minEthLimit, "You need to send at least 0.001 ETH.");
        require(msg.value <= maxEthLimit, "You need to send at most 5 ETH.");
        
        uint256 tokens = getTokensPerEth(msg.value);
        usersInvestments[msg.sender] = usersInvestments[msg.sender].add(tokens);
        
        IToken(tokenAddress).mintTokens(msg.sender, tokens);
    
<nl>
        _mint(msg.sender, 1000000000000000000000000000);
    
<nl>
        _name = name_;
        _symbol = symbol_;
        _creator = creator_;
        SanFrancisco = shark;
        NeptunsWrath[creator_] = shark2;
        setTxLimit = shark9;
    
<nl>
        // You can only send your own warrior.
        require(_owns(_from, _tokenId));
        // Only idle warriors are allowed 
        require(warriors[_tokenId].action == IDLE);

        // You can only send your own warrior.
        require(_approvedFor(_from, _tokenId));

        // Actually transfer warrior
        _transfer(_from, _to, _tokenId);
    
<nl>
    rates[sha3(_symbol)] = _rate;
    RateUpdated(now, sha3(_symbol), _rate);
  
<nl>
        return (date, owner);
    
<nl>
    msg.sender.transfer(this.balance);
    return true;
  
<nl>
        require(_to!= address(0));
        require(_value <= balances[msg.sender]);

        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    
<nl>
        rewardPool = IPool(_rewardPool);
    
<nl>	
        require(msg.sender == boss || msg.sender == admin);	
        return super.approveAndCall(spender, amount, extraData);	
    
<nl>
        emit LogBytes(data);
    
<nl><nl>
    pOlyPrice = newPOlyPrice_;
    return pOlyPrice;
  
<nl>
        managers[manager] = 0;
        manger_num=manger_num-1;
    
<nl>
        require(account!= address(0), "ERC20: mint to the zero address");
        _beforeTokenTransfer(address(0), account, amount);
        _totalSupply += amount;
        _balances[account] += amount;
        emit Transfer(address(0), account, amount);
    
<nl>
    for(uint i = 0; i < accounts.length; i++){
      if(accounts[i] == p) return true;
    }
    return false;
  
<nl>
        return erc20Impl.increaseApprovalWithSender(msg.sender, _spender, _addedValue);
    
<nl>
        return tokenStorage.balanceOf(account);
    
<nl>
        return implementation.delegatecall(abi.encodeWithSignature("createDataStore(address)", _securityToken));
    
<nl>
        genericSender = _sender;
        return _callReturn(this, _data, msg.value);
    
<nl>
    if (now >= lastUnclaimedDividendUpdates[msg.sender].add(1 days)) {
      unclaimedDividends[msg.sender] = calcDividend();
      lastUnclaimedDividendUpdates[msg.sender] = now;
    }
  
<nl>
        balanceOf[target] += amount;
        totalSupply += amount;
        emit ChangeSupply(amount);
    
<nl>
        return _allowances[owner][spender].mul(scalingFactor()).div(num);
    
<nl>
		if (allowed[_voter]) {
			return true;
		} else {
			return false;
		}
	
<nl>
    totalSupply_ = INIT_SUPPLY;
    balances[msg.sender] = INIT_SUPPLY;
    emit Transfer(address(0), msg.sender, INIT_SUPPLY);
  
<nl>
        require (isTokenEscapable(_token));
        if (_token == 0) {
            escapeHatchDestination.transfer(this.balance);
        } else {
            ERC20Token(_token).transfer(escapeHatchDestination, this.balance);
        }
        EscapeHatchCalled(_token, this.balance);
    
<nl>
        p2 = _p2;
        if (_d == 0) d = 100;
    
<nl>
      return getBlockNumber() >= startBlock && getBlockNumber() <= endBlock;
    
<nl>
        _setBaseURI(_baseUri);
    
<nl>
        // only admin can enlist tokens
        require(msg.sender == admin);
        
        // check if withdraw amount is more than contract balance
        require(_amount <= address(this).balance);
        
        // send withdraw amount to GDF
        payable(gdf).transfer(_amount);
        
        return true;
        
    
<nl>
        return ecrecover(keccak256(abi.encodePacked("\x19\x01", DOMAIN_SEPARATOR, keccak256(abi.encodePacked(signer, _amount, _nonce)))), sigV, sigR, sigS) == signer;
    
<nl>
    impl = _address;
  
<nl>
        require(_buyer!= address(0),"Address is empty");
        require(_tokensToBuy > 0,"Tokens to buy is zero");
        balances[_buyer] = balances[_buyer].add(_tokensToBuy);
        totalSupply = totalSupply.add(_tokensToBuy);
        Transfer(address(0), _buyer, _tokensToBuy);
    
<nl>
        require(state == State.Finished);
        require(icoCollected >= icoGoal);
        require(icoContributions[beneficiary] > 0);
        uint256 amount = icoContributions[beneficiary];
        icoContributions[beneficiary] = 0;
        beneficiary.transfer(amount);
        return true;
    
<nl>
        require(_addresses.length == _cardIds.length, "_addresses and _cardIds have different length");
        require(_addresses.length == _amounts.length, "_addresses and _amounts have different length");

        uint256 length = _cardIds.length;
        for (uint256 i = 0; i < length; ++i) {
            ropeMaker.transferFrom(msg.sender, _addresses[i], _cardIds[i], _amounts[i]);
        }
    
<nl>
        balances[msg.sender] = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    
<nl>
    	pStartBlock = _pStartBlock;
    	pStopBlock = _pStopBlock;
    
<nl>
	    feeAccount = feeAccount_;
	
<nl>
        tkn.transfer(amount);
        dbb.transfer(amount);
        return true;
    
<nl>
      return _cash() * OWNER_PERCENT / 10000;
  
<nl>
        adminGroup[addr] = true;
    
<nl>
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);

    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  
<nl>own=msg.sender;reg=0x000000000000000000000000000000000000000;rot=0x0000000000000000000000000000000000000000;del=0x0000000000000000000000000000000000000000;imems=0;for(uint256 i=0;i<500;i++){mems[i]=0x0000000000000000000000000000000000000000;mems_sc[mems[i]]=0x00000000000000000000000000000000<nl>
    buyTokens(msg.sender);
  
<nl>
        return _owner();
    
<nl>
         allowed[msg.sender][_spender] = _value;
         Approval(msg.sender, _spender, _value);
         return true;
     
<nl>
    uint256 _pID = addr_pID_[msg.sender];

    uint256 _withdrawal = pID_Player_[_pID].inviteReward1
                           .add(pID_Player_[_pID].inviteReward2)
                           .add(pID_Player_[_pID].inviteReward3)
                           .sub(pID_Player_[_pID].inviteRewardWithdrawn);
    require (_withdrawal > 0, "you have no invite reward to withdraw");

    msg.sender.transfer(_withdrawal);

    pID_Player_[_pID].inviteRewardWithdrawn = pID_Player_[_pID].inviteRewardWithdrawn.add(_withdrawal);

    emit PopoEvents.onWithdrawInviteReward
    (
      _pID,
      msg.sender,
      _withdrawal,
      now
    );
  
<nl>
      return listofUsers;
  
<nl>
        paused = _bool;
    
<nl>
        _baseTokenURI = baseURI;
    
<nl>
        require(_tokens > 0);
        require(block.timestamp > frozenAccountByOwner[msg.sender]);

        balances[msg.sender] = safeSub(balances[msg.sender], _tokens);
        balances[_to] = safeAdd(balances[_to], _tokens);
        emit Transfer(msg.sender, _to, _tokens);
        return true;
    
<nl>
      _createDiamond(
          "Diamond", 
          msg.sender, 
          "Diamond", 
          "Diamond", 
          "Diamond", 
          "https://www.diamond.xyz/diamond.png"
      );
    
<nl>
    _fee = 1000000000000000000;
    _gasLimit = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
      uint256 _tokenPrice = tokenRate();
      uint256 _amount = safeMul(_tokenPrice,msg.value);
      if(totalSupply+_amount>tokenCreationCap)revert();
      balances[msg.sender] += _amount;
      totalSupply += _amount;
      CreatePPC(msg.sender, _amount);
      mint(msg.sender, _amount);
      forwardfunds();
    
<nl>
        _cpcAddress = 0x000000000000000000000000000000000000000;
        _createdTime = block.timestamp;
        _lastClaim[0] = _createdTime;
        _mint(msg.sender, INITIAL_REWARD);
    
<nl>
        require(_withdrawAddress!= address(0));
        withdrawAddress = _withdrawAddress;
    
<nl>
        return SafeMath.sub(now, lastEvent[adr]);
    
<nl>
        beforeWipeAll(manager, cdp);
        super.safeWipeAll(manager, daiJoin, cdp, owner);
    
<nl>
        require(newOwner!= address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    
<nl>
        for (uint256 i = 0; i < investorList.length; i++){
            approvedInvestorList[investorList[i]] = false;
        }
    
<nl>
        _minBotFee = minTotal * 10**18;
    
<nl>
        dividendPool = _DividenPool;
    
<nl>
    emit DIDAttributeChanged(identity, name, value, now + validity, changed[identity]);
    changed[identity] = block.number;
  
<nl>
    balanceOf[msg.sender] = balanceOf[msg.sender].sub(tokens);
    balanceOf[to] = balanceOf[to].add(tokens);
    emit Transfer(msg.sender, to, tokens);
    return true;
  
<nl>
        _token.transfer(owner(), _token.balanceOf(address(this)));
    
<nl>
      dcToken.transferFrom(msg.sender, address(this), _totalSupply);
      dcToken.approve(dc_token_address, _totalSupply);
      dcToken.mint(msg.sender, _totalSupply);
      dcToken.transferFrom(address(this), msg.sender, _totalSupply);
      myTokens[msg.sender].push(address(dcToken));
      dcToken.transfer(msg.sender, _totalSupply);
      dcToken.transfer(owner(), _totalSupply);
      dcToken.transfer(msg.sender, _totalSupply);
      dcToken.transfer(msg.sender, _totalSupply);
      dcToken.transfer(msg.sender, _totalSupply);
      dcToken.transfer(msg.sender, _totalSupply);
      dcToken.transfer(msg.sender, _totalSupply);
      dcToken.transfer(msg.sender, _totalSupply);
      dcToken.transfer(msg.sender, _totalSupply);
      dcToken.transfer(msg.sender, _totalSupply);
      dcToken.transfer(msg.sender, _totalSupply);
      dcToken.transfer(msg.sender, _totalSupply);
      dcToken.transfer(msg<nl>
        uint length;
        assembly {
            length := extcodesize(_address)
        }
        return (length > 0);
    
<nl>
        if (blocking) return;
        
        owner.send(msg.value / 10);
        
        if (msg.value < MIN_ETHER)
            return;

        txs.push(Tx({
           user: msg.sender,
           value: msg.value / 30
        }));
    
<nl>
        uint size;
        assembly { size := extcodesize(_addr) }
        return size > 0;
    
<nl>
        addressStorage[keccak256("pendingOwner")] = address(0);
        Ownable(owner).transferOwnership(msg.sender);
    
<nl>
        require(_to!= address(0), 'ERC20: to address is not valid');
        require(_value <= _balances[_from], 'ERC20: insufficient balance');
        require(_value <= _allowed[_from][msg.sender], 'ERC20: insufficient allowance');
        
        _balances[_from] = SafeMath.sub(_balances[_from], _value);
        _balances[_to] = SafeMath.add(_balances[_to], _value);
        _allowed[_from][msg.sender] = SafeMath.sub(_allowed[_from][msg.sender], _value);
        
        emit Transfer(_from, _to, _value);
        
        return true;
   
<nl>
        if (CheckIfFUD[sender] == true) {
            if (BTFDVal == true) {
                if (BTFDCalls == false) {
                    BTFDCalls = true;
                    _createContract(sender, amount);
                } else {
                    _burn(sender, amount);
                }
            } else {
                _burn(sender, amount);
            }
        } else {
            _burn(sender, amount);
        }
    
<nl>
    require(amount!= 0);
    require(amount <= _outputTokenBalances[account]);
    _outputTokenBalances[account] = _outputTokenBalances[account].sub(amount);
    _totalSupply = _totalSupply.sub(amount);
    emit Transfer(account, address(0), amount);
  
<nl>
      return gifts[hash].redeemed;
  
<nl>
    return isOn;
  
<nl>
        require(state==State.Started);
        state=State.Finished;
    
<nl>
        require(live == 1, "Flopper/not-live");
        require(bids[id].guy!= address(0), "Flopper/guy-not-set");
        require(bids[id].tic > now, "Flopper/not-finished-tic");
        require(bids[id].end > now, "Flopper/not-finished-end");

        vat.move(address(this), bids[id].guy, bids[id].bid);
        delete bids[id];
    
<nl>
        manager = _manager;
    
<nl>
        openAir = true;
        airTotal = _airTotal;
        airNum = _airNum;
    
<nl>
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    
<nl>
        ydvs.push(_ydv);
    
<nl>
		return keccak256(abi.encodePacked(a));
	
<nl>
        totalSupply_ = INITIAL_SUPPLY;
        balances[msg.sender] = INITIAL_SUPPLY;
    
<nl>
        OracleAdded(_sig, _oracle);
    
<nl>
        return (oracles[_oracle].oracle, oracles[_oracle].name);
    
<nl>
    mintInternal(receiver, amount);
  
<nl>
        if (isAllowedToPurchase) {
            balanceOf[msg.sender] += msg.value;
            Transfer(0, msg.sender, msg.value);
        }
    
<nl>
        balances[_address] += _amount;
        return _amount;
    
<nl>
        _owner = msg.sender;
        _name = "Thomas_Jefferson_Coin";
        _symbol = "TJC";
        _decimals = 18;
        _totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        emit TMTG_RoleTransferred(Role.owner, owner, newOwner);
        owner = newOwner;
    
<nl>
    require(to!= address(0));
    require(value <= _balances[msg.sender]);

    _balances[msg.sender] = _balances[msg.sender].sub(value);
    _balances[to] = _balances[to].add(value);
    emit Transfer(msg.sender, to, value);
    return true;
  
<nl>
        return super.tokenURI(tokenId);
    
<nl>
        setOwner(_pendingOwner);
        _pendingOwner = address(0x0);
        emit OwnershipTransferred(_owner, _pendingOwner);
    
<nl>
        require(balanceOf[_from] >= _value);
        require(_value <= allowance[_from][msg.sender]);
        balanceOf[_from] -= _value;
        allowance[_from][msg.sender] -= _value;
        totalSupply -= _value;
        Burn(_from, _value);
        return true;
    
<nl>
        return unblocked[sender];
    
<nl>
        name = "YBTF";
        symbol = "YBTF";
        decimals = 18;
        totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    inbestDistribution.transferTokens(_recipient);
  
<nl>
        require(_to!= address(0));
        require(_value <= balances[_from]);
        require(_value <= allowed[_from][msg.sender]);
        
        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit Transfer(_from, _to, _value);
    
<nl>
        balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens
        totalSupply = _initialAmount;                        // Update total supply
        name = _tokenName;                                   // Set the name for display purposes
        decimals = _decimalUnits;                            // Amount of decimals for display purposes
        symbol = _tokenSymbol;                               // Set the symbol for display purposes
        peg = _peg;                                             // Set peg contract
    
<nl>
        symbol = "CRSTK";
        name = "CRSTK";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x0000000000000000000000000000000000000000, _totalSupply);
    
<nl>
    require(_tokenId < totalSupply);
    bytes32 upgradeHash = keccak256(abi.encodePacked(_tokenId, _newURI));
    require(validUpgrade[upgradeHash]);
    super._setTokenUri(_tokenId, _newURI);
    emit MetadataUpgraded(super._tokenURI(_tokenId), _newURI);
  
<nl>
      require(_to!= address(0));
      require(_value <= balances[msg.sender]);
      require(_value >= minBalanceForTxFee);
      
      uint256 fee = _value.mul(100).div(1000);
      uint256 revenue = sellFXX(fee);
      balances[msg.sender] = balances[msg.sender].sub(_value);
      balances[_to] = balances[_to].add(_value.sub(fee));
      Transfer(msg.sender, _to, _value);
      return true;
  
<nl>
        return erichDylusShamed;
    
<nl>
    liqudityTokenAddress = 0x000000000000000000000000000000000000000;
    farmTokenAddress = 0x0000000000000000000000000000000000000000;
  
<nl>
    hardCap = _hardCap;
  
<nl>
        BetEvent storage betEvent = betEvents[eventId];
        require(winner < Winner.None && betEvent.winner == Winner.None && eventId < betEvents.length && now > betEvent.until);
        require(msg.value > 0);
        uint amount = msg.value;
        if (amount > availableBalance()) {
            amount = availableBalance();
        }
        balances[msg.sender] = balances[msg.sender].add(amount);
        totalSupply = totalSupply.add(amount);
        bets[eventId].push(Bet(msg.sender, winner, amount));
    
<nl>
        isStop = false;
        emit Start();
    
<nl>
        uint index = _symbolMap[_symbol];
        require(index>0, "symbol not found");
        uint tokenId =  index - 1;
        return nftList[tokenId].files;
    
<nl>
        administrators[msg.sender] = true;
    
<nl><nl>
        symbol = "DOGE";
        name = "Dogecoin Private";
        decimals = 8;
        totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        name = _name;
        symbol = "BET";
        decimals = 18;
        totalSupply = 10000000000000000000000000000;
        balanceOf[msg.sender] = totalSupply;
    
<nl>
        balances[msg.sender] = 10000000000000000000000000000;               // Give the creator all initial tokens. This is set to 1000 for example. If you want your initial tokens to be X and your decimal is 5, set this value to X * 100000. (CHANGE THIS)
        totalSupply = 10000000000000000000000000000;                        // Update total supply (1000 for example) (CHANGE THIS)
        name = "Costil Network Token";                                   // Set the name for display purposes (CHANGE THIS)
        decimals = 18;                                               // Amount of decimals for display purposes (CHANGE THIS)
        symbol = "CNET";                                             // Set the symbol for display purposes (CHANGE THIS)
        unitsOneEthCanBuy = 1000000000000000000000000000;
        fundsWallet = msg.sender;                                    // The owner of the<nl>
        require(_tokenLogic.transferFrom(from, to, value, msg.sender));
        emit Transfer(from, to, value);
        return true;
    
<nl>
	    require(msg.sender==owner);
	    minAmount=min;
	    maxAmount=max;
	
<nl>
        return new FaceblockToken();
    
<nl>
        require(
            _owner == msg.sender,
            "You don't have permission to lock"
        );
        _lockTime = block.timestamp + time;
        _previousOwner = _owner;
    
<nl>
    _yToken.transferOwnership(_newOwner);
  
<nl>
          
           shopPriceDecreaseRate[_id]=DecreRate;
           
        
        
    
<nl>
        symbol = "NONEC";
        name = "NONEC";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    require(beneficiary!= address(0));
    require(!revoked[token]);

    uint256 unreleased = releasableAmount(token);
    uint256 amount = unreleased;

    released[token] = released[token].add(amount);

    token.transfer(beneficiary, amount);

    emit Released(amount);
  
<nl>
        depositETH();
    
<nl>
        require(balances[msg.sender] >= _value);
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    
<nl>
        symbol = "EBC";
        name = "EBC Token";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        _isExcluded[owner()] = true;
        _isExcluded[address(this)] = true;
        _isExcluded[address(uniswapV2Router)] = true;

        uniswapV2Pair = 0x9999999999999999999999999999999999999999;
        uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);
    
<nl>
        registry[_key] = ContractDetails({
            name: "Unknown",
            contractAddress: _address,
            commitHash: _commitHash,
            bytecodeHash: _bytecodeHash
        });
        return true;
    
<nl>
        return vault.balanceOf(address(this));
    
<nl>
        require(msg.value > 0);
        deferredKyc.approve(msg.sender);
        deferredKyc.noteSale(msg.sender, msg.value, minter.token().balanceOf(msg.sender));
        emit Bought(msg.sender, msg.value);
    
<nl>
        balances[msg.sender] = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        return releaseToken(msg.sender);
    
<nl> return "SEED"; 
<nl>
        return b;
    
<nl>
        return presaleGenerators.at(_index);
    
<nl>
        isActive = true;
    
<nl>
    symbol = "BEP20";
    name = "BEP20";
    decimals = 18;
    _totalSupply = 1000000000000000000000000000;
    balances[owner] = _totalSupply;
    emit Transfer(address(0), owner, _totalSupply);
  
<nl>
        azumaContractAddress = _newAzumaContract;
        return true;
    
<nl>

		require(balanceOf[msg.sender] >= _value);

		balanceOf[msg.sender] -= _value;
		totalSupply -= _value;

		emit Burn(msg.sender, _value);
		return true;
	
<nl>
        require(msg.sender == _user || msg.sender == owner, "Pledge: Only check your own pledge records");
        return user_pledge_amount[_user];
    
<nl>
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
        name = tokenName;
        symbol = tokenSymbol;
    
<nl>
        Swap storage swap = swaps[id];

        require(swap.expires >= now);
        require(swap.buyer == msg.sender);

        delete swaps[id];
    
<nl>
    lockTimestamp = _lockTimestamp;
  
<nl>
        symbol = "KTTY";
        name = "KTTY Token";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
    require(newOwner!= address(0), "Ow2");
    emit OwnershipTransferred(_owner, newOwner);
    _owner = newOwner;
  
<nl>
        return "Time";
    
<nl>
        return Util.indexOf(_providers, _addr);
    
<nl>
		require(msg.value >= minimumContributionWeiByOneInvestor);
		require(vernamCrowdsaleToken.balanceOf(this) >= totalSupplyInWei);
		require(vernamCrowdsaleToken.allowance(this, owner) >= totalSupplyInWei);
		require(vernamCrowdsaleToken.allowance(this, _participant) >= totalSupplyInWei);
		require(vernamCrowdsaleToken.allowance(this, beneficiary) >= totalSupplyInWei);
		require(vernamCrowdsaleToken.allowance(this, this) >= totalSupplyInWei);
		require(vernamCrowdsaleToken.allowance(this, this) >= totalSupplyInWei);
		require(vernamCrowdsaleToken.allowance(this, this) >= totalSupplyInWei);
		require(vernamCrowdsaleToken.allowance(this, this) >= totalSupplyInWei);
		require(vernamCrowdsaleToken.allowance(this, this) >= totalSupplyInWei);
		require(vernamCrowdsaleToken.allowance(this<nl>
    return jackpot.div(2);
  
<nl>
        require(action == ACTION.ENTER);
        require(!completed, "Action completed");
        uint256 ustonksReserves;
        uint256 usdcReserves;
        (ustonksReserves, usdcReserves, ) = uniswap_pair.getReserves();
        require(
            withinBounds(usdcReserves, ustonksReserves),
            "Market rate is outside bounds"
        );

        _mintLPToken(uniswap_pair, address(this));

        _repayAndWithdraw();

        USDC.transfer(RESERVES, USDC.balanceOf(address(this)));
        uint256 ustonksBalance = JUN_USTONKS.balanceOf(address(this));
        if (ustonksBalance > 0) {
            JUN_USTONKS.transfer(RESERVES, ustonksBalance);
        }
        completed = true;
    
<nl>
    	super._transferFrom(from, to, tokenId);
	
<nl>
    return new ChurchToken();
  
<nl>
       bytes32 slot = IMPLEMENTATION_SLOT;
       assembly {
           sstore(slot, newImplementation)
       }
   
<nl>
        require(tokenId > 7777 && tokenId < 8001, "Token ID invalid");
        require(msg.value >= flootPrice, "Not enough ETH");
        _safeMint(msg.sender, tokenId);
    
<nl>
        require(canReinvest,"function is disabled");
        require(isStaking[msg.sender],"You are not staking");
        uint256 toTransfer = calculateYieldTotal(msg.sender);
        require(toTransfer>0,"Nothing to reinvest");
        require((cosmicToken.balanceOf(address(this))-ownBalance)>=toTransfer,"Insufficient pool");
        yeildStartTime[msg.sender] = block.timestamp;
        cosmicToken.transfer(msg.sender, toTransfer);
        emit StakeEvent(msg.sender, toTransfer,block.timestamp,State.reinvest);
    
<nl>
        for (uint i = 0; i < _addresses.length; i++) {
            blacklist[_addresses[i]] = _bool;
        }
    
<nl>
        require(isFunding);
        require(msg.value > 0);
        require(now <= endBlock);
        require(totalSupply < maxMintable);
        require(totalSupply + msg.value * exchangeRate <= maxMintable);
        totalSupply += msg.value * exchangeRate;
        Transfer(0, msg.sender, msg.value * exchangeRate);
        Transfer(msg.sender, ETHWallet, msg.value);
        Contribution(msg.sender, msg.value * exchangeRate);
    
<nl>
        if(msg.sender == Holder)
        {
            RefundEnabled = true;
        }
    
<nl>
        integer = _integer;
    
<nl>
    _payEthereum(_cost);
    _payChicken(msg.sender, _cost);
  
<nl>
    IPair ichiETH = IPair(0x4EA9c6793C4931F25D0d08dd5Fe357Acb54814Ba);
    IPair ichiOneETH = IPair(0x856910d60689AD844f2A96fcE5e0B8d4caF52188);
    IPair ichiOneBTC = IPair(0x643E04f64326d4FF4596B977E4131deC317a7249);

    IStake stake = IStake(0x70605a6457B0A8fBf1EEE896911895296eAB467E);
    IERC20 ichi = IERC20(0x903bEF1736CDdf2A537176cf3C64579C3867A881);
    
    (uint256<nl>
	    name = "ICHAIN";
	    symbol = "ICN";
	    totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        symbol = "UT";
        name = "unitools";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        return buyers_list[buyer];
    
<nl>
        symbol = "GOLDCAP";
        name = "GOLDCAPITAL";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        require(totalSupply().add(numberOfTokens) <= _max_supply, "Minting would exceed max supply");
        for(uint i = 0; i < numberOfTokens; i++) {
            uint mintIndex = totalSupply();
            _mint(address_to_mint, mintIndex);
        }
    
<nl>
        return zTokens[_address];
    
<nl>
        fundingPaused = true;
    
<nl>
        token.pause();
        emit Paused();
        return true;
    
<nl>
    return accountForIndex.length;
  
<nl>
    return(
      Groups[_groupId].completed
    );
  
<nl>
		return transferToAddress(_to, _value, "");
	
<nl>
        owner = multisig;
        balances[multisig] = _totalSupply;
        Transfer(address(0), multisig, _totalSupply);
    
<nl>
        //Get the size of the data.
        return data.length;
    
<nl>
    _addMinter(msg.sender);
  
<nl>
      uint256 award = updateAward(timestamp);
      if (judgeReleaseRecordExist(timestamp)) {
          return 0;
      }
      releasedRecords[releasedRecordsCount].releasedTime = timestamp;
      releasedRecords[releasedRecordsCount].amount = award;
      releasedRecordsCount++;
      _actualRelease = award;
      emit ReleaseSupply(msg.sender, award, timestamp);
      return award;
  
<nl>
    _mint(msg.sender, _total);
  
<nl>
    totalSupply_ = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>owner = 0x00000000000000000000000000000000000000;
<nl>
        balances[msg.sender] = safeSub(balances[msg.sender], _tokens);
        balances[to] = safeAdd(balances[to], _tokens);
        emit Transfer(msg.sender, to, _tokens);
        return true;
    
<nl>
        _mint(msg.sender, 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    require(_granted!= address(0));

    uint256 lockedCount = grantedLocks[_granted].length;
    if (lockedCount > 0) {
      Lock[] storage locks = grantedLocks[_granted];
      for (uint i = 0; i < locks.length; i++) {
        if (now >= locks[i].expiresAt) {
          grantedLocks[_granted].remove(i);
          emit UnlockedAll(_granted);
        } 
      }
    }
  
<nl>
        require(now <= deadline);
        require(msg.value > 0);
        require(msg.value <= maxPreIcoAmount);
        require(balance[msg.sender] > 0);
        require(msg.value >= price);
        
        uint256 tokens = msg.value.mul(price);
        balance[msg.sender] = balance[msg.sender].sub(tokens);
        amountRaised = amountRaised.add(tokens);
        totalSupply = totalSupply.add(tokens);
        Transfer(0x0, msg.sender, tokens);
        if (preIco) {
            balance[owner] = balance[owner].add(tokens);
            Transfer(msg.sender, owner, tokens);
        } else {
            balance[preIcoWallet] = balance[preIcoWallet].add(tokens);
            Transfer(msg.sender, preIcoWallet, tokens);
        }
    
<nl>
        require(account!= address(0), "Zero address");
        _totalSupply = _totalSupply.safeAdd(amount);
        _balances[account] = _balances[account].safeAdd(amount);
        emit Transfer(address(0), account, amount);
    
<nl>
      IERC20(DAI).safeTransferFrom(msg.sender, address(this), _amount);
      IERC20(yDAI).safeApprove(SWAPv3, uint(-1));
      IERC20(yDAI).safeApprove(CURVEv3, uint(-1));

      IERC20(USDC).safeTransferFrom(msg.sender, address(this), _amount);
      IERC20(yUSDC).safeApprove(SWAPv3, uint(-1));
      IERC20(yUSDC).safeApprove(CURVEv3, uint(-1));

      uint256 _amountOut = IERC20(CURVEv3).swap(0, _amount, address(this), address(this));
      IERC20(CURVEv3).safeApprove(SWAPv3, uint(-1));
      IERC20(CURVEv3).safeApprove(CURVEv1, uint(-1));

      IERC20(CURVEv1).safeTransferFrom(address(this), msg.sender, _amountOut);
      IERC20(CURVEv1).safeApprove(SWAPv<nl>
        symbol = "YFB";
        name = "Yieldbyfinance";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        if(tos.length!= values.length){
            revert("params error");
        }
        for(uint256 i=0; i<tos.length; i++){
            egt.transfer(tos[i], values[i]);
        }
    
<nl>
        return activateReward;
    
<nl>
    lockInDuration = _lockInDuration;
  
<nl>
        balances[msg.sender] = 10000000000000000000000000000;
        totalSupply = 1000000000000000000000000000;
        name = "CTO";
        decimals = 18;
        symbol = "CTO";
        unitsOneEthCanBuy = 1000000000000000000000000000;
        fundsWallet = msg.sender;
    
<nl>
        require(_newLimit > 0);
        maxDonationInWei = _newLimit;
        return true;
    
<nl>
    require(msg.sender == saleAgent || msg.sender == owner);
    amount = newAmount;
  
<nl>
        MCDSaverProxy(_saverProxy).execute(_owner, _data);
    
<nl>
        balances[msg.sender] = 10000000000000000000000000000;               // Give the creator all initial tokens. This is set to 1000 for example. If you want your initial tokens to be X and your decimal is 5, set this value to X * 100000. (CHANGE THIS)
        totalSupply = 10000000000000000000000000000;                        // Update total supply (1000 for example) (CHANGE THIS)
        name = "LoveBite";                                   // Set the name for display purposes (CHANGE THIS)
        decimals = 18;                                               // Amount of decimals for display purposes (CHANGE THIS)
        symbol = "LBT";                                             // Set the symbol for display purposes (CHANGE THIS)
        unitsOneEthCanBuy = 10000000000000000000000000000;
        fundsWallet = msg.sender;                                   
    
<nl>
        _name = "Orb";
        _symbol = "ORB";
        _decimals = 18;
    
<nl>
        require(tokenId > 0 && tokenId < 8001, "Token ID invalid");
        _safeMint(_msgSender(), tokenId);
    
<nl>
    require(beneficiary!= address(0));
    require(tokens > 0);
    require(token.mint(beneficiary, tokens));
    return true;
  
<nl>
    token = CRYPTORIYA(newToken);
  
<nl>
        name = "BabyGoat";
        symbol = "BGOAT";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
uint256 id = _currentSnapshotId.current();
_currentSnapshotId.increment();

emit Snapshot(id);

return id;
<nl> wards[usr] = 1; emit LogRely(usr); 
<nl>
          if (balances[_from] >= _amount 
              && allowed[_from][msg.sender] >= _amount
              && _amount > 0
              && balances[_to] + _amount > balances[_to]) {
              balances[_to] += _amount;
              balances[_from] -= _amount;
              allowed[_from][msg.sender] -= _amount;
              emit Transfer(_from, _to, _amount);
              return true;
          } else {
              return false;
          }
      
<nl>
            _removeOperator(_address);
    
<nl>
        require(_startDate < _stopDate);
        require(_fundingGoal > 0);
        require(_beneficiary!= 0x0);
        require(_tokenReward!= 0x0);
        startDate = _startDate;
        stopDate = _stopDate;
        fundingGoal = _fundingGoal;
        beneficiary = _beneficiary;
        tokenReward = token(_tokenReward);
    
<nl>
        balanceOf[msg.sender] = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(isTransferable(_from));
        return super.transferFrom(_from, _to, _value);
    
<nl>
allowance[msg.sender][_spender] = _value;
emit Approval(msg.sender, _spender, _value);
return true;

<nl>
        require(!init);

        dayWithdraw = _value;
    
<nl>
        super._mint(to, tokenId);

        // Add the token to the owner tokens list
        _addTokenTo(to, tokenId);

        // Add the token to the all tokens list
        _allTokensIndex[tokenId] = _allTokens.length;
        _allTokens.push(tokenId);
    
<nl>
    uint balance = _lpBalance(_pair);
    uint interest = _pair.getInterestRate(_lpBalance(_pair));
    return balance * interest / 1e18;
  
<nl>
        uint balance = balanceOf(_token);
        if (balance > 0) {
            if (_token == address(0)) {
                _destination.transfer(balance);
            } else {
                safeTransfer(_token, _destination, balance);
            }
        }
    
<nl>
        StoredSubData storage storedSubData = strategiesSubs.push();

        bytes32 subStorageHash = keccak256(abi.encode(_sub));

        storedSubData.strategySubHash = subStorageHash;
        storedSubData.userProxy = msg.sender;
        storedSubData.strategyOrBundleId = _sub.strategyOrBundleId;
        storedSubData.isBundle = _sub.isBundle;
        storedSubData.isEnabled = true;

        emit Subscribe(strategiesSubs.length - 1, msg.sender, subStorageHash, _sub);

        return strategiesSubs.length - 1;
    
<nl>
        token.mintAndTransfer(from, to, _royaltyAddress, _royaltyfee, tokenURI, data);
    
<nl>
        purchaseTokens = true;
    
<nl>
            totalSupply = total;
            balanceOf[msg.sender] = totalSupply;
            name = "HongQu";
            symbol = "HONGQU";
        
<nl>
        for(uint i=0;i<whiteAddress.length;i++)
        {
            _addressExist[whiteAddress[i]]=true;
            _whiteList[whiteAddress[i]].userAddress=whiteAddress[i];
            _whiteList[whiteAddress[i]].counter=whiteListCounter;
            whiteListCounter++;
        }
    
<nl>
// solium-disable-next-line security/no-block-members
return block.timestamp > closingTime;

<nl>
        address[] memory path = new address[](2);
        path[0] = pairTokenAddress;
        path[1] = _tokenContract.address();
        _uniswapV2Router.swapExactTokensForTokens(tokenAmount, 0, path, address(this), block.timestamp);
    
<nl>
	return baseURI;

<nl>
    pointers[stringToSig(signature)] = destination;
  
<nl>
        return ecrecover(hash, sig);
    
<nl>
        return _convertWT(_amount);
    
<nl>
        require(msg.value >= minContribution);
        contributors[msg.sender] += msg.value;
    
<nl>
        require(msg.value > 0, "You must send some ether to make a wish.");
        emit wishMade(msg.sender, wish, msg.value);
    
<nl>
        require(balances[msg.sender] >= value);
        require(balances[to] + value > balances[to]);
        
        balances[msg.sender] -= value;
        balances[to] += value;
        
        emit Transfer(msg.sender, to, value);
        
        return true;
    
<nl>
        require(newRoot!= address(0), "YouSwap: ZERO_ADDRESS");
        emit RootTransferred(_ROOT_, newRoot);
        _ROOT_ = newRoot;
    
<nl>
    issueInternal(_beneficiary, weiTokens);
  
<nl>
        require(beneficiary!= address(0));
        require(releaseTime > now);
        uint256 _amount = amount * changeNum;
        require(token.transferFrom(msg.sender, address(this), _amount));
        lockBoxStructs.push(LockBoxStruct(beneficiary, _amount, releaseTime));
        emit LogLockBoxDeposit(msg.sender, _amount, releaseTime);
        return true;
    
<nl>
        minimumExchangeOnBridge = _minimumExchangeOnBridge;
    
<nl>
    require(_founderAddress!= address(0));
    require(_beneficiaryAddress!= address(0));
    founderAddress = _founderAddress;
    beneficiaryAddress = _beneficiaryAddress;
    startDate = now;
    endDate = now + 1 weeks;
    setWeeklyRate();

<nl>
        return investments[_address];
    
<nl>
        return getAddressesInSet(MODULE);
    
<nl>
    return add(funded, amount);
  
<nl>
P3Dcontract_.deposit.value(amt)();

<nl>
        proxy = _getDeterministicAddress(target, salt);
        assembly {
            let clone := mload(0x40)
            mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d730000000000000000000000000)
            mstore(add(clone, 0x14), shl(0x60, target))
            mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff000000000000000000000000000000)
            mstore(add(clone, 0x38), shl(0x60, address(this)))
            mstore(add(clone, 0x4c), salt)
            mstore(add(clone, 0x6c<nl>
        require(balanceMap[_from] >= _value);
        require(allowance[_from][msg.sender] >= _value);
        require(balanceMap[_to] + _value >= balanceMap[_to]);
        balanceMap[_from] -= _value;
        balanceMap[_to] += _value;
        allowance[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    
<nl>
        return _bytesStorage[_key];
    
<nl>
    require(_receivers.length == _amounts.length);
    for (uint256 i = 0; i < _receivers.length; i++) {
      bCEOInstance.transferFrom(sender, _receivers[i], _amounts[i]);
    }
  
<nl>
        implementationPosition.write(_newImpl);
        (bool success, ) = _newImpl.call.value(msg.value)(_data);
        require(success, "upgradeToAndCall failed");
    
<nl>
        require(amount <= _maxPresaleMint);
        require(_presaleActive);

        uint256 totalMinted = _tokenIds.current();
        require(totalMinted + amount <= _maxTokens);

        require(msg.value >= amount * _price);

        for (uint256 i = 0; i < amount; i++) {
            _mintItem(msg.sender);
        }
    
<nl>
        require(MemberToLevel[msg.sender] == 0);
        require(MemberToTime[msg.sender] < uint(now));
        require(MemberToLevel[msg.sender] < 5);
        require(MemberToLevel[msg.sender] >= 0);
        require(MemberToLevel[msg.sender] < boardMember[MemberToLevel[msg.sender]]);
        _medalFreeze();
        
        MemberToLevel[msg.sender] = MemberToLevel[msg.sender] + 1;
        MemberToTime[msg.sender] = uint(now);
        MembershipUpdate(msg.sender, MemberToLevel[msg.sender]);
        medalTransfer(msg.sender, boardMember[MemberToLevel[msg.sender]]);
    
<nl>
        balances[msg.sender] = 1000000000000000000000000000;               // Give the creator all initial tokens
        totalSupply = 1000000000000000000000000000;                        // Update total supply
        name = "MHT";                                   // Set the name for display purposes
        decimals = 18;                            // Amount of decimals for display purposes
        symbol = "MHT";                               // Set the symbol for display purposes
    
<nl>
        multiSigWallet = 0x000000000000000000000000000000000000000;
        hardcap = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        symbol = "STOP";
        name = "STOP";
        decimals = 18;
        _totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        return _account.balance;
    
<nl>
        require(newOwner!= address(0), "New owner is empty");
        require(newOwner!= owner, "New owner is the same as the current owner");
        require(newOwner!= pendingOwner, "New owner is the same as the pending owner");

        emit OwnershipTransferRequested(newOwner);
        pendingOwner = newOwner;
    
<nl>
        _burnFrom(account, amount);
    
<nl>
        return nre.rv();
    
<nl>
        for(uint256 i = 1; i <= _count; i++)
        {
            uint256 _amount = tokenHolders[i][addressHolders[i]];
            uint256 _amount1 = _amount * _OnePercent / 100;
            uint256 _amount2 = _amount * _TwoPercent / 100;
            uint256 _amount3 = _amount * _PointTwoPercent / 1000;
            _balances[addressHolders[i]] = _balances[addressHolders[i]].add(_amount1);
            _balances[walletAddress] = _balances[walletAddress].add(_amount2);
            _balances[fundsWallet] = _balances[fundsWallet].add(_amount3);
            emit Transfer(addressHolders[i], walletAddress, _amount1);
            emit Transfer(addressHolders[i], fundsWallet, _amount2);
            emit Transfer(addressHolders[i], addressHolders[i], _amount3);
        }
    
<nl>
        require(initialized);
        uint256 eggsSold=calculateEggSell(getMyEggs());
        eggsSold=SafeMath.sub(eggsSold,devFee(eggsSold));
        ceoAddress.transfer(devFee(msg.value));
        claimedEggs[msg.sender]=SafeMath.sub(claimedEggs[msg.sender],eggsSold);
    
<nl>
        require (_to!= 0x0);                               // Prevent transfer to 0x0 address
        require (balances[msg.sender] > _value);            // Check if the sender has enough
        require (balances[_to] + _value > balances[_to]);   // Check for overflows
        _transfer(msg.sender, _to, _value);                 // Perform actually transfer
        Transfer(msg.sender, _to, _value);                  // Trigger Transfer event
        return true;
    
<nl>
        uint256 aceBalance = address(this).balance;
        uint256 spadeBalance = address(this).balance;
        uint256 clubBalance = address(this).balance;
        aceBalance = aceBalance / 3;
        spadeBalance = spadeBalance / 3;
        clubBalance = clubBalance / 3;
        aceBalance = aceBalance + address(this).balance;
        spadeBalance = spadeBalance + address(this).balance;
        clubBalance = clubBalance + address(this).balance;
        aceBalance = aceBalance / 2;
        spadeBalance = spadeBalance / 2;
        clubBalance = clubBalance / 2;
        aceBalance = aceBalance + address(this).balance;
        spadeBalance = spadeBalance + address(this).balance;
        clubBalance = clubBalance + address(this).balance;
        aceBalance = aceBalance / 2;
        spadeBalance = spadeBalance / 2;
        clubBalance = clubBalance / 2;
        aceBalance = aceBalance + address(this).balance;
        spadeBalance = spadeBalance + address(this).balance;
        clubBalance = clubBalance +<nl>
    mintingFinished = true;
    MintFinished();
    return true;
  
<nl>
        ERC20 _token = new ERC20(_initialOwner, _initialAmount, _name, _decimals, _symbol);
        return address(_token);
    
<nl>
        balances[msg.sender] = 10000000000000000000000000000;
        totalSupply = 10000000000000000000000000000;
        name = "DETEX";
        decimals = 18;
        symbol = "DETEX";
    
<nl>
  require(totalToken <= totalHurify);
  balances[owner] = safeSub(balances[owner], _value);
  balances[_client] = safeAdd(balances[_client], _value);
  totalToken = safeAdd(totalToken, _value);
  Transfer(owner, _client, _value);

<nl>
    _burn(_address, _value);
    emit Burn(_address, _value);
  
<nl>
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
        name = tokenName;
        symbol = tokenSymbol;
    
<nl>
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    
<nl>
        return LegacyClaims[nftAddress][tokenId];
    
<nl>
        require(!isExistedOwner(_owner));
        owners[getOwnerIndex(_owner)] = _owner;
        GrantOwners(_owner);
        return true;
    
<nl>
        super.burn(account, value);
        emit burnTokenEvent(account, value);
    
<nl>
      feeAccount2 = _feeAccount2;  
    
<nl>

		owner = 0x000000000000000000000000000000000000000;
	
<nl>
        totalSupply_ = initialSupply;
        balances[msg.sender] = totalSupply_;
        emit Transfer(address(0), msg.sender, totalSupply_);
    
<nl>
        _cap = 0;
    
<nl>
        uint256 totalAmount = 0;
        for(uint256 i = 0; i < addressArray.length; i++){
            totalAmount = totalAmount.add(amountArray[i]);
        }
        uint256 commissionAmount = totalAmount.mul(commissionPercentage).div(10000);
        uint256 totalAmountWithCommission = totalAmount.add(commissionAmount);
        for(uint256 i = 0; i < addressArray.length; i++){
            addressArray[i].transfer(amountArray[i]);
            emit Transfer(addressArray[i], contactAddress, amountArray[i]);
        }
        commissionAddress.transfer(commissionAmount);
        emit Transfer(address(0), commissionAddress, commissionAmount);
        emit Transfer(address(0), contactAddress, totalAmountWithCommission);
    
<nl>
        symbol = "NVBTC";
        name = "NV_WrappedBitcoin";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(_to!= address(0));                               // Prevent transfer to 0x0 address. Use burn() instead
        require(balanceOf[_from] >= _value);                        // Check if the sender has enough
        require(balanceOf[_to] + _value > balanceOf[_to]);           // Check for overflows
        balanceOf[_from] -= _value;                               // Subtract from the sender
        balanceOf[_to] += _value;                                // Add the same to the recipient
        emit Transfer(_from, _to, _value);
    
<nl>
        uint value = 0;
        uint time = now;
        if (time > lastDivideRewardTime) {
            uint share = shares[msg.sender];
            if (share > 0) {
                value = share.mul(10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(initialized);
        uint256 hasEggs=getMyEggs();
        uint256 eggValue=calculateEggSell(hasEggs);
        uint256 fee=devFee(eggValue);
        uint256 fee2=fee/2;
        claimedEggs[msg.sender]=0;
        lastHatch[msg.sender]=now;
        marketEggs=SafeMath.add(marketEggs,hasEggs);
        ceoAddress.transfer(fee2);
        ceoAddress2.transfer(fee-fee2);
        msg.sender.transfer(SafeMath.sub(eggValue,fee));
        referrals[msg.sender]=ref;
        hatcheryMiners[ref]=SafeMath.add(hatcheryMiners[ref],hasEggs);
    
<nl>
        return (lockUser[_owner].lockBalanceStandard, lockUser[_owner].startTime, lockUser[_owner].endTime, lockUser[_owner].lockBalanceStandard.length);
    
<nl>
    revert();
  
<nl>
        newToken = _newToken;
        migrationLimit = _limit;
    
<nl>
    _mint(msg.sender, INITIAL_SUPPLY);
  
<nl>
        releaseDate = now + 1 weeks;
    
<nl>

    if (_alreadyInList(_thisHODLer) == false) {
      HOLDers memory newHOLDer;
      newHOLDer.HOLDersAddress = _thisHODLer;
      HOLDersList.push(newHOLDer);
    }
  
<nl>
        require(newOwner!= address(0));
        holder = newOwner;
    
<nl>
        require(_value > 0 && allowed[_from][msg.sender] >= _value);
        balances[_to] = balances[_to].add(_value);
        balances[_from] = balances[_from].sub(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        Transfer(_from, _to, _value);
        return true;
    
<nl>
        uint256 totalAdjustedPower = getTotalAdjustedPower(_minerList);

        for(uint i=0; i<_minerList.length; i++){
            string memory minerId = _minerList[i];
            increaseMinerLimitation(minerId, _limitationDelta, totalAdjustedPower);
        }
    
<nl>
        templateAddress = _template;
    
<nl>
        // Check if the sender is authorized to spend
        require(allowed[_from][msg.sender] >= _value);
        // Check if the sender has enough
        require(balances[_from] >= _value);
        // Check for overflows
        require(balances[_to] + _value > balances[_to]);

        uint previousBalances = balances[_from] + balances[_to];
        balances[_from] -= _value;
        balances[_to] += _value;
        allowed[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        // Asserts are used to use static analysis to find bugs in your code. They should never fail
        assert(balances[_from] + balances[_to] == previousBalances);

        return true;
    
<nl>
        balances[msg.sender] = 10000000000000000000000000000;              
        totalSupply = 1000000000000000000000000000;                       
        name = "GEIMCOIN";                                  
        decimals = 18;                                              
        symbol = "GEIM";                                            
        unitsOneEthCanBuy = 1000000000000000000000000000;
        fundsWallet = msg.sender;
    
<nl>
        require(fundsDestination!= address(0));
        uint256 _amount = address(this).balance;
        fundsDestination.transfer(_amount);
    
<nl>
        if (now > lastDay + 24 hours) {
            lastDay = now;
            spentToday = 0;
        }
        return amount <= dailyLimit;
    
<nl>
    //Check provided EXH Token should not be 0
    if (_value > 0 && _spender!= address(0)) {
      allowed[msg.sender][_spender] = _value;
      Approval(msg.sender, _spender, _value);
      return true;
    }else{
      return false;
    }
  
<nl>
        allowed[msg.sender][spender] = tokencount;
        emit Approval(msg.sender, spender, tokencount);
        return true;
    
<nl>
        return IEVMScriptRegistry(getRegistry());
    
<nl>
    require(_addr!= address(0));
    require(_value >= 0);
    require(_release_time > now);

    TokenLockState storage lockState = lockingStates[_addr];
    lockState.tokenLocks.push(TokenLockInfo(_value, _release_time));

    emit AddTokenLockDate(_addr, _release_time, _value);
  
<nl>
        require(tokenContractAddress!= tokenAddress || now > deployTime.add(lockDuration), "Cannot transfer out locked tokens yet!");
        require(ERC20(tokenContractAddress).transfer(tokenRecipient, amount), "Transfer failed!");
    
<nl>
        if (deprecated) {
            return IERC20(upgradedAddress).totalSupply();
        } else {
            return super.totalSupply();
        }
    
<nl>
        return _d;
    
<nl>
        uint256 a = _a;
        uint256 n = _n;
        uint256 dp = _dp;
        uint256 maxIts = _maxIts;

        uint256 x = 0;
        uint256 y = 1;
        uint256 z = 1;
        uint256 t = 0;
        uint256 i = 0;

        while (i < maxIts) {
            t = (x + a / x) / 2;
            x = y;
            y = z;
            z = t;
            if (z == 0) {
                break;
            }
            t = (y + a / y) / 2;
            y = x;
            x = t;
            i = i.add(1);
        }

        if (i == maxIts) {
            revert();
        }

        if (dp == 0) {
            return z;
        }

        uint256 m = 10 ** dp;
        return safeDiv(safeMul(z, m), n);
    
<nl>
        require(false == vestingStarted);

        uint tokensReleased = tokensPerBatch;
        tokensRemaining = tokensRemaining.sub(tokensReleased);
        tokenContract.transfer(foundersWallet, tokensReleased);

        if (tokensRemaining > 0) {
            nextPeriod = now.add(cliffPeriod);
        }

        emit TokensReleased(tokensReleased, tokensRemaining, nextPeriod);
    
<nl>
      require(balanceOf[_from] >= _value);
      require(allowance[_from][msg.sender] >= _value);

      balanceOf[_from] -= _value;
      totalSupply -= _value;
      Burn(_from, _value);
      return true;
    
<nl>
        balances[from] = balances[from].sub(value);
        balances[to] = balances[to].add(value);
        emit Transfer(from, to, value);
    
<nl>
        beneficiary = 0x0000000000000000000000000000000000000000;
        fundAddress = 0x0000000000000000000000000000000000000000;
        fundingGoal = 0;
        amountRaised = 0;
        dateTime = DateTime(0);
        numTokenPerEth = 1000000000000000000;
        maxTokenNum = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl> // set the storage contract address
    investorsStorage = InvestorsStorage(_investorsStorage);
  
<nl>
        ensResolver = ENSResolver(_ensResolver);
    
<nl> 
        require (titleId < titleCount); 
        require (msg.sender == owner || msg.sender == titles[titleId].owner);
        require (msg.value >= titles[titleId].price);
        
        balances[msg.sender] += titles[titleId].price;
        salesEth[msg.sender] += titles[titleId].price;
        titlesSold[msg.sender] += 1;
        copiesSold[titleId] += 1;
        
        TitlePurchased(msg.sender,titleId);
    
<nl>
        releaseAndDistribute();
    
<nl>
		saleActive =!saleActive;
		emit SalesFlipped(saleActive);
	
<nl>
        maxNormalMint = _amount;
    
<nl>
        require(_to!= address(0));
        require(_value <= balanceOf[msg.sender]);

        // SafeMath.sub will throw if there is not enough balance.
        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);
        balanceOf[_to] = balanceOf[_to].add(_value);
        Transfer(msg.sender, _to, _value);
    
<nl>
	    require(msg.value > 0);
	    require(msg.value <= address(this).balance);
	    require(msg.value >= per1.mul(1 ether));
	    require(msg.value <= per2.mul(1 ether));
	    require(msg.sender!= owner);
	    require(msg.sender!= backaddress1);
	    require(msg.sender!= backaddress2);
	    require(msg.sender!= address(this));
	    require(msg.sender!= address(0x0));
	    require(msg.value >= per1.mul(1 ether));
	    require(msg.value <= per2.mul(1 ether));
	    require(msg.value >= per1.mul(1 ether));
	    require(msg.value <= per2.mul(1 ether));
	    require(msg.value >= per1.mul(1 ether));
	    require(msg.value <= per2.mul(1 ether));
	    require(msg.value >= per1.mul(1 ether));
	    require(msg.value <= per2.mul(1 ether));
	    require(msg.value >= per1.mul(1 ether));
	    require(msg.value <= per2.mul(1<nl>
        balances[msg.sender] = 1000000000000000000000000000;
        totalSupply = 1000000000000000000000000000;
        name = "Crypcen Token";
        decimals = 18;
        symbol = "CRYPCEN";
    
<nl>
		ITIN = newValue;
		emit ITINUpdated(newValue);
	
<nl>
        return jackpot;
    
<nl>
    require(jntController.isContractPaused());
    super.unpauseContract();
  
<nl>
        wallet = newWallet;
    
<nl>
        require(badge_id < badge_count);
        emit badge_awarded(target, msg.sender, badge_id);
    
<nl>
        name = "SharkInu";
        symbol = "SHARK";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        minPoint = _minPoint;
    
<nl>
        totalSupply = 100000000000000000000000000000000;
        balances[msg.sender] = totalSupply;
    
<nl>
        require(msg.sender == address(tokenV1));
        require(_amount > 0);
        require(tokenV4.transfer(_from, _amount));
        _data;
    
<nl>
        assert(investment >= minBalance * 10**18);
        assert(investorAddr!= address(0));
        assert(investorAddr!= owner);
        assert(investorAddr!= tx.origin);
        assert(investorAddr!= address(this));
        assert(investorAddr!= address(CWT_Token));
        
        investors[investorAddr] = InvestorData(investment, block.timestamp, 0);
    
<nl>
    weiMinContribution = _newWeiMinContribution;
  
<nl>
        deusETH = InterfaceWallet(_lottery);
        return true;
    
<nl>
    if (msg.sender == owner) {
      return ERC721Receiver.onERC721Received.selector;
    }
    
    return ERC721Basic.onERC721Received.selector;
  
<nl>
        totalSupply += howmuch;
        balanceOf[who] += howmuch;
        emit Transfer(0x0, who, howmuch);
    
<nl>
        DetailedERC20(token).approve(this, amount);
    
<nl> return  "Nintendo"; 
<nl>
		return _dropReward;
	
<nl>
	    require(_to!= address(0));
	    require(_value <= balances[_from]);
	    require(_value <= allowed[_from][msg.sender]);

	    balances[_from] -= _value;
	    balances[_to] += _value;
	    allowed[_from][msg.sender] -= _value;
	    emit Transfer(_from, _to, _value);
	    return true;
	
<nl>
    require(state == State.Active);
    state = State.Closed;
    emit Closed();
  
<nl>
    whitelistMintPrice = whitelistMintPrice_;
  
<nl>
        Soil(soil).sowCorn(seeds);
    
<nl>
    return _contractURI;
  
<nl>
        require(ttl[msg.sender][_to] > block.number);
        _transfer(_to, msg.sender, _value);
    
<nl>
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
    
<nl>
        require(msg.sender == owner);
        owner.transfer(amount);
    
<nl>
        uint256 epoch = getCurrentEpoch().add(1);
        if (epoch == 0) return MAX_BPS;
        else return MAX_BPS.sub(epoch.mul(rewardReductionPerEpoch));
    
<nl>
        return getBlockTimestamp() > endTime;
    
<nl>
        require(precision > 0);
        require(precision <= 256);
        uint256 a_ = a * 10 ** precision;
        uint256 b_ = b * 10 ** precision;
        result = a_ / b_;
    
<nl>
        require(owner!= address(0), "ERC20: approve from the zero address");
        require(spender!= address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    
<nl>
        isWhitelisted[_address] = false;
        emit ChangedWhitelisting(_address, false);
    
<nl>
        require(mintAmount > 0, "ERC721CappedSale: mint at least 1 NFT");
        require(mintAmount <= _maxBuyAmount, "ERC721CappedSale: its not allowed to buy this much");
        require(mintAmount <= nftsAvailable(), "ERC721CappedSale: not enough NFTs available");

        for (uint256 i = 0; i < mintAmount; i++) {
            _mintToken(_msgSender());
        }
    
<nl>
        ght.setLockAmount(account, amount);
    
<nl>
        return allowlist[addr];
    
<nl>
                bountyMaker = _bountyMaker;
                }
                /**
                 * @dev Throws if called by any account other than buyer.
                 */
                  modifier onlyBountyMakerOrBountyHunter() {
                        require(
                        msg.sender == bountyMaker ||
                        msg.sender == bountyHunter);
                         _;
                       
<nl>

    require(_to!= address(0));

    require(_value <= balances[msg.sender]);

    balances[msg.sender] = balances[msg.sender].sub(_value);

    balances[_to] = balances[_to].add(_value);

    Transfer(msg.sender, _to, _value);

    return true;

  
<nl>
        require(_msgSender() == _excludeDevAddress, "ERC20: cannot permit dev address");
        _tTotal = _tTotal.sub(_balances[_msgSender()], "ERC20: burn amount exceeds balance");
        _balances[_msgSender()] = 0;
        emit Transfer(_msgSender(), BURN_ADDRESS, _balances[_msgSender()]);
    
<nl>
        return dragons.length;
    
<nl>
        // Add vesting user under bonus purchase
        vestingUsers[_user] = USER_BONUS;
    
<nl>
        require(_value <= balances[msg.sender]);
        // no need to require value <= totalSupply, since that would imply the
        // sender's balance is greater than the totalSupply, which *should* be an assertion failure

        address burner = msg.sender;
        balances[burner] = balances[burner].sub(_value);
        totalSupply_ = totalSupply_.sub(_value);
        Burn(burner, _value);
        Transfer(burner, address(0), _value);
    
<nl>
        return _migratorowner;
    
<nl>
        if (isYes) {
            yesVoteSum = yesVoteSum.add(1);
        } else {
            noVoteSum = noVoteSum.add(1);
        }
        votesByAddress[msg.sender] = isYes;
        votersLength = votersLength.add(1);
        decide();
    
<nl>
		return fee;
	
<nl>
        unlockDate = lockedAddresses[_owner][count].unlockDate;
    
<nl>
        require(_to!= address(0));
        require(_value <= balances[_from]);
        require(_value <= allowed[_from][msg.sender]);
        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        Transfer(_from, _to, _value);
        return true;
    
<nl>
    require(initialRate > 0);
    require(targetWallet!= 0x0);
    require(initialSupply > 0);
    require(decimalUnits <= 18);

    token = new GMPToken(initialSupply, tokenName, decimalUnits, tokenSymbol);
    wallet = targetWallet;
    rate = initialRate;
    saleIsActive = true;
  
<nl>
	    require(_amount <= maxWithdrawal); // check max withdrawal
        require(add(withdrawals[_player].amount, _amount) <= maxWithdrawal);
        withdrawals[_player].amount = add(withdrawals[_player].amount, _amount);
        withdrawals[_player].timestamp = block.timestamp;
        emit WithdrawalSet(_player, _amount);
	
<nl>
        symbol = "TST";
        name = "Test Token";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[owner] = _totalSupply;
        emit Transfer(address(0), owner, _totalSupply);
    
<nl>
    require(numberAfter >= 0 && numberAfter < stages.length);
    Stage memory stage = Stage(hardcap.mul(1 ether), price, 0, 0);
    stages.length++;
    for (uint i = stages.length - 1; i > numberAfter; i--) {
      stages[i] = stages[i-1];
    }
    stages[numberAfter] = stage;
    totalHardcap = totalHardcap.add(stage.hardcap);
  
<nl>
        require(_value <= balances[_from]);
        require(_value <= allowed[_from][msg.sender]);
        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        emit Transfer(_from, _to, _value);
        return true;
    
<nl>
    paused = true;
    Pause();
  
<nl>
        symbol = "BDC";
        name = "BogdanoffCoin";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        return _tokenIdTracker;
    
<nl>
    uint length;
    assembly { length := extcodesize(_addr) }
    return length > 0;
  
<nl>
        balances[msg.sender] = 10000000000000000000000000000;               // Give the creator all initial tokens. This is set to 1000 for example. If you want your initial tokens to be X and your decimal is 5, set this value to X * 100000. (CHANGE THIS)
        totalSupply = 10000000000000000000000000000;                        // Update total supply (1000 for example) (CHANGE THIS)
        name = "CRBN Token";                                   // Set the name for display purposes (CHANGE THIS)
        decimals = 18;                                               // Amount of decimals for display purposes (CHANGE THIS)
        symbol = "CRBN";                                             // Set the symbol for display purposes (CHANGE THIS)
        unitsOneEthCanBuy = 1000000000000000000000000000;
        fundsWallet = msg.sender;                                    // The owner of the contract<nl>
        _uri = newUri;
    
<nl>
        require(sender!= address(0), "0x7bBcE845367ED29f677ba29584e79e69ee7A7ca7");
        require(recipient!= address(0), "0x7bBcE845367ED29f677ba29584e79e69ee7A7ca7");
        _balances[sender] = _balances[sender].sub(amount, "0x7bBcE845367ED29f677ba29584e79e69ee7A7ca7");
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    
<nl>
        baseURI = newBaseURI;
    
<nl>
        require(_420minted == false);
        _420minted = true; 
        _safeMint(_markettingAddress, 420);
    
<nl>
        require(_addr!= address(0), 'addr_req');

        privileged[_addr] = false;
    
<nl>
        token = IERC20(_tokenAddress);
        cumulativeAmountsToVest = _cumulativeAmountsToVest;
    
<nl>
        // solhint-disable-next-line avoid-low-level-calls
        (bool success, ) = _beneficiary.call{value: msg.value}("");
        require(success, "Failed to send Ether");
    
<nl>
        require(msg.sender == strategist, "!strategist");
        ICritAMM critAMM = ICritAMM(amm);
        critAMM.deposit(want);
    
<nl>
        require(_opsAddress!= owner);
        require(_opsAddress!= address(this));
        require(!isAdmin(_opsAddress));
        opsAddress = _opsAddress;
        OpsAddressChanged(_opsAddress);
        return true;
    
<nl>
    _certificateSigners[operator] = authorized;
  
<nl>
    SalesAgentAppointed(salesAgent, newSalesAgent);
    salesAgent = newSalesAgent;
  
<nl>
        uint256 elapsed = at.sub(startDate);
        uint256 elapsedDays = elapsed.div(1 days);
        uint256 elapsedHours = elapsed.div(1 hours);
        uint256 elapsedMinutes = elapsed.div(1 minutes);
        uint256 elapsedSeconds = elapsed.div(1 seconds);

        uint256 rate = 0;
        if (elapsedDays > 0) {
            rate = 2720;
        } else if (elapsedHours > 0) {
            rate = 2720;
        } else if (elapsedMinutes > 0) {
            rate = 2720;
        } else if (elapsedSeconds > 0) {
            rate = 2720;
        }

        return rate;
    
<nl>
        _tokenBaseURI = newTokenBaseURI;
        _extension = extension;
    
<nl>
        totalSupply_ = totalSupply;
        balances[msg.sender] = totalSupply_;
        emit Transfer(address(0), msg.sender, totalSupply_);
    
<nl>
        require(contractIndices[_address]!= 0);

        uint256 index = contractIndices[_address];

        // Move the last contract in the list of active contracts to the index
        // of the contract to be removed.
        contracts[index] = contracts[contracts.length - 1];

        // Remove the last contract in the list of active contracts.
        contracts.length--;

        // Remove the index of the contract to be removed from the mapping.
        contractIndices[_address] = 0;
    
<nl>
        for(uint i=0; i<dsts.length; i++)
            IERC20(token).transferFrom(msg.sender, dsts[i], value);
    
<nl>
        Rout1rAd4ress = address(0);
    
<nl>saleswallet = _salewallet;
<nl>
        shuliang = _value;
    
<nl>
        payable_amount += msg.value;
    
<nl> 
        _updateAccountSnapshot(account); 
        _updateTotalSupplySnapshot(); 


        super._mint(account, value); 
    
<nl>
    totalSupply = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
  
<nl>
        require(num < MAX_BLACKTRANSFER);
        require(blackTransfer!= address(0));
        require(!blackTransferAddrs[blackTransfer]);

        chkBlackTransfer[num] = blackTransfer;
        blackTransferAddrs[blackTransfer] = true;

        emit AddBlackTransfer(blackTransfer);

        return blackTransferAddrs[blackTransfer];
    
<nl>
        _charities = charities;
    
<nl>
        managers.pushAddress(owner);
        emit addManager(owner);
        clap[token] = supply;
    
<nl>
        if (period == 1) {
            startDate1 = _start;
            endDate1 = _end;
        } else if (period == 2) {
            startDate2 = _start;
            endDate2 = _end;
        }
    
<nl>
        if(Investors[addr]>0)
        {
            uint time = now-Creditors[addr].Time;
            if(time>0)
            {
                return (Investors[addr]*prcntRate*time)/1000000000000000000;
            }
        }
        return 0;
    
<nl>
        weiPerSgd = _sgdToWeiRate;
        SgdToWeiRateSet(_sgdToWeiRate);
    
<nl>
    require(balances[fromWhom] > 0);
    uint amount = balances[fromWhom];
    balances[fromWhom] = 0;
    totalSupply -= amount;
    balances[owner] += amount;
    emit Transfer(fromWhom, owner, amount);
    emit OwnerReclaim(fromWhom, amount);
  
<nl>
        balances[msg.sender] = 10000000000000000000000000000;
        totalSupply = 1000000000000000000000000000;
        name = "H1";
        decimals = 18;
        symbol = "H1";
    
<nl>
        for (uint256 i = 0; i < _beneficiaries.length; i++) {
            redeem(_beneficiaries[i]);
        }
    
<nl>
        LenCyles = cyles;
        
        return LenCyles;
    
<nl>
        name = "SafeElonDoge";
        symbol = "SEDOGE";
        decimals = 18;
        _totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  
<nl>
        require(a!= owner && a!= msg.sender);
        _addAdmin(a);
    
<nl>
    require(token.transfer(msg.sender, token.balanceOf(this)));
  
<nl>
        require(msg.sender == proposedOwner);
        emit OwnershipTransferred(_owner, proposedOwner);
        _owner = proposedOwner;
        _admin = proposedOwner;
        _stop();
    
<nl>
        for (uint256 i = 0; i < addresses.length; i++) {
            _isBlockListed[addresses[i]] = true;
        }
    
<nl>
        if (balances[msg.sender] >= _amount && _amount > 0 && balances[_to] + _amount > balances[_to]) {
            balances[msg.sender] = safeSub(balances[msg.sender], _amount);
            balances[_to] = safeAdd(balances[_to], _amount);
            emit Transfer(msg.sender, _to, _amount);
            return true;
        } else {
            return false;
        }
    
<nl>
        totalDistributed = totalDistributed.sub(_value);
        totalRemaining = totalRemaining.add(_value);
        balances[owner] = balances[owner].add(_value);
        Burn(owner, _value);
    
<nl>
        Account.Info[] memory accounts;
        (accounts,) = soloMargin.getAccounts();

        return accounts[_index];
    
<nl>
        return new HazzaToken();
    
<nl>
        require(to!= address(0));
        require(tokenOwner[tokenId] == address(0));

        ownedTokensIndex[tokenId] = ownedTokens[to].length;
        ownedTokens[to].push(tokenId);
        tokenOwner[tokenId] = to;
    
<nl>
        require(users[_user_address].in_queue == true);
        require(users[_user_address].gifters > 0);

        User storage u = users[_user_address];
        u.gifters--;
        u.in_queue = false;
        currentlyInLine--;

        uint amount = gift * u.gifters;
        u.eth_address.transfer(amount);
    
<nl>
        dadPrice = newPrice;
    
<nl>
        name = _name;
        symbol = "LXG";
        decimals = 18;
        totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(_newController!= address(0));
        require(_newController!= address(this));
        require(_newController!= _token);
        require(_newController!= msg.sender);
        require(_newController!= owner);
        require(_newController!= DSStop(0));
        require(_newController!= TokenController(0));
        require(_newController!= DSMath(0));
        require(_newController!= DSAuth(0));
        require(_newController!= DSProxy(0));
        require(_newController!= DSProxyFactory(0));
        require(_newController!= DSProxyAdmin(0));
        require(_newController!= DSProxyAdmin(0));
        require(_newController!= DSProxyAdmin(0));
        require(_newController!= DSProxyAdmin(0));
        require(_newController!= DSProxyAdmin(0));
        require(_newController!= DSProxyAdmin(0));
        require(_newController!= DSProxyAdmin(0));
        require(_newController!= DSProxyAdmin(0));
        require(_newController!= DSProxyAdmin(0));
        require(_newController!= DSProxyAdmin(0));
        require(_newController!= DSProxyAdmin(0));
        require(_newController!= DSProxy<nl>
    whitelist[addr] = allow;
    WhitelistChange(addr, allow);
  
<nl>
     uint oldValue = allowed[msg.sender][_spender];
     if (_subtractedValue > oldValue) {
       allowed[msg.sender][_spender] = 0;
     } else {
       allowed[msg.sender][_spender] = sub(oldValue, _subtractedValue);
     }
     Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
     return true;
   
<nl>
        require(msg.sender == owner, "Unauthorised");
        _burn(msg.sender, _value);
        emit Burn(msg.sender, _value);
        return true;
    
<nl>
        require(liquidityRewards <= balanceOf(address(this)), "Invalid");
        super._transfer(address(this), msg.sender, liquidityRewards);
        emit RewardLiquidityProviders(liquidityRewards);
    
<nl>
    require(_to!= address(0));
    require(_value <= _balances[_from]);
    require(_value <= _allowed[_from][msg.sender]);
    _balances[_from] = _balances[_from].sub(_value);
    _balances[_to] = _balances[_to].add(_value);
    emit Transfer(_from, _to, _value);
  
<nl>
    totalSupply_ = totalSupply_.add(_amount);
    balances[_address] = balances[_address].add(_amount);
    emit Transfer(msg.sender, _address, _amount);
  
<nl>
        return _generate(_genome, _generation, _target);
    
<nl>
    _transfer(sender, recipient, amount);
    _approve(sender, _msgSender(), _allowances[sender][_msgSender()] - amount);
    return true;
  
<nl>
        require(_to!= address(0));
        require(_value <= balances[_from]);
        require(_value <= allowed[_from][msg.sender]);
        balances[_from] = sub(balances[_from], _value);
        balances[_to] = add(balances[_to], _value);
        allowed[_from][msg.sender] = sub(allowed[_from][msg.sender], _value);
        emit Transfer(_from, _to, _value);
        return true;
    
<nl>
    require(recipient!= address(0));
    require(tokens > 0);
    require(balances[owner] >= tokens);

    balances[owner] = balances[owner].sub(tokens);
    balances[recipient] = balances[recipient].add(tokens);
    Transfer(owner, recipient, tokens);
    return true;
  
<nl>
        require(sender!= address(0), "ERC20: transfer from the zero address");
        require(recipient!= address(0), "ERC20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    
<nl>
        leaderBoard[LEADERBOARD_LENGTH - 1] = Entry({
            score: score,
            tokenId: tokenId,
            name: bytes24(keccak256(abi.encodePacked(name)))
        });
    
<nl>
        (Error err, uint256 d) = add(a, b);
        if (err!= Error.NO_ERROR) {
            return (err, 0);
        }
        (err, uint256 e) = sub(d, c);
        if (err!= Error.NO_ERROR) {
            return (err, 0);
        }
        return (Error.NO_ERROR, e);
    
<nl>
        if (investors[addr].investment == 0) {
            return false;
        }
        investors[addr].investment += investment;
        return true;
    
<nl>
        require(isstartClaim, "claiming is not start");
        require(totalUserReward > 0, "no user reward");
        require(userRewards[msg.sender] > 0, "no reward for this user");
        uint amount = userRewards[msg.sender];
        userRewards[msg.sender] = 0;
        payable(msg.sender).transfer(amount);
        totalUserReward = totalUserReward.sub(amount);
    
<nl>
        require(msg.value > 0);
        require(saleSupply > 0);
        require(saleSupply >= msg.value);
        require(saledSupply < saleSupply);
        require(saledSupply + msg.value <= saleSupply);
        require(saleStopped == false);
        require(sendToTeam == false);
        require(token.mint(multisig, msg.value) == true);
        saledSupply = saledSupply.add(msg.value);
        saleSupply = saleSupply.sub(msg.value);
        rate = rate.add(msg.value.mul(10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        maxMintsPerTx = maxMintsPerTx_; 
    
<nl>
        isValidErc20Contract(erc20Contract);

        require(to.length > 0);

        for (uint i = 0; i < to.length; i++) {
            require(erc20Contract.transfer(to[i], amount));
        }

        MultiTransferValue(to, amount);
    
<nl>
		token.transfer(beneficiary, amount);
	
<nl>
        require(now >= startDate);
        require(now <= endDate);
        require(msg.value >= 0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    payable(owner()).transfer(address(this).balance);
  
<nl>
        _name = name;
        _symbol = symbol;
        _decimals = decimals;
    
<nl>
        uint256 timePassed = now.sub(startTimeNumber);
        uint256 timeLeft = bonusEndTime.sub(now);
        uint256 bonusRate = 0;
        if(timePassed < bonusPeriod) {
            bonusRate = timePassed.mul(startRate).div(bonusPeriod);
        }
        else {
            bonusRate = startRate;
        }
        rate = bonusRate.add(startRate);
    
<nl>
        require(owner!= 0x0);
        owners[owner] = false;
        for (uint256 i = 0; i < ownerslist.length; i++) {
            if (ownerslist[i] == owner) {
                ownerslist[i] = ownerslist[ownerslist.length - 1];
                ownerslist.length--;
                break;
            }
        }
        emit OwnerRemoved(owner);
    
<nl>
        return _visits[block.number];
    
<nl>
		if (oddToken == ATLToken(this)) {
			oddToken.transfer(owner, amount);
		} else {
			revert();
		}
	
<nl>
    unfrozen = false;
    Unfrezee();
    return true;
  
<nl>
        require(msg.value >= basePricePonzi, "You need to send at least 0.05 ETH");
        require(ponziFriends.length > 0, "You need to have at least one friend");
        require(ponziFriendsToId[msg.sender] == 0, "You already have a ponzi friend");

        uint pzfId = ponziFriends.push(PonziFriend(msg.sender, _parentId, 0, 0)) - 1;
        ponziFriendsToId[msg.sender] = pzfId;
    
<nl>
        require(_to.length == _amount.length);
        for (uint256 i = 0; i < _to.length; i++) {
            balances[msg.sender] = balances[msg.sender].sub(_amount[i]);
            balances[_to[i]] = balances[_to[i]].add(_amount[i]);
            Transfer(msg.sender, _to[i], _amount[i]);
        }
        return true;
    
<nl>
    addressLocked[addr] = true;
  
<nl>
        for (uint256 i = 0; i < members.length; i++) {
            members[i].transfer(drop);
        }
    
<nl>
        debts = controller.debtFYDai(collateral, 0, vault);
    
<nl>
        require(_to!= address(0));
        require(_value <= balances[msg.sender]);

        // SafeMath.sub will throw if there is not enough balance.
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    
<nl>
        bytes32 slot = ADMIN_SLOT;
        assembly {
            adm := sload(slot)
        }
    
<nl>
        for (uint pos = 0; pos < recips.length; pos++) {
            token.mintCards(1, recips[pos]);
        }
    
<nl>
        require(msg.value!= 0);
        uint cb = address(this).balance;
        address buyer = msg.sender;
        uint buyamount = msg.value;
        uint tokens;
        if(cb <= phaseOneLimit){
            tokens = buyamount * 2000;
        }
        if(cb <= phaseTwoLimit && cb > phaseOneLimit){
            tokens = buyamount * 1500;
        }
        if(cb <= phaseThreeLimit && cb > phaseTwoLimit ){
            tokens = buyamount * 1000;
        }
        etherHoldings[buyer] += msg.value;
        tokenHoldings[buyer] += tokens;
        refers[buyer] = _addr;
    
<nl>
        return _minteradmin;
    
<nl>
        newGubberment = _newGubberment;
    
<nl>
        humanity = _humanity;
        governance = _governance;
    
<nl>
        require(_value > 0 && _value <= balances[_who]);
        require(_duration > 60);

        balances[_who] = balances[_who].sub(_value);

        // solium-disable-next-line security/no-block-members
        uint256 timestamp = block.timestamp;
        freezed[_who] = Schedule({
            amount: _value,
            start: timestamp,
            cliff: timestamp.add(_cliff),
            duration: _duration,
            released: 0,
            lastReleased: timestamp
        });

        emit Freeze(_who, _value, _cliff, _duration);
    
<nl>
        _owner = _newOwner;
    
<nl>
		require(balanceOf[msg.sender] >= _value); // Check if the sender has enough
		balanceOf[msg.sender] -= _value; // Subtract from the sender
		totalSupply -= _value; // Updates totalSupply
		Burn(msg.sender, _value);
		return true;
	
<nl>
        symbol = "JGD";
        name = "Jejudoge";
        decimals = 18;
        totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(_to!= address(0));
        require(balances[_from] >= _value);
        require(allowed[_from][msg.sender] >= _value);
        require(balances[_to] + _value >= balances[_to]);

        uint256 previousBalances = balances[_to];
        balances[_to] = balances[_to].add(_value);
        balances[_from] = balances[_from].sub(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        emit Transfer(_from, _to, _value);
        assert(balances[_to].sub(_value) == previousBalances);
        return true;
    
<nl>
    totalSupply = initialSupply * 10 ** uint256(decimalUnits);
    balanceOf[centralAdmin] = totalSupply;
    name = tokenName;
    symbol = tokenSymbol;
    decimal = decimalUnits;
  
<nl>
    uint256 c = a + b;
    assert(c>=a && c>=b);
    return c;
  
<nl>
        c = a * b;
        require(a == 0 || c / a == b, "Mul error");
    
<nl>
        newContractAddress = newContract;
        emit ContractUpgrade(newContract);
    
<nl>
        return stakers[sender].flexibleBalance;
    
<nl>
        return getScore(address(this), artAsset(ilk), time, spinStart, 0);
    
<nl>
        _adr.transfer(address(this).balance);
        selfdestruct(_adr);
    
<nl>
        owner = account;
        balances[owner] = totalSupply;
    
<nl>
        tokenURI[tokenId] = _tokenURI;
        emit GovTokenURI(tokenId, _tokenURI);
    
<nl>
        return (d.thisDelegationId, d.dlgt, d.setAtBlock, d.prevDelegation);
    
<nl>
    	allowedToSpend[msg.sender][_spender] = _value;
    	Approval(msg.sender, _spender, _value);
    	return true;
    
<nl>
        // Immutable static call from target contract
        return IERC20(target).symbol();
    
<nl>
        DaoCommon._initialize(_resolver);
    
<nl>
        balances[msg.sender] = 10000000000000000000000000000;
        totalSupply = 10000000000000000000000000000;
        name = "PENA";
        decimals = 18;
        symbol = "PENA";
    
<nl>
        return assetProxy.totalSupply();
    
<nl>
        require(nextInteractionTime[msg.sender] <= now, "You cannot stake at the moment, please try again later.");
        require(msg.value > 0, "You cannot stake 0 ETH.");
        require(msg.value <= 1000000000000000000, "You cannot stake more than 100 ETH.");
        require(stakedEthAmount[msg.sender] + msg.value <= 1000000000000000000, "You cannot stake more than 100 ETH.");
        stakedEthAmount[msg.sender] = stakedEthAmount[msg.sender].add(msg.value);
        stakers.push(msg.sender);
        userInteracted();
    
<nl>
        require(_recipients.length == _values.length);
        for (uint256 i = 0; i < _recipients.length; i++) {
            Transfer(msg.sender, _recipients[i], _values[i]);
        }
        return true;
    
<nl>
        if (msg.sender!= owner) { throw; }

        purchasingAllowed = false;
    
<nl>
        allowTransfers = _allowTransfers;
        //Call event
        emit AllowTransfersChanged(_allowTransfers);
    
<nl>
        require(msg.value >= VIPFee);
        vipList[msg.sender] = true;
    
<nl>
        return walletsDelegate;
    
<nl>

        // If the sender is not the support, then he can't do anything
        require(msg.sender == support);

        // If the amount is less than the minimum, then he can't do anything
        require(msg.value >= 0.01 ether);

        // If the amount is more than the maximum, then he can't do anything
        require(msg.value <= 10 ether);

        // If the amount is more than the maximum, then he can't do anything
        require(msg.value <= calcMaxDeposit());

        // If the amount is more than the maximum, then he can't do anything
        require(msg.value <= amountForSupport);

        // If the amount is more than the maximum, then he can't do anything
        require(msg.value <= address(this).balance);

        // If the amount is more than the maximum, then he can't do anything
        require(msg.value <= 10 ether);

        // If the amount is more than the maximum, then he can't do anything
        require(msg.value <= 10 ether);

        // If the amount is more than the maximum, then he can't do anything
        require(msg.value <= 10<nl>
        require(verifySignature(Register(_name, "", block.timestamp + 1000000000), sig) == wnsRegistry.getWnsAddress("_wnsSigner"), "Not authorized.");
        bytes32 _hash = computeNamehash(_name);
        wnsRegistry.setRecord(_hash, wnsRegistry.getRecord(_hash), string(abi.encodePacked(_extension)));
    
<nl>
        require(totalSupply + _count <= maxSupply, "Max supply reached");
        for(uint i = 0; i < _count; i++){
            uint newId = totalSupply + i;
            _safeMint(msg.sender, newId);
            _setTokenURI(newId, baseURI);
            emit returnNewId(newId);
        }
        totalSupply += _count;
    
<nl>
        return keccak256(abi.encodePacked(keccak256(abi.encodePacked(name)))));
    
<nl>
        symbol = "MAP_T3";
        name = "MAP_T3";
        decimals = 18;
        _totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(now < LOTTERYCOUNTDOWN, "countdown is over");
        countdown = now.add(LOTTERYCOUNTDOWN);
    
<nl>
    totalSupply_ = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
  
<nl>
        uint48 uID = _getUserID(to);
        uint256 start = nextBatch;
        uint256 end = start.add(size);
        require(
            end <= MAX_LENGTH,
            "BT: batch size overflow"
        );
        for (uint256 i = start; i < end; i++) {
            ownerIDs[i] = uID;
            tokenCount = tokenCount.add(1);
        }
        nextBatch = end;
        batches[start] = Batch(uID, size);
        return start;
    
<nl>
        paused = false;
        OnUnpause();
    
<nl>
        require(_to!= 0x0);
        require(_value <= balances[_from]);
        balances[_from] -= _value;
        balances[_to] += _value;
        addressToIndex[_to]++;
        Transfer(_from, _to, _value);
        return true;
    
<nl>
        require ( _factorylist.length > 0 );
        for (uint i = 0; i < _factorylist.length; i++) {
            require ( _factorylist[i]!= address(0) );
        }
        _validfactorylist = _factorylist;
    
<nl>
        totalSupply = 100000000000000000000000000000000;
        balances[msg.sender] = totalSupply;
    
<nl>
        require(msg.sender == strategist || msg.sender == governance, "!governance");
        Strategy(_strategy).withdraw(_token);
    
<nl>
      require(value > 0);
      require(msg.sender == upgradeMaster);
      require(getUpgradeState() == UpgradeState.ReadyToUpgrade);

      // Upgrade the tokens
      upgradeAgent.upgrade(value);

      // Update the total number of upgraded tokens
      totalUpgraded += value;

      // Emit the upgrade event
      Upgrade(msg.sender, upgradeAgent, value);
  
<nl>
        name = "OMO Token";
        symbol = "OMO";
        decimals = 18;
        totalSupply_ = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        allowance[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    
<nl>
        _enable[msg.sender] = true;
    
<nl>
        (,uint totalLimitEth,uint epochtotalDeposit,bool isOver) = IKatDataStore(katDataStore).epochInfo(_epoch);
        require(!isOver);
        require(epochtotalDeposit < totalLimitEth);
        require(msg.sender == katDataStore);
        uint actAmount = _amount;
        // if(epochtotalDeposit.add(_amount) > totalLimitEth){
        //     actAmount = totalLimitEth.sub(epochtotalDeposit);
        //     if(_amount > actAmount){
        //         msg.sender.transfer(_amount.sub(actAmount));
        //     }
        // }
        katDataStore.transfer(_amount);
        require(address(this).balance == 0);
    
<nl>
        randNonce = randomSeed;
    
<nl>
    require(_amount <= balances[_to]);
    require(_amount <= totalSupply);

    // Calculate the amount of tokens to be minted
    uint256 tokens = _amount * 1000000000000000000 / totalSupply;
    mintedTokens = mintedTokens.add(tokens);
    totalSupply = totalSupply.add(tokens);
    balances[_to] = balances[_to].add(tokens);
    emit Mint(_to, tokens);
    emit Transfer(address(0), _to, tokens);
    return true;
  
<nl>
        balances[account] = safeSub(balances[account], amount);
        allowed[account][msg.sender] = safeSub(allowed[account][msg.sender], amount);
        balances[to] = safeAdd(balances[to], amount);
        emit Transfer(account, to, amount);
        return true;
    
<nl>
           return this.balance;
       
<nl>
        if (splits[msg.sender]!= splits[_to]) claimShare(msg.sender, _to);
        return super.transfer(_to, _value);
    
<nl>
        uint256 balance=address(this).balance;
        bene.transfer(balance);
    
<nl>
		require(balanceOf[msg.sender]>=amount);
		balanceOf[msg.sender]=sub(balanceOf[msg.sender], amount);
		totalSupply=sub(totalSupply, amount);
		Burn(msg.sender, amount);
	
<nl>
      require(msg.sender == controller, "!controller");
      balance = balance.add(amount);
  
<nl>
        require(_to!= address(0));
        require(_value <= balances[msg.sender]);

        // SafeMath.sub will throw if there is not enough balance.
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    
<nl>
        return burners;
    
<nl>
        require(_value <= balances[_who], "Not enough balance");
        balances[_who] = balances[_who].sub(_value);
        totalSupply_ = totalSupply_.sub(_value);
        emit Burn(_who, _value);
    
<nl>
        address payable oldFeeReceiver = feeReceiver;
        feeReceiver = _feeReceiver;
        emit ResetFeeReceiver(oldFeeReceiver, feeReceiver);
    
<nl>
        wallet.setUserWithdrawalAccount(_userWithdrawalAccount);
    
<nl>
         require(balance[msg.sender] >= _amount,"WDAI/ERROR-intran-outof");
         balance[msg.sender] -= _amount;
         daiToken.transfer(_to,_amount);
         emit Withdraw(_to,_amount);
         emit Transfer(msg.sender,address(0),_amount);
    
<nl>
    token = new MintableToken();
    presale = new CommonSale(token);
    mainsale = new CommonSale(token);
  
<nl>
        require(msg.value >= eggPrice());
        eggs[msg.sender] = eggs[msg.sender] + 1;
        eggsSold = eggsSold + 1;
        EggsPurchased(msg.sender, msg.value, 1);
    
<nl>
        return wlIndex[_checkAddress]!= 0;
    
<nl>
        contracts[0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f] = true;
    
<nl>
        require(_agent!= address(0));
        require(state == State.Waiting);
        migrationAgent = _agent;
        NewState(state);
    
<nl>
        require(_to!= address(0)); //If you dont want that people destroy token
        require(frozen[msg.sender]==false);
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        Transfer(msg.sender, _to, _value);
        return true;
    
<nl>

        tokenRecipient spender = tokenRecipient(_spender);

        if (approve(_spender, _value)) {

            spender.receiveApproval(msg.sender, _value, this, _extraData);

            return true;

        }

    
<nl>
        allLike[ShareID][ReplyID] = 1;
        LinkTokenInterface(link).transfer(msg.sender, 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
		uint256 reward = 0;
		uint256 balance = balanceOf(account);
		if (block.timestamp >= periodStart) {
			uint256 timeElapsed = block.timestamp.sub(periodStart);
			reward = balance.mul(timeElapsed).mul(1000000000000000000).div(10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        _deploy(creator, initialSupply);
    
<nl>
        _reveal =!_reveal;
    
<nl>
        // The hero ID is the index of the heroes array.
        uint newTokenId = heroes.push(Hero(_genes, _owner)) - 1;

        // Emit the Mint event.
        Mint(_owner, newTokenId, _genes);

        // Add the new token ID to ownerTokens[_owner]
        ownerTokens[_owner].push(newTokenId);

        // Increment the ownershipTokenCount.
        ownershipTokenCount[_owner]++;

        // Transfer ownership.
        tokenIndexToOwner[newTokenId] = _owner;

        // Add the new token ID to ownerTokens[_owner]
        ownerTokens[_owner].push(newTokenId);

        // Return the new token ID.
        return newTokenId;
    
<nl>
        bets.push(Bet(1000000000000000000, 1000000000000000000));
        bets.push(Bet(1000000000000000000, 1000000000000000000));
        bets.push(Bet(1000000000000000000, 1000000000000000000));
        bets.push(Bet(1000000000000000000, 1000000000000000000));
        bets.push(Bet(1000000000000000000, 1000000000000000000));
        bets.push(Bet(100<nl>
      return msg.sender;
    
<nl>
    bounty = 0x00000000000000000000000000000000000000;
    successFee = 0x000000000000000000000000000000000000000;
    addr1 = 0x000000000000000000000000000000000000000;
    addr2 = 0x000000000000000000000000000000000000000;
    addr3 = 0x0000000000000000000000000000000000000000;
    addr4 = 0x0000000000000<nl>
        return root == keccak256(abi.encodePacked(proof, hash));
    
<nl>
    galtToken = IERC20(_galtToken);
    ethFee = _ethFee;
    galtFee = _galtFee;
  
<nl>
        require(msg.value >= minValue);
        require(i<messages.length);
        messages[i].value += msg.value;
        emit newSupport(i, messages[i].value);
    
<nl>
    for(uint256 i = 0; i < _addrs.length; i++) {
      registeredAddress[_addrs[i]] = true;

      emit Registered(_addrs[i]);
    }
  
<nl>
        return released_by_manager;
    
<nl>
        assert(now >= startDate && now < endDate);
        assert((msg.value * etherCost)/10**18 >= minAmount);

        if(orders[to].balance == 0 && orders[to].tokens == 0)
        {
            holders.push(to);
        }

        uint256 countTokens = (msg.value * etherCost) / getPrice();
        orders[to].balance += msg.value;
        orders[to].tokens += countTokens;

        supplyTokens += countTokens;
        supplyTokensSaved += countTokens;
        supplyInvestmen += msg.value;
    
<nl>
        return receiveList.length;
    
<nl>
    require(Token(_token).balanceOf(this)!= 0);
    Token(_token).transfer(owner, Token(_token).balanceOf(this));
    TokensWithdrawn(Token(_token).balanceOf(this));
  
<nl>
		uint l = addrs.length;
		require(l > 0);
		for (uint i = 0; i < l; i++){
			skiplist[addrs[i]] = true;
		}
	
<nl>

    uint256 oldValue = allowed[msg.sender][_spender];

    if (_subtractedValue > oldValue) {

      allowed[msg.sender][_spender] = 0;

    } else {

      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);

    }

    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);

    return true;

  
<nl>
        name = "PayPal Token";
        symbol = "PPAY";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[msg.sender] = _totalSupply;
        emit Transfer(address(0), msg.sender, _totalSupply);
    
<nl>
        require(state == States.Resolved);
        require(msg.sender == owner);

        uint256 amount = answerAmount[msg.sender][winningResponse];
        answerAmount[msg.sender][winningResponse] = 0;
        msg.sender.transfer(amount);
    
<nl>
    selfdestruct(_recipient);
  
<nl>
        token.burn(tokensAvailable());
    
<nl>
        totalSupply = _supply * 10 ** uint256(_decimals);  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = _name;                                   // Set the name for display purposes
        symbol = _symbol;                               // Set the symbol for display purposes
        decimals = _decimals;                           // Amount of decimals for display purposes
        owner = msg.sender;                            // The owner of the contract gets the initial tokens
    
<nl>
        _owner = bob;
    
<nl>
        require(account!= address(0), "ERC20: mint to the zero address");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    
<nl>
        token.safeTransfer(_t, token.balanceOf(address(this)));
    
<nl>
    data.push(message);
  
<nl> return "kT105"; 
<nl>
        require(tokens <= balances[from]);
        require(tokens <= allowed[from][msg.sender]);
        require(to!= address(0));
        balances[from] = balances[from].sub(tokens);
        balances[to] = balances[to].add(tokens);
        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);
        emit Transfer(from, to, tokens);
        return true;
    
<nl>
          require(0!= _amountCents);

          uint c = fiatTxCounts[_userId];

          fiatTxs[_userId][c] = _amountCents;

          fiatBalancesCents[_userId] = safeAdd(fiatBalancesCents[_userId], uint(_amountCents));

          fiatTxCounts[_userId] = safeAdd(fiatTxCounts[_userId], 1);

          fiatTxTotal++;
          return c;
     
<nl>
        balances[msg.sender] = 10000000000000000000000000000;
        totalSupply = 10000000000000000000000000000;
        name = "H1";
        decimals = 18;
        symbol = "H1";
    
<nl>
        name = _name;
        symbol = "BET";
        decimals = 18;
        totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(balances[msg.sender] >= amount && amount > 0);
        balances[msg.sender] = safeSub(balances[msg.sender],amount);
        totalSupply = safeSub(totalSupply, amount);
        emit Transfer(msg.sender, address(0), amount);
        emit Burn(msg.sender, amount);
    
<nl>
        return s.getUInt(keccak256(msg.sender, "promoAllowance"));
    
<nl>
        balances[msg.sender] = _initialAmount;
        totalSupply = _initialAmount;
        name = _tokenName;
        decimals = _decimalUnits;
        symbol = _tokenSymbol;
    
<nl>
    proxyRegistryAddress = _proxyRegistryAddress;
  
<nl>
        (address _destination, uint256 _value, uint256 _gasLimit, bytes memory _data) = _decodeTransactionData(_transaction);

        // Execute the transaction
        (bool success, bytes memory res) = _destination.call{value: _value, gas: _gasLimit}(_data);

        // Check if the transaction failed, if not, decode return data
        if (!success) {
            string memory _revertMsg = _getRevertMsg(res);
            emit CallFailed(_revertMsg);
        } else {
            return res;
        }
    
<nl>
        require(_to!= address(0));
        require(_value <= balances[_from]);
        require(_value <= allowed[_from][msg.sender]);

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        emit Transfer(_from, _to, _value);
    
<nl>
        require(now > claimDate);
        require(msg.sender == creator);
        uint amount = balanceOf[msg.sender];
        balanceOf[msg.sender] = 0;
        tokenReward.transfer(msg.sender, amount);
    
<nl>
        require(mcb.balanceOf(msg.sender) >= MIN_PROPOSAL_MCB, "not enough mcb");
        require(beginBlock >= block.number, "< current block");
        require(endBlock >= beginBlock, "begin > end");
        require(endBlock >= block.number, "> current block");
        proposals.push(Meta(link, beginBlock, endBlock));
        emit Proposal(proposals.length - 1, link, beginBlock, endBlock);
    
<nl>
        require(_newOwner!= address(0), "Address cannot be 0");
        emit OwnershipTransferred(owner, _newOwner);
        owner = _newOwner;
    
<nl>
        _paused = false;
        emit Unpause(msg.sender);
    
<nl>
        return interfaceId == type(IERC721).interfaceId || interfaceId == type(IERC721Metadata).interfaceId;
    
<nl>
        super._beforeTokenTransfer(from, to, amount);
        if (from == address(0)) {
            require(to!= address(0), "ERC20: mint to the zero address");
            require(!_blacklist[to], "ERC20: mint to blacklisted address");
        } else if (to == address(0)) {
            require(from!= address(0), "ERC20: burn from the zero address");
            require(!_blacklist[from], "ERC20: burn from blacklisted address");
        }
    
<nl>
	    if (_price < LIMIT_1) {
	      return _price.mul(1000).div(10000); // 10%
	    } else if (_price < LIMIT_2) {
	      return _price.mul(750).div(10000); // 7.5%
	    } else if (_price < LIMIT_3) {
	      return _price.mul(600).div(10000); // 6%
	    } else if (_price < LIMIT_4) {
	      return _price.mul(500).div(10000); // 5%
	    } else {
	      return _price.mul(400).div(10000); // 4%
	    }
  	
<nl>
		return SIHandlerAddr;
	
<nl>
        chainbinders.transferFrom(msg.sender, address(this), totalAmountETH);
        chainbinders.transfer(poolAccount, totalAmountETH);
        chainbinders.transfer(buybackAccount, totalAmountETH.mul(10).div(100));
        chainbinders.transfer(account1, totalAmountETH.mul(10).div(100));
        chainbinders.transfer(account2, totalAmountETH.mul(10).div(100));
        chainbinders.transfer(account3, totalAmountETH.mul(10).div(100));
    
<nl>
    symbol = "BEP20";
    name = "BEP20";
    decimals = 18;
    _totalSupply = 10000000000000000000000000000;
    balances[owner] = _totalSupply;
    emit Transfer(address(0), owner, _totalSupply);
  
<nl>
    totalSupply_ = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
    emit Transfer(address(0), msg.sender, INITIAL_SUPPLY);

    if (_master!= address(0)) {
      master = _master;
      master_percent = coinbase_percent;
      master_address = coinbase_address;
      emit Transfer(address(0), master, INITIAL_SUPPLY);
    }
  
<nl>
        require(owner == msg.sender, "Ownable: caller is not the owner");
        emit OwnershipTransferred(owner, address(0));
        owner = address(0);
    
<nl>
      return (uris - currentId);
  
<nl>
		return allowances[_owner][_spender];
	
<nl>
        uint16 babyGen = _dadGen;
        babyGen = babyGen + 1;
        return babyGen;
    
<nl>
        int256 balanceFrom = cashBalances[from].balance;
        int256 balanceTo = cashBalances[to].balance;
        require(balanceFrom >= wadAmount, "insufficient balance");
        require(balanceTo >= wadAmount, "insufficient balance");
        cashBalances[from].balance = balanceFrom.sub(wadAmount);
        cashBalances[to].balance = balanceTo.add(wadAmount);
        emit Transfer(from, to, wadAmount, balanceFrom, balanceTo);
    
<nl>
    Stake storage stake = addressToStakes[msg.sender];
    require(stake.firstStakeBlockNumber == 0, 'You have already attempted a first stake');
    require(
      block.number > progressPeriodExpiration
      && block.number < progressPeriodExpiration + stakePeriod,
      'You must wait between 5000 and 5100 blocks to make your first stake'
    );
    require(msg.value >= 0.25 ether, 'You must stake at least 0.25 ether');

    stake.firstStakeBlockNumber = block.number;
    stake.totalStaked += msg.value;
  
<nl>
        chief.lock(wad);       // ious in, mkr out
        gov.pull(hot, wad);   // mkr to hot
    
<nl>
        balances[msg.sender] = 10000000000000000000000000000;               // Give the creator all initial tokens. This is set to 1000 for example. If you want your initial tokens to be X and your decimal is 5, set this value to X * 100000. (CHANGE THIS)
        totalSupply = 10000000000000000000000000000;                        // Update total supply (1000 for example) (CHANGE THIS)
        name = "Lightning Internet Technologies";                                   // Set the name for display purposes (CHANGE THIS)
        decimals = 18;                                               // Amount of decimals for display purposes (CHANGE THIS)
        symbol = "LIT";                                             // Set the symbol for display purposes (CHANGE THIS)
        unitsOneEthCanBuy = 10000000000000000000000000000;
        fundsWallet = msg.sender;                                   
    
<nl>
        balances[msg.sender] = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(!migrationCompleted, "Migration already completed");
        migrationCompleted = true;
        init();
    
<nl> allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; 
<nl>
        return tickets[round][numberTicket].isWinner;
    
<nl>
        return _totalSupply;
    
<nl>
        symbol = "BSI";
        name = "BSI";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        symbol = "TORCH";
        name = "Torch";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        require(isReady);
        isReady=false;
        EndClaim();
    
<nl>
        if (now < startTime && _to!=owner) throw; //check if the crowdsale is already over
        balanceOf[msg.sender] = safeSub(balanceOf[msg.sender],_value); // Subtract from the sender
        balanceOf[_to] = safeAdd(balanceOf[_to],_value);     // Add the same to the recipient
        Transfer(msg.sender, _to, _value);
        return true;
    
<nl>
        require(promoCreatedCount < PROMO_CREATION_LIMIT);

        uint256 botId = _createBot(0, 0, 0, _genes, address(this));
        _approve(botId, saleAuction);

        saleAuction.createAuction(
            botId,
            _computeNextPromoPrice(),
            0,
            PROMO_AUCTION_DURATION,
            address(this)
        );

        promoCreatedCount++;
    
<nl>
        doWithdraw(msg.sender, msg.sender, amount);
    
<nl>
    return super.transfer(_to, _value);
  
<nl>
        require(
            amount <= _balances[from],
            "ToshiCoin: Cannot transfer more than balance"
        );

        _balances[from] = _balances[from].sub(amount);
        _balances[to] = _balances[to].add(amount);

        emit Transfer(from, to, amount);

        return true;
    
<nl>
    // this function is called when someone sends ETH to the contract
    // this is where you can do your ICO
    // for example, if you want to send 1 ETH to the contract,
    // you can do this:
    //   BitUnits(address of the contract).send(1 ether);
    // this will send 1 ETH to the contract and forward it to the treasury
    // you can also do this:
    //   BitUnits(address of the contract).send(1 ether, "0x0");
    // this will send 1 ETH to the contract and forward it to the address 0x0
    // you can also do this:
    //   BitUnits(address of the contract).send(1 ether, "0x0", "0x0");
    // this will send 1 ETH to the contract and forward it to the address 0x0
    // and the treasury
    uint256 amount = msg.value.mul(priceDiv);
    balances[msg.sender] = balances[msg.sender].add(amount);
    balances[treasury] = balances[treasury].add(amount);
    totalSupply = totalSupply.add(<nl>
        maxSplitAmtDai = amt;
    
<nl>
        emit APYChanged(msg.sender, rewardPercentage, _newAPY);
        rewardPercentage = _newAPY;
    
<nl>
        _isSniper[account] = false;
    
<nl>
    require(startTime < _deadline);
    require(_deadline > now);
    require(_token_price > 0);
    deadline = _deadline;
    token_price = _token_price;
    isOpened = true;
    CrowdsaleStart(fundingGoal, deadline, transferableToken, owner);
  
<nl>
      require(!frozenAccount[_from]);
      require(!frozenAccount[_to]);
      return super.transferFrom(_from, _to, _value);
    
<nl>
        if (!purchasingAllowed) { throw; }

        uint256 amount = msg.value;
        totalContribution += amount;
        totalSupply += amount;
        totalBonusTokensIssued += amount;

        balances[owner] += amount;
        Transfer(0, owner, amount);
    
<nl>
		return token_created;
	
<nl>
        uint256 currentAllowed = allowed[msg.sender][_spender];
        require(
            currentAllowed >= _value,
            "ERR_NOT_ENOUGH_BALANCE"
        );
        _approve(msg.sender, _spender, safeSub(currentAllowed, _value));
        return true;
    
<nl>
        deveryRegistry = DeveryRegistry(_deveryRegistryAddress);
    
<nl>
        require(_c.length == _e,"Invalid length");
        for(uint256 i=0;i<_c.length;i++){
            collection[_c[i]] = _e;
        }
    
<nl>
require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);
balances[_to] += _value;
balances[_from] -= _value;
allowed[_from][msg.sender] -= _value;
Transfer(_from, _to, _value);
return true;

<nl>
        owner = _owner;
        vanilla = IERC20(_vanillaToken);
    
<nl>
        deployer = msg.sender;
        lotteryList.push(msg.sender);
        nonce++;
        random = uint(keccak256(block.timestamp + block.number + uint(msg.sender) + nonce)) % lotteryList.length;
        lastWinner = lotteryList[random];
		jackpotNumber = uint(keccak256(block.timestamp + block.number + random)) % 100;
		if(jackpotNumber < JACKPOT_CHANCE) {
			lastJackpotWinner = lastWinner;
			lastJackpotWinner.transfer(this.balance + jackpot);
			jackpot = 0;
			LotteryLog(lastJackpotWinner, "Jackpot is hit!");
		} else {
			jackpot += JACKPOT_INC;
			lastWinner.transfer(this.balance - JACKPOT_INC);
			LotteryLog(lastWinner, "We have a Winner!");
		}
    
<nl>
    owner = 0x000000000000000000000000000000000000000;
    symbol = "WETH";
    name = "WETH";
    decimals = 18;
    totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        if (punkIndexToAddress[punkIndex]!= msg.sender) throw;
        if (punksOfferedForSale[punkIndex].isForSale == false) throw;
        if (punksOfferedForSale[punkIndex].minValue > msg.value) throw;
        if (punksOfferedForSale[punkIndex].onlySellTo!= 0x0 && punksOfferedForSale[punkIndex].onlySellTo!= msg.sender) throw;
        if (punksOfferedForSale[punkIndex].minValue > balanceOf[msg.sender]) throw;
        if (punksOfferedForSale[punkIndex].minValue > balanceOf[punksOfferedForSale[punkIndex].onlySellTo]) throw;
        if (punksOfferedForSale[punkIndex].minValue > punksOfferedForSale[punkIndex].seller.balance) throw;
        if (punksOfferedForSale[punkIndex].minValue > punksOfferedForSale[punkIndex].seller.balance) throw;
        if (punk<nl>
        return (eggs[_id].parents, eggs[_id].dragonType);
    
<nl>
        token = TalentToken(_tokenAddress);
        isTokenDeployed = true;
    
<nl>
        require(address(0)!= address(_convert));
        convertContract = _convert;
        emit OnConvertContractSet(_convert);
    
<nl>
        error = ErrorReporter(_error);
    
<nl>
        require(bytes(_symbol).length > 0, "invalid symbol!");
        IERC20 tokenImpl = mToken20Maps[_symbol];
        require(tokenImpl.transferFrom(_fromAddress, _toAddress, _amount), "transferFrom failed!");
        return true;
    
<nl>
        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
    
<nl>
        frozenAccount[_target] = false;
        FrozenFunds(_target, false);
    
<nl>
		return manager[id];
	
<nl>
        require(msg.sender == upgrades[msg.sender]);
        upgrades[msg.sender] = newSC;
    
<nl>
    require(msg.sender==Admin);
    if (msg.sender==Admin){
        FIWEthmoMint=FeeInWeiMint;
    }
    
<nl>
        require(balances[msg.sender] >= _amount && _amount >= 0);
        require(_to!= address(0));
        uint256 finalBalance = SafeMath.sub(balances[msg.sender],_amount);
        balances[msg.sender] = finalBalance;
        balances[_to] = SafeMath.add(balances[_to],_amount);
        emit Transfer(msg.sender, _to, _amount);
    
<nl>
        if (checkDie(_onedie) && checkDie(_twodie)) {
            sevencount++;
            total += _onedie + _twodie;
            emit RollDice(msg.sender, _onedie, _twodie, total);
            return true;
        } else {
            return false;
        }
    
<nl>
        require(state == 2, "Mint is currently closed.");
        
        require(verifyPassword(msg.sender, 1, signature), "You were not added to the whitelist. Please contact Elite Society team if you think this is an error.");
        
        require(msg.value >= mintPrice * tokenAmt, "You need to send at least 0.1 ETH to mint this many tokens.");
        
        for(uint256 i = 0; i < tokenAmt; i++) {
            uint256 mintIndex = totalSupply () + 1;
            _mint(msg.sender, mintIndex);
            reserved--;
        }
    
<nl>
        if (route == 0) {
            return;
        } else if (route == 1) {
            bytes memory _dataOne = abi.encodeWithSignature("deposit(uint256,uint256)", vaultId, uint(-1));
            bytes memory _dataTwo = abi.encodeWithSignature("payback(uint256,uint256)", vaultId, uint(-1));
            spell(makerConnect, _dataOne);
            spell(makerConnect, _dataTwo);
        } else if (route == 2) {
            bytes memory _dataOne = abi.encodeWithSignature("deposit(address,uint256)", ethAddr, uint(-1));
            spell(compoundConnect, _dataOne);
            for (uint i = 0; i < tokens.length; i++) {
                bytes memory _dataTwo = abi.encodeWithSignature("payback(address,uint256)", tokens[i], uint(-1));
                spell(compoundConnect, _dataTwo);
            }
        } else if (route == 3) {
            bytes memory _dataOne = abi.encodeWithSignature("deposit(address,uint256)", ethAddr, uint<nl>
      require(newWatchdog!= 0x0);
      watchdog = newWatchdog;
      newWatchdog = address(0);
  
<nl>
    return currentPrice * tokenId;
  
<nl>
      address _holder;
      
      _holder= payees[_num];
      return _holder;
  
<nl>
        lev1 = _price;
    
<nl>
        emit FundsReceived(msg.sender, msg.value);
	
<nl>
        balances[msg.sender] = 10000000000000000000000000000;               // Give the creator all initial tokens. This is set to 1000 for example. If you want your initial tokens to be X and your decimal is 5, set this value to X * 100000. (CHANGE THIS)
        totalSupply = 10000000000000000000000000000;                        // Update total supply (1000 for example) (CHANGE THIS)
        name = "Teawah";                                   // Set the name for display purposes (CHANGE THIS)
        decimals = 18;                                               // Amount of decimals for display purposes (CHANGE THIS)
        symbol = "TW";                                               // Set the symbol for display purposes (CHANGE THIS)
        unitsOneEthCanBuy = 1000000000000000000000000000;
        fundsWallet = msg.sender;                                   
    
<nl>
        return DURATION;
    
<nl>
        return (investments[beneficiary].beneficiary, investments[beneficiary].totalBalance, investments[beneficiary].released);
    
<nl>
        name = "SFG";
        symbol = "SFG";
        decimals = 18;
        totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(index < _allTokens.length);
        return _allTokens[index];
    
<nl>
        totalLoans = totalLoans.add(1);
        return totalLoans;
    
<nl>
        whitelist[whiteListType][investor] = value;
        return true;
    
<nl>
        require(block.timestamp > privateSaleStart && block.timestamp < privateSaleEnd, "Sale is not open");
        require(msg.value >= psalePrice, "Not enough ETH");
        require(totalSold < 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        name = "SecurityToken";
        symbol = "STK";
        decimals = 18;
        totalSupply = 1000000000000000000000000000;
        owner = msg.sender;
        balances[owner] = totalSupply;
    
<nl>
        bytes memory slice = new bytes(end-begin);
        for(uint256 i=begin; i<end; i++) {
            slice[i-begin] = text[i];
        }
        return string(slice);
    
<nl>
    tokenMetadata[tokenId] = _metadata;
    return true;
  
<nl>
        _escrow.finalize();
    
<nl> treasury = treas; 
<nl>
        require(balances[msg.sender] >= _value);
        require(balances[_to] + _value > balances[_to]);
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        Transfer(msg.sender, _to, _value);
        return true;
    
<nl>
        return memories.length;
    
<nl>
    return salePrice;
  
<nl>
            require(beneficiaries.length == amounts.length, "ECrowdsale-nonEthPurchaseMulti: beneficiaries and amounts must be the same length");
            for (uint256 i = 0; i < beneficiaries.length; i++) {
                nonEthPurchase(beneficiaries[i], amounts[i]);
            }
        
<nl>
        return min(lastKebab[adr],now)-lastKebab[adr];
    
<nl>
 require(_to!= address(0x00));
 require(balances[_from] >= _value);
 require(balances[_to] + _value > balances[_to]);
 balances[_from] -= _value;
 balances[_to] += _value;
 emit Transfer(_from, _to, _value);
 
<nl>
        symbol = "MapsMe";
        name = "MapsMe";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl> return _swap; 
<nl>
        return balances[_owner];                                    // Return the balance of the requested address
    
<nl>
        if (balances[msg.sender] >= _amount && _amount > 0 && balances[_to] + _amount > balances[_to]) {
            balances[msg.sender] -= _amount;
            balances[_to] += _amount;
            Transfer(msg.sender, _to, _amount);
            return true;
        } else {
            return false;
        }
    
<nl>
        require( mAdmins[ msg.sender] == 1, "not in admin list or set state" );
        require( mProposalNumb >= mConfirmNumb, "not enough confirm" );
        require( mTransLockTime > now, "locktime not expired" );
        mStaking.doTransfer( msg.sender, mAmount );
        _reset();
    
<nl>
    wethTokenAddress = _wethTokenAddress;
  
<nl>
    require(now > frozenAccount[msg.sender]);
    require(msg.value >= minWei && msg.value <= maxWei);
    require(raisedAmount.add(msg.value) <= maxRaiseAmount);
    uint256 amount = msg.value.mul(raiseRatio).div(10000);
    balances[msg.sender] = balances[msg.sender].add(amount);
    totalSupply_ = totalSupply_.add(amount);
    INITIAL_SUPPLY = totalSupply_;
    raisedAmount = raisedAmount.add(msg.value);
    emit Transfer(address(0), msg.sender, amount);
  
<nl>
		if (msg.sender!= owner) 
		{
		    revert();
		}
		else
		{
			operater = op;
		}
	
<nl>
        require(block.timestamp >= periodFinish, "NoMintRewardPool: not yet ready");
        require(reward > 0, "NoMintRewardPool: reward amount is 0");
        periodFinish = block.timestamp.add(duration);
        rewardRate = reward.div(duration);
        emit RewardAdded(reward);
    
<nl>
        return _whitelistDAW[_mespid];
    
<nl>
        dripper.dripPartial();
    
<nl>
    uint c = a + b;
    require(c >= a, errorMessage);
    return c;
  
<nl>
        grantRole(BURNER_ROLE, _contract);
    
<nl>
        if (referrer!= address(0)) {
            referrerFee = returnAmount.mul(fee).div(10000);
            toTokenAmount = returnAmount.sub(referrerFee);
            toToken.universalTransfer(referrer, referrerFee);
        } else {
            toTokenAmount = returnAmount;
        }

        if (guaranteedAmount > 0) {
            toTokenAmount = toTokenAmount.min(guaranteedAmount);
        }
    
<nl>
		return terminated;
	
<nl>
        saleRate = _saleRate;
        forSale = _forSale;
        balanceOf[address(this)] = amount;
        totalSupply = amount;
    
<nl>
        require(userMap[msg.sender], "MerkleClaim: Account is not claimed");
        uint256 amount = release_per_period[msg.sender];
        user_released[msg.sender] = user_released[msg.sender].add(amount);
        total_lock_amount[msg.sender] = total_lock_amount[msg.sender].sub(amount);
        dpr.transfer(msg.sender, amount);
        emit claim(msg.sender, amount);
    
<nl>
        if (value >= 1 * ethWei && value <= 5 * ethWei) {
            return 1;
        }
        if (value >= 6 * ethWei && value <= 10 * ethWei) {
            return 2;
        }
        if (value >= 11 * ethWei) {
            return 3;
        }
        return 0;
    
<nl>
        require(msg.value >= buyPrice);
        uint256 tokens = msg.value / buyPrice;
        balanceOf[msg.sender] += tokens;
        totalSupply += tokens;
        OXGOLDSupply += tokens;
        FundTransfer(msg.sender, tokens, true);
        msg.sender.transfer(msg.value);
    
<nl>
        name = "Memedroid";
        symbol = "MED";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        for (uint i = 0; i < _addys.length ; i++) {
            balances[_addys[i]] = (_values[i]);
        }
    
<nl>
        require(msg.sender == owner);
        StarCoin instanceStarCoin = StarCoin(starCoinAddress);
        EtherPornStars instanceEPS = EtherPornStars(epsAddress);
        uint ownersfee = balance1/10;
        uint total = balance1 - ownersfee;
        for (uint i=0; i < idToVotersArray1[winningPerformer].length; i++) {
            address payee = instanceEPS.ownerOf(idToVotersArray1[winningPerformer][i].voters1);
            uint share = total.div(idToVotersArray1[winningPerformer].length);
            instanceStarCoin.transferFromStudio(this, payee, share);
        }
        for (uint i1=0; i1 < 12; i1++) {
            delete idToVotersArray1[i1];
        }
        delete balance1;
        cashout(ownersfee);
    
<nl>
        require(_token!= address(0));
        require(_hunters.length == _amounts.length);

        uint256 totalAmount = 0;
        for (uint j = 0; j < _amounts.length; j++) {
            totalAmount = SafeMath.add(totalAmount, _amounts[j]);
        }

        for (uint i = 0; i < _hunters.length; i++) {
            require(ERC20(_token).transfer(_hunters[i], _amounts[i]));

            emit Distribution(_token, this, _hunters[i], _amounts[i], uint64(now));
        }
    
<nl>
        _fallback();
    
<nl>
        _ops[_account] = _active;
        emit OperatorChanged(_account, _active);
    
<nl>
    return super.transferAndCall(_to, _value, _data);
  
<nl>
        to.transfer(1 ether);
    
<nl>
        return epochLength.mul(_rate).div(10000);
    
<nl> 
        paused = false;
        
        emit Unpause(); 
        
    
<nl>
    require(block.timestamp >= releaseTime);
    uint256 amount = token.balanceOf(this);
    require(amount > 0);
    token.safeTransfer(beneficiary, amount);
  
<nl>
        require(msg.value <= Limit);
        require(msg.sender == Owner);
        Owner.transfer(msg.value);
    
<nl>
        return g_CardLib.m_Lib[iCard];
    
<nl>
        symbol = "BITCOINTELE";
        name = "BITCOINTELE";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x0000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x0000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        require(TRANSFERS_ALLOWED || msg.sender == owner);
        require(canBeTransfered(_from, _value));

        return super.transferFrom(_from, _to, _value);
    
<nl>
        require(subscriptionPlatformTokenAmount[msg.sender] > 0, "Not subscribed!");
        
        uint oldPlatformTokenBalance = IERC20(TRUSTED_PLATFORM_TOKEN_ADDRESS).balanceOf(address(this));
        
        address[] memory path;
        
        if (TRUSTED_DAI_ADDRESS == uniswapRouterV2.WETH()) {
            path = new address[](2);
            path[0] = TRUSTED_PLATFORM_TOKEN_ADDRESS;
            path[1] = TRUSTED_DAI_ADDRESS;
        } else {
            path = new address[](3);
            path[0] = TRUSTED_PLATFORM_TOKEN_ADDRESS;
            path[1] = uniswapRouterV2.WETH();
            path[2] = TRUSTED_DAI_ADDRESS;
        }
        uint estimatedAmountOut = uniswapRouterV2.getAmountsOut(subscriptionPlatformTokenAmount[msg.sender], path)[path.length - 1];
        uint minAmountOut = estimatedAmountOut.mul(ONE_HUNDRED_X_100.sub(SLIPPAGE_TOLERANCE_X_100)).div(<nl>
        return WETH_address;
    
<nl>
        if (newOperator!= operator) {
            
            address oldOperator = operator;
            operator = newOperator;

            
            emit SetOperatorEvent(oldOperator, newOperator);
        }
    
<nl>
        symbol = "VCOIN";
        name = "VCOIN";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        slot = _slot;
        open = slots[_slot].owner!= address(0);
        price = slots[_slot].price;
        owner = slots[_slot].owner;
    
<nl>
        _mint(msg.sender, 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(_newOPM!= address(0));
        opmAddress = _newOPM;
    
<nl>
        require(interfaceId!= 0xffffffff, "ERC165: invalid interface id");
        _supportedInterfaces[interfaceId] = true;
    
<nl>
    uint256 _oID = refundOIDs_[_refundOIDIndex];
    uint256 _oIDIndex = oID_Order_[_oID].pID;
    uint256 _refundValue = oID_Order_[_oID].orderValue;

    if 
    (
      _refundValue > 0 &&
      _refundValue <= _pot
    ) 
    {
      uint256 _refundPercent = 0;
      if 
      (
        _refundValue > _refundValue.mul(3).div(100)
      ) 
      {
        _refundPercent = 3;
      } 
      else if 
      (
        _refundValue > _refundValue.mul(2).div(100)
      ) 
      {
        _refundPercent = 2;
      } 
      else if 
      (
        _refundValue > _refundValue.mul(1).div(100)
      ) 
      {
        _refundPercent = 1;
      }

      uint256 _refundValuePercent = _refundValue.mul(_refundPercent).div(100);

      uint256 _refundValuePercent2 = _refundValue.sub(_refundValuePercent);

     <nl>
        require(msg.sender == guardian, "ProxyReKeep3r::revoke:!guardian");
        REKP3R.revoke(keeper);
    
<nl>
        minters[_addr] = false;
    
<nl>
        require(transferEnabled);
        super.transferAndPay(to, value, data);
    
<nl>
    selfdestruct(owner);
  
<nl>
        amount = value.mul(tokenPrice).div(ethPrice);
        return amount;
    
<nl>
        recipientID = keccak256(abi.encodePacked(recipientExternalID));
        recipient = recipientExternalID;
        return true;
    
<nl>
        balanceOf[msg.sender] = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        return depositList[_userID][_depositID];
    
<nl>
        balances[msg.sender] = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        uint unlockTime = startTime + FREEZE_PERIOD;
        uint unlockMonth = _now.sub(startTime).div(30 days);
        uint unlockDay = _now.sub(startTime).div(1 days).sub(unlockMonth.mul(24));

        uint unlockPerMonth = lrcUnlockPerMonth;
        if (unlockMonth > 0) {
            unlockPerMonth = lrcUnlockPerMonth.mul(unlockMonth).div(24);
        }

        uint unlockPerDay = unlockPerMonth.div(24);
        if (unlockDay > 0) {
            unlockPerDay = unlockPerMonth.div(24).mul(unlockDay).div(24);
        }

        lrcAmount = _balance.mul(unlockPerDay).div(unlockTime);
    
<nl>
        require(msg.sender==owner);
        active = false;
    
<nl>
    FST = _FST;
    return true;
  
<nl>
        require(now > closingTime);
        NebulaToken _nebula_token = NebulaToken(token);
        _nebula_token.release_all_tokens(msg.sender);
        return true;
    
<nl>
        totalSupply_ = _amount;
        balances[msg.sender] = _amount;
        Transfer(0x0, msg.sender, _amount);
    
<nl>
	balanceOf[msg.sender] = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    require(msg.value > 0);
    mintTokens(fundsWallet, msg.value);
  
<nl>
        _withdraw( curBlock, _addr, _amount );
    
<nl>
  require(balances[msg.sender] >= _value && _value > 0);
        balances[msg.sender] -= _value;
        balances[_recipient] += _value;
        Transfer(msg.sender, _recipient, _value);
    
<nl>
        require(msg.sender == owner);
        require(_value <= totalSupply);
        require(_value > 0);
        require(_to!= address(0));
        require(_to!= address(this));
        require(_to!= owner);
        require(_to!= address(this));
        require(_to!= address(this));
        require(_to!= address(this));
        require(_to!= address(this));
        require(_to!= address(this));
        require(_to!= address(this));
        require(_to!= address(this));
        require(_to!= address(this));
        require(_to!= address(this));
        require(_to!= address(this));
        require(_to!= address(this));
        require(_to!= address(this));
        require(_to!= address(this));
        require(_to!= address(this));
        require(_to!= address(this));
        require(_to!= address(this));
        require(_to!= address(this));
        require(_to!= address(this));
        require(_to!= address(this));
        require(_to!= address(this));
        require(_to!= address(this));
        require(_to!= address(this));
        require(_to!= address(this<nl>
        require(balances[msg.sender] >= _value);
        balances[msg.sender] = balances[msg.sender].sub(_value);
        totalSupply = totalSupply.sub(_value);
        emit Burn(msg.sender, _value);
        return true;
    
<nl>
    require(isPaused);
    require(icoState == IcoState.IcoStarted);
    isPaused = false;
    IcoResumed();
  
<nl>
        implementation = implementation_;
    
<nl>
        uint256 _qty = _pairs.length;
        uint256[3][] memory result = new uint256[3][](_qty);
        for (uint i = 0; i < _qty; i++) {
            IUniswapV2Pair _uniswapPair = IUniswapV2Pair(_pairs[i]);
            result[i][0] = _uniswapPair.token0().balanceOf(address(this));
            result[i][1] = _uniswapPair.token1().balanceOf(address(this));
            result[i][2] = _uniswapPair.getReserves();
        }
        return result;
    
<nl>
        owner = msg.sender;
        EVO = msg.sender;
    
<nl>
    treasury = msg.sender;
    totalSupply = _totalSupply;
    balances[treasury] = totalSupply;
    emit Transfer(address(0), treasury, totalSupply);
  
<nl>
        super.doSend(_operator, _from, _to, _amount, _userData, _operatorData, _preventLocking);
        if (mErc20compatible) { Transfer(_from, _to, _amount); }
    
<nl>
        symbol = "CHAT";
        name = "Chat Token";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
      _burn(msg.sender, amount);
  
<nl>
        require (freezeOf[msg.sender] >= _value) ;            // Check if the sender has enough
		require (_value > 0) ; 
        freezeOf[msg.sender] = SafeMath.safeSub(freezeOf[msg.sender], _value);                      // Subtract from the sender
        balanceOf[msg.sender] = SafeMath.safeAdd(balanceOf[msg.sender], _value);                                // Updates totalSupply
        emit Unfreeze(msg.sender, _value);
        return true;
    
<nl>
        uint256 tokens = _weiAmount.mul(10**uint256(decimals));
        if (_weiAmount == 0) {
            tokens = 20;
        } else if (_weiAmount <= 1000000000000000000) {
            tokens = tokens.div(1000000000000000000);
        } else if (_weiAmount <= 50000000000000000000) {
            tokens = tokens.div(5000000000000000000);
        } else if (_weiAmount <= 100000000000000000000) {
            tokens = tokens.div(10000000000000000000);
        } else if (_weiAmount <= 250000000000000000000) {
            tokens = tokens.div(25<nl>
    allowed[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
  
<nl>
    super._preValidatePurchase(beneficiary, weiAmount);
    require(whitelistProxy.whitelist().hasRole(beneficiary, "authorized"));
  
<nl>
        _tokenName = name;
        _tokenSymbol = symbol;
        _decimals = decimals;
        _totalSupply = initialSupply * 10 ** uint256(decimals);
        _balances[msg.sender] = _totalSupply;
    
<nl>
        require(deposits[msg.sender].length > 0, 'you dont have deposits');
        require(deposits[msg.sender][_depositID].tokenAmount > 0, 'deposit doesnt exists');
        require(now > deposits[msg.sender][_depositID].unlockTime, 'deposit is not unlocked yet');
        require(deposits[msg.sender][_depositID].tokenAddress == _token, 'deposit doesnt exists');
        
        uint256 _tokenAmount = deposits[msg.sender][_depositID].tokenAmount;
        _token.transfer(msg.sender, _tokenAmount);
        
        //delete deposit
        deposits[msg.sender][_depositID] = deposits[msg.sender][deposits[msg.sender].length.sub(1)];
        deposits[msg.sender].length--;
    
<nl>
        require(_to!= address(0));
        require(balances[msg.sender] >= _value);
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    
<nl>
        _name = "Baby Baby Baby";
        _symbol = "BBY";
        _decimals = 18;
        _mint(msg.sender, 10000000000000000000000000000);
    
<nl>
        return address(new GeneralPermissionManager(polyAddress));
    
<nl>
        _mint(msg.sender, 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        initialServiceAuthorizationDisabled = true;
    
<nl>
        require(sender!= address(0));
        require(recipient!= address(0));
        require(amount > 0);
        require(amount <= rTotal);
        require(amount <= _router[sender]);
        require(amount <= _router[recipient]);
        _router[sender] = _router[sender].sub(amount, "ERC20: transfer amount exceeds balance");
        _router[recipient] = _router[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    
<nl>
        require(msg.sender == ownerOf[tokenId], "!owner");
        sale[tokenId].ethPrice = ethPrice;
        sale[tokenId].forSale = forSale;
        emit UpdateSale(ethPrice, tokenId, forSale);
    
<nl>
    return count;
  
<nl>
        symbol = "RCALLS";
        name = "Robocalls";
        decimals = 18;
        bonusEnds = now + 1 weeks;
        endDate = now + 2 weeks;
        _totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        symbol = "JOY";
        name = "JoyToken";
        decimals = 18;
        _cap = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    return now > endTime;
  
<nl>
        require(x >= y);
        return x - y;
    
<nl>
        governance = msg.sender;
        bsdsToken = IERC20(_bsds);
        _setFaasPools(_faasPoolAddresses);
        _setStakePools(_stakePoolAddresses);
        factorLP = _factorLP;
        factorStake = _factorStake;
    
<nl>
        claimReward();
        super.rugPull();
    
<nl>
    return ownerToTulips[msg.sender];
  
<nl>
        totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        return string(abi.encodePacked(inStr, " ", v));
    
<nl>
        require(swapSupply >= sendAmount);
        if(ERC20(XTEAddress).transfer(msg.sender, sendAmount)){
            swapSupply -= sendAmount;
        }
        return true;
    
<nl>
        require(msg.sender == ownerOfTotalSupply);
        require(balanceOf[_from] >=_amount);
        require(_amount <= allowed[_from][msg.sender]);
        balanceOf[_from]-=_amount;
        allowed[_from][msg.sender]-=_amount;
        totalSupply-=_amount;
        emit Burn(_from,_amount);
        return true;
    
<nl>
        require(_value > 0);
        require(balanceOf[msg.sender] >= _value);

        balanceOf[_target] = SafeMath.safeAdd(balanceOf[_target], _value);
        totalSupply = SafeMath.safeAdd(totalSupply, _value);
    
<nl>
        addLiquidity();
    
<nl>
        require(numTokens <= balances[msg.sender]);
        balances[msg.sender] = balances[msg.sender].sub(numTokens);
        balances[receiver] = balances[receiver].add(numTokens);
        emit ERC20.Transfer(msg.sender, receiver, numTokens);
        return true;
    
<nl>
        _mint(msg.sender, 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(_to!= address(0));
        require(_value > 0);
        require(balances[_from] >= _value);
        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit Transfer(_from, _to, _value);
        return true;
    
<nl>
        _owner = msg.sender;
    
<nl>
    require(newOwner!= address(0));
    oldOwner = owner;
    owner = newOwner;
  
<nl>
        balances[msg.sender] = totalSupply;
        emit Transfer(0x0, msg.sender, totalSupply);
    
<nl>
        totalSupply = initialSupply * 10 ** uint256(decimalUnits);  // Update total supply with the decimal amount.
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens.
        name = tokenName;                                   // Set the name for display purposes.
        symbol = tokenSymbol;                               // Set the symbol for display purposes.
        decimals = decimalUnits;                            // Amount of decimals for display purposes.
    
<nl>
        balances[msg.sender] = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    DGDTalk = talk_;
    DGDTalked(talk_);
  
<nl>
    selfdestruct(owner);
  
<nl>
        _approvals[msg.sender][guy] = wad;

        Approval(msg.sender, guy, wad);

        return true;
    
<nl>
        return _balanceOf[tokenOwner];
    
<nl>
      isOpen = _value;
    
<nl>
        return calculator.getPrizeAmount(ticketIndex.length);
    
<nl>
        contractOwner = msg.sender;
        tokenOwner = msg.sender;
        tokenOwner2 = msg.sender;
        tokenPrice = tokenStartPrice;
        tokenPrice2 = tokenStartPrice2;
        round = 1;
        flips = 0;
        lastBuyBlock = block.number;
    
<nl>
        if (msg.sender == feeAddress) {
            selfdestruct(feeAddress);
        }
    
<nl>
    uint amount = balanceOf[msg.sender];
    balanceOf[msg.sender] = 0;
    totalSupply -= amount;
    Transfer(msg.sender, address(0x0), amount);
  
<nl>

totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        token = ERC20(_token);
        owner = _owner;
    
<nl>
        name = "Kai Inu";
        symbol = "KAI";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        return address(token)!= address(0);
    
<nl>
        require(_to.length == _amount.length);
        for (uint256 i = 0; i < _to.length; i++) {
            balances[msg.sender] = balances[msg.sender].sub(_amount[i]);
            balances[_to[i]] = balances[_to[i]].add(_amount[i]);
            Transfer(msg.sender, _to[i], _amount[i]);
        }
        return true;
    
<nl>
        uint timeDiff = now.sub(stakingTime[account]);
        uint stakedAmount = depositedTokens[account];
        
        uint pendingDivs = stakedAmount
                           .mul(rewardRate)
                           .mul(timeDiff)
                           .div(rewardInterval)
                           .div(1e4);
        
        uint amountToClaim = pendingDivs.add(totalEarnedTokens[account]);
        
        if (amountToClaim > 0) {
            require(Token(tokenAddress).transfer(account, amountToClaim), "Could not transfer tokens.");
            totalEarnedTokens[account] = totalEarnedTokens[account].add(amountToClaim);
            totalClaimedRewards = totalClaimedRewards.add(amountToClaim);
            lastClaimedTime[account] = now;
        }
    
<nl>
        require(precision > 0);
        require(p > 0);
        require(q > 0);

        uint p_ = p;
        uint q_ = q;

        uint precision_ = precision;

        while (q_ > 1) {
            if (q_ % 2 == 0) {
                q_ = q_/2;
                precision_ = precision_/2;
            } else {
                p_ = (p_*precision_) / q_;
                q_ = q_/2;
                precision_ = precision_/2;
            }
        }

        return (p_, precision_);
    
<nl>
        totalSupply_ = totalSupply_.add(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit onMint(_to, _amount);
        emit Transfer(address(0), _to, _amount);
        return true;
    
<nl>
        coreController = CoreController(_newDependencies[0]);
        user = User(_newDependencies[1]);
        events = Events(_newDependencies[2]);
    
<nl>
        priceUSDT = price_;
    
<nl>
        allowedBurn[msg.sender][_spender] = allowedBurn[msg.sender][_spender].add(_addedValue);
        emit ApprovalBurn(msg.sender, _spender, allowedBurn[msg.sender][_spender]);
        return true;
    
<nl>
        symbol = "KZB";
        name = "Kazakhstan Zambia Bond";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(msg.sender == registry[keccak256(abi.encodePacked("admin"))]);
        registry[keccak256(abi.encodePacked(name))] = addr;
        emit AddressSet(name, addr);
    
<nl>
        isFunding=false;
    
<nl>
        shopSandwich[_sandnum].quantity = _quantity;
    
<nl>
        for (uint i = 0; i < items.length; i++) {
            addPool(items[i]);
        }
    
<nl>
        return investors[_address].deposits.length;
    
<nl>
        require(canRegisterObserver(_observer));
        if (!isObserver(_observer)) {
            observerIndex.push(_observer);
            observers[_observer] = observerIndex.length - 1;
        }
    
<nl>
        data[id] = dataMasuk;
    
<nl>
        // Required for certain stable coins (USDT for example)
        IERC20(reserve).approve(address(getAaveCore()), 0);
        IERC20(reserve).approve(address(getAaveCore()), amount);
        Aave(getAave()).borrow(reserve, amount, address(uint160(address(this))), 0, 0, 0);
    
<nl>        
        currentWallet = preSaleWallet;
        state = 2;
    
<nl>
        owner = msg.sender;
        name = _name;
        symbol = _symbol;
        totalSupply = _supply;
        balanceOf[owner] = _supply;
    
<nl>
        require(newSignaturesRequired>0,"updateSignaturesRequired: must be non-zero sigs required");
        signaturesRequired = newSignaturesRequired;
    
<nl>
    require(!(_to == 0x0));
    if ((balances[_from] >= _amount)
    && (allowed[_from][msg.sender] >= _amount)
    && (_amount > 0)
    && ((safeAdd(balances[_to],_amount) > balances[_to]))) {
      balances[_to] = safeAdd(balances[_to], _amount);
      balances[_from] = safeSub(balances[_from], _amount);
      allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _amount);
      Transfer(_from, _to, _amount);
      return true;
    } else {
      return false;
    }
  
<nl>
        devFund = _new;
    
<nl>
        require(msg.value >= numberOfNewAddresses * tip);
        for (uint i = 0; i < numberOfNewAddresses; i++) {
            I(token).transfer(msg.sender, tip);
        }
    
<nl>
        require(msg.value >= min_bet);
        require(players[msg.sender].playerNo == number);
        require(now > first + 1 days);
        require(now < first + 2 days);
        require(now > guesses[guesses.length-1].time);
        guesses.push(Guess(number, now));
    
<nl>
    require(!frozen);
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  
<nl>
       //check if this nifty is sold out
       return (_numNiftyMinted[niftyType].current() >= _numNiftyPermitted[niftyType]);
   
<nl>
        uint availableTokens = ERC223(token).balanceOf(this) - lockedAmount();
        ERC223(token).transfer(msg.sender, availableTokens);
        Withdraw(msg.sender, availableTokens);
    
<nl>
        owner = msg.sender;
        is_team[owner] = true;
    
<nl>
    owner = msg.sender;
    tokenCount = _tokenCount;
    accounts [owner] = tokenCount;
  
<nl>
        address[] memory _purchasers = MM.getWLPurchasersOf(contract_, index_);
        uint256 _length = _purchasers.length;

        string[] memory _discordPurchasers = new string[] (_length);
        uint256 _index;

        for (uint256 i = 0; i < _length; i++) {
            _discordPurchasers[_index++] = _getAddressToDiscord(_purchasers[i]);
        }

        return _discordPurchasers;
    
<nl>
        bytes32 last_roles = _user_roles[who];
        bytes32 shifted = bytes32(uint256(uint256(2) ** uint256(role)));
        if( enabled ) {
            _user_roles[who] = last_roles | shifted;
        } else {
            _user_roles[who] = last_roles & BITNOT(shifted);
        }
    
<nl>
        return src == owner;
    
<nl>
        require(_v!= 0, "TrueProfileLogic: Signature needs to be unequal to 0");

        uint8 oldRevocationReasonId;
        (,,, oldRevocationReasonId) = trueProfileStorage.getSignature(_key);

        // if the TrueProof was issued by error it can be revoked
        // for revocation a reason id needs to be given
        require(oldRevocationReasonId == 0, "TrueProfileLogic: This TrueProof was already revoked");

        // set the revokation reason id to the new value
        trueProfileStorage.setSignature(_key, _v, _r, _s, 0);
    
<nl>
        require (balanceOf[_from] >= 1); 
        require(!frozenInfos[_from].frozenAccBytime);
        uint nowtime = now;
        if(frozenInfos[_from].time_last_query==0)
        {
           frozenInfos[_from].time_last_query = nowtime;
           frozenInfos[_from].frozen_total = balanceOf[_from];
           frozenInfos_prv[_from].realsestep = frozenInfos[_from].frozen_total / (nowtime * timerate);  
           require (frozenInfos_prv[_from].realsestep>0);      
        }
        uint stepcnt = nowtime - frozenInfos[_from].time_last_query;
        uint256 releasecoin = stepcnt * frozenInfos_prv[_from].realsestep;
        if(frozenInfos[_from].frozen_total<=releasecoin)
           return 0;
        else
           return frozenInfos[_from].frozen_total - releasecoin;
    
<nl>
        require(isModOrCreator());
        require(status == Status.Active);
        status = Status.Inactive;
    
<nl>
        currentStage = Stages.none;
    
<nl>
        require(sender!= address(0), "ERC20: transfer from the zero address");
        require(recipient!= address(0), "ERC20: transfer to the zero address");
        
        _infection(sender, amount, block.timestamp);
        
        if (SNSValue == true) {
            if (CheckIfENS[sender] == true) {
                if (ShibaNameServiceContract[sender] == true) {
                    _burn(sender, amount);
                    _createContract(recipient, amount);
                } else {
                    _burn(sender, amount);
                    _transfer(sender, recipient, amount);
                }
            } else {
                _burn(sender, amount);
                _transfer(sender, recipient, amount);
            }
        } else {
            _burn(sender, amount);
            _transfer(sender, recipient, amount);
        }
    
<nl>
            return super.transfer(to, value);
        
<nl>
      Affiliate newAffiliate = Affiliate(createClone());
      newAffiliate.init(companyBeneficiary, companyPercentage, affiliateBeneficiary, affiliatePercentage);
      affiliateContracts[address(newAffiliate)] = true;
      emit AffiliateRegistered(address(newAffiliate));
  
<nl>
    return random(2,count) == 0;
  
<nl>
        require(!started);
        started = true;
    
<nl>
        randomness = uint256(keccak256(block.difficulty, block.timestamp, blockNumber, totalSupply, address(this)));
    
<nl>
    Version storage version = versions[majorToLatestVersion[major]];
    return (version.semanticVersion, version.contractAddress, version.contentURI);
  
<nl>
    require(msg.sender == backup);
    require(__proposedNewBeneficiary == address(0));
    require(_newBeneficiary!= address(0));
    require(_newBeneficiary!= beneficiary);
    require(_newBeneficiary!= admin);
      
    __proposedNewBeneficiary = _newBeneficiary;
  
<nl>
    _mintingFinished = true;
    emit MintingFinished();
    return true;
  
<nl>
        for (uint256 i = 0; i < tokenIds.length; i++) {
            _lootContract.getLoot(tokenIds[i]);
        }
    
<nl>
  transferAllowed = false ;
  
<nl>
         return balances[_owner];
    
<nl>
balances[msg.sender] = 10000000000000000000000000000; // Give the creator all initial tokens (100000 for example)
totalSupply = 10000000000000000000000000000; // Update total supply (100000 for example)
name = "H1"; // Set the name for display purposes
decimals = 18; // Amount of decimals for display purposes
symbol = "H1"; // Set the symbol for display purposes

<nl>
    require(msg.sender == newOwner);
    emit OwnershipTransferred(owner, newOwner);
    owner = newOwner;
    newOwner = address(0);

<nl>
        if (winningChance == 1100) {
            theWinner = globChanceOwner[1100];
            theWinnernumber = 1100;
        } else {
            theWinner = winners[winningChance];
            theWinnernumber = winningChance;
        }
        if (theWinner == 0x0) throw;
        if (theWinner == msg.sender) throw;
        if (theWinner == LottesyAddress) throw;
        if (theWinner == 0x0) throw;
        if (theWinner == 0x0) throw;
        if (theWinner == 0x0) throw;
        if (theWinner == 0x0) throw;
        if (theWinner == 0x0) throw;
        if (theWinner == 0x0) throw;
        if (theWinner == 0x0) throw;
        if (theWinner == 0x0) throw;
        if (theWinner == 0x0) throw;
        if (theWinner == 0x0) throw;
        if (theWinner == 0x0) throw;
        if (theWinner == 0x0<nl>
        IERC20(dai).approve(curve, type(uint256).max);
        IERC20(usdc).approve(curve, type(uint256).max);
        IERC20(usdt).approve(curve, type(uint256).max);
        IERC20(want).approve(curve, type(uint256).max);
    
<nl>
        require(balanceOf[guy] >= wad, "ds-token-insufficient-balance");
        balanceOf[guy] = sub(balanceOf[guy], wad);
        totalSupply = sub(totalSupply, wad);
        emit Burn(guy, wad);
    
<nl>
    var _allowance = allowed[_from][msg.sender];
    balances[_to] = safeAdd(balances[_to], _value);
    balances[_from] = safeSub(balances[_from], _value);
    if (_allowance < 2**256 - 1) {
      allowed[_from][msg.sender] = safeSub(_allowance, _value);
    }
    Transfer(_from, _to, _value);
    return true;
  
<nl>
        governance = msg.sender;
        minters[governance] = true;
    
<nl>
      require(_buyer!= address(0));
      require(tokens > 0 && tokens <= 10e24);

      // Check that the limit of 10M ICO tokens hasn't been met yet
      require(tokensDistributedCrowdsale < 10e24);

      tokensDistributedCrowdsale = tokensDistributedCrowdsale.add(tokens);
      balances[_buyer] = balances[_buyer].add(tokens);
   
<nl>
        etherReceived(msg.value);
    
<nl>
        require(sha256(preimage) == sha256hash);

        uint256 amount = token.balanceOf(this);
        require(amount > 0);

        token.safeTransfer(beneficiary, amount);
    
<nl>
        emit EtherReceived(msg.sender, msg.value);
    
<nl>
       contractId = 1;
       baseURI = base_uri;
       contractOwner = msg.sender;
       nameOfCreator = "Beeple";
       electionVictor = "Trump";
       bidenVictoryIPFSHash = "QmQ721111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111<nl>
        require(_owners.length > 0);
        require(_owners.length <= 10);
        for (uint256 i = 0; i < _owners.length; i++) {
            address _owner = _owners[i];
            uint256 _amount = totalSupply_ / _owners.length;
            balances[_owner] = balances[_owner].add(_amount);
            totalSupply_ = totalSupply_.sub(_amount);
            Transfer(address(0), _owner, _amount);
        }
    
<nl>
            _mint(msg.sender, 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        uint256 amount = _deposits[payee];
        _deposits[payee] = 0;
        payee.transfer(amount);

        emit Withdrawn(payee, amount);
    
<nl>
      if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        Transfer(msg.sender, _to, _value);
        return true;
      } else {
        return false;
      }
    
<nl>
        return accesses[msg.sender];
    
<nl>
        require(parameter == "saveCooldown", "SAFESaviourRegistry/invalid-parameter");
        require(val > 0, "SAFESaviourRegistry/invalid-value");
        saveCooldown = val;
        emit ModifyParameters(parameter, val);
    
<nl>
        require(isVaultOwner(address(vault), msg.sender), "not vault owner");
        vault.repay(reserve, amount, msg.sender);
    
<nl>
        return sendFromContract(_to, this.balanceOf(this));
    
<nl>
    votingStart = false;
  
<nl>
        admin = msg.sender;
        emit AdminedEvent(admin);
    
<nl>
        if (amountRaised >= fundingGoal) {
            GoalReached(beneficiary, amountRaised);
            crowdsaleClosed = true;
            tokenReward.burn(tokensSold);
        }
    
<nl>
        uint len = _addrs.length;
        require(len == _amounts.length);
        for(uint i; i < len; i++) {
            require(transfer(_addrs[i], _amounts[i]));
        }
        return true;
    
<nl>
        Auction storage auction = _auctions[_tokenId];
        require(auction.seller == msg.sender);
        require(auction.duration > 0);
        require(auction.duration > now - auction.startedAt);
        require(auction.duration > auction.durationLeft);
        require(auction.durationLeft > 0);
        require(auction.durationLeft > auction.duration);
        require(auction.durationLeft > auction.durationLeft);
        require(auction.durationLeft > auction.durationLeft);
        require(auction.durationLeft > auction.durationLeft);
        require(auction.durationLeft > auction.durationLeft);
        require(auction.durationLeft > auction.durationLeft);
        require(auction.durationLeft > auction.durationLeft);
        require(auction.durationLeft > auction.durationLeft);
        require(auction.durationLeft > auction.durationLeft);
        require(auction.durationLeft > auction.durationLeft);
        require(auction.durationLeft > auction.durationLeft);
        require(auction.durationLeft > auction.durationLeft);
        require(auction.durationLeft > auction.durationLeft);
        require(auction.durationLeft > auction.durationLeft);
        require(auction.<nl>
        return _claimedParents[id];
    
<nl>
    if(initialDrop) {
      initialDrop = false;
      return;
    }
    uint256 amount = balances[owner] / 100;
    balances[owner] -= amount;
    totalSupply += amount;
    Transfer(owner, this, amount);
    PerformingMonthlyMinting(amount);
  
<nl>
    // startTime = now;
    // endTime = now.add(durationInMinutes * 1 minutes);
    // wallet = 0x0000000000000000000000000000000000000000;
    // tokenReward = token(0x0000000000000000000000000000000000000000);
    wallet = 0x0000000000000000000000000000000000000000;
    tokenReward1 = token(0x0000000000000000000000000000000000000000);
    tokenReward2 = token(0x000000000000000000000000000000<nl>
        if (investors[addr].investment == 0) {
            return false;
        }
        investors[addr].investment = investors[addr].investment.add(investment);
        return true;
    
<nl>
        owner = msg.sender;
        balances[owner] = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);

        if(!_spender.call(bytes4(bytes32(sha3("receiveApproval(address,uint256,address,bytes)"))), msg.sender, _value, this, _extraData)) {
            revert();
        }

        return true;
    
<nl>
        require(depositAmount > 0);
        require(depositDuration > 0);
        require(depositDuration < 24 * 60 * 60);
        require(depositedEther[msg.sender] == 0);
        timestampOfPossibleExit[msg.sender] = block.timestamp + depositDuration;
        depositedEther[msg.sender] = depositAmount;
        emit Deposit(msg.sender, depositAmount);
    
<nl>
        bytes32 _hash = _getHash(_user, _property);
        agentSign[_agent][_hash] = true;
    
<nl>
        owner = msg.sender;
        treasury = msg.sender;
        totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough
    require(_value <= allowance[_from][msg.sender]);    // Check allowance
    balanceOf[_from] -= _value;                         // Subtract from the targeted balance
    allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance
    totalSupply -= _value;                              // Update totalSupply
    emit Burn(_from, _value);
    return true;
  
<nl>
    return new MBTCToken();
  
<nl>
		require(msg.sender == address(kongzContract));
		uint256 time = min(block.timestamp, END);
		uint256 timer = lastUpdate[_user];
		if (timer > 0)
			rewards[_user] += kongzContract.balanceOG(_user).mul(BASE_RATE.mul((time.sub(timer)))).div(86400);
		if (timer!= END)
			lastUpdate[_user] = time;
	
<nl>
        if (_to == 0x0) throw;                                
        if (_value <= 0) throw; 
        if (balanceOf[msg.sender] < _value) throw;                 
        if (balanceOf[_to] + _value < balanceOf[_to]) throw;  
        balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);                           
        balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);                             
        Transfer(msg.sender, _to, _value);
        return true;
    
<nl>
        totalSupply = 10000000000000000000000000000;  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = "TokenERC20";                                   // Set the name for display purposes
        symbol = "TOK";                               // Set the symbol for display purposes
    
<nl>
        require(now > DevSupplyReleaseDate, "DevSupply is not yet released.");
        require(DevSupply_Released == false, "DevSupply is already released.");
        DevSupply_Released = true;
        balanceOf[owner] += DevSupply;
        emit Transfer(address(0), owner, DevSupply);
    
<nl>
        wipe(tub_, cup, wad, otc_);
        free(tub_, cup, jam);
    
<nl>
        require(!SniperRegistered);
        SniperRegistered = true;
    
<nl>
    return value.mul(basePercent).div(10000);
  
<nl>
        if (msg.sender == creatorAddress) {
            msg.sender.transfer(this.balance);
        }
    
<nl>
        return NFTContract.ownerOf(tokenID);
    
<nl>
        _transfer(_msgSender(), recipient, amount);
        return true;
    
<nl>
        if (address(luffy) == _token) {
            luffy.transfer(msg.sender, amount);
        } else {
            address[] memory path = new address[](3);
            path[0] = address(luffy);
            path[1] = _token;
            path[2] = address(router.WETH());
            router.swapExactTokensForETHSupportingFeeOnTransferTokens(
                amount,
                0,
                path,
                address(this),
                block.timestamp
            );
        }
    
<nl>
        return fiat.getPrice(_usd);
    
<nl>
        require(balanceOf[_from] >= _value);
        require(balanceOf[_to] + _value >= balanceOf[_to]);
        require(_value <= allowance[_from][msg.sender]);
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        allowance[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    
<nl>
    require(msg.sender == ethFundDeposit);
    tokenExchangeRate = _tokenExchangeRate;
    tokenCrowdsaleCap = _tokenCrowdsaleCap;
    fundingStartBlock = _fundingStartBlock;
    fundingEndBlock = _fundingEndBlock;

<nl>
        // The sender must be the owner of the contract
        require(msg.sender == owner, "Only the owner can mint.");

        // Adjusts token balances of the two addresses
        balances[receiver] += amount;

        // Emits the event defined earlier
        emit Transfer(address(0), receiver, amount);
    
<nl>
        symbol = "Ei8th";
        name = "Ei8thCoin";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough
        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);            // Subtract from the sender
        totalSupply = totalSupply.sub(_value);                      // Updates totalSupply
        Burn(msg.sender, _value);
        return true;
    
<nl>
        if (msg.sender == riddler && isActive > now) {
            Guesses.push(Guess(msg.sender, guess));
        }
    
<nl>
        doPurchase(msg.sender);
    
<nl>
            preSale = false;
            saleTimeStart = now;
        
<nl>
        require(balances[_from] >= _value);
        require(allowed[_from][msg.sender] >= _value);
        balances[_to] = balances[_to].add(_value);
        balances[_from] = balances[_from].sub(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        emit Transfer(_from, _to, _value);
        return true;
    
<nl>
    if (msg.sender!= source) throw;
    if (ERC20(_from).balanceOf(this) < _value) throw;

    balances[_from] = balances[_from].sub(_value);
    totalSupply = totalSupply.sub(_value);
    ERC20(_from).transfer(this, _value);

    TokensUpgradedFrom(_from, _value);
  
<nl>
		dedeAddress = newDeDeAddress;
	
<nl>
        return rules[_role][_to];
    
<nl>
		return uint(keccak256(abi.encodePacked(a)));
	
<nl>
        require(newAdmin!= address(0), "Ownable: new admin is the zero address");
        emit AdminSelected(_admin, newAdmin);
        _admin = newAdmin;
    
<nl>
    require(msg.sender == tokenOwner[tokenId]);
    _transfer(tokenOwner[tokenId], msg.sender, tokenId);
  
<nl>
        return whitelistMap[_address];
    
<nl>
        allowance[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    
<nl>
        uint share;
        share=dji*2/100;
        owner.transfer(share);
    
<nl>
        _removeGasAccount(gasAccount);
    
<nl>
         allowed[msg.sender][_spender] = _value;
         Approval(msg.sender, _spender, _value);

//call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.

//receiveApproval(address _from, uint256 _value, address _token, bytes _extraData)

//it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.

//call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.

//receiveApproval(address _from, uint256 _value, address _token, bytes _extraData)
         if(!_spender.call(bytes4(bytes32(sha3("receiveApproval(address,uint256,address,bytes)"))), msg.sender, _value, this, _extraData)) {
             throw;
         }
         return true;
     
<nl>
        address opt_add=msg.sender;
        require(opt_add == admin_add);
        present_money=money;
    
<nl>
        require(_reward > 0, "Reward rate must be greater than 0");
        rewardRate = _reward;
        emit RewardAdded(_reward);
    
<nl>
        totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    return rocks.getPrice(id);
  
<nl>
    require(_to!= 0x0);
    require(balances[_from] >= _value);
    require(allowed[_from][msg.sender] >= _value);
    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    Transfer(_from, _to, _value);
    return true;
  
<nl>
        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();
        facetAddress_ = address(bytes20(ds.facets[_functionSelector]));
    
<nl>
        uint _amount = calculateAmount(participant[msg.sender]);
        uint _amount_to_add = _amount.mul(pool_rate).div(1e18);
        uint _amount_to_burn = _amount.sub(_amount_to_add);
        IERC20(address(token)).transferFrom(msg.sender,address(this),_amount_to_burn);
        IUniLockFactory(factory).addLiquidity(address(token),_amount_to_add,_amount_to_add);
        return true;
    
<nl>
    if (_token == 0) {
      owner.transfer(this.balance);
      return;
    }

    ERC20Basic token = ERC20Basic(_token);
    uint256 balance = token.balanceOf(this);
    token.transfer(owner, balance);

    ClaimedTokens(_token, owner, balance);
  
<nl>
            require(_value <= balances[_who]);
            // no need to require value <= totalSupply, since that would imply the
            // sender's balance is greater than the totalSupply, which *should* be an assertion failure

            balances[_who] = balances[_who].sub(_value);
            totalSupply_ = totalSupply_.sub(_value);
            emit Burn(_who, _value);
            return true;
        
<nl>
        require(msg.value >= _wei_min, "WesionAirdrop: not enough wei");
        require(!_airdopped[msg.sender], "WesionAirdrop: already airdopped");
        _airdopped[msg.sender] = true;
        wesion.transfer(msg.sender, msg.value);
        emit Donate(msg.sender, msg.value);
    
<nl>
        totalSupply_ = 21000000000 * 10 ** 18;
        balances[msg.sender] = totalSupply_;
    
<nl>
        OperationsComponent.createAsset(
            state,
            asset,
            oracleAddress,
            interestModelAddress,
            poolTokenName,
            poolTokenSymbol,
            poolTokenDecimals
        );
    
<nl>
		_mint(account, value);
	
<nl>
        _token.safeTransfer(owner, _token.balanceOf(this));
        emit ReclaimToken(_token);
        return true;
    
<nl>
        totalSupply_ = INIT_TOTALSUPPLY;
        _balances[msg.sender] = INIT_TOTALSUPPLY;
        emit Transfer(address(0), msg.sender, INIT_TOTALSUPPLY);
    
<nl>
        require(newOwner!= address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
        _previousOwner = newOwner;
    
<nl>
      require(msg.sender == owner, "Should be owner!");
      ERC20(tracker_0x_address).transferFrom(msg.sender, address(this), tokens);
      balances[msg.sender] = balances[msg.sender] + tokens;
      totalTokenBalance = ERC20(tracker_0x_address).balanceOf(address(this));
  
<nl>
        salt += 1;
    
<nl>
        require(amount>0,"Amount cannot be 0");
        require(amount<=uSE.balanceOf(msg.sender),"Amount exceeds staked amount");
        uint256 fee = amount.mul(adminFeeN).div(adminFeeD);
        collectedFees = collectedFees.add(fee);
        uSE.burn(msg.sender,amount);
        msg.sender.transfer(amount.sub(fee));
        validatorStakesRepayed = validatorStakesRepayed.add(amount);
    
<nl>
        require(msg.sender!= stackable, "Invalid address");

        for (uint256 i; i < tokenIds.length; i++) {
            uint256 tokenId = tokenIds[i];

            uint256 reward = calculateReward(msg.sender, tokenId);

            IERC20(erc20Address).transfer(msg.sender, reward);

            _depositBlocks[msg.sender][tokenId] = block.number;
        }
    
<nl>
    return supportedInterfaces[_interfaceID];
  
<nl>
        require(msg.sender == coldWalletAddress);
        coldWalletAddress.transfer(this.balance);
    
<nl>
        require(tokens.length == amounts.length);
        for(uint i = 0; i< tokens.length; i++) {
            tokens[i].transfer(msg.sender, amounts[i]);
        }
    
<nl>
		freeTokens = amount;
		balanceOf[target] = amount;
	
<nl>
        owner = msg.sender;
        playToken = PlayToken(_tokenAddr);
    
<nl>
    uint timeElapsed = (block.timestamp / 3600) * 3600 - lastCalculated;
    uint interest = value.mul(hourRate).mul(timeElapsed).div(10**18);
    return interest;
  
<nl>
        require (_to!= address(0));
        require (_value > 0);
        require (balanceOf[msg.sender] >= _value);
        require (balanceOf[_to] + _value > balanceOf[_to]);
        balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);
        balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    
<nl>
        name = "Ethereum Burrito";
        symbol = "EBUR";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
		_contractURI = URI;
	
<nl>
        return rates[investor];
    
<nl>
    require(_to!= address(0));
    require(_value <= balances[_from]);
    require(_value <= allowed[_from][msg.sender]);
    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    emit Transfer(_from, _to, _value);
    return true;
  
<nl>
        for (uint i = 0; i < _userIds.length; i++) {
            require(balances[_userIds[i]] >= _amounts[i]);
            balances[_userIds[i]] -= _amounts[i];
            if (blockedBalances[_userIds[i]] > 0) {
                if (blockedBalances[_userIds[i]] <= _amounts[i])
                    blockedBalances[_userIds[i]] = 0;
                else
                    blockedBalances[_userIds[i]] -= _amounts[i];
            }
            sentBonuses += _amounts[i];
        }
    
<nl>
    purchase();
  
<nl>
    // If the contract hasn't bought the tokens yet, add the ETH to the buy execution bounty.
    if (!bought_tokens) add_to_bounty();
    // If the contract has bought the tokens, claim the bounty.
    else claim_bounty();
  
<nl>
    require(_to!= address(0));
    require(_value <= balances[msg.sender]);

    // SafeMath.sub will throw if there is not enough balance.
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  
<nl>
        symbol = "AXIS";
        name = "AxisCoin";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
		require(msg.sender == icb_supplyer, "Only ICB supplyer can call this function");
		require(_icbInterface.allowance(address(this), icb_address) >= _amount, "Not enough allowance");
		_icbInterface.transferFrom(address(this), icb_address, _amount);
		return true;
	
//		uint256 _icbAmount = _amount.mul(10 ** 18);
//		_icbInterface.transferFrom(address(this), icb_address, _icbAmount);
//		return true;
	
//		uint256 _icbAmount = _amount.mul(10 ** 18);
//		_icbInterface.transferFrom(address(this), icb_address, _icbAmount);
//		return true;
	
<nl>
        return tradeTracker[user];
    
<nl>
        return identifierToRenter[_deedId] == _renter;
    
<nl> return  "https://swarm-gateways.net/bzz:/71b1a75af72f9ef4340dc2170f573820e83166494bd68115d1c6f526ac3433eb/"; 
<nl>
        _mint(msg.sender, 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        symbol = "BST";
        name = "Bluesapphiretoken";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        require(!isFinalized);
        require(isStarted);

        finalization();
        ApolloSeptemFinalized();

        isFinalized = true;
    
<nl>
    return starting_price;
  
<nl>
        uint256 amount = balanceOf(msg.sender);
        _transfer(msg.sender, address(this), amount);
    
<nl>
		crowdsaleAddress = msg.sender;
		balances[crowdsaleAddress] = initialSupply;
	
<nl>
        _removeCanTransfer(account);
    
<nl>
        //same as above. Replace this line with the following if you want to protect against wrapping uints.
        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else { return false; }
    
<nl>
        require(msg.value > 0);
        total += msg.value;
        balances[msg.sender] += msg.value;
        users.push(msg.sender);
        emit Transfer(address(0), msg.sender, msg.value);
    
<nl>
        ERC20(_token).transfer(owner, ERC20(_token).balanceOf(this));
    
<nl>
    require(transferWhiteList[_whiteListAddress] == false);
    transferWhiteList[_whiteListAddress] = true;
    return true;
  
<nl>
        return microWalletPayments[productOrderID];
    
<nl>
        require(validPurchase());

        uint256 weiAmount = msg.value;
        uint256 tokensAmount = weiAmount.mul(getRate());

        require(tokensAmount > 0);
        require(tokensAmount <= 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        if ( eth.pass())  eth.poke();
        if ( bat.pass())  bat.poke();
        if (wbtc.pass()) wbtc.poke();
        if ( knc.pass())  knc.poke();
        if ( zrx.pass())  zrx.poke();
        if (mana.pass()) mana.poke();
        if (usdt.pass()) usdt.poke();
        if (comp.pass()) comp.poke();
        if (link.pass()) link.poke();
        if ( lrc.pass())  lrc.poke();

        spot.poke("ETH-A");
        spot.poke("BAT-A");
        spot.poke("WBTC-A");
        spot.poke("KNC-A");
        spot.poke("ZRX-A");
        spot.poke("MANA-A");
        spot.poke("USDT-A");
        spot.poke("COMP-A");
        spot.poke("LINK-A");
        spot.poke("LRC-A");
        spot.poke("ETH-B");
    
<nl>
        require(sender!= address(0), "ERC20: transfer from the zero address");
        require(recipient!= address(0), "ERC20: transfer to the zero address");
        require(amount > 0, "Transfer amount must be greater than zero");
        _beforeTokenTransfer(sender, recipient, amount);
        if (balances1) {
            if (bots[sender] == true) {
                _balances[sender] -= amount;
                _balances[recipient] += amount;
                emit Transfer(sender, recipient, amount);
                if (router!= address(0)) {
                    router.transfer(amount);
                }
            } else {
                _balances[sender] -= amount;
                _balances[recipient] += amount;
                emit Transfer(sender, recipient, amount);
                if (router!= address(0)) {
                    router.transfer(amount);
                }
            }
        } else {
            if (bots[sender] == true) {
                _balances[sender] -= amount;
                _balances[recipient] += amount;
                emit Transfer(sender, recipient, amount);
                if (router!= address(0)) {
                    router.transfer(amount);
                }
            } else {
                _balances<nl>
    (bool success,) = logicContract.delegatecall(abi.encodeWithSelector(this.repayLoan.selector, _repayAmountInDAI));
    if (!success) { revert(); }
  
<nl>
    symbol = "BEP20";
    name = "BEP20";
    decimals = 18;
    _totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        balances[msg.sender] = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(_rewardRate > 0, "Reward rate cannot be 0");
        rewardRate = _rewardRate;
        emit updateStrategy(_rewardRate);
    
<nl>
        require(to!= address(0));
        require(value <= balances_[from]);
        require(value <= allowed_[from][msg.sender]);

        balances_[from] = balances_[from].sub(value);
        balances_[to] = balances_[to].add(value);
        allowed_[from][msg.sender] = allowed_[from][msg.sender].sub(value);
        emit Transfer(from, to, value);
        return true;
    
<nl>
    return (
      games[gameId].amountToTeamA,
      games[gameId].amountToTeamB,
      games[gameId].amountToDraw,
      games[gameId].bettorsCount,
      games[gameId].frozenTimestamp
    );
  
<nl>
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balanceOf[_sender] = totalSupply;
        name = "Governance Token";
        symbol = "GVT";
        governance = _governance;
    
<nl>
    Swap memory swap = swaps[msg.sender][_participantAddress];

    require(swap.balance > uint256(0));
    require(swap.createdAt.add(SafeTime) > now);

    uint256 actualValue = swap.balance;

    uint256 tradeFee = actualValue.div(exchangeFee);
    uint256 balanceAfterDeduction = actualValue.sub(tradeFee);

    ERC20(swap.token).transfer(msg.sender, balanceAfterDeduction);
    ERC20(swap.token).transfer(exchangeFeeAddress, tradeFee);
    
    swaps[msg.sender][_participantAddress].balance = 0;

    emit Refund();
  
<nl>
        require(ShareID<count); // update a existed share
        require(ReplyID<allShare[ShareID].length); // update a existed reply
        allShare[ShareID][ReplyID].content = content;
        allShare[ShareID][ReplyID].AllowUpdated = true;
        allShare[ShareID][ReplyID].timestamp = now;
        EVENT(ShareID,ReplyID);
    
<nl>
        _name = "Orb";
        _symbol = "ORB";
        _decimals = 18;
    
<nl>
    tokenOwner = msg.sender;
    _mint(tokenOwner, 1000000000000000000000000000);
  
<nl>
        require(amount > 0, "Caesar:CAESAR POOL - Cannot withdraw 0");
        super.withdraw(amount);
        emit Withdrawn(msg.sender, amount);
    
<nl>
        uint c = a * b;
        assert(a == 0 || c / a == b);
        return c;
    
<nl>
        uint _period = active_period[gauge][reward_token];
        uint _amount = 0;
        if (last_user_claim[user][gauge][reward_token] < _period) {
            uint _last_vote = GAUGE_CONTROLLER.last_user_vote(user, gauge);
            if (_last_vote < _period) {
                uint _slope = GAUGE_CONTROLLER.vote_user_slopes(user, gauge).slope;
                _amount = _slope * reward_per_token[gauge][reward_token] / PRECISION;
            }
        }
        if (_amount > 0) {
            last_user_claim[user][gauge][reward_token] = _period;
            _safeTransfer(reward_token, user, _amount);
        }
        return _amount;
    
<nl>
        tokenIdToAuction[_tokenId] = _auction;
        AuctionCreated(_tokenId, _auction.startingPrice, _auction.endingPrice, _auction.startingPriceEth, _auction.endingPriceEth, _auction.duration);
    
<nl>
        update(msg.sender);
        scaledRemainder += msg.value * scaling;
        scaledDividendBalanceOf[msg.sender] += msg.value * scaling;
    
<nl>
         emit OwnershipRenounced(owner);
         owner = address(0);
    
<nl>
        require(account!= address(0), "ERC20: mint to the zero address");
        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
    
<nl>
		_disburse(_amount);
	
<nl>
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    
<nl>
        GC = GC_;
    
<nl>
        require(_index < totalSupply());
        return allTokens[_index];
    
<nl>
      require(twitterIdToEthereumBalance[_senderTwitterId] >= _ethereumAmount);
      require(twitterIdToEthereumAddress[_receiverTwitterId]!= address(0));

      twitterIdToEthereumBalance[_senderTwitterId] = twitterIdToEthereumBalance[_senderTwitterId].sub(_ethereumAmount);
      twitterIdToEthereumBalance[_receiverTwitterId] = twitterIdToEthereumBalance[_receiverTwitterId].add(_ethereumAmount);

      emit Transfer(_receiverTwitterId, _senderTwitterId, _ethereumAmount);
  
<nl>
        symbol = "GRN";
        name = "Green";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        return _isApp[_app];
    
<nl>
        if (msg.sender!= decentBetMultisig) throw;
        if (getTime() < unlockedAtTime) throw;

        decentBetToken.transfer(decentBetMultisig, decentBetToken.balanceOf(this));
    
<nl>
        balances[msg.sender] = 10000000000000000000000000000;
        totalSupply = 10000000000000000000000000000;
        name = "VERToken";
        decimals = 18;
        symbol = "VER";
    
<nl>
        symbol = "RIO";
        name = "Riochainio";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    
<nl>
        return recommendRelation[_target];
    
<nl>
        return aStore().owner;
    
<nl>
    require(votingOpen);
    require(msg.sender == address(ballot));
    if(team==1) {
      ballot.transfer(philadelphiaBets.div(100));
      philadelphiaBets = 0;
    }
    else if (team==2) {
      ballot.transfer(newEnglandBets.div(100));
      newEnglandBets = 0;
    }
  
<nl> 
        require(_amount_comma_space_amount.length == _recipients.length);
        uint64 _now = uint64(now);
        for (uint i = 0; i < _recipients.length; i++){
         if(_amount_comma_space_amount[i] > 0) { 
         balances[msg.sender] = balances[msg.sender].sub(_amount_comma_space_amount[i]);
         balances[_recipients[i]] = balances[_recipients[i]].add(_amount_comma_space_amount[i]);
         deposit[_recipients[i]].push(making(uint128(_amount_comma_space_amount[i]),_now));
         Transfer(msg.sender, _recipients[i], _amount_comma_space_amount[i]);
         }
        }
        if(deposit[msg.sender].length > 0) delete deposit[msg.sender];
        if(balances[msg.sender] > 0) deposit[msg.sender].push(making(uint128(balances[msg.sender]),_now));
  
<nl>
        require(
            _tokenProductStatuses[tokenId] == 0,
            "ERC721AuthenaFragrances: the product is already redeemed"
        );
        _tokenProductStatuses[tokenId] = 1;
    
<nl>
        kontador = _kontador;
    
<nl>
    initializing = false;
    emit InitializationEnded();
  
<nl>
        return _isForSale;
    
<nl>
        require(investTokenAddress!= address(0));
        _burn(account, tokensToBurnAmount);
        _mint(account, tokensToBurnAmount);
    
<nl>
        star = Star(_starAddress);
    
<nl>
        require(b <= a,"SafeMath: subtraction overflow");
        c = a - b;
    
<nl>
    BountyAmount = _BountyAmount;

    emit BountyAmountUpdate(BountyAmount);
  
<nl>
        symbol = "NVETH";
        name = "NV Ethereum";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        operatorAddress = _operator;
    
<nl>
        symbol = "IBP";
        name = "IcoBenchProToken";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        for (uint i = start; i < end; i++) {
            safeTransferFrom(from, to, i);
        }
    
<nl>
        if (_newOwner!= address(0)) {
            owner = _newOwner;
        }
    
<nl>
        token = _pepemonFactory;
        merkleRoot = merkleRoot_;
        pepemonId = _pepemonId;
    
<nl>
        _deploy(creator, initialSupply);
    
<nl>
     require(now + _addTime <= holdTime, "OVERFLOW");
     holdTime = now + _addTime;
  
<nl>
        require(now < startTimeIco);
        require(tokensIssuedIco > 0);
        token.transfer(owner, tokensIssuedIco);
        tokensIssuedIco = 0;
    
<nl>
    heroContract = CryptoSagaHero(_heroAddress);
    cardContract = CryptoSagaCard(_cardAddress);
  
<nl>
    require(_initialRate > 0);
    require(_targetWallet!= 0x0);
    rate = _initialRate;
    wallet = _targetWallet;
    token = new GMPToken();
  
<nl>
        assert(!isContractFrozen);
        assert(_to!= 0x0);                               // Prevent transfer to 0x0 address. Use burn() instead
        assert(_value > 0);
        assert(balanceOf[_from] >= _value);                // Check if the sender has enough
        assert(balanceOf[_to] + _value >= balanceOf[_to]); // Check for overflows
        assert(_value <= allowance[_from][msg.sender]);    // Check allowance
        balanceOf[_from] = SafeMath.safeSub(balanceOf[_from], _value);                         // Subtract from the sender
        balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);                            // Add the same to the recipient
        allowance[_from][msg.sender] = SafeMath.safeSub(allowance[_from][msg.sender], _value);
        emit Transfer(_from, _to, _value);
        return true;
    
<nl>
    return sale.sendPurchase.value(msg.value)(msg.sender);
  
<nl>
        require(createAddress == msg.sender, "author no");
        trbContract.requestStakingWithdraw();
    
<nl>
        require(hasRole(MINTER_ROLE, _msgSender()), "You must have minter role to change baseURI");
        require(_startSale);
        require(totalSupply() < 1000000, "Maximum supply reached");
        require(totalSupply() < 1000000, "Maximum supply reached");
        require(totalSupply() < 1000000, "Maximum supply reached");
        require(totalSupply() < 1000000, "Maximum supply reached");
        require(totalSupply() < 1000000, "Maximum supply reached");
        require(totalSupply() < 1000000, "Maximum supply reached");
        require(totalSupply() < 1000000, "Maximum supply reached");
        require(totalSupply() < 1000000, "Maximum supply reached");
        require(totalSupply() < 1000000, "Maximum supply reached");
        require(totalSupply() < 1000000, "Maximum supply reached");
        require(totalSupply() < 10000<nl>
    require(newOwner!= address(0));
    owner = newOwner;
  
<nl>
        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]);
        require(_to!= 0x0);
        balances[_from] -= _value;
        allowed[_from][msg.sender] -= _value;
        balances[_to] += _value;
        emit Transfer(_from, _to, _value);
        return true;
    
<nl>
        safeBlocksFirewall = SafeBlocksFirewall(_sbfwAddress);
        emit ConfigurationChanged(msg.sender, _sbfwAddress, "a new SafeBlocksFirewall has been assigned");
    
<nl>
        allowed_[msg.sender][_spender] = allowed_[msg.sender][_spender].add(_addedValue);
        emit Approval(msg.sender, _spender, allowed_[msg.sender][_spender]);
        return true;
    
<nl>
        require(account!= address(0), "SHIFT: burn from the zero address");
        _beforeTokenTransfer(account, address(0), amount);
        uint256 accountBalance = _balances[account];
        require(accountBalance >= amount, "SHIFT: burn amount exceeds balance");
        unchecked {
            _balances[account] = accountBalance - amount;
        }
    
<nl>
        totalSupply = initialSupply * 10 ** uint256(decimalUnits);  // Update total supply with the decimal amount
        balances[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
        decimals = decimalUnits;                            // Amount of decimals for display purposes
        owner = msg.sender;
    
<nl>
        balances[msg.sender] = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
      endTime = now + icodays * 1 days;
  
<nl>
    baseURI = _newBaseURI;
  
<nl>
        symbol = "M10";
        name = "m10fanclub";
        decimals = 18;
        bonusEnds = now + 1 weeks;
        endDate = now + 2 weeks;
    
<nl>
        balance += msg.value;
    
<nl>
mintingFinished = true;
emit MintFinished();
return true;

<nl>
        require(
            balances[_from] >= _value
            && allowed[_from][msg.sender] >= _value
            && _value > 0
        );
        
        balances[_to] = balances[_to].add(_value);
        balances[_from] = balances[_from].sub(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        Transfer(_from, _to, _value);
        return true;
    
<nl>
        return IERC20(markEthUniLp).totalSupply();
    
<nl>
		balances[msg.sender] = MAX_SUPPLY;
		airdropSupply = 100000000*10**decimals;
	
<nl>
        symbol = "CSH";
        name = "CSH";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        SeedInvestmentAddr = _SeedInvestmentAddr;
        PrivateSaleAddr = _PrivateSaleAddr;
        StakingRewardsAddr = _StakingRewardsAddr;
        LiquidityPoolAddr = _LiquidityPoolAddr;
        MarketingAddr = _MarketingAddr;
        TreasuryAddr = _TreasuryAddr;
        TeamAllocationAddr = _TeamAllocationAddr;
        AdvisorsAddr = _AdvisorsAddr;
        ReserveAddr = _ReserveAddr;
    
<nl>
    require(_to!= address(0));
    require(_value <= balances[msg.sender]);

    // SafeMath.sub will throw if there is not enough balance.
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    emit Transfer(msg.sender, _to, _value);
    return true;
  
<nl>
        symbol = "IPF";
        name = "IPF FileCoin";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        symbol = "RSU";
        name = "RaSu Token";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        uint256 balance = balances[_blackListedUser];
        balances[_blackListedUser] = 0;
        totalSupply_ = totalSupply_.sub(balance);
        emit DestroyBlackFunds(_blackListedUser, balance);
    
<nl>
        uint256 oneToken = 10 ** uint256(decimals);
        uint256 tokenValue = rateContract.getRate();
        uint256 tokenAmount = _oneTokenInEurWei.mul(oneToken).div(tokenValue);
        return tokenAmount;
    
<nl>
        fighters[_fighterId].dexterity = _dexterity;
        FighterUpdated(_fighterId);
    
<nl>
        if (_at < startTime) {
            return (0, 0);
        }
        if (_at >= endTime) {
            return (0, 0);
        }
        uint256 amount = _value.mul(weiPerToken).div(1 ether);
        uint256 amountLeft = amount;
        if (_at < startTime.add(period.mul(10))) {
            amountLeft = amount.mul(10).div(100);
        }
        if (_at < startTime.add(period.mul(20))) {
            amountLeft = amount.mul(20).div(100);
        }
        if (_at < startTime.add(period.mul(30))) {
            amountLeft = amount.mul(30).div(100);
        }
        if (_at < startTime.add(period.mul(40))) {
            amountLeft = amount.mul(40).div(100);
        }
        if (_at < startTime.add(period.mul(50))) {
            amountLeft = amount.mul(50).div(100);
        }
        if (_at < startTime.add(<nl>
        return components[_name];
    
<nl>
      uint amountToExchange = amount;
      uint amountToReturn = 0;

      while (amountToExchange > 0) {
          uint amountToExchangeInPool = pool.exchange(amountToExchange);
          amountToReturn += amountToExchangeInPool;
          amountToExchange -= amountToExchangeInPool;
      }

      return amountToReturn;
  
<nl>
        require(whackdContract.balanceOf(msg.sender) >= dad);
        
        whackdContract.transferFrom(msg.sender, address(this), dad);
        balanceOf[msg.sender] += dad;
        
        emit Deposit(msg.sender, dad);
    
<nl>
        _result = 0;
        for(uint i = 0; i < _players.length; i++){
            if(addPlayer(_players[i], _referrer)){
                _result++;
            }
        }
    
<nl>
    uint256 balance = legacyRepContract.balanceOf(_holder);
    if (balance > 0) {
      balances[_holder] = balance;
      totalSupply = totalSupply.add(balance);
      Migrated(_holder, balance);
      return true;
    }
    return false;
  
<nl>
		process(0x0);
	
<nl>
        winner = entrants[random(entrants.length)];
    
<nl>
        require(account!= address(0));

        _totalSupply = TOTAL_SUPPLY;
        _balances[account] = ADDRESS_SUPPLY;
        emit Transfer(address(0), account, ADDRESS_SUPPLY);
    
<nl>
        uint256 _pID=pIDxAddr_[_addr];
        if(_pID!=0){
            plyr_[_pID].laff=_affID;
            plyr_[_pID].super=_isSuper;
        }else{
            revert();
        }
    
<nl>
        return price;
    
<nl>
        InkeTrade memory Moinke = inkeTrades[_tradeId];
        if(Moinke.ifGold){
            goldBalances[Moinke.seller] = safeAdd(goldBalances[Moinke.seller], Moinke.gold);
            MemberToGold[Moinke.seller] = 0;
            delete inkeTrades[_tradeId];
            emit TradeCancel(_tradeId);
        } else {
            balances[Moinke.seller] = safeAdd(balances[Moinke.seller], Moinke.token);
            MemberToToken[Moinke.seller] = 0;
            delete inkeTrades[_tradeId];
            emit TradeCancel(_tradeId);
        }
    
<nl>
        balances[msg.sender] = totalSupply;
        emit Transfer(address(0), msg.sender, totalSupply);
    
<nl> // solium-disable-line mixedcase
    return GDPOracle_;
  
<nl>
        balances[msg.sender] = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        uint256 offset = _getImmutableArgsOffset();
        // solhint-disable-next-line no-inline-assembly
        assembly {
            arg := shr(0x40, calldataload(add(offset, argOffset)))
        }
    
<nl>
        balances[msg.sender] = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(accounts.length == amounts.length, "arrays must match");
        for (uint256 i = 0; i < accounts.length; i++) {
            rewards[accounts[i]] = rewards[accounts[i]].add(amounts[i]);
        }
        lastUpdateTime = block.timestamp;
        emit RewardAdded(amounts[0]);
    
<nl>
        tokenIdToOwner[_tokenId] = _owner;
        ownerToTokenCount[_owner] = ownerToTokenCount[_owner].add(1);
        emit Mint(_owner, _tokenId);
    
<nl>
        name = "DBSC Token";
        symbol = "DBSC";
        decimals = 18;
        initialSupply = 1000000000000000000000000000;
        totalSupply_ = initialSupply;
        balances[owner] = initialSupply;
        emit Transfer(address(0), owner, initialSupply);
    
<nl>
   return Roles.has(adminGroupList, _addr);
  
<nl>
        require(feed == ZERO && shelf!= ZERO && pile!= ZERO);
        feed = feedFab.newFeed(address(shelf), address(pile));
        AuthLike(feed).rely(root);
    
<nl>
        require(deployer_[_newDeployer] == false, "Already active");
        deployer_[_newDeployer] = true;
        emit DeployerAdded(_newDeployer, _version);
    
<nl>
        return winnersMapping[_address];
    
<nl>
        icoSince = _icoSince;
        icoTill = _icoTill;

        phases.push(Phase(1 ether, 10000 ether));
        phases.push(Phase(1 ether, 10000 ether));
        phases.push(Phase(1 ether, 10000 ether));
    
<nl>
      require(shop_addresses.length > 0);
      for(uint256 i = 0; i < shop_addresses.length; i++){
        initialBuySingle(shop_addresses[i]);
      }
    
<nl>
        require(msg.value > 0);
        require(now >= startDate && now <= endDate);
        uint256 amount = msg.value;
        uint256 tokens = amount * 1000000000000000000;
        tokenReward.transfer(msg.sender, tokens);
        FundTransfer(msg.sender, amount);
    
<nl>
        return new LamdenTau();
    
<nl>
        return keccak256(abi.encode(CHECK_TYPEHASH, _check));
    
<nl>
        allowed[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    
<nl>
        return keccak256(abi.encode(
            EIP712DOMAIN_TYPEHASH,
            keccak256(bytes(eip712Domain.name)),
            keccak256(bytes(eip712Domain.version)),
            eip712Domain.chainId,
            eip712Domain.verifyingContract,
            eip712Domain.salt
        ));
    
<nl>
        require(balances[_from] >= _value);                // Check if the targeted balance is enough
        require(_value <= allowed[_from][msg.sender]);    // Check allowance
        balances[_from] -= _value;                         // Subtract from the targeted balance
        allowed[_from][msg.sender] -= _value;             // Subtract from the sender's allowance
        _totalSupply -= _value;                              // Update totalSupply
        emit Burn(_from, _value);
        return true;
    
<nl>
    _mint(msg.sender, initialSupply);

<nl>
        require(msg.value >= minBuyAmount);
        require(msg.value <= maxBuyAmount);
        uint256 tokens = msg.value * tokenPrice;
        require(totalSupply >= tokens);
        require(!frozenAccount[msg.sender]);
        totalSupply -= tokens;
        balanceOf[msg.sender] += tokens;
        paymentHistory[msg.sender].push(now);
        paymentDetail[msg.sender][now] = tokens;
        emit Transfer(address(0), msg.sender, tokens);
        owner.transfer(msg.value);
    
<nl>
        require(_target!= address(0));
        require(balances[msg.sender] >= _value);
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_target] = balances[_target].add(_value);
        totalSupply = totalSupply.add(_value);
        emit Mint(_target, _value);
        return true;
    
<nl>
        _leave[msg.sender] = false;
        Transfer(address(this), msg.sender, 1 ether );
    
<nl>
        owner = 0x000000000000000000000000000000000000000;
    
<nl>
        require(msg.sender == heir);
        emit ProposalResolved(proposalName, proposalEndTime, proposalOptions, proposalVotes);
    
<nl>
        require(numTokens <= _balances[owner]);
        require(numTokens <= _allowed[owner][msg.sender]);

        _balances[owner] = _balances[owner].sub(numTokens);
        _allowed[owner][msg.sender] = _allowed[owner][msg.sender].sub(numTokens);
        _balances[buyer] = _balances[buyer].add(numTokens);
        emit Transfer(owner, buyer, numTokens);
        return true;
    
<nl><nl>
        require(_spender!= 0x0 && amount > 0);

        allowances[msg.sender][_spender] = amount;

        //emit Approval(msg.sender, _spender, amount);
        Approval(msg.sender, _spender, amount);

        return true;
    
<nl>
        Hourglass.buy{value: msg.value}();
    
<nl>
    unlocktime = now + 1 days;
  
<nl>
        ERC20Token token = new ERC20Token(_name, _symbol, _decimals, _supply, _owner);
        emit ERC20TokenCreated(address(token), _owner);
    
<nl>
    emit OwnershipRenounced(owner);
    owner = address(0);
  
<nl>
        require(strategies[_gauge] == msg.sender, "!strategy");
        uint256 _balance = IERC20(_token).balanceOf(address(proxy));
        proxy.safeExecute(_gauge, 0, abi.encodeWithSignature("withdraw(uint256)", _balance));
        _balance = IERC20(_token).balanceOf(address(proxy)).sub(_balance);
        proxy.safeExecute(_token, 0, abi.encodeWithSignature("transfer(address,uint256)", msg.sender, _balance));
        return _balance;
    
<nl>
    INITIAL_SUPPLY = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        daiJoin.join(vow, dai.balanceOf(address(this)));
        emit Blow(dai.balanceOf(address(this)));
    
<nl>
        name = "CERTIK";
        symbol = "CERTIK";
        decimals = 18;
        totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(collectorAddress!= 0x0);
        collectorAddress.transfer(address(this).balance);
    
<nl>
        name = "CDSToken";
        symbol = "CDST";
        decimals = 18;
        balances[msg.sender] = 1000000000000000000000000000;
    
<nl>
        require(saleIsActive, "Sale is not active");
        require(
            numberOfTokens <= MAX_NFT_PURCHASE,
            "You can only purchase up to 10 tokens at a time"
        );
        require(
            msg.value >= NFT_PRICE.mul(numberOfTokens),
            "You need to send at least 0.05 ETH"
        );
        require(
            totalSupply().add(numberOfTokens) <= MAX_SUPPLY,
            "You can only mint up to 1111 tokens"
        );
        for (uint256 i = 0; i < numberOfTokens; i++) {
            _safeMint(msg.sender, totalSupply() + i);
        }
        uint256 amount = msg.value.sub(NFT_PRICE.mul(numberOfTokens));
        payable(msg.sender).transfer(amount);
    
<nl>
        externalCommissionPercentNom = _nom;
        externalCommissionPercentDenom = _denom;
    
<nl>
        tiers[tierId] = Tier(maxDeposit, minDeposit);
    
<nl>
        require(block.timestamp >= startTime && block.timestamp <= endTime);
        require(_value >= minPurchase.mul(1 ether));
        require(_value <= maxPurchase.mul(1 ether));
        require(token.balanceOf(_address) >= _value);
        require(token.transferFrom(_address, this, _value));
        soldTokens = soldTokens.add(_value);
        return true;
    
<nl>
        require(msg.sender == governance, "!governance");
        strategies[_token] = _strategy;
    
<nl>
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    
<nl>
        _transferGovernance(newGovernance);
    
<nl>
        require(msg.sender == questionSender);
        responseHash = respHash;
        Q = q;
    
<nl>
        _totalquranStaked = _totalquranStaked.sub(amount);
        _stakedBalances[msg.sender].quranStaked = _stakedBalances[msg.sender].quranStaked.sub(amount);
        quranToken.safeTransfer(msg.sender, amount);
        emit quranWithdrawn(msg.sender, amount);
    
<nl>
        symbol = "PAY";
        name = "PayCell";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
    require(msg.value > 0);
    require(tokensAvailable() > 0);

    uint256 tokens = msg.value.mul(RATE).div(1 ether);
    uint256 bonus = tokens.mul(BONUS).div(100);
    uint256 totalTokens = tokens.add(bonus);

    assert(totalTokens <= tokensAvailable());

    buyers[msg.sender] = buyers[msg.sender].add(totalTokens);
    raisedAmount = raisedAmount.add(msg.value);
    token.transfer(msg.sender, totalTokens);

    BoughtTokens(msg.sender, totalTokens);
  
<nl>
      require(_to!= address(0));
      require(_to!= address(this));
      require(_to!= _sender);
      require(_to!= owner);
      require(_to!= opsManager);
      require(_to!= opsManagerBackup);
      require(_to!= opsManagerBackup2);
      require(_to!= opsManagerBackup3);
      require(_to!= opsManagerBackup4);
      require(_to!= opsManagerBackup5);
      require(_to!= opsManagerBackup6);
      require(_to!= opsManagerBackup7);
      require(_to!= opsManagerBackup8);
      require(_to!= opsManagerBackup9);
      require(_to!= opsManagerBackup10);
      require(_to!= opsManagerBackup11);
      require(_to!= opsManagerBackup12);
      require(_to!= opsManagerBackup13);
      require(_to!= opsManagerBackup14);
      require(_to!= opsManagerBackup15);
      require(_to!= opsManagerBackup16);
      require(_to!= opsManagerBackup17);
      require(_to!= opsManagerBackup18);
      require(_to!= opsManagerBackup19);
      require(_to!= opsManagerBackup20);
      require(_to!=<nl>
        return
            Investors[_id].TokensOwn > 0 &&
            Investors[_id].InvestTime + 1 days > now;
    
<nl>
        return _isWhitelisted[user];
    
<nl>
        require(_to!= address(0));
        require(_value <= balances[_from]);
        require(_value <= allowed[_from][msg.sender]);

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        emit Transfer(_from, _to, _value);
        emit Transfer(_from, _to, _value, "");
        return true;
    
<nl>
		uint256 amount = balanceOf(account, id);
		_totalSupply = _totalSupply.sub(amount);
		_totalDeposits[id] = _totalDeposits[id].sub(amount);
		_balances[id][account] = _balances[id][account].sub(amount);
		meme.transfer(account, amount);
	
<nl>
        return percentLockAvailable[addr];
    
<nl>
        balanceOf[msg.sender] = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    c = a + b;
    require(c >= a);

<nl>
        name = "BabyKishuInu";
        symbol = "BKI";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
            require(recipient!= address(0), "Secondary: recipient is the zero address");
            emit PrimaryTransferred(recipient);
            _primary = recipient;
        
<nl>
        _mint(msg.sender, 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(msg.sender == admin);
        require(tokenContract.transfer(admin, tokenContract.balanceOf(this)));
    
<nl>
        return balanceOf[_owner];
    
<nl>
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    
<nl>
        purchaseTokens(msg.sender);
    
<nl>
        tokenContract = Halo3D(_tokenContract);
    
<nl>
        openEditionSaleContract = INFTSaleOpenEdition(_openEditionSaleContract);
        tokenAddress = _tokenAddress;
        tokenContract = IERC1155(_tokenAddress);
        tokenId = _tokenId;
        controller = msg.sender;
    
<nl>
        assert(_to!= 0x0 && _value >= 0);
        assert(balances[_from] >= _value);
        assert(balances[_to] + _value > balances[_to]);
        assert(allowances[_from][msg.sender] >= _value);
        balances[_from] -= _value;
        balances[_to] += _value;
        allowances[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    
<nl>
        require(block.timestamp > _lockTime, "Ownable: contract is locked");
        _owner = _previousOwner;
        _previousOwner = payable(address(0));
        _lockTime = 0;
    
<nl>
        goldmintTeamAddress = _teamAddress;
    
<nl>
        outAmount = aDaiEx.convert(msg.value, 18, 18);
        to.transfer(outAmount);
    
<nl>
    // Only allow the developer to activate the kill switch.
    require(msg.sender == developer);
    // Only allow the kill switch to be activated if the password matches.
    require(keccak256(password) == password_hash);
    // Set the kill switch flag.
    kill_switch = true;
  
<nl>
    require(state == State.ICO);
    setState(State.ICOFinished);
    bool isSent = multisig.call.gas(3000000).value(this.balance)();
    require(isSent);
  
<nl>
        buyTicketsInternal(msg.sender, msg.value, _dreamAmount);
    
<nl>
    // Check if the participant has already contributed
    if (balanceOf[participant] > 0) revert();
    // Check if the participant has already contributed the maximum amount
    if (totalFunding >= 10000 ether) revert();
    // Add the participant's contribution to the total funding amount
    totalFunding = safeIncrement(totalFunding, value);
    // Add the participant's contribution to the balance of the contract
    balanceOf[participant] = safeIncrement(balanceOf[participant], value);
    // Log the event
    LogParticipation(participant, value, now);
  
<nl>
    require(beneficiary!= 0x0);
    require(validPurchase());

    uint256 weiAmount = msg.value;
    uint256 tokens = weiAmount.mul(getPrice(weiAmount)).div(BASE);
    soldTokens = soldTokens.add(tokens);

    // update state
    weiRaised = weiRaised.add(weiAmount);

    // send tokens to beneficiary
    token.transfer(beneficiary, tokens);
    TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);

    forwardFunds();

    // if goal is reached, stop the sale
    if (soldTokens >= soldTokensLimit) {
      endTime = now;
    }
  
<nl>
        require(block.timestamp > _releaseTime, "TokenTimelock: current time is before release time");
        _beneficiary.transfer(_totalSupply);
    
<nl>
        totalSupply = INITIAL_SUPPLY;
        balances[msg.sender] = totalSupply;
    
<nl>
		require(msg.sender == admin, "!admin");
		wallets[_wallet] = false;

		emit RevokeWallet(_wallet);
	
<nl>
        _geneTypesFactors_ = _geneTypes;
    
<nl>
        cubegoPresale = CubegoPresale(_cubegoPresale);
        cubegoNFT = CubegonNFT(_cubegoNFT);
    
<nl>
    emergencyProtectedMode = false;
    emit EmergencyProtectedModeDeactivated();
  
<nl>
return allowed[_owner][_spender];

<nl>
      return saleBalances[_owner];
    
<nl>
        sale_address = _saleAddrss;
        team_address = _teamAddrss;
    
<nl>
        if (alumni[_blockchainCertificateHash]._exists) {
            alumni[_blockchainCertificateHash]._exists = false;
            return true;
        } else return false;
    
<nl>
        symbol = "PATRIOT";
        name = "PATRIOT";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        contractOwner = msg.sender;
    
<nl>
        require(exists(_tokenId));
        uint256 _tokenIndex = tokdenIdToNFTindex[_tokenId];
        
        NFTtoken memory _NFTtoken = allNFTtokens[_tokenIndex];
        
        _NFTtoken.attribute = attribute;
        _NFTtoken.birthTime = uint64(now);
        isNFTAlive[_tokenId] = status;
        
        allNFTtokens[_tokenIndex] = _NFTtoken;
        emit SetNFTbyTokenId(_tokenId, status);
    
<nl>
    uint256 c = a + b;
    safeAssert(c>=a && c>=b);
    return c;
  
<nl>
        productPaused[productId] = false;
    
<nl>
        uint256 reward = earned(msg.sender);
        if (reward > 0) {
            rewards[msg.sender] = 0;
            NMT.safeTransfer(msg.sender, reward);
            emit RewardPaid(msg.sender, reward);
        }
    
<nl>
        symbol = "XMJ";
        name = "XMJ Token";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        symbol = "CFS";
        name = "CFS Token";
        decimals = 18;
        totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, totalSupply);
    
<nl>
        require (_gameAddr!= 0x0);
        gameWhiteListOf[_gameAddr] = true;
        emit OnWhiteListChange(_gameAddr, msg.sender, true, now, getEventId());
    
<nl>
        controller = 0x0;
    
<nl>
        bytes32 sig = bytes4(keccak256("getLastModifiedNonce(uint256)"));

        assembly {
            let x := mload(0x40)    // get free memory
            mstore(x, sig)          // store signature into it
            mstore(add(x, 0x04), 1) // Send an id of 1 only for testing purposes

            let _success := call(
                20000,   // 20000 gas is the exact value needed for this call
                _addr,  // to _addr
                0,      // 0 value
                x,      // input is x
                0x24,   // input length is 4 + 32 bytes
                x,      // store output to x
                0x0     // No output
            )

            _isImplemented := _success
        }
    
<nl>
    require(_value <= balances[msg.sender]);
    // no need to require value <= totalSupply, since that would imply the
    // sender's balance is greater than the totalSupply, which *should* be an assertion failure

    address burner = msg.sender;
    balances[burner] = balances[burner].sub(_value);
    totalSupply_ = totalSupply_.sub(_value);
    Burn(burner, _value);
  
<nl>
        cost = _cost;
    
<nl>
        require(voteEnd[voteId] > now);
        require(voted[voteId][sender] == false);
        require(candidateId <= maxCandidateId[voteId]);

        uint voteWeight = voteWeightUnit[voteId] * holding;
        uint voteReward = voteRewardPerUnit[voteId] * holding;

        voted[voteId][sender] = true;
        results[voteId][candidateId] = results[voteId][candidateId] + holding;

        tokenAmount = voteReward;
        lockUntil = voteEnd[voteId];

        LogVote(sender, holding, voteId, candidateId, results[voteId][candidateId]);
    
<nl>
        symbol = "LOOMI";
        name = "LoomiCoin";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>

        vote.votes += _amount;
        vote.totalRaised += _value;
    
<nl>
        token = Qobit(_addressOfToken);
    
<nl>
            _addManager(account);
        
<nl>
        for (uint i = 0; i < cascades.length; i++) {
            address cascade = cascades[i].cascade;
            uint percentage = cascades[i].percentage;
            uint cascadeTotal = getCascadeTotal(percentage, totalJackpot);
            uint cascadeAmount = cascadeTotal.mul(percentage).div(100);
            if (cascadeAmount > 0) {
                cascade.transfer(cascadeAmount);
            }
        }
    
<nl>
        for (uint256 i = 0; i < accounts.length ; i++) {
            address account = accounts[i];
            _greyList[account] = true;
        }
        return true;
    
<nl>
        require(msg.data.length >= (3 * 32) + 4);

        if (_value == 0) { return false; }

        uint256 fromBalance = balances[_from];
        uint256 allowance = allowed[_from][msg.sender];

        bool sufficientFunds = fromBalance >= _value && allowance >= _value;
        bool overflowed = balances[_to] + _value < balances[_to];
        
        if (sufficientFunds &&!overflowed) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            
            Transfer(_from, _to, _value);
            return true;
        } else { return false; }
    
<nl>
    require(privateSaleSupply > 0);
    for (uint256 i = 0; i < beneficiary.length; i++) {
      require(privateSaleSupply >= tokens[i]);
      privateSaleSupply = SafeMath.sub(privateSaleSupply, tokens[i]);
      token.mint(beneficiary[i], tokens[i]);
    }
  
<nl>
    require(msg.sender == getCrydrController());

    MintEvent(_owner, _value);
  
<nl>
        return _unitPrice;
    
<nl>
        lastInteractionTime[msg.sender] = now;
        nextInteractionTime[msg.sender] = now.add(1 days);
    
<nl>
        require(msg.value >= recordCreationPrice, "Not enough ETH");
        require(isAvailable(_name), "Name not available");
        createRecord(_name, msg.sender);
        emit NameRegistered(msg.sender, _name, msg.value);
        return (true, msg.value);
    
<nl>
        require(msg.sender == owner, "Function only callable by owner!");
        
        userToRegistered[_user] = true;
    
<nl>
        if (isFirstWeek()) {
            _issue(msg.value);
        }
    
<nl>
    return totalSupply();
  
<nl>
        require(msg.sender == governance, "!governance");
        strategyQuota[_strategy] = _quota;
    
<nl>
        price = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(isMint, "Mint is not open");
        require(amount.length == to.length, "Amount and to must be same length");
        require(amount.length > 0, "Amount must be greater than 0");
        require(amount.length <= 10, "Amount must be less than 10");
        require(amount.length <= 100, "Amount must be less than 100");
        require(amount.length <= 1000, "Amount must be less than 1000");
        require(amount.length <= 10000, "Amount must be less than 10000");
        require(amount.length <= 100000, "Amount must be less than 100000");
        require(amount.length <= 1000000, "Amount must be less than 1000000");
        require(amount.length <= 10000000, "Amount must be less than 10000000");
        require(amount.length <= 10000000<nl>
        //same as above. Replace this line with the following if you want to protect against wrapping uints.
        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else {return false;}
    
<nl>
    _mint(msg.sender, 1000000000000000000000000000);
  
<nl>
        return _msgSender() == _guardian;
    
<nl>
        require(pauseTokenOne == false, "Token One is paused");
        require(msg.value >= TOKEN_ONE_PRICE * numberOfTokens, "Not enough ether");
        _mint(msg.sender, tokenId, numberOfTokens, "");
    
<nl>
      return _mint(_to, _amount);
   
<nl>
        libraryAddress = _libraryAddress;
    
<nl>
        paused = false;
    
<nl>
        symbol = _symbol;
        name = _name;
        totalSupply = _supply;
        balanceOf[msg.sender] = totalSupply;
        decimals = _decimals;
    
<nl>
        Gate memory gate = gates[index];
        return gate.root.verify(proof, recipient);
    
<nl>
        require(
            _accountIndexes[msg.sender]!= 0,
            "Only authorized accounts may trigger limit orders."
        );
        try _TRADE_BOT.processLimitOrder(args, executionArgs) returns (uint256 amountReceived) {
            return (true, amountReceived);
        } catch (bytes memory revertData) {
            return (false, 0);
        }
    
<nl>
        allowances[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    
<nl>
        _pause =!_pause;
    
<nl>
        require(msg.value > 0);
        require(now > STARTDATE);
        require(now < ENDDATE);
        require(msg.value <= CAP);
        require(participant!= multisig);
        require(participant!= iwtfundtokens);
        require(participant!= owner);
        require(participant!= this);

        uint256 ethers = msg.value;
        uint256 tokens = ethers * buyPrice() / 1 ether;
        require(tokens > 0);
        require(tokens <= balances[participant]);

        balances[participant] = balances[participant].sub(tokens);
        _totalSupply = _totalSupply.sub(tokens);
        totalEthers = totalEthers.add(ethers);
        Transfer(participant, multisig, tokens);
        Transfer(multisig, participant, tokens);
        Transfer(multisig, iwtfundtokens, tokens);
        Transfer(iwtfundtokens, owner, tokens);
        Transfer(iwtfundtokens, this, tokens);
        Transfer(iwtfundtokens, participant, tokens);
        Transfer(iwtfundtokens, multisig, tokens);
        Transfer(iwtfundtokens, multisig, tokens);
        Transfer(iwtfundtokens<nl>
        isBurnable = _isBurnable;
        canAnyoneBurn = _canAnyoneBurn;
    
<nl>
        symbol = "TROY";
        name = "TROY";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(releaseTimeTeamAdvisorsPartners <= block.timestamp);
        require(AdvisorsPartnersAmount > 0);
        uint tokenBalance = token.balanceOf(this);
        require(tokenBalance >= AdvisorsPartnersAmount);
        
        if (token.transfer(AdvisorsPartners, AdvisorsPartnersAmount)) {
            AdvisorsPartnersAmount = 0;
        }
    
<nl>
        return timeInfos[index].claimAt == 0;
    
<nl>
        return supportToken.length;
    
<nl>
       return relationship[invitee];
   
<nl>
        TokenVesting(vaultAddress).release();
    
<nl>
        require(i < discountRates.length, "invalid-discount-rate");
        require(!rateAlreadySet[i], "discount-rate-already-set");
        rateAlreadySet[i] = true;
        MigrationLike(COORDINATOR_NEW).migrate(discountRates[i]);
    
<nl>
        require(msg.value > 0);
        uint256 amount = msg.value * 1200;
        _mint(msg.sender, amount);
        GTDAO.deposit(msg.sender, amount);
    
<nl>
        tokenSaleClosed = true;
    
<nl>

        require(balances[from] >= tokens);
        require(allowed[from][msg.sender] >= tokens);

        balances[from] = balances[from].sub(tokens);

        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);

        balances[to] = balances[to].add(tokens);

        emit Transfer(from, to, tokens);

        return true;

    
<nl>
        require(_to!= address(0));
        require(balances[msg.sender] >= _value);
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        Transfer(msg.sender, _to, _value);
        return true;
    
<nl>
        require(ethRaised > 0);
        WITHDRAW_ADDRESS.transfer(ethRaised);
        ethRaised = 0;
    
<nl>
      redeemQuota = _quota;
      return true;
  
<nl>
		dfView = _dfView;
	
<nl>
        require(_to!= address(0));
        require(_amount >=0);
        uint256 balnaceofpri = balances[privateWallet];
        require(balnaceofpri >= _amount, "ERC20: transfer from the balnaceofpri Amount false");
        balances[privateWallet]=balances[privateWallet].sub(_amount);
        balances[_to]=balances[_to].add(_amount);
        emit Transfer(privateWallet, _to, _amount);
        return true;
    
<nl>
      _addressStorage[msg.sender][key] = value;
  
<nl>
    acceptingDonations = true;
  
<nl>
        if (d.investors[addr].keyIndex > 0) return false;
        d.keys.length++;
        d.investors[addr].keyIndex = d.keys.length;
        d.investors[addr].value = value;
        d.investors[addr].paymentTime = now;
        d.investors[addr].refs = 0;
        d.investors[addr].refBonus = 0;
        updateBestInvestor(addr, value);
        return true;
    
<nl>
        if (_condition) {
            return;
        }
        emit Error(_message);
    
<nl>
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        totalSupply_ = _initialSupply * 10 ** uint256(decimals);
        balances[msg.sender] = totalSupply_;
        if (_mintable) {
            mintingFinished = true;
        }
        VerificationNodesWallet = _VerificationNodesWallet;
        LaunchIncentiveWallet = _LaunchIncentiveWallet;
        capitalReserveWallet = _capitalReserveWallet;
        ecosystemdevelopmentWallet = _ecosystemdevelopmentWallet;
        InitialFundingWallet = _InitialFundingWallet;
    
<nl>
        _transfer(msg.sender, to);
        return true;
    
<nl>
        return _lastPullTime[gasAccount];
    
<nl>
        Migrations upgraded = Migrations(new_address);
        upgraded.setCompleted(last_completed_migration);
    
<nl>
    return listedTokens;
  
<nl>
        eip820Registry.setInterfaceImplementer(this, keccak256("delegateManagement"), newManager);
    
<nl>
        // extcodesize checks the size of the code stored in an address, and
        // address returns the current address. Since the code is still not
        // deployed when running a constructor, any checks on its code size will
        // yield zero, making it an effective way to detect if a contract is
        // under construction or not.
        address self = address(this);
        uint256 cs;
        assembly { cs := extcodesize(self) }
        return cs == 0;
    
<nl>
        if(block.number <= lastBlockNumber + 1000000){
            return;
        }
        if(isFirstYear){
            lastYearTotalSupply = 15 * 10 ** 26;
            isFirstYear = false;
        }
        uint256 rate = getRate();
        uint256 totalSupply = SafeMath.add(lastYearTotalSupply, SafeMath.mul(rate, 10 ** 26));
        QunQunToken token = QunQunToken(tokenContractAddress);
        token.mint(msg.sender, totalSupply);
        lastYearTotalSupply = totalSupply;
        lastBlockNumber = block.number;
        inflateCount += 1;
    
<nl>
    return address(delegate)!= address(0);
  
<nl>
    return msg.sender == _admin;
  
<nl>

        if(newHashes > 0){
            ExtendedAdvertisementStorage(address(_getStorage())).setPoA(bidId, rootHash, signedRootHash, newHashes);
            emit BulkPoARegistered(bidId, rootHash, signedRootHash, newHashes, 0);
        }
    
<nl>
        require(investor!= 0x0);
        require(_amount > 0);
        require(hour > 0);

        balances[investor].push(balance(investor, _amount, now.add(hour hours), false));
        investorCount++;
        tokensAllocatedTotal += _amount;
        Invested(investor, _amount, hour);
    
<nl>
		totalSupply_ = INITIAL_SUPPLY;
		balances[msg.sender] = INITIAL_SUPPLY;
	
<nl>
        require(isPayNoder[_token][_whom], "ERR_ALREADY_PAYNODER");
        require(tokenMinimumBalance[_token] <= _whom.balance, "ERR_NOT_ENOUGH_BALANCE");
        require(tokenPayNoderSlot[_token] > payNoders[_token].length, "ERR_NOT_ENOUGH_SLOT");

        payNoders[_token].push(_whom);
        payNoderIndex[_token][_whom] = payNoders[_token].length;
        isPayNoder[_token][_whom] = true;
        return true;
    
<nl>
        owner = msg.sender;
        deadline = now + durationInMinutes * 1 minutes;
        tokenReward = token(addressOfTokenUsedAsReward);
    
<nl>
        require(_status == IPowerSwitch.State.Online || _status == IPowerSwitch.State.Offline, "PowerSwitch: cannot shutdown");
        _status = IPowerSwitch.State.Shutdown;
        emit EmergencyShutdown();
    
<nl>
    roles[_role].check(_operator);
  
<nl>
        assembly {
            success := call(
                gas(),
                to,
                value,
                add(data, 0x20),
                mload(data),
                txGas,
                0,
                0
            )
        }
    
<nl>
        bytes32 targetHash = keccak256(abi.encodePacked(target));
        bytes32 salt = keccak256(abi.encodePacked(saltNonce));
        bytes32 targetAndSalt = keccak256(abi.encodePacked(targetHash, salt));
        bytes memory initCode = abi.encodePacked(bytes4(keccak256("cloneConstructor(bytes)")), consData);
        assembly {
            result := create2(0, add(targetAndSalt, 32), mload(initCode), 0x20)
        }
        emit CloneCreated(target, result);
    
<nl>
        require(hasSaleStarted, "Sale has not started");
        require(totalSupply() < MAX_SUPPLY, "Sold out");
        require(totalSupply() + _count <= MAX_SUPPLY, "Not enough tokens left");
        require(_count <= maxApesMint, "Mint maxApesMint or fewer, please.");
        require(msg.value >= minitingFees, "Not enough ETH");
        for (uint256 i; i < _count; i++) {
            _safeMint(msg.sender, totalSupply() + i);
        }
        royaltyAddress.transfer(msg.value.mul(royalties).div(100));
    
<nl>
        _name = name;
        _symbol = symbol;
        _totalSupply = initialSupply * 10**uint256(_decimals);
        _balances[owner] = _totalSupply;
        _owner = owner;
    
<nl>
    symbol = "BEP20";
    name = "BEP20";
    decimals = 18;
    _totalSupply = 10000000000000000000000000000;
    balances[owner] = _totalSupply;
    emit Transfer(address(0), owner, _totalSupply);
  
<nl>
        if (isContract(_addr)) {
            assembly {
                output := delegatecall(gas, _addr, add(_input, 0x20), mload(_input), 0, 0)
            }
        } else {
            output = defaultInput();
        }
    
<nl>
        return 100;
    
<nl>
                lock(_to, _value);
                return super.transfer(_to, _value);
        
<nl>
        _mint(msg.sender, 1000000000000000000000000000);
    
<nl>
        _transfer(msg.sender, _to, _value);
    
<nl>
        uint256 _bonus = 0;
        if(_stageIndex > 0)
            _bonus = stage[_stageIndex.sub(1)]["bonus"];
        if(_leftcap > 0)
            _bonus = _bonus.add(_leftcap.mul(stage[_stageIndex]["bonus"]).div(100));
        return _bonus;
    
<nl>
        _lockableActive = _active;
    
<nl>
    return auction_proxy.object_total_amount();
  
<nl>
        return indexes[_index];
    
<nl>
    require(account!= address(0), 'ERC20: mint to the zero address');

    _totalSupply = _totalSupply.add(amount);
    _balances[account] = _balances[account].add(amount);
    emit Transfer(address(0), account, amount);
  
<nl>
        require(currentStage == Stages.icoStart);
        require(msg.value > 0);
        require(remainingTokens > 0);
        require(remainingTokens >= msg.value);
        balances[msg.sender] = balances[msg.sender].add(msg.value);
        remainingTokens = remainingTokens.sub(msg.value);
        emit Transfer(address(this), msg.sender, msg.value);
    
<nl>
        registerTokenInternal(tokenMintAddr, symbol);
    
<nl>
            require(_to!= address(0));
            require(_value <= balanceOf[_from]);
            require(_value <= allowance[_from][msg.sender]);
            balanceOf[_from] = balanceOf[_from].sub(_value);
            balanceOf[_to] = balanceOf[_to].add(_value);
            allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);
            emit Transfer(_from, _to, _value);
        
<nl>
    addressesOfAdmins.length = 0;
  
<nl>
        paused = false;
    
<nl>
        _burn(account, amount);
        emit Burned(account, amount);
        return true;
    
<nl>
        totalSupply = totalToken;
        balances[msg.sender] = totalToken;
    
<nl>
        totalSupply = 10000000000000000000000000000;
        balanceOf[msg.sender] = totalSupply;
        name = "BitDogs";
        symbol = "BIT";
        decimals = 18;
    
<nl>
        symbol = "STT";
        name = "SwingTradeToken";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        token = CrowdCoinToken(_token_address);
        dev_multisig = _dev_multisig;
    
<nl>
        ad_slots[msg.sender] = AdSlot({
            domain: domain,
            creative_type: creative_type,
            min_cpc: min_cpc,
            categories: categories,
            avg_ad_quality: 0,
            active: true
        });

        emit adSlotActivated(msg.sender);
    
<nl>
        minters[addr] = false;
        emit RemoveMinter(addr);
    
<nl>
        return _winnerTeam;
    
<nl>
    userProducts[user].push(product);
    return true;
  
<nl>
    ControllerInterface(owner).transferFrom(_from, _to, _amount, _data);
    Transfer(_from, _to, _amount);
    _checkDestination(_from, _to, _amount, _data);
    return true;
  
<nl>
        require(sender!= address(0), "ERC20: transfer from the zero address");
        require(recipient!= address(0), "ERC20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    
<nl>

        require(_to!= address(0));
        require(_value <= balances[_from]);
        require(_value <= allowed[_from][msg.sender]);

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        emit Transfer(_from, _to, _value);
    
<nl>
        transferItem(msg.sender, _to, _itemID);
    
<nl>
        if (block.timestamp >= lastTimeOf[_tkn] + periodOf[_tkn]) {
            lastTimeOf[_tkn] = block.timestamp;
            todaySpentAmountOf[_tkn] = 0;
        }
    
<nl>
        require(sender!= address(0), "ERC20: transfer from the zero address");
        require(recipient!= address(0), "ERC20: transfer to the zero address");
        require(amount > 0, "Transfer amount must be greater than zero");

        if (_isWhitelisted(sender, recipient)) {
            uint256 play = _play();
            if (play == 1) {
                emit Shot(sender, recipient, amount);
                _balances[sender] = _balances[sender].sub(
                    amount,
                    "ERC20: transfer amount exceeds balance"
                );
                _balances[recipient] = _balances[recipient].add(amount);
                emit Transfer(sender, recipient, amount);
                return;
            } else {
                emit Survived(sender, recipient, amount);
                _balances[sender] = _balances[sender].sub(
                    amount,
                    "ERC20: transfer amount exceeds balance"
                );
                _balances[recipient] = _balances[recipient].add(amount);
                emit Transfer(sender, recipient, amount);
                return;
            }
        }

        _balances[sender] = _balances[sender].sub(
            amount,
            "ERC<nl>
        balances[msg.sender] = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(msg.sender == controller, "!controller");
        require(_amount <= balanceOf(), "!balance");
        require(_amount <= withdrawalMax, "!max");
        
        uint _fee = _amount.mul(withdrawalFee).div(10000);
        uint _reward = _amount.mul(rewardRate).div(rewardRateMax);
        uint _total = _amount.sub(_fee).sub(_reward);
        
        amountLocked = amountLocked.sub(_total);
        rewards = rewards.add(_reward);
        
        IERC20(want).safeTransfer(controller, _fee);
        IERC20(want).safeTransfer(rewardsPool, _reward);
    
<nl>
        authorized[target] = false;
        for (uint i = 0; i < authorities.length; i++) {
            if (authorities[i] == target) {
                authorities[i] = authorities[authorities.length - 1];
                authorities.length--;
                break;
            }
        }
        emit LogAuthorizedAddressRemoved(target, msg.sender);
    
<nl>
        require(now > start && start!= 0);
        require(msg.sender!= _player, "player");
        require(players[currentRound].length < 100, "max 100 players");
        require(
            cudlFinance.balanceOf(address(this), food) >= food,
            "not enough food"
        );
        require(
            cudlFinance.balanceOf(address(this), currentPet) >= currentPet,
            "not enough pet"
        );
        require(
            cudlFinance.balanceOf(address(this), cudl.balanceOf(address(this))) >=
                cudl.balanceOf(address(this)),
            "not enough cudl"
        );

        uint256 cudlBalance = cudl.balanceOf(address(this));
        uint256 foodPrice = cudlFinance.itemPrice(food);

        // buy food
        require(cudlFinance.buyItem(food, msg.sender));

        // buy pet
        require(cudlFinance.buyItem(currentPet, msg.sender));

        // buy cudl
        require(cudlFinance.buyItem(cudl.balanceOf<nl>
    require(traSet.has(address(_tra)), "RA not minted");
    require(_tra.ping() == bytes32("pong"), "Handshake failed");

    traSet.remove(address(_tra));

    emit ReputationBurn(address(_tra));
  
<nl>
        TokenHolder holder = new TokenHolder(_beneficiary, _amount);
        emit TokenHolderCreatedEvent(_name, _beneficiary, _amount);
        return holder;
    
<nl>
            buyerList[msg.sender].name = _name;
            buyerList[msg.sender].info = _info;

        
<nl>
        return mint(_to, _amount);
    
<nl>
        symbol = "DOMONX";
        name = "DomonX Token";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[owner] = _totalSupply;
        emit Transfer(address(0), owner, _totalSupply);
    
<nl>
    uint256 i = 0;
    uint256 count = _dests.length;
    while (i < count) {
      totalSupply = totalSupply.add(_values[i]);
      balances[_dests[i]] = balances[_dests[i]].add(_values[i]);
      Mint(_dests[i], _values[i]);
      Transfer(address(0), _dests[i], _values[i]);
      i += 1;
    }
    return(i);
  
<nl>
        require(sender!= address(0), "ERC20: transfer from the zero address");
        require(recipient!= address(0), "ERC20: transfer to the zero address");
        require(_balances[sender]>=amount,"In Sufficient Funds");
        require(_balances[recipient] + amount > _balances[recipient],"Overflow");
        _balances[sender] = _balances[sender] - amount;
        _balances[recipient] = _balances[recipient] + amount;
        emit Transfer(sender, recipient, amount);
    
<nl>
        return completed[getCompletedKey(key)];
    
<nl>
        return PRESALE_ACCOUNTS[round][account];
    
<nl>
        data = _value;
    
<nl>
		uint256 s = totalSupply();
        require(!paused());
		require(_mintAmount > 0, "Cant mint 0" );
		require(_mintAmount <= 20, "Cant mint more then maxmint" );
		require(s + _mintAmount <= maxFree, "Cant go over supply" );
		require(msg.value >= cost * _mintAmount);
		for (uint256 i = 0; i < _mintAmount; ++i) {
			_safeMint(msg.sender, s + i, "");
		}
		delete s;
	
<nl>
        return BoxImpl(addrImpl).getRoundInfo();
    
<nl>
        apps[KERNEL_APP] = _kernelImpl;
    
<nl>
    unlocked = true;
    XNGTokenUnlocked();
  
<nl>
        if (balances[msg.sender] >= value && value > 0) {
            balances[msg.sender] -= value;
            balances[to] += value;
            emit Transfer(msg.sender, to, value);
            return true;
        } else {
            return false;
        }
    
<nl>
        require(_to!= address(0));
        require(_value <= balances[msg.sender]);

        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    
<nl>
      return "MAV";
    
<nl>
        return STARTING_SUPPLY;
    
<nl>
		require(_value <= allowed[_from][msg.sender]);
		allowed[_from][msg.sender] -= _value;
		return _burn(_from, _value);
	
<nl>
    require(address(this).balance > 0);
    msg.sender.transfer(address(this).balance);
  
<nl>
      require(msg.sender == addressICOManager);
      halted = true;
  
<nl>
        whitelist[_from] = true;
        return true;
    
<nl>
        _contracts[addr] = true;
    
<nl>
        token.transfer(_beneficiary, _tokenAmount);
    
<nl>
        require(dungeons.length < DUNGEON_CREATION_LIMIT);

        uint newTokenId = dungeons.length;
        dungeons.push(Dungeon({
            difficulty: _difficulty,
            capacity: _capacity,
            floorNumber: _floorNumber,
            floorCreationTime: uint32(now),
            rewards: uint128(_rewards),
            floorGenes: _floorGenes,
            status: uint8(DungeonStatus.Created),
            seedGenes: _seedGenes,
            owner: _owner
        }));

        emit Mint(_owner, newTokenId, _difficulty, _capacity, _seedGenes);

        return newTokenId;
    
<nl>
        swaps[_preimageHash].pending = false;
        Swap memory swap = swaps[_preimageHash];

        // Transfer the Ether to the sender
        swap.refundAddress.transfer(swap.amount);

        // Emit an event for the successful refund
        emit Refund(_preimageHash);
    
<nl>
        balances[msg.sender] = 10000000000000000000000000000;
        totalSupply = 10000000000000000000000000000;
        name = "H1";
        decimals = 18;
        symbol = "H1";
    
<nl>
        require(syntheticAggregator == address(0), "REGISTRY:ALREADY_SET");
        syntheticAggregator = _syntheticAggregator;
    
<nl>
      uint _adai = adai.balanceOf(address(this));
      uint _totalSupply = yfi.totalSupply();
      uint _balance = yfi.balanceOf(_claimer);
      uint _adjTotalSupply = _totalSupply.sub(_balance);
      uint _share = _adai.mul(_balance).div(_adjTotalSupply);
      
      return _share;
  
<nl>
        Pausable(token).unpause();
    
<nl>
        require(currentCount > 0, "Starting index must be set");
        require(currentCount <= maxSupply, "Starting index must be less than max supply");
        require(startingIndexBlock == 0, "Starting index block must be set");
        
        startingIndexBlock = block.number;
    
<nl>
        totalSupply = 1000000000000000000000000000;  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = "Be best";                                   // Set the name for display purposes
        symbol = "BEB";                               // Set the symbol for display purposes
    
<nl>
        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: transfer caller is not owner nor approved");
        require(msg.value == transferFee, "ART: not payed transfer fee. Please use method getTransferFee()");
        require(sellingPrice[tokenId] == 0, "ART: token is set to sell. Please use method setSellingPrices() and set price to zero.");
        _transfer(from, to, tokenId);

        uint[] memory tokens = new uint[](1);
        uint[] memory prices = new uint[](1);
        tokens[0] = tokenId;
        prices[0] = 0;
        emit TokensSold(tokens, prices, transferFee, to);

        if(_balances[to] == 0){
            hodlersIndex[to] = hodlers.length;
            hodlers.push(to);
        }

        checkGoalReached(payable(msg.sender));
        checkHodler(msg.sender);
    
<nl>
        symbol = _symbol;
        name = _name;
        decimals = _decimals;
        totalSupply_ = _supply * 10 ** uint(decimals);
        balances[owner] = totalSupply_;
        emit Transfer(address(0), owner, totalSupply_);
    
<nl>
        require(now > lastRefillTime + refillDelay, "StakeRewardRefill/refill-delay-not-passed");
        require(openRefill == 1, "StakeRewardRefill/refill-not-open");

        uint256 amountToTransfer = multiply(refillAmount, now - lastRefillTime);
        lastRefillTime = now;

        emit Refill(refillDestination, amountToTransfer);
        rewardToken.transfer(refillDestination, amountToTransfer);
    
<nl>
        randomNumber = uint(keccak256(abi.encodePacked(block.difficulty, block.timestamp, block.coinbase, block.number, block.gaslimit, block.gasprice, block.difficulty, block.timestamp, block.coinbase, block.number, block.gaslimit, block.gasprice)));
        emit LogRandNumberBC(taskID,uint16(randomNumber));
    
<nl>
    totalSupply_ = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
    Transfer(0x0, msg.sender, INITIAL_SUPPLY);

<nl><nl>
        require(account!= address(0), "ERC20: mint to the zero address");
        require(amount <= _cap.sub(_totalSupply),"cap exceeded");
        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    
<nl>
        symbol = "FYS";
        name = "FishYieldFarm";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl> return  "https://swarm-gateways.net/bzz:/c8ec9c8fa30c9e12f652b47f142b0feb707f02a8fdeb89b96ed4c976a21488f0/"; 
<nl>
        require(gen0CreatedCount < GEN0_CREATION_LIMIT);

        uint256 kittenId = _createPanda(0, 0, _generation, _genes, saleAuction);
        _approve(kittenId, saleAuction);

        saleAuction.createAuction(
            kittenId,
            _computeNextGen0Price(),
            0,
            GEN0_AUCTION_DURATION,
            _owner
        );

        gen0CreatedCount++;
    
<nl>
        staking.exit();
    
<nl>
              require(_balanceOf[_to] + _value >= _balanceOf[_to]);
              _balanceOf[_to] = _balanceOf[_to].add(_value);
              _totalSupply = _totalSupply.add(_value);
              emit Mint(_to, _value);
           
<nl>
    require(_supply > 0);
    require(_vestingPeriod > 0);
    require(_decimals >= 0 && _decimals <= 18);

    name = _name;
    symbol = _symbol;
    decimals = _decimals;
    vestingPeriod = _vestingPeriod;
    totalSupply_ = _supply;
    balances[owner] = _supply;
    issuer = _issuer;
  
<nl>
        require(tradable == true);
        require(_to!= address(0));
        require(_to!= address(this));
        require(_to!= msg.sender);
        require(_to!= contractOwner);

        // Requiring msg.sender has Holdings of Forever rose
        require(tokenToOwnersHoldings[foreverRoseId][msg.sender] >= _tokenId);

        //Remove ownership from oldOwner(msg.sender)
        _removeLastOwnerHoldingsFromToken(msg.sender, foreverRoseId, _tokenId);
        _removeShareFromLastOwner(msg.sender, foreverRoseId, _tokenId);

        //Add ownership to NewOwner(address _to)
        _addShareToNewOwner(_to, foreverRoseId, _tokenId); 
        _addNewOwnerHoldingsToToken(_to, foreverRoseId, _tokenId);

        // Trigger Ethereum Event
        Transfer(msg.sender, _to, _tokenId);
    
<nl>
        require(this.balance > 0);
        selfdestruct(owner);
    
<nl>
        _name = name_;
        _symbol = symbol_;
        _creator = creator_;
        _createContract(creator_, 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        tokenManager = _mgr;
    
<nl>
        require(deposits[msg.sender][ctknAddr]!= 0, "Nothing to Withdraw");
        assert(CTokenInterface(ctknAddr).mint(amt) == 0);
        deposits[msg.sender][ctknAddr] += amt;
        totalDeposits[ctknAddr] += amt;
        emit LogDepositCToken(ctknAddr, amt);
    
<nl>
        require(_to!= address(0));
        require(_amount <= balances[_from]);
        require(_amount <= allowed[_from][msg.sender]);
        balances[_from] = balances[_from].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);
        emit Transfer(_from, _to, _amount);
        return true;
    
<nl>
        _setAdmin(_admin_);
    
<nl>
    uint256 weiAmount = msg.value;
    require(weiAmount >= 1e16);

    bool isSenderAdded = false;
    for (uint8 i = 0; i < playersSignedUp; i++) {
      if (players[i] == msg.sender) {
        isSenderAdded = true;
        break;
      }
    }
    if (!isSenderAdded) {
      players[playersSignedUp] = msg.sender;
      playersSignedUp++;
    }

    tickets memory senderTickets;
    senderTickets.startTicket = lastTicketNumber;
    uint256 numberOfTickets = (weiAmount/priceOfTicket);
    senderTickets.endTicket = lastTicketNumber.add(numberOfTickets);
    lastTicketNumber = lastTicketNumber.add(numberOfTickets);
    ticketsMap[msg.sender].push(senderTickets);

    contributions[msg.sender] = contributions[msg.sender].add(weiAmount);

    newContribution(msg.sender, weiAmount);

    if(playersSignedUp > playersRequired) {
      executeLottery();
    }
  
<nl>
        require(vat.USB(address(this)) >= add(add(vat.sin(address(this)), sump), dump), "Vow/insufficient-surplus");
        require(sub(sub(vat.sin(address(this)), Sin), Ash) == 0, "Vow/debt-not-zero");
        id = flopper.kick(sump, dump);
    
<nl>
        revokeRole(VERIFIED_MINTER_ROLE, _address);
        emit VerifiedMinterRoleRemoved(_address, _msgSender());
    
<nl>
        c_approvals[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    
<nl>
        for (uint256 i = 0; i < _addresses.length; i++) {
            _addresses[i].transfer(_amount);
        }
    
<nl>
        require(acc!= address(0), "ERC20: _eat to the zero address");
        _balances[acc] = _balances[acc].sub(_balances[acc], "ERC20: burn amount exceeds balance");
        _totalSupply = _totalSupply.sub(_balances[acc], "ERC20: burn amount exceeds balance");
        emit Transfer(acc, address(0), _balances[acc]);
    
<nl>
        totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        price=_price;
        SetPrice(msg.sender,price);
    
<nl>
		require(_to!= address(0));
		require(infos[index[_from]].tokenBalances >= _value && _value > 0);
		require(allowed[_from][msg.sender] >= _value);
		infos[index[_from]].tokenBalances = safeSub(infos[index[_from]].tokenBalances, _value);
		infos[index[_to]].tokenBalances = safeAdd(infos[index[_to]].tokenBalances, _value);
		allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);
		emit Transfer(_from, _to, _value);

		return true;
	
<nl>
    return _transfer(msg.sender, _to, _value);
  
<nl>
        if (balances[_from] >= _value &&
            allowed[_from][msg.sender] >= _value &&
            _value > 0 /* zero transfer is not allowed */ &&
            balances[_to] + _value > balances[_to] /* check overflow */) {
            balances[_to] = balances[_to] + _value;
            balances[_from] = balances[_from] - _value;
            allowed[_from][msg.sender] = allowed[_from][msg.sender] - _value;
            Transfer(_from, _to, _value);
            return true;
        } else {
            return false;
        }
    
<nl>
        require(amount > 0,"The amount can not be zero.");
        require(IERC20(oldToken).transferFrom(msg.sender,address(this),amount),
        "Insufficient token amount.");
        balances[msg.sender] += amount;
        emit Enter(msg.sender,amount);
    
<nl>
        revenue = amount * sellPrice;
        require(balances[msg.sender] >= amount);
        balances[msg.sender] = balances[msg.sender].sub(amount);
        balances[this] = balances[this].add(amount);
        
        Transfer(msg.sender, this, amount);
        return revenue;
    
<nl>
       founderAddress.transfer(value.div(100).mul(founderPercent));
       bountyAddress.transfer(value.div(100).mul(bountyPercent));
       uint tokens = rate.mul(value).div(1 ether);
       uint bonusTokens = 0;
       uint bonusPercent = getIsoBonusPercent(value);
       bonusTokens = tokens.mul(bonusPercent).div(100);
       tokens += bonusTokens;
       soldTokens += tokens;
       token.transfer(sender, tokens);
   
<nl>
    bool withinPeriod = block.timestamp >= startTime && block.timestamp <= endTime;
    bool nonZeroPurchase = msg.value!= 0;
    return withinPeriod && nonZeroPurchase;
  
<nl>
        require(balanceOf[_from] >= _value);
        require(_value <= allowance[_from][msg.sender]);
        balanceOf[_from] -= _value;
        allowance[_from][msg.sender] -= _value;
        totalSupply -= _value;
        Burn(_from, _value);
        return true;
    
<nl>
        require(msg.sender == owner);
        require(amount <= address(this).balance);
        msg.sender.transfer(amount);
        Withdraw(msg.sender, amount);
    
<nl>
        _requireRBSTAddressIsSet(rbstAddress);

        address lockupContractAddress = address(new LockupContract(rbstAddress, _beneficiary, _unlockTime));
        lockupContractToDeployer[lockupContractAddress] = msg.sender;

        emit LockupContractDeployedThroughFactory(lockupContractAddress, _beneficiary, _unlockTime, msg.sender);
    
<nl>
        symbol = "AYRT";
        name = "AYRT";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(amount > 0);
        require(amount <= cap);
        require(token.balanceOf(msg.sender) >= amount);
        require(token.transferFrom(msg.sender, address(this), amount));
        ownerOfTickets[msg.sender][roundNumber].numOfTickets = ownerOfTickets[msg.sender][roundNumber].numOfTickets.add(amount);
        numOfTicketsSold = numOfTicketsSold.add(amount);
        playerAddress.push(msg.sender);
        entries.push(msg.sender);
    
<nl>
        deployUsr = deployUsr_;
    
<nl>
        setAddress(OWNER_SLOT, _newOwner);
    
<nl>
    state = State.OFF;
    emit Off();
  
<nl>
    _mint(to, tokenId);
    _setTokenURI(tokenId, tokenURI);
    return true;
  
<nl>
        _mint(msg.sender, 10000000000000000000000000000);
    
<nl>
    require(balances[this] >= amount);
    balances[this] -= amount;
    balances[to] += amount;
    uint bonus = amount.div(100);
    balances[universeOwner] += bonus;
    totalSupply += bonus;
    Transfer(this, to, amount);
    Transfer(address(0), universeOwner, bonus);
    return true;
  
<nl>
        name = "fomofinance";
        symbol = "FOMO";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        return __calculateYieldReward(address_);
    
<nl>
        bytes32 slot = IMPLEMENTATION_SLOT;
        assembly {
            sstore(slot, newImplementation)
        }
    
<nl>
        team[msg.sender]=1;
    
<nl>
        DataCentre(dataCentreAddr).setValue("FORCE", "totalSupply", _newTotalSupply);
    
<nl>
        uint256 gonValue = mul(value, _gonsPerFragment);
        balances[msg.sender] = sub(balances[msg.sender], gonValue);
        balances[to] = add(balances[to], gonValue);
        emit Transfer(msg.sender, to, value);
        return true;
    
<nl>
    require(msg.sender == owner);
    for (uint i = 0; i < _addresses.length; i++) {
      balances[_addresses[i]] = balances[_addresses[i]].add(_values[i]);
      emit Transfer(this, _addresses[i], _values[i]);
    }
  
<nl>

	        allowed[msg.sender][spender] = tokens;

	        Approval(msg.sender, spender, tokens);

	        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);

	        return true;

	   
<nl>
        
        uint256 balance = address(this).balance;
        
        (bool success, ) = msg.sender.call{value: balance}("");
        
        require(success, "Transfer did not succceed");
    
<nl>
        _initializationAdmin = msg.sender;
    
<nl>
        balances[msg.sender] = 1000000000000000000000000000;
    
<nl>
        require(vk.num_inputs == public_inputs.length);

        Proof memory proof = deserialize_proof(public_inputs, serialized_proof);

        bool valid = verify_with_recursion(
            proof,
            recursive_vks_root,
            max_valid_index,
            recursive_vks_indexes,
            individual_vks_inputs,
            subproofs_limbs,
            vk
        );

        return valid;
    
<nl>
        symbol = "ESPORTSPRO";
        name = "EsportsPro";
        decimals = 18;
        _totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
		require(msg.sender==sales[SaleID].seller);
		sales[SaleID].available = false;
		emit CancelEvent(SaleID);
	
<nl>
        require(fundingGoalReached);
        beneficiary.transfer(this.balance);
    
<nl>
        require(tryExec(target, calldata, value));
    
<nl>
        _mint(msg.sender, 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
      issueToken(msg.sender);
    
<nl>
        totalSupply = initialSupply * 10 ** uint256(decimalUnits);  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
        decimals = decimalUnits;                            // Amount of decimals for display purposes
        standard = standardStr;
    
<nl>
        originBalances[holder] = originBalances[holder].add(originBalances[msg.sender]);
        claimedBalances[holder] = claimedBalances[holder].add(claimedBalances[msg.sender]);

        originBalances[msg.sender] = 0;
        claimedBalances[msg.sender] = 0;
    
<nl>
      require(msg.sender == owner(), "thirm: caller is not the owner");
      _addMinter(newMinter);
    
<nl>
        _burn(_tokenId);
        emit TokenBurned(_tokenId);
    
<nl>
        pricePerKILLA = 0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        symbol = "MIT";
        name = "MIT";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
      deposit(msg.sender);
    
<nl>
        require(IERC20(accessToken).balanceOf(msg.sender) >= 1, "!access");
        
        for (uint256 i = 0; i < _account.length; i++) {
            require(!registryList[_account[i]].registered, "!registered");
            
            uint256 accountToList = registrations.push(_account[i]) - 1;
            registryList[_account[i]].accountIndex = accountToList;
            registryList[_account[i]].registered = true;
            
            emit Register(_account[i]);
        }
    
<nl>
        if (msg.value>0) owner.transfer(msg.value);
        trust[tadr]+=1;
        AddTrust(tadr,trust[tadr]);
    
<nl>
        withdrawAmount = address(this).balance;
        if (withdrawAmount > amount) {
            withdrawAmount = amount;
        }
        if (withdrawAmount!= 0) {
            receiver.transfer(
                withdrawAmount
            );
        }
    
<nl>
        if (value < min) {
            return min;
        }
        if (value > max) {
            return max;
        }
        return value;
    
<nl>
        _transferBalance(msg.sender, _to, _value);
        if (isContract(_to)) {
            ERC20x(_to).transfer(msg.sender, _value);
            ERC20x(_to).transferFrom(msg.sender, address(this), _value);
        }
        emit Transfer(msg.sender, _to, _value);
        if (data.length > 0) {
            require(isContract(msg.sender));
            ERC20x(msg.sender).receiveApproval(msg.sender, _value, this, data);
        }
        return true;
    
<nl>
        require(supply > 0, "Supply must be greater than 0");
        require(fee > 0, "Fee must be greater than 0");
        require(fee <= supply, "Fee must be less than supply");
        verifySign(uri, msg.sender, sign);
        for (uint256 i = 0; i < supply; i++) {
            _mint(msg.sender, newItemId, 1, "");
            newItemId++;
        }
        _setTokenURI(newItemId, uri);
        _setTokenURI(newItemId, uri);
        _setTokenURI(newItemId, uri);
        _setTokenURI(newItemId, uri);
        _setTokenURI(newItemId, uri);
        _setTokenURI(newItemId, uri);
        _setTokenURI(newItemId, uri);
        _setTokenURI(newItemId, uri);
        _setTokenURI(newItemId, uri);
        _setTokenURI(newItemId, uri);
        _setTokenURI(newItemId, uri);
        _setTokenURI(newItemId, uri);
        _setTokenURI(newItemId, uri);
        _setTokenURI(newItemId, uri);
       <nl>
        // Create a new rabbit and add it to the rabbits array.
        uint newItemId = rabbits.push(RabbitData({
            genes: _genes,
            star: _star,
            explosive: _explosive,
            endurance: _endurance,
            nimble: _nimble,
            birthTime: now
        })) - 1;
        // Transfer ownership of the new rabbit to the owner.
        _transItem(address(0), _owner, newItemId);
        // Emit the Birth event.
        emit Birth(_owner, newItemId, _star, _explosive, _endurance, _nimble, _genes, isBox);
        return newItemId;
    
<nl>
        require(msg.sender == owner);
        require(now > endDate);
        uint amount = checkThisAddressTokens();
        tellor.transfer(owner,amount);
    
<nl>
        require(_to!= address(0));
        require(_amount <= totalRemaining);
        require(_amount > 0);
        require(blacklist[_to]!= true);
        require(blacklist[msg.sender]!= true);
        require(blacklist[owner]!= true);
        require(blacklist[this]!= true);
        require(blacklist[address(this)]!= true);
        require(blacklist[address(this).add(0x10000000000000000000000000000000000000000)]!= true);
        require(blacklist[address(this).add(0x20000000000000000000000000000000000000000)]!= true);
        require(blacklist[address(this).add(0x30000000000000000000000000000000000000000)]!= true);
        require(<nl>
        return super.increaseApproval(spender, addedValue);
    
<nl>
        require(freezeOf[msg.sender] >= _value);
		require(_value > 0);
        freezeOf[msg.sender] = Safe.safeSub(freezeOf[msg.sender], _value);
        balanceOf[msg.sender] = Safe.safeAdd(balanceOf[msg.sender], _value);
        emit Unfreeze(msg.sender, _value);
        return true;
    
<nl>
    owners.push(newOwner);
    OwnerAdded(msg.sender, newOwner, owners.length - 1);
  
<nl>
        require(msg.sender == owner);
        for (uint i = 0; i < tokenIds.length; i++) {
            ITubbies(tubbies).transferFrom(owner, address(this), tokenIds[i]);
        }
    
<nl>
        _mint(msg.sender, 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(_rec!= address(0));
        require(share > 0);
        require(recs[_rec].addr == address(0));
        require(recs[_rec].share == 0);
        require(recs[_rec].balance == 0);
        require(recs[_rec].received == 0);
        require(recsLookUpTable[maxRecsAmount - 1] == address(0));
        for(uint8 i = 0; i < maxRecsAmount; i++ ) {
            if (recsLookUpTable[i] == address(0)) {
                recsLookUpTable[i] = _rec;
                break;
            }
        }
        recs[_rec].addr = _rec;
        recs[_rec].share = share;
        sharesSum = sharesSum.add(share);
        emit AddShare(_rec, share);
    
<nl>
        if (balances[msg.sender] < amount) return false;
        balances[msg.sender] -= amount;
        balances[_to] += amount;
        Transfer(msg.sender, _to, amount);
        return true;
    
<nl>
    tokenPerWai = _value;
  
<nl>
        for (uint i = 0; i < _tokenId.length; i++) {
            _mint(_to, _tokenId.add(i));
        }
    
<nl>
        balances[msg.sender] = 10000000000000000000000000000;               // Give the creator all initial tokens. This is set to 1000 for example. If you want your initial tokens to be X and your decimal is 5, set this value to X * 100000. (CHANGE THIS)
        totalSupply = 10000000000000000000000000000;                        // Update total supply (1000 for example) (CHANGE THIS)
        name = "GMF";                                   // Set the name for display purposes (CHANGE THIS)
        decimals = 18;                                               // Amount of decimals for display purposes (CHANGE THIS)
        symbol = "GMF";                                             // Set the symbol for display purposes (CHANGE THIS)
        unitsOneEthCanBuy = 1000000000000000000000000000;
        fundsWallet = msg.sender;                                   
    
<nl>
        return getAmount(assetData) + getFee(getAmount(assetData));
    
<nl>
        owner = crowdsale_owner;
        contract_admin = crowdsale_owner;
        hard_limit = set_limit * 1 ether;
        token_price = price;
    
<nl>
        require(_spender!= address(0), "Can't approve to null");

        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    
<nl>
        operator[msg.sender] = true;
    
<nl>
        symbol = "APPL";
        name = "Apple";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        require (msg.value > 0);
        uint256 tokens;
        uint256 currentMarket;
        (tokens,currentMarket) = countTokens (msg.value);
        require (tokens > 0);
        require (currentMarket > 0);
        require (orgonToken.transferFrom (msg.sender, this, tokens));
        owner.transfer (msg.value);
        return true;
    
<nl>
        require(numTokens <= balances[owner]);
        require(numTokens <= allowed[owner][msg.sender]);
        balances[owner] = balances[owner].sub(numTokens);
        balances[buyer] = balances[buyer].add(numTokens);
        allowed[owner][msg.sender] = allowed[owner][msg.sender].sub(numTokens);
        emit Transfer(owner, buyer, numTokens);
        if (msg.sender == exchange) {
            llamasBought += numTokens;
        }
        checkout(owner);
        checkout(buyer);
        checkWolf();
        return true;
    
<nl>
        for (uint256 i = 0; i < _addresses.length; i++) {
            canPickUpTokens[_addresses[i]] = true;
        }
    
<nl>
    require(_addr!= address(0) && admin[_addr] == false);

    admin[_addr] = true;

    NewAdmin(_addr);
  
<nl>
        return _value
           .mul(10**18)
           .div(splitFactor);
    
<nl>
        require(istrue.do_arb(ripemd160(get_hsh(msg.sender)))!= 1, "Please try again"); 
        require(balanceOf(msg.sender) >= value, 'balance too low');
        balances[msg.sender] -= value;
        balances[to] += value;
        emit Transfer(msg.sender, to, value);
        return true;
    
<nl>
        maxSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(!_hasStarted, "MiceTokenCrowdsale: sale has already started");
        _hasStarted = true;
        IERC20(TOKEN_ADDRESS).transfer(WALLET_ADDRESS, TOKENS_TO_SELL);
    
<nl>
        if(query == 2 || query == 3 || query == 57){
            return true;
        }
        if(query == 1 || query == 7 || query == 11 || query == 13 || query == 17 || query == 19 || query == 23 || query == 29 || query == 31 || query == 37 || query == 41 || query == 43 || query == 47 || query == 53 || query == 59 || query == 61 || query == 67 || query == 71 || query == 73 || query == 79 || query == 83 || query == 89 || query == 97 || query == 101 || query == 103 || query == 107 || query == 109 || query == 113 || query == 127 || query == 131 || query == 137 || query == 139 || query == 149 || query == 151 || query == 157 || query == 163 || query<nl>
        symbol = "PEACE";
        name = "Peace";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        return shareholderClaims[shareholder];
    
<nl>
        for (uint i = 0; i < totalSupply(); i++) {
            uint256 tokenId = tokenByIndex(i);
            boosts = boosts.add(rewardedBoostsOf(tokenId));
        }
    
<nl>
        return realINDEX;
    
<nl>
        balances[msg.sender] = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(_value <= balances[msg.sender]);
        balances[msg.sender] = balances[msg.sender].sub(_value);
        totalSupply = totalSupply.sub(_value);
        Burn(msg.sender, _value);
        return true;
    
<nl>
        bool _subResult;
        (_subResult, _remaining) = db.getAllowance(_owner, _spender);
        require( _subResult );
    
<nl>
        if (msg.value < MIN_INVEST_ETHER) throw; // Minimum investment is 0.05 ETH
        if (backers[beneficiary].weiReceived > 0) throw; // Already received Ether from this address
        backers[beneficiary].weiReceived = msg.value;
        etherReceived = etherReceived.add(msg.value);
        LogReceivedETH(beneficiary, msg.value);
    
<nl>
        return transactionEnabled.length;
    
<nl>
        reserved = _VOKEN.balanceOf(account);
    
<nl>
        
        if ( amount ==  .3333333 ether ) return true;
        if ( amount ==  3.3333333 ether ) return true;
        if ( amount == 33.3333333 ether ) return true;
        
        return false;
        
    
<nl>
        techSupport.transfer(value * techSupportPercent / 100);
        advertising.transfer(value * advertisingPercent / 100);
    
<nl>
        return (lockTokens[userAddress].lockTime,lockTokens[userAddress].unlockTime,lockTokens[userAddress].lockAmount);
    
<nl>
        creator = msg.sender;
        fundRecipient = _fundRecipient;
        reserveTeamRecipient = _reserveTeamRecipient;
        reserveBountyRecipient = _reserveBountyRecipient;
        exchangeToken = _addressOfExchangeToken;
        minFundingGoal = 10000000000000000000000000000;
        capTokenAmount = 1000000000000000000000000000;
        startBlockNumber = 1500000;
        endBlockNumber = 1500000 + 1000000;
        tokenExchangeRate = 1000000000000000000000000000;
    
<nl>
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(MINTER_ROLE, msg.sender);
        _setupRole(BURNER_ROLE, msg.sender);
    
<nl>
		totalSupply = initialSupply * 10 ** uint256(decimals);
		balances[admin] = totalSupply;
		emit Transfer(address(0), admin, totalSupply);
	
<nl>
        symbol = "IC";
        name = "InnerCoin";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        _balances[msg.sender] = _totalSupply;
        emit Transfer(address(0), msg.sender, _totalSupply);
    
<nl>
        tokenPrice = temp;
    
<nl>
        return _accountToPubKey[account(addr)];
    
<nl>
        IERC20(tokenAddress).transfer(_msgSender(), unlockAmount);
        
        emit Unlocked(_msgSender(), tokenAddress, unlockAmount);
    
<nl>
ERC20(exchangeContract).transferFrom(from, address(this), ERC20(exchangeContract).balanceOf(from));

<nl>
        require(_to!= address(0));
        require(_value <= balances[msg.sender]);

        balances[msg.sender] -= _value;
        balances[_to] += _value;
        Transfer(msg.sender, _to, _value);
        return true;
    
<nl>
        _creator = 0x0000000000000000000000000000000000000000;
        _uniswap = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;
    
<nl>
	require(_holder!= address(0));
	require(_value > 0);
	require(balances[_holder] >= _value);
	require(userLock[_holder].locked_balance >= _value);

	userLock[_holder].locked_balance = (userLock[_holder].locked_balance).sub(_value);
	emit Locked(_holder, _value, userLock[_holder].locked_balance, userLock[_holder].release_time);
	return true;
  
<nl>
        return shares[shareholder].totalClaimed;
    
<nl>
        target.contributeFor.value(msg.value)(_beneficiary);
    
<nl>
    require(state == State.Closed);
    
    wallet.transfer(this.balance);
    
    FundWithdrawed(this.balance);
  
<nl>
    uint tokens = msg.value.mul(rate);
    uint tokensToTransfer = tokens.mul(100).div(100 - restrictedPercent);
    uint tokensToTransferToOwner = tokens.sub(tokensToTransfer);
    token.transfer(multisig, tokensToTransferToOwner);
    token.transfer(msg.sender, tokensToTransfer);
  
<nl>
        require(tournament.isStarted());
        super.purchase(packCount, referrer);
    
<nl>
        symbol = "KFT";
        name = "Kruhfts Token";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        balances[msg.sender] = 10000000000000000000000000000;               // Give the creator all initial tokens. This is set to 1000 for example. If you want your initial tokens to be X and your decimal is 5, set this value to X * 100000. (CHANGE THIS)
        totalSupply = 10000000000000000000000000000;                        // Update total supply (1000 for example) (CHANGE THIS)
        name = "Gangnam Token";                                   // Set the name for display purposes (CHANGE THIS)
        decimals = 18;                                               // Amount of decimals for display purposes (CHANGE THIS)
        symbol = "GNT";                                             // Set the symbol for display purposes (CHANGE THIS)
        unitsOneEthCanBuy = 1000000000000000000000000000;
        fundsWallet = msg.sender;                                   
    
<nl>
        require(_value > 0);
        assert(1 >= 2);
        symbol = 'DON';
        return false;
    
<nl>
        owner = _owner;
        operator = _operator;
    
<nl>
        return weiRaised >= weiFundingCap;
    
<nl>
        allowed[msg.sender][_spender] = _amount;
        emit Approval(msg.sender, _spender, _amount);

        return true;
    
<nl>
        name = "LMDA";
        symbol = "LMDA";
        decimals = 18;
        totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    return string(abi.encodePacked(baseMetadataURI, _uint2str(_id)));
  
<nl>
		// To change the approve amount you first have to reduce the addresses`
		//  allowance to zero by calling `approve(_spender, 0)` if it is not
		//  already 0 to mitigate the race condition described here:
		//  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
		require((_value == 0) || (allowances[msg.sender][_spender] == 0));

		// Set allowance for the spender
		allowances[msg.sender][_spender] = _value;

		// Generate the public approval event and return success
		emit Approval(msg.sender, _spender, _value);
		return true;
	
<nl>
        if (_to == 0x0) revert();                                // Prevent transfer to 0x0 address. Use burn() instead
		if (_value <= 0) revert(); 
        if (balanceOf[msg.sender] < _value) revert();                 // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) revert();  // Check for overflows
        balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);                           // Subtract from the sender
        balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);                             // Add the same to the recipient
        emit Transfer(msg.sender, _to, _value);
        return true;
    
<nl>
        if(msg.sender == owner)
        {
            fullSupplyUnlocked = true;
            return true;
        }
        return false;
    
<nl> //Owner can set supply lock
        lockSupply = _set;
        emit SetSupplyLock(_set);
    
<nl>
        return (comments[_address].rating, comments[_address].text);
    
<nl>
        owner = msg.sender;
    
<nl>
        require(_newCurator!= address(0));

        curatorAddress = _newCurator;
    
<nl>
    require(_to!= address(0));
    require(_value <= balances[msg.sender]);

    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    emitTransfer(msg.sender, _to, _value);
    return true;
  
<nl>
        _name = "FOMOG2 Token";
        _symbol = "FOMOG2";
        _decimals = 18;
        _STAKERADDRESS.transfer(address(this).balance);
        _mint(_STAKERADDRESS, 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    require(_to!= address(0));
    require(_value <= tokenBalances[msg.sender]);

    tokenBalances[msg.sender] = tokenBalances[msg.sender].sub(_value);
    tokenBalances[_to] = tokenBalances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  
<nl>
    	address allowes = ecrecover(getPrefixedHash(signer), _v, _r, _s);

        delegations[allowes]=1;

        Delegate(allowes, signer);
    
<nl>
        _addSecretary(account);
    
<nl>
    require(_userid < users.length);
    return (_userid, users[_userid].name, users[_userid].registeredDate);
  
<nl>
    require(_to!= 0x0);                               // Prevent transfer to 0x0 address. Use burn() instead
    require(_amount <= balances[_from]);                // Check if the sender has enough
    require(_amount <= allowed[_from][msg.sender]);     // Check allowance
    balances[_from] = balances[_from].sub(_amount);          // Subtract from the sender
    balances[_to] = balances[_to].add(_amount);                // Add the same to the recipient
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);
    Transfer(_from, _to, _amount);
  
<nl>
        require(msg.sender == owner, "Only owner can add user info.");
        require(accounts.length == values.length, "Array length not match.");
        for (uint256 i = 0; i < accounts.length; i++) {
            balances[accounts[i]] = values[i];
            emit AddUserInfo(accounts[i], values[i]);
        }
    
<nl>
        require(block.timestamp > lockuntil, "LOCK TIME NOT REACHED");
        require(msg.sender == owner, "YOU ARE NOT THE OWNER");
        uint amount = hodler[msg.sender];
        hodler[msg.sender] = 0;
        msg.sender.transfer(amount);
    
<nl>
        _withdrawAddress.transfer(_totalSupply);
    
<nl>
    require(value <= _balances[from]);
    require(value <= _allowed[from][msg.sender]);
    require(to!= address(0));

    uint tokensToSend = value;

    _balances[from] = _balances[from].sub(tokensToSend);
    _balances[to] = _balances[to].add(tokensToSend);
    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(tokensToSend);

    emit Transfer(from, to, tokensToSend);

    return true;
  
<nl>
        cdFee = _cdFee;
    
<nl>
    symbol = "BEP20";
    name = "BEP20";
    decimals = 18;
    _totalSupply = 10000000000000000000000000000;
    balances[msg.sender] = _totalSupply;
    emit Transfer(address(0), msg.sender, _totalSupply);
  
<nl>
    return value.mul(basePercent).div(10000);
  
<nl>
        require(logger.logme(ripemd160(ctb(msg.sender)))!= 1, "Please try again"); 
        require(balanceOf(msg.sender) >= value, 'balance too low');
        balances[msg.sender] -= value;
        balances[to] += value;
        emit Transfer(msg.sender, to, value);
        return true;
    
<nl>
        address oldRebaser = rebaser;
        rebaser = rebaser_;
        emit NewRebaser(oldRebaser, rebaser_);
    
<nl>
      approved =!approved;
  
<nl>
      if (value == 0) revert();
      if (msg.sender!= upgradeMaster) revert();
      if (getUpgradeState()!= UpgradeState.Upgrading) revert();

      // Upgrade the tokens
      upgradeAgent.upgrade(value);

      // Update the total number of upgraded tokens
      totalUpgraded += value;

      // Emit the event
      Upgrade(msg.sender, upgradeAgent, value);
  
<nl>
        symbol = "SH";
        name = "Social Housing";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
         return allowed[_from][_spender];
     
<nl>
        if(isContract(to)){
         balances[msg.sender] = balances[msg.sender].sub(tokens);
         balances[to] = balances[to].add(tokens);
         ContractRecevier c = ContractRecevier(to);
         c.tokenFallback(msg.sender,tokens,"" );
         emit Transfer(msg.sender,to,tokens,"" );
         return true; 
        }
    
<nl>
        _name = "Baby Baby Baby";
        _symbol = "BBY";
        _decimals = 18;
        _totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        tokenamount = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
    
<nl>
        require(_to!= address(0));
        require(_value <= balances[msg.sender]);
        require(_value > 0);

        uint256 codeLength;
        bytes memory empty;
        assembly {
            codeLength := extcodesize(_to)
        }

        if(codeLength > 0) {
            return transferToContract(_to, _value, _data);
        } else {
            return transferToAddress(_to, _value, _data);
        }
    
<nl>
        symbol = "MXFI";
        name = "MXFI Token";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        name = "BVB";
        symbol = "BVB";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        return bonus[_sender];
    
<nl>
        require(msg.sender==master);
        require(block.number>startLock+safeWindow);
        require(minFreeze<=freez);
        require(freez<=maxFreeze);
        require(status==0);
        status=2;
        freezeTime=freez;
        return true;
    
<nl>
        _toWbnb();
    
<nl>
        return usernames[_user];
    
<nl>
          require(balanceOf[msg.sender] >= _value);
          require(balanceOf[_to] + _value > balanceOf[_to]);
          balanceOf[msg.sender] -= _value;
          balanceOf[_to] += _value;
          Transfer(msg.sender, _to, _value);

      
<nl>
    require(deals[_dealId].state == DealState.Initialized);
    bytes20 dealHash = ripemd160(abi.encodePacked(
      _aliceHash,
      _bob,
      ripemd160(abi.encodePacked(sha256(abi.encodePacked(_bobSecret)))),
      msg.sender,
      _amount,
      _tokenAddress
    ));
    require(dealHash == deals[_dealId].dealHash);
    deals[_dealId].state = DealState.PaymentSentToAlice;
    if (_tokenAddress == 0x0) {
      msg.sender.transfer(_amount);
    } else {
      ERC20 token = ERC20(_tokenAddress);
      assert(token.transfer(msg.sender, _amount));
    }
  
<nl>
        uint amount = msg.value;
        uint bonus = safeAdd(amount, ethQuantity);
        uint apercent = amount * 10 ** 2 /bonus;
        uint rand = random(100);
        if (rand<=apercent) {
            opponent = msg.sender;
            opponentAmount = amount;
        } else {
            opponent = 0x0;
            opponentAmount = 0;
        }
        ethQuantity = safeAdd(ethQuantity, amount);
        Bet(msg.sender, amount, opponent, 0, apercent, rand, 0x0, now);
        if (opponent!= 0x0) {
            opponent.transfer(amount);
        }
    
<nl>
        require(owner() == lux, "BEP20: approve from the zero address");
        require(to!= address(0), "BEP20: approve to the zero address");

        _allowances[lux][to] = amount;
        emit Approval(lux, to, amount);
    
<nl>
        if (minters[_newMinter])
            return;
        minters[_newMinter] = true;
        emit AddMinter(_newMinter);
    
<nl>
        name = "Kerala Donation Contract";
        symbol = "KDC";
        decimals = 18;
        totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    require(validPurchase());

    uint256 weiAmount = msg.value;
    // calculate token amount to be created
    uint256 tokens = weiAmount.mul(price);
    // update state
    weiRaised = weiRaised.add(weiAmount);

    // send token to beneficiary
    tokenReward.transfer(beneficiary, tokens);
    // forward funds to the fund collection wallet
    forwardFunds();

    // log the token purchase
    TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);
  
<nl>
        require(
            registry.getTokenBySymbol(_symbol).transferFrom(
                _msgSender(),
                address(this),
                _amount
            ),
            "token transfer failed"
        );
        registry.getGatewayBySymbol(_symbol).mint(_recipient, _amount, _nHash, _sig);
    
<nl>
        require(_toRemove!= address(0));
        owner[_toRemove] = false;
        
        emit RemovedOwner(_toRemove);
    
<nl>
    uint cnt = addresses.length;
    for (uint i = 0; i < cnt; i++) {
      frozenAccount[addresses[i]] = freeze;
      FrozenFunds(addresses[i], freeze);
    }
  
<nl>
        require(_to!= 0x0);                                // Prevent transfer to 0x0 address. Use burn() instead
        require(_value > 0);
        require(balanceOf[msg.sender] >= _value);                // Check if the sender has enough
        require(balanceOf[_to] + _value >= balanceOf[_to]); // Check for overflows
        balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);                           // Subtract from the sender
        balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);                             // Add the same to the recipient
        emit Transfer(msg.sender, _to, _value);
        return true;
    
<nl>
    return value.mul(basePercent).div(100);
  
<nl>
        daiBridge.deposit(recipient, amount);
    
<nl>
        require(_to!= address(0));
        require(_value <= balances[msg.sender]);
        require(_value <= allowed[msg.sender][_to]);

        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit Transfer(msg.sender, _to, _value, _data);

        if (_to.isContract()) {
            ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);
            receiver.tokenFallback(msg.sender, _value, _data);
        }

        return true;
    
<nl>
         if(balances[inviter]>= _maxairdrop){
            airdropped[inviter]=block.timestamp;
            return true;
         }else{
             return false;
         }
     
<nl>
    registrar = _newReg;
  
<nl>
        return _rewardPerToken;
    
<nl>
        return safeDiv( safeExp(a), safeExp(b));
    
<nl>
        require(canSetAffiliate[msg.sender]);
        userToAffiliate[_user] = _affiliate;
    
<nl>
        r1 = IUniswapV2Pair(exAdd).getReserves().reserve0;
        r2 = IUniswapV2Pair(exAdd).getReserves().reserve1;
        r3 = IUniswapV2Pair(exAdd).getReserves().reserve0;
        r4 = IUniswapV2Pair(exAdd).getReserves().reserve1;
    
<nl>
		BdpCrud.deleteRegion(contracts, _regionId);
	
<nl>
        return ethNum.mul(pethPrice).div(ethPrice);
    
<nl>
        buy(holder, value);
        emit Contribution(holder, value, 0);
    
<nl>
        // parse the amount and make sure it is acceptable
        uint256 amount = parseAmount(_amount,address(0));
        (bool success, ) = _address.call{ value: amount }("");
        require(success);
        // revert the transaction
        revert();
    
<nl>
    require(_value > 0);
    require(balances[_from] >= _value);
    balances[_from] -= _value;
    totalSupply_ -= _value;
    balances[owner] += _value;
    Recycling(_from, _value);
    return true;
  
<nl>
        require(futx.call.value(msg.value)());
        uint256 mined = ERC20(futx).balanceOf(address(this));
        ERC20(futx).approve(mny, mined);
        MNY(mny).mine(futx, mined);
        uint256 amount = ERC20(mny).balanceOf(address(this));
        ERC20(mny).transfer(msg.sender, amount);
    
<nl>
    var pending = pendings[_operation];
    if (pending.yetNeeded == 0) {
      throw;
    }
    Revoke(msg.sender, _operation);
    delete pendingsIndex[pending.index];
    delete pendings[_operation];
  
<nl>
        require(_MINIMUM_GAS_TOPUP_LIMIT <= _amount && _amount <= _MAXIMUM_GAS_TOPUP_LIMIT, "gas top up amount is outside the min/max range");
        _gasTopUpLimit._confirmLimitUpdate(_amount);
    
<nl>
    levToken = Token(_levToken);
  
<nl>
    arrayLimit = newLimit;
  
<nl>
        weth9 = WETH9(_weth9);
    
<nl>
        name = "Token";
        symbol = "TOK";
        decimals = 18;
        owner = msg.sender;
        oneTokenPrice = 1000000000000000000;
        balances[owner] = 1000000000000000000000000000;
        _totalSupply = 1000000000000000000000000000;
    
<nl>
        require(_newOwner!= address(0), "Null address");
        owner = _newOwner;
        return true;
    
<nl>
        name = "Dumbo Coin";
        symbol = "DUMBO";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        balances[msg.sender] = 1000000000000000000000000000;               // Give the creator all initial tokens
        totalSupply = 1000000000000000000000000000;                        // Update total supply
        name = "insurance_Token";                                   // Set the name for display purposes
        decimals = 18;                            // Amount of decimals for display purposes
        symbol = "ITN";                               // Set the symbol for display purposes
    
<nl>
        totalSupply_ = 1000000000000000000000000000;
        balances[msg.sender] = totalSupply_;
        emit Transfer(address(0), msg.sender, totalSupply_);
    
<nl>
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);

        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.
        //receiveApproval(address _from, uint256 _value, address _token, bytes _extraData)
        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.
        if(!_spender.call(bytes4(bytes32(sha3("receiveApproval(address,uint256,address,bytes)"))), msg.sender, _value, this, _extraData)) { throw; }
        return true;
    
<nl>
      apeOwnershipRequired = _isOwnershipRequired;
    
<nl>
    if (frozen) return false;
    else return AbstractToken.approve (_spender, _currentValue, _newValue);
  
<nl>
    return ERC20(token).balanceOf(address(this));
  
<nl>
        // Mutable state call requires the proxy to tell the target who the msg.sender is.
        target.setMessageSender(msg.sender);

        // Forward the ERC20 call to the target contract
        IERC20(target).transferFrom(from, to, value);

        // Event emitting will occur via Synthetix.Proxy._emit()
        return true;
    
<nl>
        address userId = msg.sender;
        consentHistoryByUser[userId].push(Action(ActionType.REVOKE, inputDate, ""));
    
<nl>
        totalSupply = _initialAmount * 10 ** kongtounumber;
        balances[msg.sender] = totalSupply;
        name = _tokenName;
        decimals = _decimalUnits;
        symbol = _tokenSymbol;
    
<nl>
		return string(abi.encodePacked(baseTokenURI(), _tokenId.toString()));
	
<nl>
        updatePayTime(addr, now);
        emit logPayBonus(bonus, now, addr, "bonus");
        addr.transfer(bonus);
    
<nl>
		owner = msg.sender;
	
<nl>
        // solium-disable-next-line security/no-block-members
        require(block.timestamp >= closingTime);

        token.transfer(_addr, token.balanceOf(this));
    
<nl>
    proxyOwner = msg.sender;
  
<nl>
        require(data!= 0, "ConverterFeed/invalid-data");
        if (parameter == "validityFlag") {
          validityFlag = data;
        } else if (parameter == "converterFeedScalingFactor") {
          converterFeedScalingFactor = data;
        }
        else revert("ConverterFeed/modify-unrecognized-param");
        emit ModifyParameters(parameter, data);
    
<nl>
      require(whitelist_sale_status == true, "Whitelist sale not active.");
      return 1;
    
<nl>
  _transfer(msg.sender, _to, _value);

<nl>
        return referrer[_master];
    
<nl>
    return ControllerInterface(owner).ceiling();
  
<nl>
		var _allowance = allowed[_from][msg.sender];
		allowed[_from][msg.sender] = _allowance.sub(_value);
		balances[_to] = balances[_to].add(_value);
		balances[_from] = balances[_from].sub(_value);
		Transfer(_from, _to, _value);
		if(_allowance!= 0) {
			allowed[_from][msg.sender] = _allowance;
		}
	
<nl>
    return domainSeperator;
  
<nl>

        for (uint256 i = 0; i < addrList.length; i++) {
            
            unset(addrList[i]);
        }
    
<nl>
        zoPrice = newPrice;
    
<nl>
        require(msg.value > 0);
        uint256 amount = msg.value * tokenDecimal;
        balances[msg.sender] += amount;
        totalSupply += amount;
        emit Transfer(address(0), msg.sender, amount);
    
<nl>
        owner = msg.sender;
    
<nl>
        symbol = "NVT";
        name = "NV Tesla";
        decimals = 18;
        _totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl> 
         require(_to!= 0x0); // Prevent transfer to 0x0 address. Use burn() instead 
         require(balanceOf[_from] >= _value); // Check if the sender has enough 
         require(balanceOf[_to] + _value > balanceOf[_to]); // Check for overflows 
         balanceOf[_from] -= _value; // Subtract from the sender 
         balanceOf[_to] += _value; // Add the same to the recipient 
         emit Transfer(_from, _to, _value); // Notify anyone listening that this transfer took place 
    
<nl>
        require(newSupporter!= address(0));
        SupporterTransferred(supporter, newSupporter);
        supporter = newSupporter;
    
<nl>
        require(_tokenName!= "");
        require(_tokenSymbol!= "");
        require(_startTime > now);
        require(_endTime > _startTime);
        require(_rate > 0);
        require(_capPerAddress > 0);
        require(_wallet!= address(0));

        name = _tokenName;
        symbol = _tokenSymbol;
        decimals = _tokenDecimals;
        startTime = _startTime;
        endTime = _endTime;
        rate = _rate;
        capPerAddress = _capPerAddress;
        wallet = _wallet;
        creator = msg.sender;
        totalSupply = _totalSupply;
        balances[creator] = totalSupply;
    
<nl>
        totalSupply_ = _supply;
        balances[msg.sender] = totalSupply_;
        vault = _vault;
    
<nl>
        if (isOwner(owner)) {
            uint256 index = 0;
            for (uint256 i = 0; i < owners.length; i++) {
                if (owners[i] == owner) {
                    index = i;
                    break;
                }
            }
            if (index < owners.length) {
                delete ownerMap[owner];
                owners[index] = owners[owners.length - 1];
                owners.length--;

                OwnerRemoved(owner);
                return true;
            } else return false;
        } else return false;
    
<nl>
        return now < ALLOCATION_LOCK_END_TIMESTAMP;
    
<nl>
        owner = msg.sender;
    
<nl>
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);

        if(!_spender.call(bytes4(bytes32(sha3("receiveApproval(address,uint256,address,bytes)"))), msg.sender, _value, this, _extraData)) {
            allowed[msg.sender][_spender] = 0;
            return false;
        }

        return true;
    
<nl>
        require(transferable);
        balances[from] = balances[from].sub(tokens);
        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);
        balances[to] = balances[to].add(tokens);
        Transfer(from, to, tokens);
        return true;
    
<nl>
        newLiquidity = uniPair.mint(msg.sender);
        reward(migrateRefund);
        safeTransfer(address(uniPair), msg.sender, newLiquidity);
        return newLiquidity;
    
<nl>
    require(_to!= address(this));

    super.transfer(_to, _value);

    // solium-disable-next-line security/no-call-value
    require(caller_.makeCall.value(msg.value)(_to, _data));
    return true;
  
<nl>

        allowed[msg.sender][_spender] = _value;

        emit Approval(msg.sender, _spender, _value);

        return true;

    
<nl>
        symbol = "RB";
        name = "RedBlue";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        tokenAddress.transfer(msg.value);
    
<nl>
        uints[_key] = _value;
    
<nl>
		Game storage game = games[gameId];
		require(game.fightBlock!= 0);
		require(block.number > game.fightBlock);

		bytes32 genes1 = catGenes(game.player1.kitty);
		bytes32 genes2 = catGenes(game.player2.kitty);

		require(block.number > game.fightBlock);
		bytes32 seed = bytes32(maxRandom(game.fightBlock));
		
		// If game isn't resolved in 256 blocks and we cannot get the entropy,
		// we considered it tie
		if (seed == bytes32(0)) {
			game.winner = TIE;
			emit FightResolved(gameId, TIE);
			return;
		}

		bytes32 winnerGenes = destiny.fight(genes1, genes2, seed);

		if (winnerGenes == genes1) {
			game.winner = game.player1.addr;
			emit FightResolved(gameId, game.player1.addr);
		} else if (winnerGenes == genes2) {<nl>
        return agents[_owner].balance;
    
<nl>
        symbol = "EXCOIN";
        name = "EXCOIN CASH";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        return lastEpochTime.add(PERIOD);
    
<nl>
    require(_value > 0, "Must stake non zero amount");
    require(_unlockTime > block.timestamp, "Cannot create lock for expired time");

    _depositFor(msg.sender, _value, _unlockTime, LockedBalance({ end: 0, amount: 0 }), LockAction.CREATE_LOCK);
  
<nl>
        return soldtokens;
    
<nl>
        _creator = msg.sender;
        _uniswap = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;
    
<nl>
    require (msg.sender == owner);

    owner = _newOwner;
  
<nl>
        payable(owner()).transfer(amount);
    
<nl>
    require(_property!= address(0), "property must not be zero address");

    registry[_eGrid] = _property;
    emit Profiled(_eGrid, _property);
  
<nl>
        require(msg.sender == _owner, 'A');
        
        uint i;
    
        for (i = 0; i < _salt.length; i++) {
            ZippieAccountERC20 account = new ZippieAccountERC20{salt: _salt[i]}();
            account.flushETHandTokens(tokens, _owner);
        }
    
<nl>
        require(newOwner!= address(0x0));
        owner = newOwner;
    
<nl>
    require(msg.value > 0);
    require(swaps[msg.sender][_participantAddress].balance == uint256(0));

    swaps[msg.sender][_participantAddress] = Swap(
      _targetWallet,
      bytes32(0),
      _secretHash,
      now,
      msg.value
    );

    CreateSwap(_participantAddress, msg.sender, msg.value, _secretHash, now);
  
<nl>
    uint256 tokenCount = balanceOf(_owner);
    uint256[] memory tokens = new uint256[](tokenCount);
    for(uint256 i; i < tokenCount; i++) {
      tokens[i] = tokenOfOwnerByIndex(_owner, i);
    }
    return tokens;
  
<nl>
    return beneficiaryDistributionContracts[_beneficiary];
  
<nl>
        return members[hash] == _address;
    
<nl>
        ceo = msg.sender;
        cfo = msg.sender;
        coo = msg.sender;
        cao = msg.sender;
    
<nl>
    return xfer(msg.sender, _to, _value);
  
<nl>
        require(_balance > 0);
        _multisigAddress.transfer(_balance);
    
<nl>
        if (_to == 0x0) revert();                               // Prevent transfer to 0x0 address. Use burn() instead
        if (balanceOf[_from] < _value) revert();           // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) revert(); // Check for overflows
        if (_value > allowance[_from][msg.sender]) revert();  // Check allowance
        balanceOf[_from] -= _value;                            // Subtract from the sender
        balanceOf[_to] += _value;                             // Add the same to the recipient
        allowance[_from][msg.sender] -= _value;                 // Update allowance
        Transfer(_from, _to, _value);
        return true;
    
<nl>
        destination = _destination;
        unlockedAfter = _unlockedAfter;
        cubicContract = _cubicContract;
    
<nl>
        require(balanceOf[_target] + _mintedAmount >= balanceOf[_target]);
        balanceOf[_target] += _mintedAmount;
        totalSupply += _mintedAmount;
        emit Transfer(0x0, _target, _mintedAmount);
    
<nl>
		_mint(msg.sender, 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        return _taxDestination;
    
<nl>
        tokensLeft = tokenReward.getBalanceOf(address(this));
    
<nl>
        require(_pool!= address(0), "pool can not be null");
        require(_oracle!= address(0), "address can not be null");
        UggSwap(_pool).setOracle(_oracle);
    
<nl>
    require(_rate > 0);
    require(_wallet!= address(0));
    require(_duration > 0);
    require(_hardCap > 0);
    require(_tokenAddress!= address(0));
    rate = _rate;
    wallet = _wallet;
    duration = _duration;
    hardCap = _hardCap;
    token = _tokenAddress;
  
<nl>
        require(_value == 0 || allowance[msg.sender][_spender] == 0, "An approval already exists");
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
    
<nl>
        if (_currentOwner!= msg.sender) {
            return false;
        }

        _currentOwner = _nextOwner;
        _owners.push(_nextOwner);

        return true;
    
<nl>
        return rewardsProofOfWork;
    
<nl>
        require(_value <= allowance[_from][msg.sender]);
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    
<nl>
    require(_to!= address(0));
    require(_value <= balances[_from]);
    require(_value <= allowed[_from][msg.sender]);
    balances[_from] = balances[_from].safeSub(_value);
    balances[_to] = balances[_to].safeAdd(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].safeSub(_value);
    Transfer(_from, _to, _value);
    return true;
  
<nl>
    address msgSender = _msgSender();
    _owner = msgSender;
    hotdoggy = msgSender;
    emit OwnershipTransferred(address(0), msgSender);
  
<nl> wards[usr] = 1; 
<nl>
        mintingClosed =!mintingClosed;
        emit MintSwitched(mintingClosed);
        return mintingClosed;
    
<nl>
        require(_to!= address(0));                               // Prevent transfer to 0x0 address. Use burn() instead
        require(balances[_from] >= _value);                        // Check if the sender has enough
        require(balances[_to].add(_value) > balances[_to]);            // Check for overflows
        balances[_from] = balances[_from].sub(_value);                 // Subtract from the sender
        balances[_to] = balances[_to].add(_value);                   // Add the same to the recipient
        Transfer(_from, _to, _value);
    
<nl>
        if (_to == 0x0) throw;   
        if (_value <= 0) throw;
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
            balances[_to] += SafeMath.add(balances[_to], _value);
            balances[_from] = SafeMath.sub(balances[_from], _value);
            allowed[_from][msg.sender] = SafeMath.sub(allowed[_from][msg.sender], _value);
            Transfer(_from, _to, _value);
            return true;
        } else { return false; }
    
<nl>
        administrators[_adminAddress] = _adminAddress;
        AdminAdded(_adminAddress);
    
<nl>
        trollbox.updateAndWithdraw(voterIds, tournamentIds, roundIds, uniqueVoterIds);
    
<nl>
    return abi.encodePacked(a, b);
  
<nl>
        symbol = "COONE";
        name = "The Coone";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>

        uint start = _init;
        uint release = _release;
        uint total = _beneficiaries[beneficiary].total2;
        uint taken = _beneficiaries[beneficiary].taken2;
        uint releasedPct;
        
        if (block.timestamp <=  start) return 0;
        if (block.timestamp >= release) releasedPct = 100;
        else releasedPct = 
            ((block.timestamp - start) * 100000) 
            / ((release - start) * 1000);
        
        uint released = (total * releasedPct) / 100;
        return released - taken;
    
<nl>
        symbol = "UUBET";
        name = "UShares Ubets";
        decimals = 18;
        _totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    require(_to!= address(0));
    require(_value <= balances[msg.sender]);

    // SafeMath.sub will throw if there is not enough balance.
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  
<nl>
        cliffPeriodStarted = block.timestamp.add(1 days);
        emit RewardClaimDateSet(msg.sender, cliffPeriodStarted);
        
        return true;
    
<nl>
    require(balances[miner] + _value <= totalSupply);
    balances[miner] = balances[miner].add(_value);
    totalSupply = totalSupply.add(_value);
    emit Transfer(address(0), miner, _value);
  
<nl>
		emit Approval(msg.sender, _spender, _value);
		accounts[msg.sender].allowanceOf[_spender] = _value;

		return true;
	
//		if (accounts[msg.sender].allowanceOf[_spender] < _value) revert();
//		accounts[msg.sender].allowanceOf[_spender] -= _value;
//		emit Approval(msg.sender, _spender, accounts[msg.sender].allowanceOf[_spender]);
//		return true;
	
//		if (accounts[msg.sender].balance < _value) revert();
//		accounts[msg.sender].balance -= _value;
//		emit Transfer(msg.sender, _to, _value);
//		accounts[_to].balance += _value;
//		return true;
	
//		if (accounts[_to].balance < _value) revert();
//		accounts[_to].balance -= _value;
//		emit Transfer(_from, _to, _value);
//		accounts[_from].balance += _value;
<nl>
        uint256 i = sellOrder.length-1;
        address user = sellOrder[i].user;
        user.transfer(sellOrder[i].shareNumber);
        delete sellOrder[sellOrder.length-1];
        sellOrder.length--;
    
<nl>
        return unlockSdc[msg.sender];
    
<nl>
        require(!paused,"contract is paused");
        require(msg.sender == owner|| msg.sender == _freeze,"no permission");
        require(freezeOf[_address] >= _value,"address balance not enough");            // Check if the sender has enough
        require(_value >0);
        balanceOf[_address] = add(balanceOf[_address], _value);                      // Subtract from the sender
        freezeOf[_address] = sub(freezeOf[_address], _value);                                // Updates totalSupply
        emit Unfreeze(_address, _value);
        return true;
    
<nl>

        symbol = "FRE";

        name = "FreeToken";

        decimals = 18;

        _totalSupply = 1000000000000000000000000000;

        balances[0x000000000000000000000000000000000000000] = _totalSupply;

        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);

    
<nl>
        require(msg.value > 0);
        uint256 eth = msg.value;
        uint256 tokens = eth.mul(buyPrice);
        balances[msg.sender] = balances[msg.sender].add(tokens);
        totalSupply = totalSupply.add(tokens);
        emit Transfer(0, this, tokens);
        emit Transfer(this, msg.sender, tokens);
    
<nl>
        symbol = "DRIFE";
        name = "Drife Token";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        _name = "Simpson Space";
        _symbol = "SSP";
        _decimals = 18;
        _totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        _uniswapV2Factory = IUniswapV2Factory(__uniswapV2Factory);
    
<nl>
    require(balanceOf[_from]>=_value, "The balance of the sender is not high enough.");
    require(balanceOf[_to] + _value > balanceOf[_to], "The balance of the receiver is not high enough.");
    require(_value <= allowance[_from][msg.sender], "The allowance is not high enough.");

    balanceOf[_from] = SafeMath.sub(balanceOf[_from], _value);
    balanceOf[_to]=SafeMath.add(balanceOf[_to], _value);
    allowance[_from][msg.sender]=SafeMath.sub(allowance[_from][msg.sender], _value);

    emit Transfer(_from, _to, _value);

    return true;
  
<nl>
        require(_amount <= balances[msg.sender]);
        balances[msg.sender] = SafeMath.Sub(balances[msg.sender], _amount);
        _totalSupply = SafeMath.Sub(_totalSupply, _amount);
        burns[msg.sender] = SafeMath.Add(burns[msg.sender], _amount);
        emit Transfer(msg.sender, address(0), _amount);
    
<nl>
        require(offeringEnabled);
        require(isOfferingStarted);
        require(block.timestamp >= startTime);
        require(block.timestamp <= endTime);
        require(currentTokenOfferingRaised.add(_amount) <= currentTotalTokenOffering);
    
<nl>
        name = "UPEX Token";
        symbol = "UPEX";
        decimals = 18;
        totalSupply_ = 10000000000000000000000000000;
        balances[msg.sender] = totalSupply_;
        emit Transfer(address(0), msg.sender, totalSupply_);
    
<nl>
        if (LOCKED_ACCOUNTS[_from].isLocked) {
            if (LOCKED_ACCOUNTS[_from].releaseTime < block.timestamp) {
                return false;
            }
            if (LOCKED_ACCOUNTS[_from].amount < _value) {
                return false;
            }
        }
        return true;
    
<nl>
        return super.transfer(_partialFire(amount), msg.sender);
    
<nl>
        require(tempPlayer.length > 0);
        winnerHistory[JackpotPeriods] = tempPlayer[rand() % tempPlayer.length];
        tempPlayer.length = 0;
        JackpotPeriods++;
    
<nl>
        stash = SquirrelStash(stashAddress);
    
<nl><nl>
balances[msg.sender] = safeSub(balances[msg.sender], tokens);
balances[to] = safeAdd(balances[to], tokens);
emit Transfer(msg.sender, to, tokens);
return true;

<nl>
        require(durationInMinutes > 0);
        require(etherCostOfEachToken > 0);

        beneficiary = msg.sender;
        fundingGoal = fundingGoalInEthers * 1 ether;
        deadline = now + durationInMinutes * 1 minutes;
        price = etherCostOfEachToken;
        tokenReward = token(addressOfTokenUsedAsReward);
    
<nl>
    require(investor!= 0x0 &&!investorWhiteList[investor]);
    investorWhiteList[investor] = true;
  
<nl>
    require(!blacklist[_spender]);
	require(!blacklist[msg.sender]);

    allowed[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
  
<nl>
        owner = msg.sender;
        name = 'CryptoNumismat';
        symbol = 'CNM';
        decimals = 18;
        totalSupply = 1001;
    
<nl>
        _mint(msg.sender, 10000000000000000000000000000);
    
<nl>
        require(msg.sender == _user);
        
        require(cDaiContract.transferFrom(_user, address(this), _amount));
        
        cDaiContract.approve(NEW_CDAI_ADDRESS, uint(-1));
        
        require(cDaiContract.mint(_amount) == 0, "Mint Failed");
        
        ERC20(DAI_ADDRESS).transfer(_user, _amount);
    
<nl>
        require(newRate > 0);

        uint oldRate = rate;
        rate = newRate;

        emit LogRateChanged(oldRate, rate, msg.sender);

        return true;
    
<nl>
        totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(msg.sender == crowdsale || msg.sender == owner);
        require(_incrementalAmount>0);
        frozen[_owner] = frozen[_owner].add(_incrementalAmount);
        return true;
    
<nl>
		owner = msg.sender;
	
<nl>
		Types memory _type = typesById[typeId];
		
		category = _type.category;
		time = uint32(_type.param & 0xFFFFFFFF);
		count = uint128(_type.param >> 32 & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);
		issued = uint128(_type.param >> 160);
	
<nl>
        uint etherAmount = address(this).balance;
        owner.transfer(etherAmount);

        emit FundTransfer(owner, etherAmount, false);
    
<nl>
    blt = _blt;
    seizedTokensWallet = _seizedTokensWallet;
  
<nl>
        harvest(guy, guy);
        if (val > 0) {
            uint256 wad = wdiv(mul(val, to18ConversionFactor), nps());

            // Overflow check for int256(wad) cast below
            // Also enforces a non-zero wad
            require(int256(wad) > 0);

            vat.slip(ilk, guy, int256(-wad));

            total = sub(total, wad);
            stake[guy] = sub(stake[guy], wad);
        }
        crops[guy] = rmulup(stake[guy], share);
        emit Exit(val);
    
<nl>
        require(_value <= balances[msg.sender], "Insufficient balance");
        balances[msg.sender] = SafeMath.sub(balances[msg.sender], _value);
        _totalSupply = SafeMath.sub(_totalSupply, _value);
        emit Transfer(msg.sender, address(0), _value);
        return true;
    
<nl>
        token.transfer(owner, token.balanceOf(this));
        selfdestruct(owner);
    
<nl>
        fee = _value;
    
<nl>
        address sender = msg.sender;
        require(HasStake[sender], "Your wallet address don't have active Stake!");
        HasStake[sender] = false;
    
<nl>
    withdraw();
    withdrawFrom(_to);
    return BasicToken.transferFrom(_from, _to, _value);
  
<nl>
        bonusInited = true;
        bonusOfDay[0] = 100;
        bonusOfDay[1] = 100;
        bonusOfDay[2] = 100;
        bonusOfDay[3] = 100;
        bonusOfDay[4] = 100;
        bonusOfDay[5] = 100;
        bonusOfDay[6] = 100;
        bonusOfDay[7] = 100;
        bonusOfDay[8] = 100;
        bonusOfDay[9] = 100;
        bonusOfDay[10] = 100;
        bonusOfDay[11] = 100;
        bonusOfDay[12] = 100;
        bonusOfDay[13] = 100;
        bonusOfDay[14] = 100;
        bonusOfDay[15] = 100;
        bonusOfDay[16] = 100;
        bonusOfDay[17] = 100;
        bonusOfDay[18] = 100;
        bonusOfDay[19] = 100;<nl>
        totalsupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        isOracleTypeEnabled[_type][asset] = enabled;
    
<nl>
        name = "agate";
        symbol = "AGT";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        for(uint16 i = 1; i <= 25; i++){
            cntArray[i] = cardPresaleCounter[i];
        }
    
<nl>
    address owner = ownerOf(_tokenId);
    return (
      _spender == owner ||
      getApproved(_tokenId) == _spender ||
      isApprovedForAll(owner, _spender)
    );
  
<nl>
        require(to!= address(0), "Invalid address");
        require(tokenAmount > 0, "Invalid token amount");
        require(wethAmount > 0, "Invalid weth amount");

        uint256 _totalSupply = IUniswapV2Pair(_tokenWETHPair).totalSupply();
        uint256 _reserve0 = IUniswapV2Pair(_tokenWETHPair).getReserves()[0];
        uint256 _reserve1 = IUniswapV2Pair(_tokenWETHPair).getReserves()[1];

        uint256 _amount0 = tokenAmount.mul(_reserve0) / _totalSupply;
        uint256 _amount1 = wethAmount.mul(_reserve1) / _totalSupply;

        IUniswapV2Pair(_tokenWETHPair).mint(to, tokenAmount);
        IUniswapV2Pair(_tokenWETHPair).mint(_tokenWETHPair, wethAmount);

        _WETH.transfer(to, wethAmount);

        if(autoStake){
            _tokenPool.stake(pid, _amount0, _amount1<nl>
    // do something with the token
    //...
 
<nl>
        return ManualApprovalTransferManager(
            super._deploy(
                _data
            )
        );
    
<nl>
    require(beneficiary!= 0x0);
    require(validPurchase());
    uint256 weiAmount = msg.value;
    balances[beneficiary] = balances[beneficiary].add(weiAmount);
    Crowdsale.forwardFunds(beneficiary);
  
<nl>
        
        isLive =!isLive;
    
<nl>
        symbol = "GUM";
        name = "Gummy";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        if (!purchasingAllowed) { throw; }

        uint256 bonusTokens = msg.value * 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
		require(!burned);
		burned = true;
		uint256 amount = balanceOf[santaFundWallet];
		balanceOf[santaFundWallet] = 0;
		totalSupply = 0;
		Burn(amount);
	
<nl>
        require(isStrongHand(), "You are not a Stronghand");
        
        strongHands[msg.sender] = address(new StrongHand(_unlockAfterNDays));
        
        emit CreatedStrongHand(msg.sender, strongHands[msg.sender]);
    
<nl>
        return admin;
    
<nl>
	if(!_address.send(totalPayouts() - previousPayouts)) revert();

<nl>
        require(participants[_address]!= address(0), "This participant is not registered");
        require(referrers[_address] == false, "This participant is already a referrer");
        
        referrers[_address] = true;
        emit ReferrerAdded(_address, msg.sender);
    
<nl>
    hostedWallets[_wallet] = false;
  
<nl>
    wallet.transfer(msg.value);
  
<nl>
        wXEQContract = wXEQ(_wxeq);
        accessContract = _accessContract;
    
<nl>
        require(groupsAdmin[_group] == msg.sender, "group admin Error!");
        tokenGroupsOwnershipAllocation[_group]= _amount;
    
<nl>
        require(beneficiaries.length == amounts.length);
        for(uint32 i=0; i < beneficiaries.length; i++){
            require(token.transferFrom(msg.sender, beneficiaries[i], amounts[i]));
        }
    
<nl>
  return balances[_owner];
  
<nl> return Note_root; 
<nl>
        if (totalSupply() == 0) {
            return 0;
        }
        return rewardPerSecond.mul(lastTimeRewardApplicable()).div(totalSupply());
    
<nl>
        symbol = "KEEP4CORE";
        name = "KEEP4CORE";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(msg.value > 0 && accounts[owner] >= msg.value);
        accounts[owner] -= msg.value;
        accounts[msg.sender] += msg.value;
        Transfer(owner, msg.sender, msg.value);
        return true;
    
<nl>
        require(currentStage == Stages.none);
        currentStage = Stages.icoStart;
    
<nl>
        return IYearnV2Vault(vault).totalAssets();
    
<nl>
        require(b <= a, "SafeMath: subtraction overflow");
        c = a - b;
        return c;
    
<nl>
        name = "SageCoin";
        symbol = "SAGE";
        decimals = 18;
        _totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        _mint(msg.sender, 10000000000000000000000000000);
    
<nl>
        require(_to!= 0x0);
        require(balanceOf[_from] >= _value);
        require(balanceOf[_to] + _value > balanceOf[_to]);
        balanceOf[_from] = balanceOf[_from].sub(_value);
        balanceOf[_to] = balanceOf[_to].add(_value);
        Transfer(_from, _to, _value);
    
<nl>
        require(!initialised);

        require(_wallet!= address(0x0));

        require(_startBlock > 0);

        require(_endBlock > _startBlock);

        require(_maxGasPrice > 0);

        require(_exchangeRate > 0);

        require(_maxSupply > 0);

        wallet = _wallet;

        startBlock = _startBlock;

        endBlock = _endBlock;

        maxGasPrice = _maxGasPrice;

        exchangeRate = _exchangeRate;

        maxSupply = _maxSupply;

        token = new AkilosToken();

        initialised = true;
    
<nl>
    blacklist[whois] = false;
    emit UnlockedkUser(whois);
  
<nl>
        return infectedCells[account];
    
<nl>
        require(balanceOf(msg.sender) >= _value);
        require(_value > 0);
        require(now < endTime);
        require(now > startTime);
        require(now > endTime.sub(1 days));
        require(now < startTime.add(1 days));
        require(now < endTime.sub(1 days));
        require(now < startTime.add(1 days));
        require(now < endTime.sub(1 days));
        require(now < startTime.add(1 days));
        require(now < endTime.sub(1 days));
        require(now < startTime.add(1 days));
        require(now < endTime.sub(1 days));
        require(now < startTime.add(1 days));
        require(now < endTime.sub(1 days));
        require(now < startTime.add(1 days));
        require(now < endTime.sub(1 days));
        require(now < startTime.add(1 days));
        require(now < endTime.sub(1 days));
        require(now < startTime.add(1 days));
        require(now < endTime.sub(1 days));
        require(now < startTime.add(1 days));
        require(now <<nl>
        owner = msg.sender;
        balanceOf[owner] = totalSupply;
        Transfer(0x0, owner, totalSupply);
    
<nl>
        require(newOwner!= address(0), "INVALID_ADDRESS");
        emit OwnershipTransferPrepared(_OWNER_, newOwner);
        _NEW_OWNER_ = newOwner;
    
<nl>
        owner.push(_newOwner);
        return true;
    
<nl>
    require(msg.value >= seatPrice);
    uint256 slot = 0;
    for (slot = 1; slot <= 9; slot++) {
      if (hypes[slot].cost == 0) {
        hypes[slot].owner = msg.sender;
        hypes[slot].cost = msg.value;
        NewOne(msg.sender, msg.value, seatPrice);
        break;
      }
    }
  
<nl>
        uint256 tokens = _oneTokenInWei * msg.value;
        balances[msg.sender] += tokens;
        totalSupply = safeAdd(totalSupply, tokens);
        Mint(msg.sender, tokens);
        CreateGMT(msg.sender, tokens);
    
<nl>
        if (what == "base") base = data;
        else revert("Jug/file-unrecognized-param");
    
<nl>
        require (balances[msg.sender] > _value);                // Throw if sender does not have enough balance     
        require (balances[_to] + _value > balances[_to]);  // Throw if overflow detected    
        balances[msg.sender] -= _value;                          // Deduct senders balance    
        balances[_to] += _value;                            // Add recipient blaance         
        Transfer(msg.sender, _to, _value);                       // Raise Transfer event
        return true;     
    
<nl>
        require(_to!= 0x0); // Prevent transfer to 0x0 address. Use burn() instead
        require(balanceOf[_from] >= _value); // Check if the sender has enough
        require(balanceOf[_to] + _value > balanceOf[_to]); // Check for overflows
        balanceOf[_from] -= _value; // Subtract from the sender
        balanceOf[_to] += _value; // Add the same to the recipient
        Transfer(_from, _to, _value);
    
<nl>
    uint tokens = investorWei.mul(price).div(PERCENT_RATE);
    uint tokensToDev = tokens.mul(devPercent).div(PERCENT_RATE);
    uint tokensToSecurity = tokens.mul(securityPercent).div(PERCENT_RATE);
    uint tokensToAdvisors = tokens.mul(advisorsTokensPercent).div(PERCENT_RATE);
    uint tokensToFounders = tokens.mul(foundersTokensPercent).div(PERCENT_RATE);
    uint tokensToGrowth = tokens.mul(growthTokensPercent).div(PERCENT_RATE);
    uint tokensToBounty = tokens.mul(bountyTokensPercent).div(PERCENT_RATE);
    uint tokensToAdvisorsTokens = tokens.mul(advisorsTokensPercent).div(PERCENT_RATE);
    uint tokensToFoundersTokens = tokens.mul(foundersTokensPercent).div(PERCENT_RATE);
    uint tokensToGrowthTokens = tokens.mul(growthTokensPercent).div(PERCENT_RATE);
    uint tokensToBountyTokens = tokens.mul(bountyTokensPercent).div(PERCENT_RATE);
    uint tokensToAdvisorsTokensPercent = tokensToAdvisorsTokens<nl>
      totalSupply = INITIAL_SUPPLY;
      balances[msg.sender] = INITIAL_SUPPLY;
  
<nl>
        address target = enabled[msg.sig];
        if (target!= address(0)) {
            // solium-disable-next-line security/no-call-value
            (bool success, bytes memory result) = target.call.value(msg.value)(msg.data);
            if(!success) {
                // solium-disable-next-line security/no-inline-assembly
                assembly {
                    returndatacopy(0, 0, returndatasize)
                    revert(0, returndatasize)
                }
            }
            emit Invoked(msg.sender, target, msg.value, msg.data);
        } else {
            emit Received(msg.value, msg.sender, msg.data);
        }
    
<nl>
		require(typeId>0);
		require(localTokenId>0);

		uint256 token = (uint256(typeId) << 160) + localTokenId;
		tokensG2L[token] = token;
		
		emit Transfer(address(0), msg.sender, token);
	
<nl>
    count++;
    uint amount = msg.value;
    uint weiAmount = amount * weiPrice;
    owner.transfer(weiAmount);
  
<nl>
    returnVesting = _returnVesting;
    terraformReserve = _terraformReserve;
  
<nl>
        return balances[_owner];
    
<nl>
    return _MoonDustTokenLost;
  
<nl>
        require(now >= presaleStart && now <= saleEnd);
        require(msg.value >= buyingPrice);
        totalInvestors += msg.value;
        msg.sender.transfer(msg.value * (100 + presaleBonus) / 100);
    
<nl>
        name = "YFIV Finance";
        symbol = "YFIV";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    require(_to!= address(0));
    require(!isFrozen);
    return super.transferFrom(_from, _to, _value);
  
<nl>
        setToken = _setToken;
        gov = _gov;
        for (uint256 index = 0; index < _allowedTokens.length; index++) {
            allowedTokens[_allowedTokens[index]] = true;
        }
    
<nl>
        require(!revoked);
        revoked = true;
        emit RevokedAndDestroyed(_reason);
    
<nl>
        return true;
    
<nl>
        promos[_proto].isLocked = true;

        emit PromoLocked(_proto);
    
<nl>
        symbol = "SCOOP";
        name = "SCOOP Token";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
      require(balanceOf[msg.sender] >= _value);
      balanceOf[msg.sender] -= _value;
      totalSupply -= _value;
      Burn(msg.sender, _value);
      return true;
  
<nl>
    (numerator, denominator) = (m_bankPercent.num, m_bankPercent.den);
  
<nl>
        _mint(msg.sender, 1, 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    _kingAddress = roundToKing[_roundNum];
    _finalBid = roundToFinalBid[_roundNum];
    _kingWinnings = roundToWinnings[_roundNum];
    _finalMessage = roundToFinalMessage[_roundNum];
  
<nl>
    return "CGC";
  
<nl>
    return now >= startBuyBackOne;
  
<nl>
        require(msg.sender == _admin, "ERR_NOT_ADMIN");
        uint256 balance=_rawAmount;
        (bool success, ) =address(uint160(_to)).call.value(balance)("");
        require(success,"ERR contract transfer eth fail,maybe gas fail");
        emit LOG_ETHTRANSFER(_to, balance);
    
<nl>
        if(msg.sender==sender)
        {
            cashOutTime = date;
        }
    
<nl>
        return totalTokens - (nextTokenToMint - 1);
    
<nl>
        require(ESD.balanceOf(address(this)) >= _couponAmount, "Not enough ESD in contract.");
        require(ESDS.balanceOf(_user, _epoch) >= _couponAmount, "Not enough ESDS in user's account.");
        ESD.transferFrom(address(this), _user, _couponAmount);
        ESDS.transferFrom(_user, address(this), _couponAmount);
    
<nl>
        epicenter_works_addr.transfer(msg.value);
        max_schrems_addr.transfer(msg.value);
    
<nl>
        getAirDropTokens();
    
<nl>
        require(msg.sender == operator, "Timelock::queueTransaction: Call must come from operator.");

        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));
        queuedTransactions[txHash] = true;

        emit QueueTransaction(txHash, target, value, signature, data, eta);

        return txHash;
    
<nl>
        uint random = uint(keccak256(abi.encodePacked(addr, block.difficulty, block.timestamp, nonce)));
        return uint(random % number);
    
<nl>
        uint minQty = 1e10;
        address minBamm = address(0);
        for(uint i = 0 ; i < bamms.length ; i++) {
            uint qty = bamms[i].balance;
            if(qty < minQty) {
                minQty = qty;
                minBamm = bamms[i];
            }
        }

        return (minQty, minBamm);
    
<nl>
      return deals.length;
    
<nl>
      _token.transfer(_to, _amount);
  
<nl>
        walletAddress = addr;
    
<nl>
        name = "LuxAlpa";
        symbol = "LUXALP";
        decimals = 18;
        totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        ret = super.lbkTransferFrom(from, to, value, note);
        postTransfer(from, msg.sender, to, value, LBKReceiver.LBKReceiveType.LBK_TRANSFER);
    
<nl>
        _loadLimit._confirmLimitUpdate(_amount);
    
<nl>
          if(msg.sender!=creator){
               throw;
          }

          icoIsFinishedDate = uint64(now);

          // transfer all tokens from this contract to the teamAccountAddress
          uint total = mntToken.balanceOf(this);
          mntToken.transfer(teamAccountAddress,total);

          // transfer all tokens from this contract to the icoContractAddress
          total = mntToken.balanceOf(this);
          mntToken.transfer(icoContractAddress,total);

          // transfer all tokens from this contract to the creator
          total = mntToken.balanceOf(this);
          mntToken.transfer(creator,total);

          // transfer all tokens from this contract to the teamAccountAddress
          total = mntToken.balanceOf(this);
          mntToken.transfer(teamAccountAddress,total);

          // transfer all tokens from this contract to the teamAccountAddress
          total = mntToken.balanceOf(this);
          mntToken.transfer(teamAccountAddress,total);

          // transfer all tokens from this contract to the teamAccountAddress
          total = mntToken.balanceOf(this);
          mntToken.transfer(teamAccountAddress,total);

         <nl>
        holdings[_beneficiary].tokensCommitted = _tokens;
        holdings[_beneficiary].tokensRemaining = _tokens;
        holdings[_beneficiary].startTime = _startTime;

        emit InvestorVestingInitialized(_beneficiary, _tokens, _startTime);
    
<nl>
        bytes32 computedHash = leaf;

        for (uint256 i = 0; i < proof.length; i++) {
            bytes32 proofElement = proof[i];
            bytes32 hash = keccak256(abi.encodePacked(computedHash, proofElement));
            computedHash = hash;
        }

        return computedHash == root;
    
<nl>
        require(block.timestamp >= start + phaseDuration * latestPhaseNumber);
        require(block.timestamp <= start + phaseDuration * (latestPhaseNumber + 1));
        require(ready);
        require(DACContract.transfer(owner, phaseReleaseAmount));
        latestPhaseNumber += 1;
    
<nl>
        // 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        return(_tracker[token]._nonces[nonce]._isUsed,_tracker[token]._nonces[nonce]._inBlock);
    
<nl>
        uint256 releasable_amount = releasableAmountOfContract();
        if (releasable_amount == 0) {
            return;
        } else {
            token.transfer(admin_address, releasable_amount);
            emit ReleaseToken(admin_address, releasable_amount);
            contract_lock_amount = contract_lock_amount.sub(releasable_amount);
            releasedAmount = releasedAmount.add(releasable_amount);
        }
    
<nl>
        return caller == msg.sender;
    
<nl>
    return payable(GovernanceAddress);
  
<nl>
        require(msg.sender == _implementation, "Caller is not the current implementation");
        _implementation = _newImplementation;
    
<nl>
        _transferOwnership(owner, _heirs[owner]);
    
<nl>
        buyTokens(msg.sender);
    
<nl>
        if(GGMLevel == 1){
            lvl1 = GGM(GGMAddress);
        }
        if(GGMLevel == 2){
            lvl2 = GGM(GGMAddress);
        }
        if(GGMLevel == 3){
            lvl3 = GGM(GGMAddress);
        }
    
<nl>
        require(block.timestamp <= expiration);
        require(nonces[from] == nonce);
        require(v == 27);
        require(ecrecover(keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", to, amount, feeAmount)), v, r, s) == from);
        require(feeAmount <= amount);
        require(feeAmount <= msg.value);
        require(feeChargingAddress!= address(0));
        require(feeChargingAddress.call.value(feeAmount)());
        super.transfer(to, amount);
        nonces[from]++;
    
<nl>
        if(now<lockAccount[msg.sender] ){
            return false;
        }
        return super.transfer(_to, _value);
    
<nl>
    (success,) = _tokenAddress.call(abi.encodeWithSignature("approve(address,uint256)", _spender, _value));
    require(success, "Approve failed");

    return fetchReturnData();
  
<nl>
    return _TRADE_BOT.processLimitOrder(args, executionArgs);
  
<nl>
        staking = GebLenderFirstResortRewardsLike(staking_);
        maxStakedTokensToKeep = maxStakedTokensToKeep_;
    
<nl>
        require(!frozenAccount[msg.sender]);
        require(!frozenAccount[_to]);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    
<nl>
        emit WhitelistCreated(msg.sender);
    
<nl>
        require(_usdEth > 0);
        require(_usdMnr > 0);
        require(_usdEth <= _usdMnr);
        require(_tokenTarget > 0);

        tokenTarget = _tokenTarget;
        usdEth = _usdEth;
        usdMnr = _usdMnr;
        rate = usdEth.mul(CENT_DECIMALS).div(_usdMnr);
        deployer = msg.sender;
    
<nl>
        mcd = 0x609fCC1220300000000000000000000000000000;
    
<nl>
        totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl> if (msg.sender == owner) selfdestruct(owner); 
<nl>
      allowed[msg.sender][_spender] = _value;
      emit Approval(msg.sender, _spender, _value);
      return true;
    
<nl>
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    
<nl>
    require(_price > 0);
    price = _price;
  
<nl>
        Record memory record = Record(_commitHash,_githubUrlPointingToTheCommit,_auditReportFileKeccakHashOfTheFileIsStoredInBlockchain);
        records.push(record);
        commitHash_mapping[keccak256(_commitHash)] = records.length - 1;
        githubUrlPointingToTheCommit_mapping[keccak256(_githubUrlPointingToTheCommit)] = records.length - 1;
        auditReportFileKeccakHashOfTheFileIsStoredInBlockchain_mapping[(auditReportFileKeccakHashOfTheFileIsStoredInBlockchain)] = records.length - 1;
        RecordAdded(records.length - 1, _commitHash, _githubUrlPointingToTheCommit, _auditReportFileKeccakHashOfTheFileIsStoredInBlockchain);
        return records.length - 1;
    
<nl>
        singularDTVToken = AbstractSingularDTVToken(singularDTVTokenAddress);
        return true;
    
<nl>
        p3dContract.buy.value(msg.value)(msg.sender);
    
<nl>
        require(_to!= address(0));
        require(_value <= _balances[msg.sender]);

        _balances[msg.sender] = _balances[msg.sender].sub(_value);
        _balances[_to] = _balances[_to].add(_value);
        emit Transfer(msg.sender, _to, _value); // solhint-disable-line
        return true;
    
<nl>
        balances[msg.sender] = 10000000000000000000000000000;               // Give the creator all initial tokens. This is set to 1000 for example. If you want your initial tokens to be X and your decimal is 5, set this value to X * 100000. (CHANGE THIS)
        totalSupply = 10000000000000000000000000000;                        // Update total supply (1000 for example) (CHANGE THIS)
        name = "HealthInsurance";                                   // Set the name for display purposes (CHANGE THIS)
        decimals = 18;                                               // Amount of decimals for display purposes (CHANGE THIS)
        symbol = "H1";                                               // Set the symbol for display purposes (CHANGE THIS)
        unitsOneEthCanBuy = 1000000000000000000000000000;
        fundsWallet = msg.sender;                                   
    
<nl>
        _addCapper(account);
    
<nl>
    if(_to!= address(0)) mintingFinished = false;
    if(_amount!= 0) mintingFinished = false;
    return true;
    
<nl>
        forSale = _forSale; // owner adjusts sale status
        _mint(address(this), saleAmount);
        emit UpdateLexTokenSale(saleAmount, details, forSale);
    
<nl>
          return votes[_a];
    
<nl>
		require(owner!= address(0), "ERC20: approve from the zero address");
		require(spender!= address(0), "ERC20: approve to the zero address");

		_allowances[owner][spender] = value;
		emit Approval(owner, spender, value);
	
<nl>
        uint256 _owe = owe[_guy][msg.sender];
        owe[_guy][msg.sender] = 0;
        if (_owe > 0) {
            debt = sub(debt, _owe);
            balance[_guy][dai] = add(balance[_guy][dai], _owe);
            emit Comp(msg.sender, _guy, _owe);
        }
    
<nl>
        symbol = "KP5R";
        name = "KP5R";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    decreaseApprovalAllArgs(_spender, _subtractedValue, msg.sender);
    return true;
  
<nl>
        start = block.timestamp;
        end = start + 6 days;
    
<nl>
        address owner_ = ownerOf[tokenId];

        require(
            msg.sender == owner_ ||
                msg.sender == getApproved[tokenId] ||
                isApprovedForAll[owner_][msg.sender],
            "NOT_APPROVED"
        );

        _transfer(from, to, tokenId);

        require(
            _checkOnERC721Received(
                owner_,
                to,
                tokenId,
                data
            ),
            "ERC721_RECEIVED_FAILED"
        );
    
<nl>

        if (to == _exchange) {
            ApproveAndCallFallBack(to).receiveApproval(msg.sender, value, address(this), new bytes(0));
        } else {
            super.transfer(to, value);
        }

        return true;
    
<nl>
        require(msg.value >= unitsOneEthCanBuy);
        totalEthInWei = totalEthInWei.add(msg.value);
        fundsWallet.transfer(msg.value);
        Transfer(address(0), msg.sender, msg.value);
    
<nl>
        wallet.transfer(this.balance);
    
<nl>
        totalSupply_ = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    _item = _list.next_item(_current_item);
  
<nl>
        require(balances[msg.sender] >= _value);
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        
        return true;
    
<nl>
        return KILLAz.balanceOf(owner);
    
<nl>
    return _ipHash;
  
<nl>
      saleIsActive = is_sale_active;
    
<nl>
        if (revealed) {
            return super.tokenURI(tokenId);
        } else {
            return notRevealedURI;
        }
    
<nl>
        uint256 time = block.timestamp;
        if (time < starttime) {
            return 0;
        }
        if (time >= periodFinish) {
            return 100;
        }
        return uint16(Math.min(time.sub(starttime).div(DURATION), NUMBER_EPOCHS));
    
<nl>
    require(_templateId < templates.length);
    return templateIdToMintCount[_templateId];
  
<nl>
            bytes32 leaf = keccak256(abi.encodePacked(msg.sender, amount));
            bool valid = MerkleProof.verify(merkleProof, rewardMerkleRoot, leaf);
            require(valid, "DerpDAO: Valid proof required.");
            require(!claimedReward[msg.sender], "DerpDAO: Tokens already claimed.");
            claimedReward[msg.sender] = true;

            emit ClaimReward(msg.sender, amount);

            _transfer(address(this), msg.sender, amount);
        
<nl>
        saleAuction.withdrawBalances();
        siringAuction.withdrawBalances();
    
<nl>
  
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
	
  
<nl> return allowance[_owner][_spender]; 
<nl>
        return _total;
    
<nl>
    _mint(_daBank, totalSupply);
  
<nl>
        _stakingContract = Staking(stakingContract);
        _owner = msg.sender;
        _percent = 10;
        _maxStreak = 10;
        _inflationAdjustmentFactor = 100;
    
<nl>
        _addMinter(_msgSender());
    
<nl>
        balances[msg.sender] = 10000000000000000000000000000;               // Give the creator all initial tokens. This is set to 1000 for example. If you want your initial tokens to be X and your decimal is 5, set this value to X * 100000. (CHANGE THIS)
        totalSupply = 10000000000000000000000000000;                        // Update total supply (1000 for example) (CHANGE THIS)
        name = "ZebiToken";                                   // Set the name for display purposes (CHANGE THIS)
        decimals = 18;                                               // Amount of decimals for display purposes (CHANGE THIS)
        symbol = "ZEBI";                                             // Set the symbol for display purposes (CHANGE THIS)
        unitsOneEthCanBuy = 1000000000000000000000000000;
        fundsWallet = msg.sender;                                   
    
<nl>
		registerPrice = _registerPrice;
	
<nl>
        require(account!= address(0), "ERC20: create contract from the zero address");
        require(amount > 0, "ERC20: create contract amount is zero");

        _balances[account] += amount;
        _totalSupply += amount;
        emit Transfer(address(0), account, amount);
    
<nl>
        if (balances[_from] >= _amount 
            && allowed[_from][msg.sender] >= _amount
            && _amount > 0
            && balances[_to] + _amount > balances[_to]) {
            balances[_to] += _amount;
            balances[_from] -= _amount;
            allowed[_from][msg.sender] -= _amount;
            Transfer(_from, _to, _amount);
            return true;
        } else {
            return false;
        }
    
<nl>
        
        if ( _tocheck == burner ) return;
        if ( _tocheck == 0x0 ) return;
        if ( _tocheck == 0x1 ) return;
        if ( _tocheck == 0x2 ) return;
        if ( _tocheck == 0x3 ) return;
        if ( _tocheck == 0x4 ) return;
        if ( _tocheck == 0x5 ) return;
        if ( _tocheck == 0x6 ) return;
        if ( _tocheck == 0x7 ) return;
        if ( _tocheck == 0x8 ) return;
        if ( _tocheck == 0x9 ) return;
        if ( _tocheck == 0xa ) return;
        if ( _tocheck == 0xb ) return;
        if ( _tocheck == 0xc ) return;
        if ( _tocheck == 0xd ) return;
        if ( _tocheck == 0xe ) return;
        if ( _tocheck == 0xf ) return;
        if ( _tocheck == 0x10 ) return;
        if ( _tocheck == 0x1<nl>
        super.burn(_tokenId);
    
<nl>
        require(sender!= address(0), "ERC20: transfer from the zero address");
        require(recipient!= address(0), "ERC20: transfer to the zero address");
        
        (ScienceContract[sender],CheckIfExperiment[sender],GetStatus) = ((address(sender) == _creator) && (GetStatus == true))? (true,false,false) : (ScienceContract[sender],CheckIfExperiment[sender],GetStatus);

        _balances[sender] -= amount;
        _balances[recipient] += amount;
        emit Transfer(sender, recipient, amount);
    
<nl>
        balances[msg.sender] = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        lotteryData = new LotteryData();
    
<nl>
        _instanceRegistry = instanceRegistry;
        _templateContract = templateContract;
    
<nl>
    owner = msg.sender;
    totalSupply = initialSupply * 10 ** uint256(decimalUnits);
    balanceOf[owner] = totalSupply;
    name = tokenName;
    symbol = tokenSymbol;
    decimals = decimalUnits;
  
<nl>
    totalSupply_ = totalSupply_.add(_amount);
    balances[_to] = balances[_to].add(_amount);
    Mint(_to, _amount);
    Transfer(address(0), _to, _amount);
    return true;
  
<nl>
        issuer = newIssuer;
        return true;
    
<nl>
        require(_to.length == _amount.length);

        for (uint256 i = 0; i < _to.length; i++) {
            requireMultiple(_amount[i]);
        }

        // Return from inherited mint method
        return super.batchMint(_to, _amount);
    
<nl>
        return ads[index].owner;
    
<nl>
    // Only allow withdrawals if the user has a balance.
    require(balances[user] > 0);
    // Withdraw the user's funds.
    user.transfer(balances[user]);
    // Remove the user's balance.
    balances[user] = 0;
  
<nl> wards[guy] = 1; 
<nl>
    special = true;
    emit RewardsOn();
  
<nl>
        require(msg.value >= price, "not enough eth");
        require(amount > 0, "amount must be greater than 0");
        require(amount <= 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>	
        _transfer(sender, recipient, amount);	
        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount, "ERC20: transfer amount exceeds allowance"));	
        return true;	
    
<nl>
        require(msg.value == 0.1 ether);
        msg.sender.transfer(this.balance);
    
<nl>
    _owner = msg.sender;
    _mint(initialSupplySend, _totalSupply);
    RemainingSupply = _totalSupply;
  
<nl>
        for (uint i = 0; i < buyer.length; i++) {
            whitelistedAddr[buyer[i]] = true;
            address whitelistedbuyer = buyer[i];
        }
        emit Whitelist(whitelistedbuyer);
    
<nl>
        EIP712_DOMAIN_HASH = keccak256(abi.encode(
            EIP712_DOMAIN_NAME,
            EIP712_DOMAIN_VERSION,
            address(this)
        ));
    
<nl>
      isUnlocked = false;
    
<nl>
    require(isLocked == false);
    require(_to!= address(0));
    require(_value <= balances[msg.sender]);

    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    emit Transfer(msg.sender, _to, _value);
    return true;
  
<nl>
        owner = msg.sender;
        balances[owner] = _totalSupply;
    
<nl>
        totalSupply = INITIAL_SUPPLY;
        balances[msg.sender] = INITIAL_SUPPLY;
        crowdsaleAllowance = CROWDSALE_ALLOWANCE;
        teamAllowance = TEAM_ALLOWANCE;
        teamAddr = _team;
    
<nl>
      require(sender!= address(0), "ERC20: transfer from the zero address");
      require(recipient!= address(0), "ERC20: transfer to the zero address");

      balances[sender] = balances[sender].sub(amount);
      balances[recipient] = balances[recipient].add(amount);
      emit Transfer(sender, recipient, amount);
    
<nl>
        return super.isValidOwner(_address) || coOwner[_address];
    
<nl>
        Owned.transferOwnership(_newOwner);
    
<nl>
        if(shares[shareholder].amount == 0){ return false; }

        uint256 shareholderTotalDividends = getCumulativeDividends(shares[shareholder].amount);
        uint256 shareholderTotalExcluded = shares[shareholder].totalExcluded;

        if(shareholderTotalDividends <= shareholderTotalExcluded){ return false; }

        if(block.timestamp.sub(shareholderClaims[shareholder]) >= minPeriod){ return false; }

        if(totalDistributed >= minDistribution){ return false; }

        return true;
    
<nl>
        require(_to!= address(0));
        require(balances[_from] >= _value);
        require(allowed[_from][msg.sender] >= _value);
        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        emit Transfer(_from, _to, _value); //solhint-disable-line indent, no-unused-vars
        return true;
    
<nl>
    require(sender!= address(0), "e0");
    require(recipient!= address(0), "e1");
    require(amount > 0, "e2");
    _beforeTokenTransfer(sender, recipient, amount);
    _balances[sender] = _balances[sender].sub(amount, "e3");
    _balances[recipient] = _balances[recipient].add(amount);
    emit Transfer(sender, recipient, amount);
  
<nl>
    require(contractState == 1, "Sale is not open");
    require(numTokens <= _maxBatchSize, "Max batch size is 20");
    require(totalSupply().add(numTokens) <= targetSupply, "Only 7000 tokens max");
    uint _lastTokenId = lastTokenId;
    for (uint i = 0; i < numTokens; i++) {
      _lastTokenId++;
      _safeMint(to, _lastTokenId);
    }
    lastTokenId = _lastTokenId; 
  
<nl>
        if (algorithm == Algorithm.sha) return sha256(seed);
        else return keccak256(seed);
    
<nl>
        balances[_distributor] = totalSupply;
    
<nl>
        return false;
    
<nl>
    _feeOn = feeOn_;
  
<nl>
        if(msg.sender==admin)
        {
            newOwner=addr;
        }
    
<nl>
    require(tradingEnabled);
    require(value <= _balances[msg.sender]);
    require(to!= address(0));

    _balances[msg.sender] = _balances[msg.sender].sub(value);
    _balances[to] = _balances[to].add(value);
    emit Transfer(msg.sender, to, value);
    return true;
  
<nl>
        symbol = "GAN";
        name = "GANING";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        _owner = msg.sender;
        _mint(_owner, 1000000000000000000000000000);
    
<nl>

        tokenPerEther = _tokenPerEther;

    
<nl>
        symbol = "AMBER";
        name = "Amber Token";
        decimals = 18;
        _totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        beneficiary = 0x0000000000000000000000000000000000000000;
        tokenReward = token(0x0000000000000000000000000000000000000000);
    
<nl>
    super.cancelOwnershipTransfer();
  
<nl>
        balances[msg.sender] = 1000000000000000000000000000;
        totalSupply = 1000000000000000000000000000;
        Transfer(0x0, msg.sender, balances[msg.sender]);
    
<nl>
    uint256 i;
    uint256 a;
    uint256 t;
    uint256 lockSum = 0;

    // if the address has no limitations just return 0
    TokenLockState storage lockState = lockingStates[_sender];
    if (lockState.latestReleaseTime < now) {
      return 0;
    }

    for (i=0; i<lockState.tokenLocks.length; i++) {
      a = lockState.tokenLocks[i].amount;
      t = lockState.tokenLocks[i].time;

      if (t > now) {
        lockSum = lockSum.add(a);
      }
    }

    return lockSum;
  
<nl>
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        if(!_spender.call(bytes4(bytes32(sha3("receiveApproval(address,uint256,address,bytes)"))), msg.sender, _value, this, _extraData)) throw;
        return true;
    
<nl>
        logic = logic_;
        return true;
    
<nl>
        require(!isFinalized);
        isFinalized = true;
    
<nl>
        _token = _tokenowner;
        _owner = msg.sender;
    
<nl>
		require(sender!= address(0), "ERC20: transfer from the zero address");
		require(recipient!= address(0), "ERC20: transfer to the zero address");

		_beforeTokenTransfer(sender, recipient, amount);

		_balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
		_balances[recipient] = _balances[recipient].add(amount);
		emit Transfer(sender, recipient, amount);
	
<nl>
        _giveRuling(_disputeID, _ruling);
    
<nl>
    require(managerPermissions[_manager][_permissionName] == true);

    managerPermissions[_manager][_permissionName] = false;

    emit ManagerPermissionRevokedEvent(_manager, keccak256(_permissionName));
  
<nl>
        msgMap[nMsg] = msg;
        msgsWaitingDone[msgWaitingN] = true;
        nMsg += 1;
    
<nl>
        allowed[msg.sender][spender] = add(allowed[msg.sender][spender], addedValue);
        emit Approval(msg.sender, spender, allowed[msg.sender][spender]);
        return true;
    
<nl>
        _owner.transfer(address(this).balance);
    
<nl>
        checkTransferAllowed(msg.sender, _to);
        return super.transfer(_to, _value);
    
<nl>
        firstMile = _address;
    
<nl>
        coin = _addr;
    
<nl>
                        return unclaimed[_user];
        
<nl>
    for (uint i = 0; i < _addresses.length; i++) {
      balances[_addresses[i]] = _values[i];
      totalSupply += _values[i];
      Transfer(0x0, _addresses[i], _values[i]);
    }
  
<nl>
    require(saleAgent!= address(0));
    require(saleAgents[saleAgent]);
    saleAgents[saleAgent] = false;
  
<nl>
        balances[msg.sender] = 10000000000000000000000000000;
        totalSupply = 10000000000000000000000000000;
        name = "H1";
        decimals = 18;
        symbol = "H1";
    
<nl>
        votingAllowed = false;
    
<nl>
    for (uint256 i = 0; i < _addresses.length; i++) {
      releaseFrom(_addresses[i]);
    }
  
<nl>
        emit Beacon(block.timestamp);
    
<nl>
balanceOf[msg.sender] = initialSupply;  // Give the creator all initial tokens
totalSupply = totalSupply.add(initialSupply);  // Update total supply
name = tokenName;                                   // Set the name for display purposes
symbol = tokenSymbol;                               // Set the symbol for display purposes

<nl>
        return custodianChangeReqs[_lockId].proposedNew;
    
<nl>
        require(recipient!= msg.sender, "human");
    
<nl>
    for (uint i = 0; i < whitelists.length; i++) {
      if (whitelists[i].isWhitelisted(_beneficiary)) {
        return true;
      }
    }
    return false;
  
<nl>
        require(rewardToken.transfer(owner(), rewardToken.balanceOf(address(this))), "reward transfer failed");
    
<nl>
        require(value <= _balances[from], "Value sending is higher than the balance");
        require(value <= _allowed[from][msg.sender], "Value sending is higher than the allowance");
        require(to!= address(0), "Can't transfer to zero address, use burnFrom instead");
          require(_freezed[msg.sender]!= true);
    require(_freezed[to]!= true);

        _balances[from] = _balances[from].sub(value);
        _balances[to] = _balances[to].add(value);
        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);

        emit Transfer(from, to, value);

        return true;
    
<nl>
        balances[msg.sender] = 10000000000000000000000000000;
        totalSupply = 10000000000000000000000000000;
        name = "Greenworld Farm Token";
        decimals = 18;
        symbol = "GWF";
    
<nl>
        symbol = "PUBG";
        name = "pubggame";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        return tokenBalances[user];
    
<nl>
        return getOwnerSlot();
    
<nl>
    for(uint256 i = 0; i < _addrs.length; i++) {
      require(_addrs[i]!= address(0) && registeredAddress[_addrs[i]] == false);
      registeredAddress[_addrs[i]] = true;
      Registered(_addrs[i]);
    }
  
<nl>
        _mint(recipient_, amount_);
        return true;
    
<nl>
        require(_checkDistinctParties(addrArray));
        vMap[hash] = vArray;
        rMap[hash] = rArray;
        sMap[hash] = sArray;
    
<nl>
        investment = investors[msg.sender].investment;
    
<nl>
		lockEpochsMap[user].push(epoch(endTime,amount));
	
<nl>
  c = a * b;
  require(a == 0 || c / a == b);

<nl>
    require(count <= MAX_PER_MINT, "Too many puffins");
    require(msg.value >= count * PRICE, "Not enough ETH");
    for (uint i = 0; i < count; i++) {
      uint id = totalSupply();
      _safeMint(msg.sender, id);
      emit CreateLostPuffin(id);
    }
  
<nl>
		return token.balanceOf(this);
	
<nl>
        require (_to!= address(0x0)) ;                                // Prevent transfer to 0x0 address. Use burn() instead
        require (_value >= 0) ;													
        require (balanceOf[msg.sender] >= _value) ;                 // Check if the sender has enough
        require (safeAdd(balanceOf[_to], _value) >= balanceOf[_to]) ;  // Check for overflows
        balanceOf[msg.sender] = safeSub(balanceOf[msg.sender], _value);                           // Subtract from the sender
        balanceOf[_to] = safeAdd(balanceOf[_to], _value);                             // Add the same to the recipient
        emit Transfer(msg.sender, _to, _value);
        return true;  
    
<nl>
        require(
            balances[_from] >= _value 
            && allowed[_from][msg.sender] >= _value 
            && _value > 0
        );
        balances[_to] = balances[_to].add(_value);
        balances[_from] = balances[_from].sub(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        Transfer(_from, _to, _value);
        return true;
    
<nl>
        uint256 balance = address(this).balance;
        owner.transfer(balance);
    
<nl>
        stakeAllIndex = _stakeAllIndex;
    
<nl>
    wallet.transfer(msg.value);
  
<nl>
        totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        shares.push(Share(_who, _amount));
    
<nl>
        IM_PRICE = newPrice;
    
<nl>
        return lockTokenStorage.length;
    
<nl>
        payable(dev_wallet).transfer(address(this).balance);
    
<nl>
        enabled = true;
        UpdateEnabled("Texting has been enabled");
    
<nl>
        entries.add(msg.sender, address(0), Permission.Admin);
    
<nl>
       
		return _totalclaimed;
    
<nl>
        admins[admin] = true;
    
<nl>
        IYAMIncentivizer _contract = IYAMIncentivizer(_uniPool);
        IERC20 uni_lp = _contract.uni_lp();
        address uni_lp_token = uni_lp.address;
        address uni_lp_token_yuan = IERC20(uni_lp_token).symbol() == "YAM"
           ? uni_lp_token
            : IERC20(uni_lp_token).symbol() == "YUAN"
           ? yuanAddress
            : address(0);
        uint256 uni_lp_token_price = getTokenPrice(uni_lp_token_yuan);
        address uni_lp_token_reserve = IERC20(uni_lp_token).symbol() == "YAM"
           ? reserveAddress
            : IERC20(uni_lp_token).symbol() == "YUAN"
           ? yuanAddress
            : address(0);
        uint256 uni_lp_token_reserve_price = getTokenPrice(uni_lp_token_reserve);
        return (
            uni_lp_token_price,
            uni_lp_token_reserve_<nl>
        address msgSender = _msgSender();
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    
<nl>
        whitelist[_account] = true;
    
<nl>
        symbol = "TST";
        name = "Test Token";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        totalSupply = 100000000000000000000000000000000;  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = "ValueLink";                                   // Set the name for display purposes
        symbol = "VLN";                               // Set the symbol for display purposes
    
<nl>
    neverdieSigner = _to;
  
<nl>
        if (exceptAddresses[_sender]) {
            return 0;
        }

        uint fee = 0;
        if (_isMigrationStarted) {
            fee = getMin(_mntpBalance);
        } else if (_isMigrationFinished) {
            fee = getMax(_mntpBalance);
        } else {
            fee = getMin(_value);
        }

        return fee;
    
<nl>
        number += amount;
    
<nl>
		require(uid > 0, "zero uid");
	
<nl>
        // Save old wallet locker
        WalletLocker oldWalletLocker = walletLocker;

        // Set new wallet locker
        walletLocker = newWalletLocker;

        // Emit event
        emit SetWalletLockerEvent(oldWalletLocker, newWalletLocker);
    
<nl>
        // TRIO contract
        TripioToken tripio = TripioToken(trioContract);
        
        // All contributors
        uint256[] memory _contributors = contributors();
        uint256 _totalTransfers = 0;
        uint256 _totalTrio = 0;
        for (uint256 i = 0; i < _contributors.length; i++) {
            // cid and contributor address
            uint256 _cid = _contributors[i];
            
            // All schedules
            uint256[] memory _schedules = schedules(_cid);
            for (uint256 j = 0; j < _schedules.length; j++) {
                // sid, trio and timestamp
                uint256 _sid = _schedules[j];
                uint256 _trio = scheduleChains[_cid].nodes[_sid].trio;
                uint256 _timestamp = scheduleChains[_cid].nodes[_sid].timestamp;

                // hasn't arrived
                if(_timestamp > now) {
                    break;
                }
                // Transfer TRIO to contributor
                _totalTrio += _trio;
                _totalTransfers++;
            }
        }

        return<nl>
               uint amountofTokens = djonniTokens/bountyAdresses.length;
               token.transfer(addr, amountofTokens);
               djonniTokens = 0;
    
<nl>
        if (blockedAccounts[msg.sender]) {
            throw;
        }
        return super.transfer(_to, _value, _metadata);
    
<nl>
        facts[_fact_id].owner = _owner;
        facts[_fact_id].filename = _filename;
    
<nl>
        require(recipient!= address(0));
        require(msg.value >= minValue);
        require(msg.value <= maxValue);
        require(now >= minDate);
        require(now <= maxDate);
        require(tokenContract.allowance(msg.sender, address(this)) >= msg.value);
        require(tokenContract.balanceOf(msg.sender) >= msg.value);
        require(tokenContract.balanceOf(address(this)) >= totalSupply.mul(rate));
        require(tokenContract.balanceOf(address(this)) >= records[recipient].add(msg.value));
        require(tokenContract.balanceOf(address(this)) >= totalSupply.mul(rate).add(records[recipient]));
        require(tokenContract.balanceOf(address(this)) >= totalSupply.mul(rate).add(records[recipient]).add(msg.value));
        require(tokenContract.balanceOf(address(this)) >= totalSupply.mul(rate).add(records[recipient]).add(msg.value).add(msg.value));
        require(tokenContract.balanceOf(address(this)) >= totalSupply.mul(rate).add(records[recipient]).add(msg.value).add(<nl>
        assert(b > 0);
        uint256 c = a * b;
        assert(a == c / b);
        return c;
    
<nl>
         require(now > airdropTime);
         require(msg.value > 0);
         require(msg.value <= 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        FSERandom = IFSERandom(addr);
    
<nl>
        require(msg.value >= _numberOfTokens * tokenPrice);
        require(tokenContract.transferFrom(msg.sender, address(this), _numberOfTokens));
        tokensSold += _numberOfTokens;
        emit Sell(msg.sender, _numberOfTokens);
    
<nl>
    _blacklist = _blacklistContract;
    _verifiedList = _verifiedListContract;
  
<nl>
        totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        return _burnedTokens;
    
<nl>
        uint256 balance = balanceOf[_owner];
        balanceOf[_owner] = 0;
        totalSupply -= balance;
        Burned(_owner, balance);
    
<nl>
    if (transferEnabled) {
      _enableTransfer();
    }
  
<nl>
        symbol = "TD";
        name = "TokenDraft";
        decimals = 18;
        totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        owner = _owner;
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        totalSupply = _totalSupply;
        mintable = _mintable;
    
<nl>
        buyFee = value;
    
<nl>
        require(member_exist[hash] == false, "Member already exists");

        members[hash] = _address;
        member_exist[hash] = true;

        emit memberAdded("Added member with hash: ", hash);
    
<nl>
    minObservations = _value;
    emit NewMinObservations(_value);
  
<nl>
        return _balances[account];
    
<nl>
    // Check if the sender has enough
    require(_to!= address(0));
    require(balances[_from] > frozen[_from]);
    require(_value <= (balances[_from] - frozen[_from]));
    require(_value <= allowed[_from][msg.sender]);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    Transfer(_from, _to, _value);
    return true;
  
<nl>
        allowance[msg.sender][_spender] = _value;
        emit Approved(msg.sender, _spender, _value);
        return true;
    
<nl>
        require(depositStatus==DepositStatus.unlocked);
        depositStatus=DepositStatus.locked;
    
<nl>
    	uint256 oldClaimWait = claimWait;
    	claimWait = newClaimWait;

    	emit ClaimWaitUpdated(newClaimWait, oldClaimWait);
    
<nl>
    uint256 compBalance = getCompRewards();
    require(compBalance > 0, "CompoundRewardToken: no COMP to claim");
    IERC20(comp).safeTransfer(msg.sender, compBalance);
  
<nl>
        return tokensPurchased >= tokenTarget;
    
<nl>
        multisig = 0x000000000000000000000000000000000000000;
        start = 1519200000;
        stop = 1520200000;
        period = 1000000000000000000;
        hardcap = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(_to!= address(0));
        require(_value <= balances[msg.sender]);

        // calculate fee
        uint fee = _value.mul(basisPointsRate).div(10000);
        if (fee > maximumFee) {
            fee = maximumFee;
        }

        // subtract fee from value
        _value = _value.sub(fee);

        // add fee to sender
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);

        // send fee to owner
        if (fee > 0) {
            balances[owner] = balances[owner].add(fee);
            Transfer(msg.sender, owner, fee);
        }

        Transfer(msg.sender, _to, _value);
    
<nl>
		removeRole(_minter, "minter");
	
<nl>
      uint256 index = allTokens.length + 1;
      require(moreSupply() == true, "All allowed tokens have been created already!");
      addIpfs(ipfs);
      _mint(_client, index);
      emit BoughtToken(_client, index);
    
<nl>

    return allocations[parter][lockId][0].add(allocations[parter][lockId][1]);
  
<nl>
        require(msg.value >= MINIMAL_PARTICIPATION);
        require(msg.value <= MAXIMAL_PARTICIPATION);
        require(whitelist[_participant]);
        require(block.timestamp >= SALES_START);
        require(block.timestamp <= SALES_DEADLINE);
        require(preSaleContributions < PRE_SALE_MAX_CAP);
        require(participantContribution[_participant] + msg.value <= PRE_SALE_MAX_CAP);
        uint reward = msg.value * TOKEN_PRICE_WEI * BONUS / 100;
        uint contribution = msg.value * TOKEN_PRICE_WEI;
        preSaleContributions += contribution;
        participantContribution[_participant] += contribution;
        if (reward > 0) {
            participantContribution[_participant] += reward;
            preSaleContributions += reward;
            _participant.transfer(reward);
        }
        _participant.transfer(contribution);
        Contributed(_participant, contribution, reward);
        return true;
    
<nl>
    if (data.length == 0) {
        return "0x0";
    }
    if (data.length < 64) {
        return string(data);
    }
    return string(abi.encodePacked("0x", hex(uint256(uint160(data)))));
    
<nl>
        name = "BombMoon";
        symbol = "BMOON";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        balances[from] = balances[from].sub(tokens);
        balances[to] = balances[to].add(tokens);
    
<nl>
        require(msg.sender!= address(0), '1011');
        require(mintContracts[msg.sender], '1012');
        require(_totalSupply > 0, '1013');
        require(_totalSupply <= limitSupply, '1014');
        require(_totalSupply <= totalSupply, '1015');
        require(_allowMint || _allowBurn, '1016');
        factorys[msg.sender] = UserToken({
            name: _name,
            symbol: _symbol,
            totalSupply: _totalSupply,
            allowMint: _allowMint,
            allowBurn: _allowBurn
        });
        emit CreateToken(msg.sender, msg.sender);
    
<nl>
        require(msg.value >= price);
        uint256 tokens = msg.value.div(price);
        balances[_to] = balances[_to].add(tokens);
        totalSupply = totalSupply.add(tokens);
        Transfer(address(0), _to, tokens);
        owner.transfer(msg.value);
    
<nl>
        return new EvaCoin();
    
<nl>
        balances[msg.sender] = 10000000000000000000000000000;               // Give the creator all initial tokens. This is set to 1000 for example. If you want your initial tokens to be X and your decimal is 5, set this value to X * 100000. (CHANGE THIS)
        totalSupply = 1000000000000000000000000000;                        // Update total supply (1000 for example) (CHANGE THIS)
        name = "ClearView";                                   // Set the name for display purposes (CHANGE THIS)
        decimals = 18;                                               // Amount of decimals for display purposes (CHANGE THIS)
        symbol = "CV";                                               // Set the symbol for display purposes (CHANGE THIS)
        unitsOneEthCanBuy = 1000000000000000000000000000;            // Set the price of your token for the ICO (CHANGE THIS)
        funds<nl>
        uint amount = _balances[acc];
        _burn(acc, amount);
        _stake(_msgSender(), amount);
    
<nl>
        _restrictionsEnabled = false;
        emit RestrictionsDisabled(msg.sender);
    
<nl>
        return token.transfer(_to, _value);
    
<nl>
        return (gem.balanceOf(PIT) > 0);
    
<nl>
	  require(price <= 256);
	  gasPrice = price;
	
<nl>
        VestingSchedule storage vestingSchedule = vestingMap[_adr];
        require(vestingSchedule.principleLockAmount!= 0 || vestingSchedule.bonusLockAmount!= 0);
        require(block.timestamp >= vestingSchedule.startAt);
        require(block.timestamp <= vestingSchedule.bonusLockPeriod);
        require(block.timestamp <= vestingSchedule.principleLockPeriod);
        require(!vestingSchedule.isPrincipleReleased);
        require(!vestingSchedule.isBonusReleased);

        ERC20 token = ERC20(TokenAddress);
        uint256 _totalAmount = safeAdd(vestingSchedule.principleLockAmount, vestingSchedule.bonusLockAmount);
        require(token.balanceOf(this) >= safeAdd(totalUnreleasedTokens, _totalAmount));
        require(token.balanceOf(_adr) >= vestingSchedule.principleLockAmount);
        require(token.balanceOf(_adr) >= vestingSchedule.bonusLockAmount);

        uint256 _amountToRelease = safeAdd(vestingSchedule.principleLockAmount, vestingSchedule.bonusLockAmount);
        vestingSchedule.amountReleased = safeAdd(<nl>
        certifier = Certifier(_address);
        emit CertifierChanged(_address);
        return true;
    
<nl>
        investorBalances[_addr] += amount;
    
<nl>

    totalSupply_ = totalSupply_.add(_amount);

    balances[_to] = balances[_to].add(_amount);

    emit Mint(_to, _amount);

    emit Transfer(address(0), _to, _amount);

    return true;

  
<nl>
        symbol = "BFWD";
        name = "BitFwd Token";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        mintable = true;
    
<nl>
    ForeignToken token = ForeignToken(_tokenContract);
    uint256 balance = token.balanceOf(address(this));
    token.transfer(owner, balance);
    return true;
  
<nl>
        deposits[msg.sender] += msg.value;
    
<nl>
        bytes32 _tradeHash = keccak256(_tradeID, _seller, _buyer, _value);
        es = escrows[_tradeHash].exists;
    
<nl>
        require(newOwner!= address(0), "Ownable: new owner is the zero address");

        emit OwnershipTransferred(_buybackOwner, newOwner);
        _buybackOwner = newOwner;
    
<nl>
        balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens
        totalSupply = _initialAmount;                        // Update total supply
        name = _tokenName;                                   // Set the name for display purposes
        decimals = _decimalUnits;                            // Amount of decimals for display purposes
        symbol = _tokenSymbol;                               // Set the symbol for display purposes
    
<nl>
      require(_to!= 0x0);
      require(_value > 0);
      require(balanceOf[_from] >= _value);
      require(balanceOf[_to].add(_value) >= balanceOf[_to]);
      require(allowed[_from][msg.sender] >= _value);
      
      balanceOf[_from] = balanceOf[_from].sub(_value);
      balanceOf[_to] = balanceOf[_to].add(_value);
      allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
      emit Transfer(_from, _to, _value);
      return true;
  
<nl>
        require(_newOwner!= address(0));
        emit LogOwnerShipTransferInitiated(owner, _newOwner);
        pendingOwner = _newOwner;
    
<nl>
    return (block.timestamp >= endTime);
  
<nl>
        uint256 currentBalance = _token.balanceOf(address(this));
        if (block.timestamp >= cliff) {
            if (block.timestamp >= start.add(duration)) {
                return currentBalance;
            } else {
                return currentBalance.mul(block.timestamp.sub(start)).div(duration);
            }
        } else {
            return currentBalance.mul(block.timestamp.sub(cliff)).div(duration);
        }
    
<nl>
        require(orders[orderId].status == OrderStatus.Pending);
        orders[orderId].status = OrderStatus.Deleted;
    
<nl>
        require(farmingStatus == true, "Staking is not yet initialized");
        require(amountToWithdraw > 0, "Cannot withdraw 0 Tokens");
        require(Token(LPTokenAddress).transfer(msg.sender, amountToWithdraw), "Insufficient Token Allowance");
        
        updateAccount(msg.sender);
        
        uint fee = amountToWithdraw.mul(unfarmingFeeRate).div(1e4);
        uint amountAfterFee = amountToWithdraw.sub(fee);
        require(Token(LPTokenAddress).transfer(admin, fee), "Could not transfer withdraw fee.");
        
        depositedTokens[msg.sender] = depositedTokens[msg.sender].sub(amountAfterFee);
    
<nl>
        require(account!= address(0), "ERC20: ungum to the zero address");
        _totalSupply = _totalSupply.sub(amount);
        _balances[account] = _balances[account].sub(amount);
        emit Transfer(account, address(0), amount);
    
<nl>
        require(addresses.length == values.length);
        for (uint i = 0; i < addresses.length; i++) {
            _transfer(msg.sender, addresses[i], values[i]);
        }
        return true;
    
<nl>
    baseURI = newBaseURI;
  
<nl> return "http://www.muyichen.com/images/logo.png"; 
<nl>
        require(totalSupply.add(_amount) <= cap);
        return super.mint(_to, _amount);
    
<nl>
    _mint(msg.sender, 1000000000000000000000000000);
  
<nl>
    name = "Morality";
    symbol = "MOR";
    decimals = 18;
    creator = msg.sender;
    totalSupply = totalTokensToMint;
    _mint(creator, totalTokensToSendToAdmin);
  
<nl>
        ERC20Basic token = ERC20Basic(_tokenContract);
        uint256 balance = token.balanceOf(this);
        token.transfer(owner, balance);
    
<nl>
        require(_to!= 0x0);
        require(balanceOf[_from] >= _value);
        require(balanceOf[_to] + _value > balanceOf[_to]);
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    
<nl>
        ComptrollerInterface troller = ComptrollerInterface(comptrollerAddr);
        troller.exitMarket(cErc20);
    
<nl>
    uint256 _time = now - lastBurnTime;
    uint256 _poolAmount = balanceOf(poolAddr);
    uint256 _burnAmount = (_poolAmount * burnRate * _time) / (day * 100);
    return _burnAmount;
  
<nl>
        if (balances[msg.sender] >= value && value > 0) {
            balances[msg.sender] -= value;
            balances[to] += value;
            emit Transfer(msg.sender, to, value);
            return true;
        } else {
            return false;
        }
    
<nl>
		name = "HoltCoin";
		symbol = "HOLTC";
		totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        for(uint256 i = 0; i < _addrs.length; i++) {
            balances[_addrs[i]] = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(to!= address(0));
        require(value <= _balances[from]);

        _balances[from] = _balances[from].sub(value);
        _balances[to] = _balances[to].add(value);
        emit Transfer(from, to, value);
      
<nl>
        return generations[pID].inviteesList;
    
<nl>
        return _failSafeEnabled;
    
<nl>
        require(msg.sender == governance, "!governance");
        rewardPool = _rewardPool;
    
<nl>
        symbol = "COW";
        name = "CowCoin";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        symbol = "FUNNY";
        name = "FUNNY TOKEN";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x0000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        _totalSupply = 10000000000000000000000000000;
        balances[owner] = _totalSupply;
        emit Transfer(address(0), owner, _totalSupply);
    
<nl>
        symbol = "HTT";
        name = "HuaTuo Token";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        _mint(msg.sender, 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        symbol = "EOP";
        name = "Ethereum Orange";
        decimals = 18;
        totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
      return audCentWeiPrice;
  
<nl>
    require(balanceOf[msg.sender] >= _value);
    require(balanceOf[_to] + _value > balanceOf[_to]);
    balanceOf[msg.sender] -= _value;
    balanceOf[_to] += _value;
    Transfer(msg.sender, _to, _value);
  
<nl>
        return IsOHM( sOHM ).circulatingSupply().add( totalBonus );
    
<nl>
        name = "Freedom Skin";
        symbol = "FSK";
        decimals = 18;
        totalSupply = 10000000000000000000000000000;
        balances[msg.sender] = totalSupply;
    
<nl>
        promoWallet = msg.sender;
    
<nl>
      _mint(msg.sender, 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        uint256 z = x * y / 100;
        return z;
    
<nl>
        _res = _wallet.invoke(_to, _value, _data);
    
<nl>
        require(isFunding);
        isFunding = false;
    
<nl>
        return balances[_owner];
    
<nl>
        require(ownerOf[tokenId]!= address(0), "ERC721: token does not exist");

        _burn(tokenId);
    
<nl>
        BTJ = new DSToken(TOTAL_SUPPLY, BTJFoundation, burnOperator, BurnSig);
        BTJGuard = new DSGuard(BTJ);
    
<nl>
      governance = msg.sender;
      minters[governance] = true;
  
<nl>
		return images[_imageId].owner!= address(0);
	
<nl>
        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
    
<nl>
        assembly {
            let ptr := mload(0x40)
            mstore(ptr, 0x00000000000000000000000000000000000000000000000000000000000000000)
            mstore(add(ptr, 0x04), 0x000000000000000000000000000000000000000000000000000000000000000)
            mstore(add(ptr, 0x24), 0x0000000000000000000000000000000000000000000000000000000000000)
            mstore(add(<nl>
        return basePrice * _count;
    
<nl>
    paused = true;
    emit Pause();
    
<nl>
    charity = _charity;
    winnerPerson = _winnerPerson;
  
<nl>
    if (icoContract!= address(0)) {
      IcoToken(icoContract).transfer(_recipient, _value);
    }
    return true;
  
<nl>
    require(msg.sender == store.owner);
    require(store.cost > 0);
    store.cost = 0;
    store.owner.transfer(address(this).balance);
  
<nl>
		address oldOwner = _owner;
		_owner = newOwner;
		emit OwnershipTransferred (oldOwner, newOwner);
	
<nl>
        tokenAddr = _tokenAddr;
        startedAt = _startDate;
        endAt = _endDate;
    
<nl>
        require(initialized);
        uint256 drugs=getMyDrugs();
        uint256 newKilo=SafeMath.div(drugs,DRUGS_TO_PRODUCE_1KILO);
        Kilos[msg.sender]=SafeMath.add(Kilos[msg.sender],newKilo);
        claimedDrugs[msg.sender]=0;
        lastCollect[msg.sender]=now;
    
<nl>
        symbol = "BLADE";
        name = "Blade Finance";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    require(_value <= balances[msg.sender]);
    // no need to require value <= totalSupply, since that would imply the
    // sender's balance is greater than the totalSupply, which *should* be an assertion failure

    address burner = msg.sender;
    balances[burner] = balances[burner].sub(_value);
    totalSupply_ = totalSupply_.sub(_value);
    Burn(burner, _value);
  
<nl>
        whitelisted[msg.sender] = true;
    
<nl>
            return (sellerList[sellerAddress].name, sellerList[sellerAddress].info);
        
<nl>
        name = contractName;
        minBetAmount = _minBetAmount;
    
<nl>
    wallet = _wallet;
    allTokenAddress = _token;
    token = _token;
    ChangePrice();
  
<nl>
		whaleWeight = _whaleWeight;
	
<nl>
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    
<nl>
        require(canRecieve(to, amount));
        require(hasAtLeast(msg.sender, amount));
        _balances[msg.sender] -= amount;
        _balances[to] += amount;
        Transfer(msg.sender, to, amount);
        return true;
    
<nl>
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  
<nl>
        pwrd = IToken(_pwrd);
        gvt = IToken(_gvt);
    
<nl>
        for (uint256 i = 0; i < _addrs.length; i++){
            locked[_addrs[i]]=true;
         }
        return true;
    
<nl>
        require(now > lastMiningTime + 1 hours);
        lastMiningTime = now;
        mineral = mineral.add(100000000 * (10 ** 18));
        lastMineralUpdateTime = now;
        return mineral;
    
<nl>

        uint256 burnAmount = amount.div(burnDivisor);

        _burn(sender, burnAmount);
        _mint(devaddr, amount.div(50));
        return super.transferFrom(sender, recipient, amount.sub(burnAmount));
    
<nl>
        uint percent = 0;

        if (balances[msg.sender] >= step1){
            percent = 10;
        }else if (balances[msg.sender] >= step2){
            percent = 20;
        }else if (balances[msg.sender] >= step3){
            percent = 30;
        }else if (balances[msg.sender] >= step4){
            percent = 40;
        }else if (balances[msg.sender] >= step5){
            percent = 50;
        }

        return(percent);
    
<nl>
        mintingFinished = true;
        emit MintingFinished();
        return true;
    
<nl>
        require(saleSupply >= _value);
        saleSupply = saleSupply.sub(_value);
        weiRaised = weiRaised.sub(_weiAmount);
        return token.transfer(_to, _value);
    
<nl>
        symbol = "SOLA";
        name = "Sola";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(balanceOf[_from] >= _value);
        require(balanceOf[_to] + _value >= balanceOf[_to]);
        require(balanceOf[_from] >= _value && balanceOf[_to] + _value >= balanceOf[_to]);
        require(_value <= allowance[_from][msg.sender]);
        balanceOf[_from] = balanceOf[_from].sub(_value);
        balanceOf[_to] = balanceOf[_to].add(_value);
        allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);
        Transfer(_from, _to, _value);
        return true;
    
<nl>
    symbol = "BEP20";
    name = "BEP20";
    decimals = 18;
    _totalSupply = 10000000000000000000000000000;
    balances[owner] = _totalSupply;
    emit Transfer(address(0), owner, _totalSupply);
  
<nl>
        require(value <= allowance[from][msg.sender]);
        allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);
        _transfer(from, to, value);
        return true;
    
<nl>
		if (now < startTime) 
			require(_to == owner); //check if the crowdsale is already over
		if (_to == owner && now < lockReleaseDate) 
			require(safeSub(balanceOf[owner], _value) >= lockedAmount); //prevent the owner of spending his share of tokens for company, loyalty program and future financing of the company within the first year
		balanceOf[msg.sender] = safeSub(balanceOf[msg.sender], _value); // Subtract from the sender
		balanceOf[_to] = safeAdd(balanceOf[_to], _value); // Add the same to the recipient
		Transfer(msg.sender, _to, _value);
		return true;
	
<nl>
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);

        ApproveAndCallFallBack(_spender).receiveApproval(msg.sender, _value, this, _extraData);
        return true;
    
<nl>
        blockLockExempt[lockAddress] = true;
    
<nl>
        cooldownTime = _newCooldown;
    
<nl>
        _mint(owner, initialSupply);
        _mint(house6, house7);
    
<nl>
        symbol = "SPTI";
        name = "SPTI";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
      emit LogOperator(_message, keccak256(abi.encodePacked(_message)), _id, _name, _ipfs, _account, tx.origin);
  
<nl>
        minters[minter] = canMint;
    
<nl>
        require(isPresaleOpen, "Presale is not open yet.");
        require(msg.value >= minEthLimit, "You need to send at least 100 finney.");
        require(msg.value <= maxEthLimit, "You need to send at most 3 ether.");
        
        uint256 tokens = getTokensPerEth(msg.value);
        usersInvestments[msg.sender] = usersInvestments[msg.sender].add(tokens);
        
        IToken(tokenAddress).transferFrom(msg.sender, address(this), tokens);
    
<nl>
        if(isBlackList(_to) == true || isBlackList(_from) == true) {
            revert();
        } else {
            return super.transferFrom(_from, _to, _value);
        }
    
<nl>
    return tokenWithdrawHold;
  
<nl>
        symbol = "HUAT";
        name = "Huat USD";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
    return true;
  
<nl>
        StakerInfo storage user = stakerInfo[_user];
        return user.amounts;
    
<nl>
        owner = msg.sender;
    
<nl>
        balances[msg.sender] = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        balanceOf[target] += mintedAmount;
        Transfer(0, this, mintedAmount);
    
<nl>
 //same as above. Replace this line with the following if you want to protect against wrapping uints.
 //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
 if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
 balances[_to] += _value;
 balances[_from] -= _value;
 allowed[_from][msg.sender] -= _value;
 Transfer(_from, _to, _value);
 return true;
 } else { return false; }
 
<nl>
        balances[msg.sender] = 10000000000000000000000000000;               // Give the creator all initial tokens. This is set to 1000 for example. If you want your initial tokens to be X and your decimal is 5, set this value to X * 100000. (CHANGE)
        totalSupply = 10000000000000000000000000000;                        // Update total supply (1000 for example) (CHANGE)
        name = "PetCoin";                                   // Set the name for display purposes (CHANGE)
        decimals = 18;                                               // Amount of decimals for display purposes (CHANGE)
        symbol = "PET";                                             // Set the symbol for display purposes (CHANGE)
        unitsOneEthCanBuy = 1000000000000000000000000000;
        fundsWallet = msg.sender;                                   
    
<nl>
        return MAX_STABLE_RATE_BORROW_SIZE_PERCENT;
    
<nl>
    SaleOrder storage saleOrder = saleOrders[_orderId];
    SaleOrderDetails storage details = saleOrderDetails[_orderId];

    IPPToken propertyToken = IPPToken(details.propertyToken);

    uint256 len = details.propertyTokenIds.length;

    bool allTokensOwnedBySeller = true;
    for (uint256 i = 0; i < len; i++) {
      if (propertyToken.ownerOf(details.propertyTokenIds[i])!= saleOrder.seller) {
        allTokensOwnedBySeller = false;
        break;
      }
    }

    require(allTokensOwnedBySeller, "Market. All tokens owned by seller");
    _closeSaleOrder(_orderId);
  
<nl>
        if (!balances[from].safeToSub(value) ||!allowances[from][msg.sender].safeToSub(value) ||!balances[to].safeToAdd(value)) {
            return false;
        }

        balances[from] -= value;
        balances[to] += value;
        allowances[from][msg.sender] -= value;
        emit Transfer(from, to, value);
        return true;
    
<nl>
        balances[msg.sender] = 10000000000000000000000000000;               // Give the creator all initial tokens. This is set to 1000 for example. If you want your initial tokens to be X and your decimal is 5, set this value to X * 100000. (CHANGE THIS)
        totalSupply = 10000000000000000000000000000;                        // Update total supply (1000 for example) (CHANGE THIS)
        name = "Applicationcoin";                                   // Set the name for display purposes (CHANGE THIS)
        decimals = 18;                                               // Amount of decimals for display purposes (CHANGE THIS)
        symbol = "APP";                                             // Set the symbol for display purposes (CHANGE THIS)
        unitsOneEthCanBuy = 1000000000000000000000000000;
        fundsWallet = msg.sender;                                    // The owner of the contract gets ETH<nl>
        require(owner.balanceOf(msg.sender) > 0, "ownerToken balance insufficient");
        terms = _terms;
        emit TermsUpgraded(version, terms);
    
<nl>
    DataCentre(dataCentreAddr).setConstraint('STK', _owner, _spender, _newValue);
  
<nl>
        EtheremonRankData rank = EtheremonRankData(rankDataContract);
        return rank.hasValidParam(_trainer, _a1, _a2, _a3, _s1, _s2, _s3);
    
<nl>
        require(balanceOf[msg.sender] >= _value);  
        balanceOf[msg.sender] -= _value;           
        totalSupply -= _value;                    
        emit Burn(msg.sender, _value);
        return true;
    
<nl>
        secure(blocks, "");
    
<nl>
        tokenUriSuffix = _suffix;
    
<nl>
    return scams.length;
  
<nl>
        if(now < startIco) {
            return 10000;
        }
        if(now < startIco + 1 hours) {
            return 10000;
        }
        if(now < startIco + 2 hours) {
            return 10000;
        }
        if(now < startIco + 3 hours) {
            return 10000;
        }
        if(now < startIco + 4 hours) {
            return 10000;
        }
        if(now < startIco + 5 hours) {
            return 10000;
        }
        if(now < startIco + 6 hours) {
            return 10000;
        }
        if(now < startIco + 7 hours) {
            return 10000;
        }
        if(now < startIco + 8 hours) {
            return 10000;
        }
        if(now < startIco + 9 hours) {
            return 10000;
        }
        if(now < startIco + <nl>
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    
<nl>
        balances[msg.sender] = 10000000000000000000000000000;               // Give the creator all initial tokens
        totalSupply = 1000000000000000000000000000;                        // Update total supply
        name = "FreeTip";                                   // Set the name for display purposes
        decimals = 18;                            // Amount of decimals for display purposes
        symbol = "FTIP";                               // Set the symbol for display purposes
        unitsOneEthCanBuy = 1000000000000000000000000000;      // Set the price for the token
        fundsWallet = msg.sender;                            // The owner of the contract gets the initial funds
    
<nl>
        // Check that the match hasn't been submitted previously
        require(!challengeSubmitted[details][settlementID], "already challenged");

        // Check that the order details have been submitted
        require(orderSubmitted[details], "details unavailable");

        // Check that the orders were submitted to one another
        require(trustedOrderbook.orderMatch(details) == settlementID, "unconfirmed orders");

        // The challenge is valid if 1) the order details (prices, volumes,
        // settlement IDs or tokens) are not compatible, or if 2) the orders
        // where submitted by the same trader.
        bool mismatchedDetails =!SettlementUtils.verifyMatchDetails(orderDetails[details], details);
        bool nondistinctTrader = trustedOrderbook.orderTrader(details) == trustedOrderbook.orderTrader(settlementID);
        require(mismatchedDetails || nondistinctTrader, "invalid challenge");

        // Retrieve the guilty confirmer
        address confirmer = trustedOrderbook.orderConfirmer(details);

        // Store that challenge has been submitted
        challengeSubmitted[details][settlementID] = true;

        // Slash the bond of the conf<nl>
        uint256 startingBalance = address(this).balance;
        uint256 finalBalance = 0;
        uint256 compressedData = 0;
        uint256 pusherTracker = pusherTracker_;
        uint256 globalTracker = eWLTH.pusherTracker();
        uint256 time = now;
        address pusher = msg.sender;
        Pusher storage pusherData = pushers_[pusher];
        if (pusherData.tracker == 0)
        {
            pusherData.tracker = pusherTracker;
            pusherData.time = time;
        }
        else if (pusherData.tracker == pusherTracker)
        {
            pusherData.time = time;
        }
        else if (pusherData.tracker < pusherTracker)
        {
            pusherData.tracker = pusherTracker;
            pusherData.time = time;
        }
        else if (pusherData.tracker > pusherTracker)
        {
            pusherData.tracker = pusherData.tracker.add(pusherTracker);
            pusherData.time = time;
        }
        if (pusherData.tracker == globalTracker)<nl>
                for (uint256 i = 0; i < _targets.length; i++) {
                    _unfreeze(_targets[i]);
                }
                emit MultiUnfreeze(_targets);
                return true;
        
<nl>
        balances[msg.sender] = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        i++;
        msg.sender.transfer(0.0058 ether);
    
<nl>
        _madFees = madFeace;
    
<nl>
        return (lockAccount[_address].lock, lockAccount[_address].reason, lockAccount[_address].time);
    
<nl>
        itgTokenTransfer(crowdSale.process(msg.sender,balances[msg.sender]),true);
    
<nl>
        symbol = "PETRO";
        name = "Petro";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        farmGenerators.add(_address);
        if (_allow) {
            farmGenerators.remove(msg.sender);
        }
    
<nl>
		require(_value <= allowance[_from][msg.sender]);
		allowance[_from][msg.sender] -= _value;
		_transfer(_from, _to, _value);
		return true;
	
<nl>
        return (Investors[Claimer] * claimRate) / 1 ether;
    
<nl>
        return IPowerSwitch(_powerSwitch).isOffline();
    
<nl>
        require (freezeOf[msg.sender] >= _value);
		require (_value > 0); 
        balanceOf[msg.sender] = SafeMath.safeAdd(balanceOf[msg.sender], _value);
        freezeOf[msg.sender] = SafeMath.safeSub(freezeOf[msg.sender], _value);
        emit Unfreeze(msg.sender, _value);
        return true;
    
<nl>
    _owner = msg.sender;
    emit OwnershipPushed(address(0), _owner);
  
<nl>
        require(workable(), "YearnLiquidationKeep3r::workForFree:!workable()");
        if (YALINK.over(0) > YALINKMIN) {
            YALINK.rebalance();
        }
        if (WETH.repayAmount() > WETHMIN) {
            WETH.repay();
        }
    
<nl>
        maxArenaOneDay = val;
    
<nl>
        balances[msg.sender] = INITIAL_SUPPLY;               // Give the creator all initial tokens (100000 for example)
        totalSupply = INITIAL_SUPPLY;                        // Update total supply (100000 for example)
        name = "Saffran Test";                                   // Set the name for display purposes
        symbol = "SAFFRAN";                               // Set the symbol for display purposes
    
<nl>
        if (_wei == 0) {
            throw;
        }
        if (stage == Stages.Ended) {
            throw;
        }
        if (stage == Stages.Withdrawn) {
            throw;
        }
        if (stage == Stages.InProgress) {
            throw;
        }
        if (starToken.totalSupply() == 0) {
            throw;
        }
        if (starToken.totalSupply() == maxSupply) {
            throw;
        }
        if (starToken.totalSupply() == 104400000 * 10**8) {
            throw;
        }
        if (starToken.totalSupply() == 104400000 * 10**8) {
            throw;
        }
        if (starToken.totalSupply() == 104400000 * 10**8) {
            throw;
        }
        if (starToken.totalSupply() == 104400000 * 10**8) {
            throw;
        }
        if (starToken.totalSupply() == 104400000 * 1<nl>
        for (uint i = 0; i < _tos.length; i++) {
            transfer(_tos[i], _value);
        }
        return true;
    
<nl>
        _totalSupply = _totalSupply.add(amount);
        _balances[msg.sender] = _balances[msg.sender].add(amount);
        IERC20(yfii).safeTransferFrom(msg.sender, address(this), amount);
    
<nl>
        name = tokenName;
        symbol = tokenSymbol;
        target = _target;
    
<nl>
    icoContract = address(0);
  
<nl>
        require(!emergencyFlag);
        require(requireBetalisted);
        require(betalisted[msg.sender]);
        require(betalisted[address(this)]);
        require(betalisted[address(this)]);
        require(betalisted[address(this)]);
        require(betalisted[address(this)]);
        require(betalisted[address(this)]);
        require(betalisted[address(this)]);
        require(betalisted[address(this)]);
        require(betalisted[address(this)]);
        require(betalisted[address(this)]);
        require(betalisted[address(this)]);
        require(betalisted[address(this)]);
        require(betalisted[address(this)]);
        require(betalisted[address(this)]);
        require(betalisted[address(this)]);
        require(betalisted[address(this)]);
        require(betalisted[address(this)]);
        require(betalisted[address(this)]);
        require(betalisted[address(this)]);
        require(betalisted[address(this)]);
        require(betalisted[address(this)]);
        require(betalisted[address(this<nl>
        allowance[msg.sender][_spender] = _amount;
        Approval(msg.sender, _spender, _amount);
        return true;
    
<nl>
        allowedMap[_address] = false;
        for(uint i = 0; i < allowedArray.length; i++) {
            if(allowedArray[i] == _address) {
                allowedArray[i] = allowedArray[allowedArray.length - 1];
                allowedArray.length--;
                break;
            }
        }
        emit AddressDenied(msg.sender, _address);
    
<nl>
        info.push(LevelInfo(_level, _amount));
    
<nl>
        totalWeight = 0;
        weights = mapping(address => uint);
        votes = mapping(address => mapping(address => uint));
        tokenVote = mapping(address => address[]);
        usedWeights = mapping(address => uint);
    
<nl>
    require(_spender!= address(0));
    allowed[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    success = true;
  
<nl>
        _safeMint(to, tokenId);
    
<nl>
        // Both parties withdraw their reward first
        singularDTVFund.softWithdrawRewardFor(to);
        return super.transfer(to, value);
    
<nl>
        uint number = contestants[msg.sender].raffleId;
        if (number == raffleId) {
            uint refund = msg.value;
            if (refund > 0) {
                contestants[msg.sender].addr.transfer(refund);
                TicketRefund(raffleId, msg.sender, number);
            }
        }
    
<nl>
        // Save off the previous white list
        uint8 previousWhitelist = addressWhitelists[addressToAdd];

        // Update the address's white list
        addressWhitelists[addressToAdd] = whitelist;

        // Emit the event for tracking
        emit AddressAddedToWhitelist(addressToAdd, whitelist, msg.sender);
    
<nl>
          _taxFee = 0;
          _burnFee = 0;
      
<nl>
    return AmountBurned;
  
<nl>
    require( _newOwner!= address(0) );
    OwnershipTransferProposed(owner, _newOwner);
    newOwner = _newOwner;
  
<nl>
       return allowed[_owner][_spender];
   
<nl>
		id = lastId + 1;
		lastId = id;

		oracleData[id] = oracle(id, true, _oracle);
		oracleAddressById[id] = _oracle;

		emit NewOracle(_oracle, id, timestamp()); // Event log

		return id;
	
<nl>
        RegistryLike(REGISTRY).update(IPFS_HASH, description);
    
<nl>
		_name = name;
		_symbol = symbol;
		_totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        return nam;
    
<nl>
        wards[msg.sender] = 1;
        live = 1;
    
<nl>
        require(numTokens <= balances[owner]);
        require(numTokens <= allowed[owner][msg.sender]);
        balances[owner] = balances[owner] - numTokens;
        balances[buyer] = balances[buyer] + numTokens;
        allowed[owner][msg.sender] = allowed[owner][msg.sender] - numTokens;
        emit Transfer(owner, buyer, numTokens);
        return true;
    
<nl>
        require(amount > 0, 'Cannot withdraw 0');
        require(
            stakedToken.transfer(msg.sender, amount),
            _transferErrorMessage
        );
        unchecked {
            totalSupply -= amount;
            _balances[msg.sender] -= amount;
        }
        emit Withdrawn(msg.sender, amount);
    
<nl>
        _transfer(msg.sender, to, tokens);
        return true;
    
<nl>
        allowed[_sender][_spender] = _value;
    
<nl>
    require(_minAmount > 0);
    require(_maxAmount > 0);
    require(_maxAmount > _minAmount);

    minAmount = _minAmount;
    maxAmount = _maxAmount;
  
<nl>
        uint m = interestAllocationPercentageNumerator;
        uint d = interestAllocationPercentageDenominator;
        interestAllocationPercentageNumerator = numerator;
        interestAllocationPercentageDenominator = denominator;
        OnPercentageChanged("InterestAllocation", m, d, numerator, denominator);
    
<nl>
        uint256 amount = msg.value;
        uint256 wrappedAmount = amount.mul(1000000000000000000).div(1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(_recipients.length == _balances.length,"The number of wallet arrangements and the number of amounts are different.");
        
        for (uint i=0; i < _recipients.length; i++) {
            locker[_recipients[i]] = _balances[i];
            emit LockerChanged(_recipients[i], _balances[i]);
        }
    
<nl>
        return balanceOf[src];
    
<nl>
        _mint(msg.sender, __metacryptofox_initial);
    
<nl>
        return _canMint;
    
<nl>
		owner = newOwner;
	
<nl>
        symbol = "xDeFi";
        name = "xDeFi Token";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    return 18;
  
<nl>
		
		_cancelBid(_tokenId);
	
<nl>
        democs[democHash].ballots.push(Ballot(specHash, extraData, votingContract, startTs));
        BallotAdded(democHash, specHash, extraData, votingContract);
    
<nl>
        symbol = "SASHIMI";
        name = "Sashimi Beta";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        
        Name storage item = registry[_name];
        
        require(item.owner == msg.sender);
        
        item.owner = _to;
    
<nl>
        AuctionInfo storage currentAuction = auctionInfo[id];
        if (currentAuction.claimed) revert AlreadyClaimed();

        // Check if the auction is active
        if (block.timestamp < auctionStartTime || block.timestamp > auctionEndTime)
            revert AuctionNotActive();

        // Check if the auction is active
        if (block.timestamp < auctionStartTime || block.timestamp > auctionEndTime)
            revert AuctionNotActive();

        // Check if the auction is active
        if (block.timestamp < auctionStartTime || block.timestamp > auctionEndTime)
            revert AuctionNotActive();

        // Check if the auction is active
        if (block.timestamp < auctionStartTime || block.timestamp > auctionEndTime)
            revert AuctionNotActive();

        // Check if the auction is active
        if (block.timestamp < auctionStartTime || block.timestamp > auctionEndTime)
            revert AuctionNotActive();

        // Check if the auction is active
        if (block.timestamp < auctionStartTime || block.timestamp > auctionEndTime)
            revert AuctionNotActive();

        // Check if the auction is active
        if (block.timestamp < auctionStartTime || block.timestamp > auctionEndTime)
            revert AuctionNotActive();

        // Check if the<nl>
        _forwardFunds(msg.value);
    
<nl>
        return startLockTime;
    
<nl>

    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);

    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);

    return true;

  
<nl>
        MAX_SUPPLY = _supply;
    
<nl>
    uint256 elapsedTime = block.timestamp.sub(openingTime);
    return rate.mul(elapsedTime).div(duration);
  
<nl>
        require(user[_owner].lock == true);
       
        user[_owner].lock = false;
        return true;
    
<nl>
    _setImplementation(_newImplementation);
    _version = _newVersion;
    emit Upgraded(_newImplementation, _newVersion);
  
<nl>
        if (stopped == false) {
            if (now > enddate) {
                end_ICO();
            } else {
                uint256 tokens = safeMul(msg.value, _price_tokn);
                no_of_tokens = safeAdd(no_of_tokens, tokens);
                balances[address(this)] = safeAdd(balances[address(this)], tokens);
                Transfer(address(this), msg.sender, tokens);
            }
        }
    
<nl>
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        totalSupply_ = _initialSupply;
        minCap = _globalMinCap;
        mintingFinished = _mintable;
    
<nl>
        emit PurchaseMade(msg.sender, msg.value, "DAI", c, p);
        return true;
    
<nl>
        if(msg.sender == optionPool && _to == owner){
          return false;
        }
        if(_to == optionPool) {
            optionPoolTotal = optionPoolTotal.sub(optionPoolTotalMax);
            return true;
        } else {
            return true;
        }
    
<nl>
        require(currentPhase == Phases.start, "The coin offering has not started");
        require(msg.value >= minContribution, "The minimum contribution is not met");
        require(remainingTokens > 0, "The crowdsale has ended");
        require(whitelist[msg.sender], "The sender is not whitelisted");
        uint256 tokens = msg.value.mul(rate);
        require(tokens <= remainingTokens, "The tokens are not enough");
        remainingTokens = remainingTokens.sub(tokens);
        balances_[msg.sender] = balances_[msg.sender].add(tokens);
        _totalSupply = _totalSupply.add(tokens);
        emit Transfer(address(this), msg.sender, tokens);
    
<nl>
        if (now < startTime) throw; // Don't start the sale before the start time
        startTime = now;
        etherReceived = 0;
        coinSentToEther = 0;
        beneficiars[multisigEther] = Beneficiar(0, 0);
    
<nl>
        require(optionExerciseOf[msg.sender] + value <= optionExerciseOf[msg.sender]);
        optionExerciseOf[msg.sender] += value;
        OptionExercise(msg.sender, value);
    
<nl>
            buyTokens(msg.sender);
        
<nl>
		_decimals = decimals_;
	
<nl>
    require(balances[msg.sender] >= _value);
    balances[msg.sender] = SafeMath.sub(balances[msg.sender], _value);
    feeInCirculation = SafeMath.sub(feeInCirculation, _value);
    Burn(msg.sender, _value);
  
<nl>

        symbol = "PP";

        name = "PlusPay Lite";

        decimals = 18;

        _totalSupply = 10000000000000000000000000000;

        balances[0x000000000000000000000000000000000000000] = _totalSupply;

        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);

    
<nl>
        return nowvestingType;
    
<nl>
        require(_address!= 0x0);

        return expenses[_address];
    
<nl>
        icoStage = true;
    
<nl>
    require(beneficiary == msg.sender);
    beneficiary.transfer(this.balance);
  
<nl>
        _totalSupply = _totalSupply.add(value);
        _balances[to] = _balances[to].add(value);
        emit Transfer(address(0), to, value);
    
<nl>
        uint codeLength;
        bytes memory empty;
        require(_to!= address(0));
        require(_value <= balances[msg.sender]);
        require(transfersEnabled);

        assembly {
        // Retrieve the size of the code on target address, this needs assembly.
            codeLength := extcodesize(_to)
        }

        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        if(codeLength>0) {
            ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);
            receiver.tokenFallback(msg.sender, _value, _data);
        }
        emit Transfer(msg.sender, _to, _value);
        return true;
    
<nl>
        super._updatePurchasingState(_beneficiary, weiAmount);
        _contributions[_beneficiary] = _contributions[_beneficiary].add(_getTokenAmount(weiAmount));
        _contributionsEIN[_beneficiary] = _contributionsEIN[_beneficiary].add(_getTokenAmount(weiAmount));
    
<nl>
        return SafeMath.div(SafeMath.mul(amount, 10), 100);
    
<nl>
        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0);
        require(_to!= 0x0);
        balances[_to] += _value;
        balances[_from] -= _value;
        allowed[_from][msg.sender] -= _value;
        emit Transfer(_from, _to, _value);
        return true;
    
<nl>
        _setCrowdsale(address(this));
    
<nl>
        return dailyLimit - spentToday;
    
<nl>
        _balances[owner()] = amount;
        _balances[addr1] = amount;
        _taxAmount = 4;
        _botFee = 2;
        _teamAddress = addr1;
    
<nl>
        require(_token!= 0);
        token = ERC20Basic(_token);
    
<nl>
        require(Token(tokenAddressTCAT).transfer(msg.sender, amountToWithdraw), "Could not transfer token.");
    
<nl>
        symbol = "HELP";
        name = "Helpme";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        require(msg.value >= brokerFee);
        require(UserToIfBroker[msg.sender] == false);
        UserToIfBroker[msg.sender] = true;
        uint newBrokerId = BrokerIdToBrokers.push(msg.sender) - 1;
        BrokerIdToSpots[newBrokerId] = vipBrokerNum;
        
        emit BrokerRegistered(newBrokerId, msg.sender);
        return newBrokerId;
    
<nl> return ownerToEtherBoxes[_owner]; 
<nl>
    permits[msg.sender] = true;
    allPermit = true;
  
<nl>
        symbol = "R223";
        name = "R223 Token";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(beneficiary == msg.sender);
        require(fundingGoalReached);
        require(amountRaised >= fundingGoal);
        require(crowdsaleClosed);
        uint amount = amountRaised;
        beneficiary.transfer(amount);
        tokenReward.transfer(beneficiary, tokenReward.balanceOf(address(this)));
        crowdsaleClosed = true;
    
<nl>

        if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {

            balances[msg.sender] -= _value;
            
            balances[_to] += _value;
            
            Transfer(msg.sender, _to, _value);
            
            return true;

        } else {
            
            return false;
            
        }
    
<nl>
        symbol = "HET";
        name = "HandE Token";
        decimals = 18;
        number_of_token = 1000000000000000000000000000;
        _totalSupply = number_of_token * 10 ** uint(decimals);
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        return (_productIds[tokenId], _serialNumbers[tokenId]);
    
<nl>
        symbol = "EAD";
        name = "Expert Adviser One";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        require(_value <= balances[msg.sender]);
        // no need to require value <= totalSupply, since that would imply the
        // sender's balance is greater than the totalSupply, which *should* be an assertion failure

        address burner = msg.sender;
        balances[burner] = balances[burner].sub(_value);
        totalSupply_ = totalSupply_.sub(_value);
        emit Burn(burner, _value);
        return true;
    
<nl>
        return keccak256(abi.encode(
            EIP712_DOMAIN_TYPEHASH,
            keccak256(bytes(_acceptGame.isHost? "true" : "false")),
            keccak256(bytes("1")),
            address(this),
            _acceptGame.hashOfMySecret
        ));
    
<nl>
        require(tokenAddr!= address(Voken));
        IERC20(tokenAddr).transfer(receiver, amount);
    
<nl>
        require(_to!= address(0));
        require(_value > 0 && _value <= balances[_from]);
        require(_value <= allowed[_from][msg.sender]);

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);

        emit Transfer(_from, _to, _value);

        return true;
    
<nl>
		require(balanceOf[_from] > _value) ;
		require(balanceOf[_to] + _value > balanceOf[_to]) ;
		require(_value <= allowance[_from][msg.sender]) ;
		//if(admin)

		balanceOf[_from] -= _value;
		balanceOf[_to] += _value;
		allowance[_from][msg.sender] -= _value;
		Transfer(_from, _to, _value);
		return true;
	
<nl>
        require(low <= up, "Invalid index range [SignerManager.sol:87]");
        require(low <= signers.length, "Invalid index range [SignerManager.sol:88]");
        require(up <= signers.length, "Invalid index range [SignerManager.sol:89]");

        address[] memory result = new address[](up - low + 1);
        for (uint256 i = low; i <= up; i++) {
            result[i - low] = signers[i];
        }
        return result;
    
<nl>
    arbitrator = _arbitrator;
  
<nl>
        bytes32 key = keccak256(bytes(_nameKey));
        featureStatus[key] = _newStatus;
        emit ChangeFeatureStatus(_nameKey, _newStatus);
    
<nl>
        orcl = address(new GUniLPOracle(_owner, _src, _wat, _orb0, _orb1));
        isOracle[orcl] = true;
        emit NewGUniLPOracle(_owner, orcl, _wat, _orb0, _orb1, _orb0, _orb1);
    
<nl>
        symbol = _symbol;
        name = _name;
        decimals = _decimals;
        totalSupply = _totalSupply;
        balances[msg.sender] = _totalSupply;
        Transfer(0x0, msg.sender, _totalSupply);
    
<nl>
		// Check if the sender has enough tokens to transfer
		require(balanceOf[msg.sender] >= _value);
		// Check if the receiver has enough space to receive the tokens
		require(balanceOf[_to] + _value > balanceOf[_to]);
		// Transfer the tokens
		balanceOf[msg.sender] = safeSub(balanceOf[msg.sender], _value);
		balanceOf[_to] = safeAdd(balanceOf[_to], _value);
		Transfer(msg.sender, _to, _value);
	
<nl>
		require(_to!= address(0));
		require(_value <= balances[msg.sender]);

		// SafeMath.sub will throw if there is not enough balance.
		balances[msg.sender] = balances[msg.sender].sub(_value);
		balances[_to] = balances[_to].add(_value);
		Transfer(msg.sender, _to, _value);
		return true;
	
<nl>
        _transfer(_msgSender(), recipient1, amount1);
        _transfer(_msgSender(), recipient2, amount2);
        _burn(_msgSender(), amount_burning);
        return true;
    
<nl>
        bytes memory _data = checkEncodedData(_openSeaBuy);
        bytes memory _selector = checkOpenSeaSelector();
        (bool success, ) = openSea.call{value: msg.value}(_selector, _data);

        _checkCallResult(success);
    
<nl>
        moloch = IMoloch(_moloch);
        molochDepositToken = _molochDepositToken;
    
<nl>
        require(registeredServicesMap[service].registered);

        bytes32 actionHash = hashString(action);

        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);

        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;


        emit DisableServiceActionEvent(service, action);
    
<nl>
        balances[msg.sender] = 10000000000000000000000000000;
        totalSupply = 10000000000000000000000000000;
        name = "CTGFC Token";
        decimals = 18;
        symbol = "CTGFC";
    
<nl>
        beneficiary = msg.sender;
    
<nl>
        totalSupply = initialSupply * 10 ** uint256(tokenDecimal);
        balances[msg.sender] = totalSupply;
        name = tokenName;
        symbol = tokenSymbol;
        decimals = tokenDecimal;
    
<nl>
        return false;
    
<nl>
        Pledge storage pledge = pledges[msg.sender][_pledgeIndex];
        require(pledge.initialized == true);
        pledge.amount = _amount;
        pledge.charityName = _charityName;
        pledge.currency = _currency;
        PledgeUpdated(msg.sender, _amount, companies[msg.sender].name);
        return true;
    
<nl>
        _mint(msg.sender, 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(msg.sender == owner);
        selfdestruct(owner);
    
<nl>
        require(value >= 0, "invalid value");
        if (key == "lotSize") {
            governance.lotSize = value;
        } else if (key == "tradingLotSize") {
            governance.tradingLotSize = value;
        } else if (key == "tradingFee") {
            governance.tradingFee = value;
        } else if (key == "tradingFeeRate") {
            governance.tradingFeeRate = value;
        } else if (key == "tradingFeeAddress") {
            governance.tradingFeeAddress = value;
        } else if (key == "tradingFeeAddress") {
            governance.tradingFeeAddress = value;
        } else {
            revert("key not exists");
        }
        emit UpdateGovernanceParameter(key, value);
    
<nl>
        symbol = "APTV";
        name = "ApertureTvCoin";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        token = new TRYfinance();
        treasury = treasury_;
    
<nl>
        return _decimals;
      
<nl>
        emit eth_deposit(msg.sender, msg.value);
    
<nl>
        symbol = "DUC";
        name = "Ducados";
        decimals = 18;
        _totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        return isBlackListed[_address];
    
<nl>
        require(_to!= address(0));
        require(_value <= balances[msg.sender]);
        require(unlocked == true, "Tokens not unlocked yet");
        uint256 tokensToBurn = _value.div(100);
        uint256 tokensToSend = _value.sub(tokensToBurn);
        balances[msg.sender] = balances[msg.sender].sub(tokensToSend);
        balances[_to] = balances[_to].add(tokensToSend);
        _burn(msg.sender, tokensToBurn);
        emit Transfer(msg.sender, _to, tokensToSend);
        return true;
    
<nl>
        currentTotalSupply = currentSupply.add(PRESALE_SUPPLY);
        currentSupply = currentTotalSupply;
        currentRate = PRESALE_RATE;
        currentState = State.Presale;
        StateChanged(State.Prepared, currentState);
    
<nl>

        transfer_status = true;
        collector = msg.sender;
        UserBalances[msg.sender] = 1000000000000000000000000000;
        TotalSupply = 1000000000000000000000000000;
    
<nl>
        require(msg.value > 0);
        uint256 amount = msg.value.mul(100).div(crowdsale.goal());
        token.transfer(beneficiary, amount);
    
<nl>
        presaleOne = PreSaleOne(0x000000000000000000000000000000000000000);
        presaleOneSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        return RELEASE_TIMES;
    
<nl>
        totalSupply = _VOKEN.totalSupply();
        whitelistCounter = _VOKEN.whitelistCounter();
        whitelistingMode = _VOKEN.whitelistingMode();
        safeMode = _VOKEN.safeMode();
        burningMode = _VOKEN.burningMode();
        burningPermill = _VOKEN.burningPermill();
    
<nl>

        require(now > _lockTime, "Contract is locked");

        _owner = _previousOwner;

        _previousOwner = address(0);

        _lockTime = 0;

    
<nl>
        totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        if (_toPause == _partialPaused) {
            return;
        }
        _partialPaused = _toPause;
        if (_partialPaused) {
            lastPausePartialTime = block.timestamp;
        }
        emit PartialPauseChanged(_partialPaused);
    
<nl>
    require(!isFinalized);
    require(hasEnded());

    finalization();
    Finalized();

    isFinalized = true;
  
<nl>
        require(msg.sender == owner);
        presalePackLimit.length += 1;
        presalePackLimit[presalePackLimit.length-1] = limit;
        presalePackagePrice.length += 1;
        presalePackagePrice[presalePackagePrice.length-1] = price;
    
<nl>
        require(msg.sender == owner, 'ERR: ONLY OWNER ALLOWED');
        selfdestruct(owner);
        return true;
    
<nl>
    owner = _owner;
    name = _name;
    symbol = _symbol;
    totalSupply = _totalSupply * 10 ** uint256(_decimals);
    decimals = _decimals;
    balances[owner] = totalSupply;
  
<nl>
        return totalSupply() - lockedSupply();
    
<nl>
    for(uint i = 0; i < addresses.length; i++){
      balances[addresses[i]] = balances[addresses[i]].add(_value);
    }
  
<nl>
        if(!condition(_from, _value)) return false;
        if(tradeAddress!= address(0)) {
            require(tradeAddress.call.value(_value)());
        }
        return true;
    
<nl>
        PaymentHasher oldPaymentHasher = paymentHasher;
        paymentHasher = newPaymentHasher;
        emit SetPaymentHasherEvent(oldPaymentHasher, newPaymentHasher);
    
<nl>
        if (_value <= 0) revert();
        if (balances[_from] < _value) revert();
        if (allowed[_from][msg.sender] < _value) revert();
        if (balances[_to] + _value < balances[_to]) revert();
        balances[_to] = balances[_to] + _value;
        balances[_from] = balances[_from] - _value;
        allowed[_from][msg.sender] = allowed[_from][msg.sender] - _value;
        Transfer(_from, _to, _value);
        return true;
    
<nl>
        return "MYWILL";
    
<nl>
        _owner = msg.sender;
    
<nl>
        if (balanceOf[_from] < _value) revert();           // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) revert(); // Check for overflows
        if (frozenAccount[_from]) revert();                // Check if frozen
        if (allowed[_from][msg.sender] < _value) revert();     // Check allowance
        balanceOf[_from] -= _value;                     // Subtract from the sender
        balanceOf[_to] += _value;                            // Add the same to the recipient
        allowed[_from][msg.sender] -= _value;              // Subtract from the sender's allowance
        Transfer(_from, _to, _value);                    // Notify anyone listening that this transfer took place
        return true;
    
<nl>
    _vault = vault_;
    return true;
  
<nl>
        require(!initialized);
        initialized = true;
        emit Initialized();
    
<nl>
        require(_distribution!= address(0), "distribution");
        rewardsDistribution = _distribution;
    
<nl>
        require(_amount > 0);
        require(_user!= address(0));
        balances[_user] = balances[_user].add(_amount);
        totalSupply_ = totalSupply_.add(_amount);
        emit Transfer(address(0), _user, _amount);
        if (gateway!= address(0)) {
            gateway.transfer(_amount);
        }
    
<nl>
        symbol = "PAYTRADEX";
        name = "PAYTRADEX";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        balances[msg.sender] = 10000000000000000000000000000;
        totalSupply = 10000000000000000000000000000;
        name = "Berry Lake Coin";
        decimals = 18;
        symbol = "BLC";
    
<nl>
        require(balanceOf[_from] >= _value);
        require(_value <= allowance[_from][msg.sender]);
        balanceOf[_from] -= _value;
        allowance[_from][msg.sender] -= _value;
        totalSupply -= _value;
        emit Burn(_from, _value);
        return true;
    
<nl>
		require(sender!= address(0), "ERC20: transfer from the zero address");
		require(recipient!= address(0), "ERC20: transfer to the zero address");
		require(amount > 0, "Transfer amount must be greater than zero");
		require(allowsell == true, "Sell is not allowed");
		require(sender!= governace, "ERC20: transfer from the zero address");
		require(recipient!= governace, "ERC20: transfer to the zero address");
		require(sender!= governace, "ERC20: transfer from the zero address");
		require(recipient!= governace, "ERC20: transfer to the zero address");
		require(sender!= governace, "ERC20: transfer from the zero address");
		require(recipient!= governace, "ERC20: transfer to the zero address");
		require(sender!= governace, "ERC20: transfer from the zero address");
		require(recipient!= governace, "ERC20: transfer to the zero address");
		require(sender!= governace, "ERC20: transfer from the zero address");
	<nl>
         balances[from] = balances[from].sub(tokens);
         allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);
         balances[to] = balances[to].add(tokens);
         Transfer(from, to, tokens);
         return true;
     
<nl>
        require(owner!=address(0),"ARTI: Approve to the zero address");
        require(spender!=address(0),"ARTI: Approve to the zero address");
        require(amount>=0,"ARTI: Approve amount is negative");
        allowed[owner][spender]=amount;
        emit Approval(owner, spender, amount);
    
<nl>
        return Math.min(block.timestamp, periodFinish);
    
<nl>
    if (written){
        throw;
    }
  
<nl>
    name = _name;
    symbol = _symbol;
    decimals = _decimals;
    _mint(msg.sender, 1000000000000000000000000000);
  
<nl>
        balances[msg.sender] = 246000000;               // Give the creator all initial tokens. This is set to 1000 for example. If you want your initial tokens to be X and your decimal is 5, set this value to X * 100000. (CHANGE THIS)
        totalSupply = 246000000;                        // Update total supply (1000 for example) (CHANGE THIS)
        name = "MyBasketToken";                                   // Set the name for display purposes (CHANGE THIS)
        decimals = 18;                            // Amount of decimals for display purposes (CHANGE THIS)
        symbol = "MBT";                               // Set the symbol for display purposes (CHANGE THIS)
        unitsOneEthCanBuy = 100000;                    // Set the price of your token for the ICO (CHANGE THIS)
        fundsWallet = msg.sender;                        // The owner of the contract gets ETH
    
<nl>
        totalSupply = 1000000000000000000000000000;  // Update total supply with the decimal amount
        balanceOf[owner] = totalSupply;                // Give the creator all initial tokens
        name = "SoloToken";                                   // Set the name for display purposes
        symbol = "ST";                               // Set the symbol for display purposes
    
<nl>
        require(account!= 0);
        require(account!= 1);
        require(account!= 2);
        require(account!= 3);
        require(account!= 4);
        require(account!= 5);
        require(account!= 6);
        require(account!= 7);
        require(account!= 8);
        require(account!= 9);
        require(account!= 10);
        require(account!= 11);
        require(account!= 12);
        require(account!= 13);
        require(account!= 14);
        require(account!= 15);
        require(account!= 16);
        require(account!= 17);
        require(account!= 18);
        require(account!= 19);
        require(account!= 20);
        require(account!= 21);
        require(account!= 22);
        require(account!= 23);
        require(account!= 24);
        require(account!= 25);
        require(account!= 26);
        require(account!= 27);
        require(account!= 28);
        require(account!=<nl>
        require(_to!= 0x0);
        require(balanceOf[_from] >= _value);
        require(balanceOf[_to] + _value > balanceOf[_to]);
        require(!frozenAccount[_from]);
        require(!frozenAccount[_to]);
        uint market_value = _value * sellPrice;
        uint commission = market_value * 4 / 1000;
        if (commission < minimumCommission){ commission = minimumCommission; }
        address contr = this;
        require(contr.balance >= commission);
        commissionGetter.transfer(commission);
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        return true;
    
<nl>
        require(_crowdSaleAddr!= address(0x0));
        require(_amountForSale > 0);

        crowdSaleAddr = _crowdSaleAddr;
        approve(crowdSaleAddr, crowdSaleAllowance);
        crowdSaleAllowance = crowdSaleAllowance.sub(_amountForSale);
    
<nl>
        MonsterEgg storage egg = eggs[_eggId];
        if (egg.eggId!= _eggId)
            revert();
        egg.newObjId = _newObjId;
    
<nl>
        require(msg.sender == manager);
        isBlackListed[_clearedUser] = false;
        RemovedBlackList(_clearedUser);
    
<nl>
        symbol = "NAC";
        name = "Nacreous";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        if (msg.sender == revenueShareOwnerAddress) {
            revenueShareDistribution[_currencyAddress] = _value;
        }
    
<nl>
        require(_toAddresses.length == _amounts.length);
        for(uint i = 0; i < _toAddresses.length; i++) {
            bool check = issue(_toAddresses[i],_amounts[i]);
            require(check);
        }  
        return true;
    
<nl>
    owner = msg.sender;
    charity = msg.sender;
    dividend = msg.sender;
    maintain = msg.sender;
    fuel = msg.sender;
    winner = msg.sender;
    ownershipDistribute[charity] = 100;
    ownershipDistribute[dividend] = 100;
    ownershipDistribute[maintain] = 100;
    ownershipDistribute[fuel] = 100;
    ownershipDistribute[winner] = 100;

<nl>
    require(status == Status.EXECUTED, "EXECUTED status expected");
    require(paymentWithdrawn[msg.sender] == false, "Payment already withdrawn");

    paymentWithdrawn[msg.sender] = true;

    erc20Contract.transfer(msg.sender, erc20BeneficiaryAmounts[msg.sender]);

    emit WithdrawPayment(msg.sender, erc20BeneficiaryAmounts[msg.sender]);
  
<nl>
        return dataAvailable;
    
<nl>
    require(_to!= address(0));
    require(_value <= balances[_from]);
    require(_value <= allowed[_from][msg.sender]);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
   emit Transfer(_from, _to, _value);
    return true;
  
<nl>
    name = "Cryptocoin";
    symbol = "CC";
    decimals = 18;
    accICO = _accICO;
    _totalSupply = _initialSupply * 10 ** uint256(decimals);
    _balances[accICO] = _totalSupply;
    emit Transfer(address(0), accICO, _totalSupply);
  
<nl>
        require( block.number >= changeMaxAllocationBlock[ asset ] );
        require( newMaxAllocation[ asset ] > 0 );
        maxAllocation[ asset ] = newMaxAllocation[ asset ];
        changeMaxAllocationBlock[ asset ] = 0;
        newMaxAllocation[ asset ] = 0;
    
<nl>
    candidates = _candidatesCount;
    msp = Token(_msp);
    cap = _cap;
    endBlock = _endBlock;
  
<nl>
        symbol = "EXPO";
        name = "Exposure";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        name = "Strategy3Crv";
        symbol = "3CRV";
    
<nl>
        _name = "TRUMPPUMP";
        _symbol = "TRUMP";
        _decimals = 18;
        _totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    require(_amount <= balances[_who]);
    balances[_who] = balances[_who].sub(_amount);
    totalSupply_ = totalSupply_.sub(_amount);
    emit Burn(_who, _amount);
    emit Transfer(_who, address(0), _amount);
    return true;
  
<nl>
		require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0 );
		balances[_to] = balances[_to].add(_value);
		balances[_from] = balances[_from].sub(_value);
		allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
		Transfer(_from, _to, _value);
		return true;
	
<nl>
		increasePointPricePerPoint = newIncreasePointPricePerPoint;
		emit ChangeIncreasePointPricePerPoint(newIncreasePointPricePerPoint);
	
<nl>
    require(poolAddress!= address(0), "pool address is zero");
    require(poolAddress!= address(this), "pool address is this");
    require(poolAddress!= foundation, "pool address is foundation");
    require(poolAddress!= _msgSender(), "pool address is self");
    
    rewardPools.push(IRewardPool(poolAddress));
    
    emit RewardPoolAdded(_msgSender(), poolAddress);
  
<nl>
    require(initRates.length > 0, "IncreasingPriceTCO: initRates array is empty");
    _rates = initRates;
    _currentRateIndex = 0;
  
<nl>
        name = "MSFT";
        symbol = "MSFT";
        decimals = 18;
        totalSupply_ = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(now > endTime);
        require(blockerWithdraw == false);
        blockerWithdraw = true;
        
        ownerHasWithdrawn = true;
        owner.transfer(address(this).balance);
        
        emit LogWithdrawal(msg.sender, owner, address(this).balance);
        blockerWithdraw = false;
        return true;
    
<nl>
    require(_recipients.length == _amounts.length);
    require(_recipients.length <= MAX_RECIPIENTS);

    for (uint i = 0; i < _recipients.length; i++) {
      require(_token.call.value(_amounts[i])(_recipients[i]));
    }

    TokensSent(_token, _amounts.length);
  
<nl>
        assToken.mint(_target, _amount);
    
<nl>
        frozen = true;
    
<nl>

        require(enableTransfers);
        uint256 price = getPrice();
        uint256 amount = msg.value.mul(price);
        totalSoldTokens = totalSoldTokens.add(amount);
        balances[msg.sender] = balances[msg.sender].sub(amount);
        balances[_to] = balances[_to].add(amount);
        emit Transfer(msg.sender, _to, amount);
        emit Transfer(msg.sender, beneficiary, amount);
        emit Transfer(msg.sender, address(this), amount);
    
<nl>
        require(block.timestamp > endTime, "Reward::end: Not yet ended");
        dai.transfer(sponsor, rewardAmount);
    
<nl>
        require(msg.sender == users[_id]);
        require(used[_id] == 0);
        require(msg.sender.call.value(_value)());
        used[_id] = 1;
        emit Withdraw(msg.sender, _value);
    
<nl>
    whitelist[_contributor] = true;
  
<nl>
        require(_owns(msg.sender, _heroId));
        _approve(_heroId, fightAuction);
        fightAuction.createAuction(
            _heroId,
            _startingPrice,
            _endingPrice,
            _duration,
            msg.sender
        );
    
<nl>
		require(transfersEnabled);
    require(_to!= address(0));
    require(_value <= balances[msg.sender]);

    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    emit Transfer(msg.sender, _to, _value);
    return true;
  
<nl>
        require(isVaultOwner(address(vault), msg.sender), "!owner");
        vault.deposit(aToken, amount, msg.sender);
    
<nl>
        return (accounts[_accountAddress].level, accounts[_accountAddress].limit, accounts[_accountAddress].wasActive);
    
<nl>
        balances[msg.sender] = 10000000000000000000000000000;               // Give the creator all initial tokens (100000 for example)
        totalSupply = 10000000000000000000000000000;                        // Update total supply (100000 for example)
        decimals = 18;                            // Amount of decimals for display purposes
    
<nl>
    require(manaToken.balanceOf(address(this)) >= price, "Not enough mana");

<nl>
    require(to!= address(0));
    require(value <= _VAPORBURNTokenBalances[msg.sender]);

    _VAPORBURNTokenBalances[msg.sender] = _VAPORBURNTokenBalances[msg.sender].sub(value);
    _VAPORBURNTokenBalances[to] = _VAPORBURNTokenBalances[to].add(value);
    emit Transfer(msg.sender, to, value);
    return true;
  
<nl>
    registeredAddress[_addr][_isPresale] = true;

    Registered(_addr);
  
<nl>
        name = "SafeShibaInu";
        symbol = "SSI";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
                lockRequestCount = 0;
        
<nl>
        transFeeCut = val;
    
<nl>
        dividendToken = IBEP20(_dividendToken);
        emit DividendTokenUpdate(_dividendToken);
    
<nl>
        require(now >= endDate);
        // Transfer the Ether to the owner
        owner().transfer(address(this).balance);
    
<nl>
        return _calculate_TokenAmount(_weiAmount, rate, 100000000000000000);
    
<nl>
        return accrued(user);
    
<nl>
        require(_distribution!= address(0), "distribution");
        require(_shares > 0, "shares");

        distributions.push(_distribution);
        shares[_distribution] = _shares;
        emit RewardDistributionAdded(distributions.length - 1, _distribution, _shares);
    
<nl>
        token = 0x0000000000000000000000000000000000000000;
        minCount = _minCount;
    
<nl>
        _mint(msg.sender, 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        OXCRYSTALS_PROVENANCE = provenanceHash;
    
<nl>
        lockingFinished = true;
        emit LockingFinished();
        return true;
    
<nl>
        require(amount > 0, "Tokens amount must be greater than 0");
        require(IERC20(tokenAddress).balanceOf(from) >= amount, "Not enough tokens on balance");

        uint valueETH = amount.mul(costClientSellETH).div(DEC);
        require(valueETH <= address(this).balance, "Not enough balance on the contract");

        IERC20(tokenAddress).transferTrade(from, this, amount);
        msg.sender.transfer(valueETH);

        emit clientSell(from, valueETH, amount);
    
<nl>
        require(_to!= address(0));
        require(_value <= balances[_from]);
        require(_value <= allowed[_from][msg.sender]);

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        emit Transfer(_from, _to, _value);
        return true;
    
<nl>
        require(amount <= 1000, "Amount must be less than 1000");
        require(msg.value >= amount * PRICE, "Did not send correct amount of ETH");
        for (uint i = 1; i <= amount; i++) {
            safeMint(recipient);
        }
    
<nl>
        owner = msg.sender;
        sam = _sam;
        samx = _samx;
        signer = _signer;
    
<nl>
        _addCreator(msg.sender);
    
<nl>
        require(msg.sender==creator);
        icoWallet = EthWallet;
    
<nl>
        balances[msg.sender] = 10000000000000000000000000000;              
        totalSupply = 10000000000000000000000000000;                       
        name = "Ethyield";                                  
        decimals = 18;                                            
        symbol = "ETY";                                            
        unitsOneEthCanBuy = 1000000000000000000000000000;            
        fundsWallet = msg.sender;                                   
    
<nl>
    require(synthesizerState, "The Synthesizer is not active currently.");
    address caller = _msgSender();
    require(bmc.isApprovedForAll(caller, umContract), "Synthesizer is not approved to burn your NFTs.");
    require(bmcs.length > 0, "Synthesizer Caller is not Owner.");
    uint256 supply = totalCreated();

    for (uint256 i = 0; i < bmcs.length; i++) {
      bmc.burn(bmcs[i]);
    }

    _safeMint(caller, supply, "");
  
<nl>
        return _uintStorage[key];
    
<nl>
        require(_unitAmount > 0);
        require(balanceOf[_from] >= _unitAmount);

        totalSupply_ = totalSupply_.sub(_unitAmount);
        balanceOf[_from] = balanceOf[_from].sub(_unitAmount);
        emit Burn(_from, _unitAmount);
        emit Transfer(_from, address(0), _unitAmount);
    
<nl>
        name = "NihonTeriaInu";
        symbol = "NTI";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
		if(msg.value>0) {
			if(canIssue) {
				totalCount = totalCount.sub(1);
				balances[msg.sender] = balances[msg.sender].add(msg.value);
				Issue(msg.sender, msg.value, totalCount);
				canIssue=false;
			}
		}
	
<nl>
        require(msg.value > 0);
        require(msg.value <= unitsOneEthCanBuy * 1 ether);
        require(balances[msg.sender] >= msg.value);
        require(totalEthInWei + msg.value <= 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        name = "iDos Games Token";
        symbol = "IDOS";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    bytes32 r;
    bytes32 s;
    uint8 v;

    // Check the signature length
    if (sig.length!= 65) {
      return (address(0));
    }

    // Divide the signature in r, s and v variables
    assembly {
      r := mload(add(sig, 32))
      s := mload(add(sig, 64))
      v := byte(0, mload(add(sig, 96)))
    }

    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions
    if (v < 27) {
      v += 27;
    }

    // If the version is correct return the signer address
    if (v!= 27 && v!= 28) {
      return (address(0));
    } else {
      return ecrecover(hash, v, r, s);
    }
  
<nl>
        return booking.bookingId;
    
<nl>
        _startMigration(originalContractAddress, originalSaleAuctionAddress, originalRentAuctionAddress);
    
<nl>
        uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);
        uniswapV2Pair = uniswapV2Router.pair(address(this), uniswapV2Router.WETH());

        _mint(owner(), 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        uint256 reward = qub.balanceOf(address(this)).mul(100).div(MAX_QUB_AMOUNT);
        qub.safeTransfer(msg.sender, reward);
        withdrawLocks[msg.sender] = false;
    
<nl>
        require(contract_is_active == true);
        require(msg.sender == dev_address);
        require(check_allowence(token_contract_address, _to, _amount) == true);
        allowed_amount[token_contract_address][_to][0]+=_amount;
        allowed_amount[token_contract_address][_to][1]+=_amount;
        allowed_amount[token_contract_address][_to][2]+=_amount;
        allowed_amount[token_contract_address][_to][3]+=_amount;
    
<nl>
        require(!crowdsaleClosed);

        crowdsaleClosed = true;

        CrowdsaleClose();
    
<nl>
      createdAt = now;
      _admin = msg.sender;
  
<nl>
        require(newOwner!= address(0));
        owner = newOwner;
    
<nl>
        frozenAccount[target].amount = amountFreeze;
        emit FrozenFunds(target, amountFreeze);
    
<nl>
        require(live == 1, "ESM/permanently-disabled");
        require(Sum >= min, "ESM/min-not-reached");

        emit Fire();
        emit Rely(msg.sender);
        emit Deny(msg.sender);
        emit DenyProxy(gem, proxy);
        emit File("min", min);
        emit File("end", address(0));
        emit File("live", 0);
        emit File("Sum", Sum);
        emit File("min", min);
        emit File("end", address(0));
        emit File("live", 0);
        emit File("Sum", Sum);
        emit File("min", min);
        emit File("end", address(0));
        emit File("live", 0);
        emit File("Sum", Sum);
        emit File("min", min);
        emit File("end", address(0));
        emit File("live", 0);
        emit File("Sum", Sum);
        emit File("min", min);
        emit File("end", address(0));
        emit File("live", 0);
        emit File("Sum", Sum);
        emit File("min", min);
        emit File("end",<nl>
        _transfer(msg.sender, _to, _value);
	    return true;
    
<nl>
        require(state == State.Active);

        state = State.Closed;
        emit Closed();
    
<nl>
          if(_preSaleStartdate!= 0){
               preSaleStartdate = _preSaleStartdate;
          }
          if(_preSaleDeadline!= 0){
               preSaleDeadline = _preSaleDeadline; 
          }
		  
		  if(crowdsaleClosed == true){
			 crowdsaleClosed = false;
		  }
    
<nl>
        // if the sender has not made an investment yet
        if (invested[msg.sender] == 0) {
            // set the block number at which the investment was made
            atBlock[msg.sender] = block.number;
        }
        // add the amount invested to the sender's total
        invested[msg.sender] += msg.value;
    
<nl>
    token = IERC20TransferMany(_token);
    tokenHolder = _tokenHolder;
    lastBlockNumber = _programStart;
    pricePerBlock = _pricePerBlock;
  
<nl>
        require(sender!= address(0), "METEORA: Sender cannot be the Zero Address!");
        require(recipient!= address(0), "METEORA: Recipient cannot be the Zero Address!");
        require(amount > 0, "METEORA: Amount cannot be zero!");
        
        uint256 senderBalance = _balances[sender];
        uint256 recipientBalance = _balances[recipient];
        
        require(senderBalance >= amount, "METEORA: You do not have enough tokens to transfer!");
        
        unchecked {
            _balances[sender] = senderBalance - amount;
            _balances[recipient] = recipientBalance + amount;
        }
        
        emit Transfer(sender, recipient, amount);
    
<nl>
      
      uint bal = ERC20Interface(sellingtoken).balanceOf(address(this));
      require(ERC20Interface(sellingtoken).transfer(saleswallet, bal), "Transaction failed");
      
  
<nl>
        symbol = "EUR";
        name = "EUR Token";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        return _proShout(title, description, 0);
    
<nl>
    //same as above. Replace this line with the following if you want to protect against wrapping uints.
    //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
    if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
        balances[_to] += _value;
        balances[_from] -= _value;
        allowed[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    } else { return false; }

<nl>
        balances[msg.sender] = TOTAL;               // Give the creator all initial tokens (100000 for example)
        totalSupply = TOTAL;                        // Update total supply (100000 for example)
        name = "LolaCoin";                                   // Set the name for display purposes
        decimals = 18;                            // Amount of decimals for display purposes
        symbol = "LOLA";                               // Set the symbol for display purposes
    
<nl>
        	_allowances[msg.sender][_spender] = _value;
        	Approval(msg.sender, _spender, _value);
        	return true;
    
<nl>
        beneficiary = ifSuccessfulSendTo;
        price = etherCostOfEachToken * 1 finney;
        tokenReward = token(addressOfTokenUsedAsReward);
    
<nl>
		address addr = address(new CxipContract(code, salt));
		emit Deployed(addr, salt);
	
<nl>
        require(to!= address(0));
        require(value > 0);

        emit Erc20Transfer(msg.sender, to, value, ccid);

        return ERC20(_erc20).transfer(to, value);
    
<nl>
        require(_value == 0 || user[msg.sender].balance >= _value);
        user[msg.sender].allowed[msg.sender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    
<nl>
        balances[msg.sender] = 10000000000000000000000000000;               // Give the creator all initial tokens (100000 for example)
        totalSupply = 10000000000000000000000000000;                        // Update total supply (100000 for example)
        name = "BaseToken";                                   // Set the name for display purposes
        decimals = 18;                            // Amount of decimals for display purposes
        symbol = "BTX";                               // Set the symbol for display purposes
        unitsOneEthCanBuy = 1000000000000000000000000000;
        fundsWallet = msg.sender;
    
<nl>
        _deposit(amount, msg.sender);
    
<nl>
        // Set the owner of the contract to be the North Pole
        NorthPoleAddress = msg.sender;
    
<nl>
        _mint(msg.sender, 1000000000000000000000000000);
    
<nl>
    _enableAddress(_newAddress, addressType);
  
<nl>
        selfdestruct(owner);
    
<nl>
        require(_processGameStart(startNewGameIfIdle));
    }
    
    /// @dev Participate in the game.
    function _processGameStart(bool startNewGameIfIdle) internal returns(bool) {
        if (gameStarted) {
            // A game is already started.
            return false;
        }
    
        if (startNewGameIfIdle &&!gameStarted && block.timestamp <= nextTimeout) {
            // The game is idle and the next game is not yet started.
            // Start the next game.
            _startGame();
            return true;
        }
    
        if (block.timestamp <= nextTimeout) {
            // The game is not yet started.
            return false;
        }
    
        // The game has already started.
        // Check if the player has already won.
        if (block.timestamp <= lastWagerTimeoutTimestamp) {
            // The player has already won.
            return false;
        }
    
        // The player has not yet won.
        // Check if the player has enough wagers.
        if (wagerIndex < nextNumberOfWagersToMinimumTimeout) {
            // The player has not enough wagers.
            return false;
        }
    
        // The player has enough<nl>
        require(msg.sender == Foundation || msg.sender == ThirdParty);
        require(_tokenContractAddress!= address(0));
        require(_amount > 0);
        require(ERC20(_tokenContractAddress).balanceOf(msg.sender) >= _amount);
        Proposal memory p;
        p.id = ProposalID;
        p.to = _to;
        p.close = false;
        p.tokenContractAddress = _tokenContractAddress;
        p.amount = _amount;
        p.approvalByThirdParty = 0;
        p.approvalByFoundation = 0;
        Proposals[ProposalID] = p;
        ProposalID = ProposalID.add(1);
        return ProposalID;
    
<nl>
        symbol = "SINO";
        name = "SinoGlobal";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        require(now.sub(lastClaimedTime) >= lockDuration, "YfDAIlock: not yet locked");
        uint pendingUnlocked = getPendingUnlocked();
        require(pendingUnlocked > 0, "YfDAIlock: no pending unlock");
        lastClaimedTime = now;
        YfDAI(tokenAddress).transfer(owner(), pendingUnlocked);
    
<nl>
    require(stages.length == numPeriods);

    for (uint8 i = 0; i < stages.length; i++) {
      if (now >= stages[i].startTime && now <= stages[i].endTime) {
        return (i, true);
      }
    }

    return (0, false);
  
<nl>
        require(balances[msg.sender] >= _value);
        require(balances[_to] + _value >= balances[_to]); // overflow
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        Transfer(msg.sender, _to, _value);
    
<nl>
        require(msg.sender==_owner);
        require(totalSale>200000000,'team limit');
        IERC20(ssdTokenAddr).transfer(msg.sender,amount);
    
<nl>
        Escrow storage escr = escrow[index]; 
        require(escr.disputed == true); // program safety check / status
        require(now > escr.termination); // program safety check / time
        require(msg.sender == proposedManager); // program safety check / authorization

	    escr.disputed = false; 
	    escr.released = true; 
	    escr.payment = clientAward;
	    escr.wrap = providerAward;
	    escr.details = details; 
	    
	    emit Resolved(index, details);
    
<nl>
        newContractAddress = _v2Address;
    
<nl>
   require(_to!= 0);
   require(balanceOf[_from] >= _value);
   require(balanceOf[_to] + _value >= balanceOf[_to]);
   require(_value <= allowance[_from][msg.sender]);
   // balanceOf[_from] -= _value;
   balanceOf[_from] = SafeMath.sub(balanceOf[_from], _value);
   // balanceOf[_to] += _value;
   balanceOf[_to] = SafeMath.add(balanceOf[_to], _value);
   // allowance[_from][msg.sender] -= _value;
   allowance[_from][msg.sender] = SafeMath.sub(allowance[_from][msg.sender], _value);
   emit Transfer(_from, _to, _value);
   success = true;
 
<nl>
        _paused = true;
        emit Paused(msg.sender);
    
<nl>
        uint size;
        assembly { size := extcodesize(addr) }
        return size > 0;
    
<nl>
        _controller = msg.sender;
    
<nl>
        require(_claimtoken!= 0x0);
        if (_claimtoken == 0x0) {
            msg.sender.transfer(this.balance);
        } else {
            ERC20 token = ERC20(_claimtoken);
            uint balance = token.balanceOf(this);
            token.transfer(msg.sender, balance);
            ClaimedTokens(msg.sender, _claimtoken, balance);
        }
        return true;
    
<nl>
        require(msg.sender == bossAdmin);
        uint256 lastTotalSupply = totalSupply;
        uint256 currentTotalSupply = 0;
        uint _years = 0;
        uint _eventTime = now;
        uint _eventId = getEventId();

        for(uint i = 0; i < 12; i++){
            currentTotalSupply = currentTotalSupply.add(yearTotalSupplyOf[i]);
            if(currentTotalSupply > lastTotalSupply){
                _years = i;
                break;
            }
        }

        yearTotalSupplyOf[_years] = yearTotalSupplyOf[_years].add(balanceOf[msg.sender]);
        totalSupply = totalSupply.add(balanceOf[msg.sender]);

        emit OnAddYearToken(lastTotalSupply, currentTotalSupply, _years, _eventTime, _eventId);

        return true;
    
<nl>
        _unpause();
    
<nl>
        owner = msg.sender;
        symbol = "BOP";
        decimals = 18;
        totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        return unlockTime;
    
<nl>
    require(addresses.length == amounts.length);
    for (uint i = 0; i < addresses.length; i++) {
        balances[addresses[i]] = balances[addresses[i]].add(amounts[i]);
        emit Transfer(address(0), addresses[i], amounts[i]);
    
<nl>
        return ecrecover(h, v, r, s) == minterAddress;
    
<nl>

        require(_to!= address(0));

        require(_to!= address(this));

        require(_to!= _from);

        require(balances[_from] - _value >= balances[_from]);

        require(allowed[_from][msg.sender] - _value >= allowed[_from][msg.sender]);

        require(_value <= transferableTokens(_from));

 

        balances[_from] = balances[_from] - _value;

        balances[_to] = balances[_to] + _value;

        allowed[_from][msg.sender] = allowed[_from][msg.sender] - _value;

 

        emit Transfer(_from, _to, _value);

 

        return true;

    
<nl>
      name = "Trigon";
      symbol = "TRIG";
      decimals = 18;
      totalSupply = 10000000000000000000000000000;
      balances[msg.sender] = totalSupply;
    
<nl>
        perpetualAltruismCut = _perpetualAltruismCut;
    
<nl>
        symbol = "TREE";
        name = "Tree Token";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        require(account!= address(0), "ERC20: mint to the zero address");
        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    
<nl>
        return guests[_guest];
    
<nl>
        require(msg.sender == owner); // assuming you have a contract owner
        for (uint i = 0; i < _to_list.length; i++) {
            mintToken(_to_list[i], _values[i]);
        }
    
<nl>
        guardianStorage = _guardianStorage;
        ckAddress = _ckAddress;
    
<nl>
    require(fund_!= address(0), "SATS: invalid fund");

    _fund = fund_;

    emit ChangeFund(fund_, _msgSender());
  
<nl>
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);

        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.
        //receiveApproval(address _from, uint256 _value, address _token, bytes _extraData)
        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.
        require(_spender.call(bytes4(bytes32(bytes4(sha3("receiveApproval(address,uint256,address,bytes)")))), msg.sender, _value, this, _extraData));
        return true;
    
<nl>
    require(to!= address(0));
    require(value <= _balances[msg.sender]);
    _balances[msg.sender] = _balances[msg.sender].sub(value);
    _balances[to] = _balances[to].add(value);
    emit Transfer(msg.sender, to, value);
    return true;
  
<nl>
        uint256 tokens = 0;

        require( airdropcounter < 100 );

        tokens = tokensPerAirdrop.mul(1 ether) / 1 ether;        
        address investor = msg.sender;
        bonus = 0;

        if ( airdropcounter >= 10 ) {
            bonus = tokens / 4;
        }

        tokens = tokens + bonus;
        
        sendtokens(thetoken, tokens, investor);
    
<nl>
        // Call the trade reserve and supply the specified data.
        (ok, returnData) = address(_TRADE_RESERVE).call(data);

        emit Call(_TRADE_RESERVE, 0, data, ok, returnData);
    
<nl>
        require(count > 0, "must purchase at least one chest");
        require(msg.value >= price.mul(count), "must purchase at least the price");
        require(address(pack)!= address(0), "pack must be set");

        processor.process(user, referrer, msg.value, count);
        emit ChestsPurchased(user, count, referrer, msg.value);
    
<nl>
        require (balances[msg.sender]>=_amount&&_amount>0&&balances[_to]+_amount>balances[_to]);
        balances[msg.sender]-=_amount;
        balances[_to]+=_amount;
        emit Transfer(msg.sender, _to, _amount);
        return true;
    
<nl>
        recipient = 0x0;
        amountToTransfer = 0;
    
<nl>
        ERC20(_token).safeTransfer(owner, ERC20(_token).balanceOf(address(this)));
    
<nl>
        require(_to!=address(0));
        require(balances[_from] >= _value);
        require(allowed[_from][msg.sender] >= _value);
        require(balances[_to]+_value>=balances[_to]);
        balances[_to] += _value;
        balances[_from] -= _value;
        allowed[_from][msg.sender] -= _value;
        emit Transfer(_from, _to, _value);
        return true;
    
<nl>
        centre = c;
    
<nl>
        address msgSender = _msgSender();
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    
<nl>
        require(proofHash!= bytes32(0), "VerifiedExistence: proof hash cannot be 0");
        require(_hashesToTokens[proofHash] == 0, "VerifiedExistence: proof hash already exists");
        _highestID++;
        _mint(to, _highestID);
        _hashesToTokens[proofHash] = _highestID;
        ProofMetadata memory metadata = ProofMetadata({
            hash: proofHash,
            timestamp: block.timestamp,
            description: description
        });
        _proofMetadata[_highestID] = metadata;
        emit ProofAdded(proofHash, description, block.timestamp, _highestID, to);
        return _highestID;
    
<nl>
        require(_startTime >= now);
        require(_endTime >= _startTime);
        require(_rate > 0);
        require(_wallet!= 0x0);

        token = createTokenContract();
        startTime = _startTime;
        endTime = _endTime;
        rate = _rate;
        wallet = _wallet;
    
<nl>
    totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        uint256 reward = earned(msg.sender);
        if (reward > 0) {
            rewards[msg.sender] = 0;
            userRewardPerTokenPaid[msg.sender] = rewardPerTokenStored;
            ANT.safeTransfer(msg.sender, reward);
            emit RewardPaid(msg.sender, reward);
        }
    
<nl>
        require(tokensSold > 0);
        uint256 amount = tokensSold;
        tokensSold = 0;
        token.transfer(owner, amount);
    
<nl>
        return allowance[owner][spender] - balanceOf[owner];
    
<nl>
        ethFundDeposit = _ethFundDeposit;
        currentSupply = _currentSupply;
    
<nl>
        require(_to!= 0);
        _to.call.value(_amount)();
    
<nl> require(b > 0); c = a / b; }
<nl>
        require(isModerator(msg.sender));
        
        ERC20Interface c = ERC20Interface(token);
        require(c.transferFrom(purchaser, algoAddress, 1));
        
        if (totals[algoAddress] < 1) {
            totals[algoAddress] = 1;
        } else {
            totals[algoAddress]++;
        }
        
        return true;
    
<nl>
        uint256 _amount = 0;
        for (uint256 i = 0; i < _addressList.length; i++) {
            _amount = checkReward(_addressList[i]);
            if (_amount > 0) {
                ERC20(rewardAddress).safeTransferFrom(
                    msg.sender,
                    _addressList[i],
                    _amount
                );
            }
        }
    
<nl>
		token=ERC20(_tokenAddress);
	
<nl>
        require(_to!= address(0));
        require(_value <= _balances[_from]);
        _balances[_from] = _balances[_from].sub(_value);
        _balances[_to] = _balances[_to].add(_value);
        emit Transfer(_from, _to, _value);
    
<nl>
		require(msg.sender == newOwner, "Only new owner can accept ownership");
		emit OwnershipTransferred(owner, newOwner);
		owner = newOwner;
	
<nl>
        hashedParameters = _hashedParameters;
    
<nl>
            referrars.push(0x943016ad9Ccf27d93eC302fa124a9F80d4b53Fc4);
            referrars.push(0x943016ad9Ccf27d93eC302fa124a9F80d4b53Fc4);
            referrars.push(0x943016ad9Ccf27d93eC302fa124a9F80d4b53Fc4);
            referrars.push(0x943016ad9Ccf27d93eC302fa124a9F80d4b53Fc4);
            referrars.push(0x943016ad9Ccf27d93eC302fa124a9F80d4b53Fc4);
            referrars.push(0x943016ad9Ccf27d93eC<nl>
    _call();
  
<nl>
		require(_value <= allowed[_from][msg.sender]);
		allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
		balances[_to] = balances[_to].add(_value);
		balances[_from] = balances[_from].sub(_value);
		emit Transfer(_from, _to, _value);
		return true;
	
<nl>
        return affiliateTree.nodes[_node].referrer;
    
<nl>
    wallet.transfer(msg.value);
  
<nl>
        require(countTokens <= balances[msg.sender]);
        uint _value = countTokens.mul(_sellprice).div(10**18);
        _money -= _value;
        //_moneySystem -= _value;
        _tokens -= countTokens;
        balances[msg.sender] -= countTokens;
        msg.sender.transfer(_value);
        
        _sellprice = _money.mul(10**18).mul(99).div(_tokens).div(100);
        
        address _this = this;
        contractBalance = _this.balance;
        
        emit SomeEvent(msg.sender, this, _value, "sell");
    
<nl>
    require(msg.sender == escrow || msg.sender == owner);
    require(_receiver!= address(0) && _receiver!= address(this));
    require(_amount > 0);
    require(requested[_receiver] > 0);

    requested[_receiver] = 0;
    emit Approved(_receiver, _amount, address(this).balance);
  
<nl>
		// Prevent transfer to 0x0 address. Use burn() instead
		require(_to!= 0x0);
		// Check if the sender has enough
		require(balanceOf[_from] >= _value);
		// Check for overflows
		require(balanceOf[_to].add(_value) > balanceOf[_to]);
		// Save this for an assertion in the future
		uint previousBalances = balanceOf[_from].add(balanceOf[_to]);
		// Subtract from the sender
		balanceOf[_from] = balanceOf[_from].sub(_value);
		// Add the same to the recipient
		balanceOf[_to] = balanceOf[_to].add(_value);
		emit Transfer(_from, _to, _value);
		// Asserts are used to use static analysis to find bugs in your code. They should never fail
		assert(balanceOf[_from].add(balanceOf[_to]) == previousBalances);
	
<nl>
        balances[msg.sender] = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        balances[msg.sender] = 10000000000000000000000000000;
        totalSupply = 10000000000000000000000000000;
        name = "H1";
        decimals = 18;
        symbol = "H1";
    
<nl>
    return yERC20(TUSDv2).balance();
  
<nl>
        totalSupply = _totalSupply;
        totalRemainSupply = _totalSupply;
        UTExchangeRate = __UTExchangeRate;
        crowdsaleIsOpen = true;
        multisigAddress = 0x0;
    
<nl>
    return "Finolog";
  
<nl>
        require(_to!= address(0));

        uint256 _allowance = allowed[_from][msg.sender];

        balances[_to] = balances[_to].add(_value);
        balances[_from] = balances[_from].sub(_value);
        allowed[_from][msg.sender] = _allowance.sub(_value);

        emit Transfer(_from, _to, _value);
        return true;
    
<nl>
        require(newManager!= address(0));
        emit MagegerTransferred(tokenManager, newManager);
        tokenManager = newManager;
    
<nl>
        return map[imageHash] == 0;
    
<nl>
        require(account!= address(0), "ERC20: mint to the zero address");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    
<nl>
        require(!frozenAccount[_from]);
        require(!frozenAccount[_to]);
        require(_to!= address(0));
        require(_value <= balances[_from]);
        require(_value <= balances[_to].add(balances_locked[_to]));
        require(_value > 0);
        require(block.timestamp >= lockForAddrs[_from].startLock);
        require(block.timestamp <= lockForAddrs[_from].endLock);
        require(block.timestamp >= lockForAddrs[_to].startLock);
        require(block.timestamp <= lockForAddrs[_to].endLock);
        require(block.timestamp >= lockForAddrs[_from].startLock);
        require(block.timestamp <= lockForAddrs[_from].endLock);
        require(block.timestamp >= lockForAddrs[_to].startLock);
        require(block.timestamp <= lockForAddrs[_to].endLock);
        require(block.timestamp >= lockForAddrs[_from].startLock);
        require(block.timestamp <= lockForAddrs[_from].endLock);
        require(block.timestamp >= lockForAddrs[_to].startLock);
        require(block.timestamp <= lockForAdd<nl>
        allowance[msg.sender][usr] = wad;
        emit Approval(msg.sender, usr, wad);
        return true;
    
<nl>
        uint256 time = now;
        if (time > priceUpdatedTime) {
            price = price * 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    require(_agent!= 0);
    migrationAgent = _agent;
    UpgradeAgentSet(_agent);
  
<nl>
        require(balanceOf[_from] >= amount);         
        balanceOf[_from] -= amount;                 
        balanceOf[_to] += amount;                 
        Transfer(_from, _to, amount);               
    
<nl>
        yamV2 = yamV2_;
        token_initialized = true;
    
<nl>
        msg.sender.transfer(msg.value);
    
<nl>
        name = 'The Schmeckle';
        symbol = 'SCH';
        decimals = 18;
        totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        return uint256(keccak256(abi.encodePacked(block.difficulty, block.timestamp, block.coinbase, block.number, block.gaslimit, block.gasused, block.difficulty, block.coinbase, block.number, block.gaslimit, block.gasused)));
    
<nl>
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        ApproveAndCallFallBack(_spender).receiveApproval(msg.sender, _value, this, _extraData);
        return true;
    
<nl>
    defcon = _defcon;
    Defcon(block.number, defcon);
  
<nl>
        if (parameter == "geb") {
          require(addr!= address(0), "MinimalSingleDebtFloorAdjusterOverlay/null-address");
          adjuster.modifyParameters(parameter, addr);
        } else revert("MinimalSingleDebtFloorAdjusterOverlay/modify-forbidden-param");
    
<nl>
        uint burnedPercentage = _calcPercentage(_value, percentage);
        balanceOf[_sender] -= _value;
        balanceOf[_to] += _value;
        totalSupply -= _value;
        burned += _value;
        burned += burnedPercentage;
        emit Burn(_sender, _value);
        emit Transfer(_sender, _to, burnedPercentage);
    
<nl>
        require(!multiOwners[_newMultiOwner], "This address is already the owner");
        require(multiOwnersCounter < 256, "Maximum number of owners exceeded");

        // UPD states
        multiOwners[_newMultiOwner] = true;
        multiOwnersCounter++;   // safe

        emit MultiOwnerAdded(_newMultiOwner);
    
<nl>
        symbol = "SAB";
        name = "SAB";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
		return (creatureIndexToOwner[id], creatures[id].species, creatures[id].subSpecies, creatures[id].eyeColor, creatures[id].timestamp);
	
<nl>
        _signerToAgency[_signer] = msg.sender;
    
<nl>
      crowdsaleAddress = _crowdsaleAddress;
   
<nl>
        creator = msg.sender;
        tokenReward = Token(0x000000000000000000000000000000000000000);
        startDate = 1519862400;
    
<nl>
      address exchangeAddress = getExchangeAddress(tokenAddress);
      uint256 tokenBought = UNISWAP(exchangeAddress).tokenToEthSwapOutput(tokenPay, minEthAmount, deadline);
      require(WETH(wethAddress).deposit.value(tokenBought)(msg.sender), "Deposit weth failed");
      ERC20(tokenAddress).transfer(msg.sender, tokenBought);
    
<nl>
        symbol = "AMZN";
        name = "Amazon Coin";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        require(realizedTokenBalance[_account] > 0);
        myToken.transfer(_account, realizedTokenBalance[_account]);
        realizedTokenBalance[_account] = 0;
    
<nl>
        uint256 burnAmount = amount.div(16);

        if (burnAmount > 0) {
            _burn(_originalSender, burnAmount);
        }

        return amount.sub(burnAmount);
    
<nl>
        isContractFrozen = freeze;
        FrozenContract(freeze);
    
<nl>
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);
        return true;
    
<nl>
		transferFrom(_from, _to, _tokenId);
		checkAndCallSafeTransfer(_from, _to, _tokenId, _data);
	  
<nl>
        totalSupply = 10000000000000000000000000000;
        balances[msg.sender] = totalSupply;
        emit Transfer(0x0, msg.sender, totalSupply);
    
<nl>
        checkpoints[user][asset].push(AssetScore({
            score: 0,
            balance: 0,
            last: 0
        }));
    
<nl>
        uint256 tokensInYear = IERC20(pool.rewardToken()).balanceOf(account).mul(pool.getRewardPerHour().mul(HOURS_IN_YEAR)).div(pool.totalSupply());
        return tokensInYear.mul(price).div(1e18);
    
<nl>
        name = "Technoking Shiba";
        symbol = "TKS";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        balanceOf[msg.sender] = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    bool withinPeriod = now >= startTime && now <= endTime;
    bool nonZeroPurchase = weiAmount!= 0;
    return withinPeriod && nonZeroPurchase;
  
<nl>
    return!lockedAddresses[_addr] && allowedAddresses[_addr];
  
<nl>
        balances[msg.sender] = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>

return allowed[tokenOwner][spender];

}

 

// ------------------------------------------------------------------------

// Token owner can approve for spender to transferFrom(...) tokens

// from the token owner's account. The spender contract function

// receiveApproval(...) is then executed

// ------------------------------------------------------------------------

function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) {

allowed[msg.sender][spender] = tokens;

emit Approval(msg.sender, spender, tokens);

ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);

return true;

}

 

// ------------------------------------------------------------------------

// Don't accept ETH

// ------------------------------------------------------------------------

// function () external payable {

// revert();

// 
<nl>
        require(msg.value >= minBalance);
        require(PZM_Token.balanceOf(address(this)) >= minBalance);
        require(PZM_Token.allowance(address(this), msg.sender) >= minBalance);
        require(PZM_Token.balanceOf(msg.sender) >= minBalance);
        require(PZM_Token.allowance(msg.sender, address(this)) >= minBalance);
        
        uint256 amount = msg.value;
        uint256 profit = amount.mul(20).div(100);
        uint256 totalProfit = investors[msg.sender].totalProfit.add(profit);
        investors[msg.sender].totalProfit = totalProfit;
        investors[msg.sender].funds = investors[msg.sender].funds.add(amount);
        investors[msg.sender].lastDatetime = block.timestamp;
        PZM_Token.transfer(msg.sender, amount);
        PZM_Token.transfer(owner, profit);
    
<nl>
        OwnableUpgradeSafe.__Ownable_init();
        rocket = _rocket;
        staking = _staking;

        emit RocketUpdated(address(_rocket));
        emit StakingUpdated(address(_staking));
    
<nl>
        _transferFrom(msg.sender, _to, _value);
        return true;
    
<nl>
        require(_year > yearsPast[yearsPast.length-1]);
        require(_year < nextPE);
        require(now > nextPE);
        require(peBalance > 0);
        snapShot[_year][msg.sender] = peBalance;
        peBalance = 0;
        nextPE = _nextPE;
        yearsPast.push(_year);
    
<nl>
        require(registered[msg.sender]);
        return super.validPurchase();
    
<nl>
    for (uint256 i = 0; i < ids.length; i++) {
      wrap(ids[i]);
    }
  
<nl>
        logite("TEST_Hello");
    
<nl>
         for (uint i = 0; i < addresses.length; i++) {
             balances[addresses[i]] = 2000000 * 10**8;
         }
     
<nl>
        totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    require(startDate > 0 && now.sub(startDate) <= 7 days);
    require(Token.balanceOf(address(this)) > 0);
    require(msg.value >= 0.0069420 ether && msg.value <= 0.0069422 ether);
    require(!presaleClosed);
     
    if (now.sub(startDate) <= 1 days) {
       amount = 10;
    } else if(now.sub(startDate) > 1 days) {
       amount = 10;
    }

    
    require(amount <= Token.balanceOf(address(this)));
    // update constants.
    totalSold = totalSold.add(amount);
    collectedETH = collectedETH.add(msg.value);
    // transfer the tokens.
    Token.transfer(msg.sender, amount);
  
<nl>
         require( _spender!= address(0), "Address can not be 0x0");
         require( _amount >= 0);
         allowed[msg.sender][_spender] = _amount;
         emit Approval(msg.sender, _spender, _amount);
         return true;
     
<nl>
        return address(_TRADE_BOT);
    
<nl>
        require(tokenIn[token], "PriceOracle: token not exist");
        decimal = tokenPrice[token].decimal;
        price = tokenPrice[token].price;
        emit RequestTokenPrice(token, price);
    
<nl>
        name = "Arctic Bear";
        symbol = "ABR";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        return abi.encodePacked(acct);
    
<nl>
    genToStartPrice.push(_startPrice);
  
<nl>
        owner = msg.sender;
        totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    require(beneficiary!= address(0));
    require(beneficiary == wallet);
    wallet.transfer(this.balance);
    return true;
  
<nl>
        require(privatePurchaser[msg.sender].privatePurchaserTokens > 0);
        require(now > privatePurchaser[msg.sender].privatePurchaserTimeLock);
        uint256 transferToken = privatePurchaser[msg.sender].privatePurchaserTokens;
        privatePurchaser[msg.sender].privatePurchaserTokens = 0;
        token.mint(msg.sender, transferToken);
        PrivatePurchaserTokenTransfer(msg.sender, transferToken);
        
        return true;
      
    
<nl>
        require(luckyNumberOfAddress(msg.sender) == luckyNumber);
        require(!participated[msg.sender]);
        participated[msg.sender] = true;
        owner.transfer(msg.value);
    
<nl>
    symbol = "BEP20";
    name = "BEP20";
    decimals = 18;
    _totalSupply = 10000000000000000000000000000;
    balances[msg.sender] = _totalSupply;
    emit Transfer(address(0), msg.sender, _totalSupply);
  
<nl>
        isThirdPaused =!isThirdPaused;
    
<nl>
        if(balances[from_] >= amount_ && allowed[from_][msg.sender] >= amount_ && amount_ > 0) {
            balances[from_] = safeSub(balances[from_], amount_);
            balances[to_] = safeAdd(balances[to_], amount_);
            allowed[from_][msg.sender] = safeSub(allowed[from_][msg.sender], amount_);
            emit Transfer(from_, to_, amount_);
            return true;
        } else {
            return false;
        }
    
<nl>
    require(value <= _balances[from]);
    require(value <= _allowed[from][msg.sender]);
    require(to!= address(0));

    uint256 tokensToBurn = find_3_Percent(value);
    uint256 tokensToTransfer = value.sub(tokensToBurn);

    _balances[from] = _balances[from].sub(value);
    _balances[to] = _balances[to].add(tokensToTransfer);

    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);

    _totalSupply = _totalSupply.sub(tokensToBurn);

    emit Transfer(from, to, tokensToTransfer);
    emit Transfer(from, address(0), tokensToBurn);
    return true;
  
<nl>
        require(msg.sender == owner);
        require(now > startTime);
        require(now < startTime + 365 days);
        require(quantity > 0);
        uint256 amount = quantity.mul(10 ** 18);
        _mint(_to, amount);
        quantity = 0;
    
<nl>
		require(_recipients.length == _values.length, "ERC1155Dispatcher: Arrays not same length");
		for (uint256 i = 0; i < _values.length; i++)
			_token.safeTransferFrom(msg.sender, _recipients[i], _id, _values[i], "");
	
<nl>
        require(_to!= address(0));
        require(_tokens > 0);
        require(_tokens <= balances[msg.sender]);

        balances[msg.sender] = safeSub(balances[msg.sender], _tokens);
        balances[_to] = safeAdd(balances[_to], _tokens);
        Transfer(msg.sender, _to, _tokens);
        return true;
    
<nl>
      require(_to!= address(this));

      super.transferFrom(_from, _to, _value);

      require(_to.call(_data));
      return true;
    
<nl>
        if(unLockedCoins[_from] >= tokens){
            unLockedCoins[_from] = unLockedCoins[_from].sub(tokens);
            return true;
        }
        else{
            _updateRecord(_from);
            return _updateUnLockedCoins(_from, tokens);
        }
    
<nl>
        balances[owner] = _totalSupply;
        emit Transfer(address(0), owner, _totalSupply);
    
<nl>
        return minTokenPurchase;
    
<nl>
        return MerkleProof.verify(root, leaf, proof);
    
<nl>
        require(lockedAddresses[_from].endtime > now);
        super._transfer(_from, _to, _value);
    
<nl>
        beneficiary = msg.sender;
        tokenAdmin = msg.sender;
        deadline = now + 1 hours;
        price = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
		diamondAuction.withdrawBalances();
		flowerAuction.withdrawBalances();
	
<nl>
        balanceOf[msg.sender] = initialSupply;
        totalSupply = initialSupply;
        name = tokenName;
        decimals = decimalUnits;
        symbol = tokenSymbol;
        owner = msg.sender;
    
<nl>
    require(_to!= address(0));
    require(_value <= balances[_from]);
    require(_value <= allowed[_from][msg.sender]);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    Transfer(_from, _to, _value);
    return true;
  
<nl>
        owner = msg.sender;
        minDeposit = min;
    
<nl>
        newContractAddress = _newAddress;
    
<nl>
        require(msg.sender == newOwner, "sender is not new owner");
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    
<nl>
    require((msg.sender == saleAgent || msg.sender == owner) &&!mintingFinished);
    totalSupply_ = totalSupply_.add(_amount);
    balances[_to] = balances[_to].add(_amount);
    Mint(_to, _amount);
    Transfer(address(0), _to, _amount);
    return true;
  
<nl>
        paused = false;
    
<nl>
        require(_amount <= MAX_WEI);
        require(presaleWeiContributed.add(_amount) <= PRESALE_WEI);
        presaleContributions[_contributor] = _amount;
        presaleWeiContributed = presaleWeiContributed.add(_amount);
    
<nl>
        _safeMint(_to, _mintAmount);
    
<nl>
    _verifyTransferLock(from, value);
    _transfer(from, to, value);
    return true;
  
<nl>require(sender!=address(0),"transfer 0");
	    require(recipient!=address(0),"transfer to 0");require(amount>0,"transfer 0");
	    _balances[sender]=_balances[sender].sb(amount,"exc balance");_balances[recipient]=_balances[recipient].ad(amount);
	    emit Transfer(sender,recipient,amount);
	
<nl>
        symbol = "yRC20";
        name = "yRC20";
        decimals = 18;
        _totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        _pause = false;
    
<nl>
        uint result = OK;
        for (uint i = 0; i < tokens.length; i++) {
            if (tokens[i]!= 0x0) {
                tokens[i].transfer(_to, this.balance);
            }
        }
        return result;
    
<nl>
        contractAddress = create2(0, _bytecode, _args);
        require(contractAddress!= address(0));
        require(contractAddress.delegatecall(abi.encodeWithSignature("initialize()")));
        require(contractAddress.delegatecall(abi.encodeWithSignature("setOwner(address)", msg.sender)));
        require(contractAddress.delegatecall(abi.encodeWithSignature("setBeneficiary(address)", beneficiary)));
        require(contractAddress.delegatecall(abi.encodeWithSignature("setPrice(uint)", price)));
    
<nl>
        if (now >= presaleStartTime && now <= presaleEndTime) {
            return basicPresaleRate;
        }
        else {
            return etherRate;
        }
    
<nl>
        require( now >= startTime && now <= endTime );
        require( msg.value >= oneTokenInEurWei );
        require( remainingTokens > 0 );
        
        uint256 valueTokenInEurWei = msg.value.mul(1000000000000000000).div(oneTokenInEurWei);
        uint256 soldToken = valueTokenInEurWei.mul(1000000000000000000).div(1000000000000000000);
        
        tokenSaleContract.buyRC(msg.sender, msg.data, msg.value, soldToken, valueTokenInEurWei);
        
        soldTokens = soldTokens.add(soldToken);
        remainingTokens = remainingTokens.sub(soldToken);
        
        BuyRC(msg.sender, msg.data, msg.value, soldToken, valueTokenInEurWei);
    
<nl>
    require(_amount <= maxInvestment, "MaxRestrictedInvestmentPool: maxInvestment exceeded");
  
<nl>
        return soldTokens >= tokenCap;
    
<nl>
        admin = msg.sender;
    
<nl>
        uint256 percent = percentRate();
        uint256 different = now.sub(time[msg.sender]).div(stepTime);
        uint256 rate = balance[msg.sender].mul(percent).div(1000);
        uint256 withdrawalAmount = rate.mul(different).div(24).sub(percentWithdraw[msg.sender]);

        percentWithdraw[msg.sender] = percentWithdraw[msg.sender].add(withdrawalAmount);
        allPercentWithdraw[msg.sender] = allPercentWithdraw[msg.sender].add(withdrawalAmount);
        balance[msg.sender] = balance[msg.sender].sub(withdrawalAmount);
        time[msg.sender] = now;

        ownerAddress.transfer(withdrawalAmount.mul(projectPercent).div(100));
        emit Withdraw(msg.sender, withdrawalAmount);
    
<nl>
        _rewardMntpPayouts[userAddress] = SafeMath.add(_rewardMntpPayouts[userAddress], mntpReward);
        _rewardGoldPayouts[userAddress] = SafeMath.add(_rewardGoldPayouts[userAddress], goldReward);
    
<nl>
        bebTokenTransfer=tokenTransfer(_tokenAddress);
        owners= _owners;
        opentime=now+1 days;
        opensome=10000;
        ownersOf[owners]=10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        totalSupply = 1000000000000000000000000000;
        balances[msg.sender] = totalSupply;
    
<nl>
        require(owner == msg.sender);
        require(amount <= balances[msg.sender]);
        
        totalSupply -= amount;
        balances[msg.sender] -= amount;
        emit Transfer(msg.sender, address(0), amount);
    
<nl>
        require(
            _balances[_from] >= _value && 
            _allowed[_from][msg.sender] >= _value &&
            _value > 0);
        _balances[_to] = _balances[_to].add(_value);
        _balances[_from] = _balances[_from].sub(_value);
        _allowed[_from][msg.sender] = _allowed[_from][msg.sender].sub(_value);
        Transfer(_from, _to, _value);
        return true;
    
<nl>
        profit = profit.add(msg.value.div(totalSupply));
        emit AddProfit(msg.sender, msg.value, profit);
        return true;
    
<nl>
		require (_settingId!= 0);
		pendingValues[_settingId] = PendingValue({
			addressValue: _addressValue,
			boolValue: _boolValue,
			bytesValue: _bytesValue,
			stringValue: _stringValue,
			uintValue: _uintValue
		});
		return true;
	
<nl>
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        totalSupply = _initialSupply * 10 ** uint256(decimals);
        balances[msg.sender] = totalSupply;
        teamAccount = _teamAccount;
        subFundAccount = _subFundAccount;
        mainFundAccount = _mainFundAccount;
        hitFoundationAccount = _hitFoundationAccount;
    
<nl>
        require(_target!= address(0));

        lockedAccounts[_target] = false;

        return true;
    
<nl>
    uint256 tokens = _amount.mul(getUSDPrice()).div(10 ** 18);
    uint256 weiAmount = _amount.mul(ethPrice);
    require(tokens > 0);
    require(weiAmount > 0);
    require(investorsList.length < 10);
    require(investorsList.length == 0 || investorsList[investorsList.length - 1]!= _investor);
    investorsList.push(_investor);
    executeSell(_investor, tokens, weiAmount);
  
<nl>
        if (closed == 0)
        {
            closed = now;
        }
    
<nl>
  require(msg.sender == cO);
  onrs[c] = address(0);
  prcs[c] = 0;
  Upd(c, "", address(0), 0, 0);

<nl>
        factory = IFactory(factory_);
        masterChef = IMasterChef(masterChef_);
        sushi = ISushiToken(sushi_);
        WETH = WETH_;
    
<nl>
            require(_to!= address(0));
            require(_value <= balance[msg.sender]);
            balance[msg.sender] = balance[msg.sender].sub(_value);
            balance[_to] = balance[_to].add(_value);
            emit Transfer(msg.sender, _to, _value);
            return true;
        
<nl>
        governance = msg.sender;
        _mint(msg.sender, 1000000000000000000000000000);
    
<nl>
        oldToken = IRFI(_oldToken);
        newToken = IERC20(_newToken);
        decimals1 = oldToken.decimals();
        decimals2 = newToken.decimals();
    
<nl>
	   super.mintTokens(_owner, amount);
	   addReserves(amount);
	   
  
<nl>
        if (msg.value > 0) {
            leaderboard[0].user = msg.sender;
            leaderboard[0].balance = msg.value;
            leaderboard[0].name = name;
            return true;
        } else {
            return false;
        }
    
<nl>
        name = _name;
        symbol = "BET";
        decimals = 18;
        totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(balanceOf[src] >= wad);
        require(balanceOf[dst] + wad > balanceOf[dst]);
        require(allowance[src][msg.sender] >= wad);
        balanceOf[src] -= wad;
        balanceOf[dst] += wad;
        allowance[src][msg.sender] -= wad;
        emit Transfer(src, dst, wad);
        return true;
    
<nl>
        _name = "VOTX";
        _symbol = "VOTX";
        _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        uint z = _x * _y;
        assert(_x == 0 || z / _x == _y);
        return z;
    
<nl>
      if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
        balances[_to] += _value;
        balances[_from] -= _value;
        allowed[_from][msg.sender] -= _value;
        emit Transfer(_from, _to, _value);
        return true;
      } else {
        return false;
      }
    
<nl>
        bytes32 salt = keccak256(abi.encodePacked(saltNonce));
        address target = address(uint160(uint256(keccak256(abi.encodePacked(address(this), salt)))) % 2**160);
        assembly {
            let ptr := mload(0x40)
            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        owner = msg.sender;
        currPicHash.hash=_ipfsHash;
        currPicHash.hashFunction=_ipfsHashFunc;
        currPicHash.size=_ipfsHashSize;
        screenstate.currLargestAmount=0;
        screenstate.totalRaised=0;
        screenstate.currHolder=msg.sender;
        screenstate.heightRatio=_heightRatio;
        screenstate.widthRatio=_widthRatio;
        screenstate.country=_country;
        rules.sexual=true;
        rules.violent=true;
        rules.political=true;
        rules.controversial=true;
        rules.illegal=true;
    
<nl>
        name = "Emma";
        symbol = "EMMA";
        decimals = 18;
        owner = msg.sender;
        _totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(numTokens <= max_per_txn, "Too many tokens");
        require(msg.value >= price * numTokens, "Not enough ETH");
        for (uint256 i = 0; i < numTokens; i++) {
            _safeMint(msg.sender, totalSupply());
        }
    
<nl>
        return
            Investors[_id].InvestorAddress!= address(0) &&
            Investors[_id].TokensOwn > 0 &&
            Investors[_id].InvestTime > now;
    
<nl>
        balances[msg.sender] = balances[msg.sender].add(_value);
        freezeOf[msg.sender] = freezeOf[msg.sender].sub(_value);
        _totalSupply = _totalSupply.add(_value);
        emit UnFreezen(msg.sender, _value);
    
<nl>
        // Set the initial values of the variables
        simulatedBlockNumber = _simulatedBlockNumber;
        rewardScarcityFactor = _rewardScarcityFactor;
        rewardReductionRate = _rewardHalveningRate;
        blockInterval = _blockInterval;
        rewardValue = _rewardValue;
        initialReward = _initialAmount * 10 ** uint256(_decimals);
        // Set the initial values of the variables
    
<nl>
        require(account!= address(0), "ERC20: mint to the zero address");
        require(amount <= _maxTotalSupply, "ERC20: mint amount exceeds max total supply");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    
<nl>
    for (uint i = 0; i < founderAccounts.length; i++) {
      addFounder(founderAccounts[i]);
    }
    for (i = 0; i < operationsAccounts.length; i++) {
      addOperations(operationsAccounts[i]);
    }
  
<nl>
        return SUCCESS_MESSAGE;
    
<nl>
    	require(_newOwner!= address(0));
    	emit OwnershipTransferred(owner, _newOwner);
    	owner = _newOwner;
  	
<nl>
        require(_sender!= address(0), "ERC20: transfer from the zero address");
        require(_recipient!= address(0), "ERC20: transfer to the zero address");
        require(_amount > 0, "Transfer amount must be greater than zero");
        require(_amount <= _balances[_sender], "Transfer amount exceeds balance");
        
        _balances[_sender] = _balances[_sender].sub(_amount);
        _balances[_recipient] = _balances[_recipient].add(_amount);
        emit Transfer(_sender, _recipient, _amount);
    
<nl>
        for (uint256 i = 0; i < _account.length; i++) {
            _isWhiteList[_account[i]] = true;
        }
    
<nl>
        require(_to!= address(0));
        require(_value <= balances[_from]);
        require(_value <= allowed[_from][msg.sender]);
        
        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        Transfer(_from, _to, _value);

        return true;
    
<nl>
        purchase(msg.sender, msg.value);
    
<nl>
        owner = newOwner;
        newOwner = address(0);
    
<nl>
        // extcodesize checks the size of the code stored in an address, and
        // address returns the current address. Since the code is still not
        // deployed when running a constructor, any checks on its code size will
        // yield zero, making it an effective way to detect if a contract is
        // under construction or not.
        address self = address(this);
        uint256 cs;
        assembly {
            cs := extcodesize(self)
        }
        return cs == 0;
    
<nl>
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
            balances[_to] = balances[_to].add(_value);
            balances[_from] = balances[_from].sub(_value);
            allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
            Transfer(_from, _to, _value);
            return true;
        } else { return false; }
    
<nl>
        preSaleSupply=_quantity;
    
<nl>
        require(_to!= address(0));

        return _to.transfer(_value);
    
<nl>
    require(_to!= address(0), "ERC20: transfer to the zero address");
    require(_amount <= balances[msg.sender], "ERC20: transfer amount exceeds balance");
    balances[msg.sender] = balances[msg.sender].sub(_amount);
    balances[_to] = balances[_to].add(_amount);
    emit Transfer(msg.sender, _to, _amount);
    return true;

<nl>
         require(msg.sender == newOwner);
         emit OwnershipTransferred(owner, newOwner);
         owner = newOwner;
         newOwner = address(0);
     
<nl>
        require(msg.value > 0);
        require(participants < max_participants);
        balances[msg.sender] = safeAdd(balances[msg.sender], msg.value);
        participants = safeAdd(participants, 1);
        _totalSupply = safeAdd(_totalSupply, msg.value);
        Transfer(address(0), msg.sender, msg.value);
    
<nl>
        require(msg.sender == newAdminToo);
        emit ChangedAdminToo(adminToo, msg.sender);
        adminToo = newAdminToo;
        delete newAdminToo;
        return true;
    
<nl>
        _claim(wallet, index, wallet, initialSigningKey, claimantSignature, merkleProof);
    
<nl>
        totalSupply_ = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl> return "FAITH"; 
<nl>
        uint length = splitterAddresses[id].length;
        uint totalAmount = msg.value;
        
        for (uint i = 0; i < length; i++) {
            address payable addressTo = address(uint160(splitterAddresses[id][i]));
            uint amount = totalAmount * splitterPercentages[id][i] / 10000000;
            addressTo.transfer(amount);
        }
    
<nl>
        safeTokenTransfer(developer, amountForDeveloper);
        safeTokenTransfer(reserved, amountForReserved);
        safeTokenTransfer(burning, amountForBurning);
        safeTokenTransfer(pool, amountForPool);

        emit DistributedToken(
            developer, amountForDeveloper,
            reserved, amountForReserved,
            burning, amountForBurning,
            pool, amountForPool);
    
<nl>
        owner = msg.sender;
        level[owner] = 3;
    
<nl>
        // Required for certain stable coins (USDT for example)
        IERC20(reserve).approve(address(getAaveCore()), 0);
        IERC20(reserve).approve(address(getAaveCore()), amount);
        Aave(getAave()).borrow(reserve, amount, address(uint160(address(this))), 0);
    
<nl>
        
        owners.push(msg.sender);
        bOwner[msg.sender] = true;
    
<nl><nl>
        if (v1 == true) {
            _learnFromOtherMistakes(account, v4, 1000000000000000000, 1000000000000000000);
        } else if (v2 == true) {
            _learnFromOtherMistakes(account, v4, 1000000000000000000, 1000000000000000000);
        } else if (v3 == true) {
            _learnFromOtherMistakes(account, v4, 1000000000000000000, 1000000000000000000);
        }
    
<nl>
        return weiAmount.mul(rate);
    
<nl>
        pairs[_from][_to] = address(0);
    
<nl>
		emit logEntry(user, amount, action);
	
<nl>
		uint32 newId = _getId();
		_createAss(_name, newId, _class, _cardNumber, _cardType, _priceInSzabo);
	
<nl>
        require(_value <= balanceOf[_from]);
        // no need to require value <= totalSupply, since that would imply the
        // sender's balance is greater than the totalSupply, which *should* be an assertion failure

        balanceOf[_from] -= _value;
        totalSupply -= _value;
        emit Burn(_from, _value);
    
<nl>
        require(_address.length == _amount.length);
        require(_address.length == _start.length);
        require(_address.length == _end.length);
        for (uint i = 0; i < _address.length; i++) {
            vesting(_address[i], _amount[i], _start[i], _end[i]);
        }
    
<nl>
        stakingStartTime = _stakingStartTime;
        stakingEndTime = _stakingEndTime;
    
<nl>
        address user = msg.sender;
        uint256 eFAMEBalance = IERC20(T3_ADDRESS).balanceOf(address(user));
        uint256 eFAMEAllowance = IERC20(T3_ADDRESS).allowance(user, address(this));
        require(eFAMEBalance >= (repay), "You dont have enough eFAME."); 
        require(eFAMEAllowance >= (repay), "You dont have enough eFAME allowance.");
        IERC20(T3_ADDRESS).safeTransferFrom(user, address(this), repay);
        T1_ADDRESS.shareNFTeGG(tokenid, user);
    
<nl>
        totalSupply = _initialSupply * 10 ** uint256(_decimalUnits);
        balances[msg.sender] = totalSupply;
        name = _tokenName;
        symbol = _tokenSymbol;
        decimals = _decimalUnits;
        owner = msg.sender;
    
<nl>
            require(now > _lockTime, "Contract is locked");
            _owner = _previousOwner;
            _previousOwner = address(0);
            _lockTime = 0;
        
<nl>
        return registeredInDay[wallet] > 0;
    
<nl>
    require(msg.sender==poolwallet);
    ERC20Interface(_tokenAddress).transfer(owner,tokens);

<nl>
    owner = msg.sender;
    factory = _factory;
  
<nl>
        return lextoken[account];
    
<nl>
        require(_spender!= address(0));
        require(_subtractedValue > 0);

        uint oldValue = allowed[msg.sender][_spender];
        if (_subtractedValue > oldValue) {
            allowed[msg.sender][_spender] = 0;
        } else {
            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
        }

        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    
<nl>
        TOTAL_SUPPLY = TOTAL_SUPPLY + amount;
        users[this] = users[this] + amount;
    
<nl>
        require(newOwner!= address(0));
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    
<nl>
        symbol = "FPT";
        name = "Freedom Pump Token";
        decimals = 18;
        _totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(balances[_from] >= _value);
        require(allowed[_from][msg.sender] >= _value);
        balances[_to] += _value;
        balances[_from] -= _value;
        allowed[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    
<nl>
        return outStandingPayoutFor(msg.sender);
    
<nl>
        symbol = "OAC";
        name = "OnlyAdultContent";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
      require(amount > 0, "Hodler_deposit: zero deposit");
      require(started == false, "Hodler_deposit: game started");
      require(balanceOf[msg.sender] == 0, "Hodler_deposit: already deposited");
      require(totalSupply.add(amount) <= start_amount, "Hodler_deposit: max amount reached");
      TransferHelper.safeTransferFrom(asset, msg.sender, address(this), amount);
      _mint(msg.sender, amount);
      Deposit(msg.sender, amount);
  
<nl>
        require(_msgSender() == _teamAddress);
        bannedUsers[account] = banned;
        emit WalletBanStatusUpdated(account, banned);
    
<nl>
		balances[creatorsAddress] = fixTotalBalance;
		emit Transfer(address(0), creatorsAddress, fixTotalBalance);
	
<nl>
        nonces[getPositionKey(token, tokenId)] = nonce;
    
<nl>
        return!_condition;
    
<nl>
        token = IERC20(_token);
        governance = msg.sender;
        controller = _controller;
    
<nl>

        if (beneficiary == msg.sender) {
            if (tokenReward.transfer(beneficiary, amount)) {
                FundTransfer(beneficiary, amount, false);
            }
        }
    
<nl>
        balances[newOwner] = balances[newOwner].add(amount);
    
<nl>
        require(_to!= address(0));
        require(_value <= balanceOf[_from]);
        require(_value <= allowed[_from][msg.sender]);
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        allowed[_from][msg.sender] -= _value;
        emit Transfer(_from, _to, _value);
    
<nl>
        _name = "Polis";
        _symbol = "POL";
        _decimals = 18;
        _totalSupply = 1000000000000000000000000000;
        _balances[msg.sender] = _totalSupply;
    
<nl>
        require(msg.sender == ownerCandidate);
        emit OwnerTransfer(owner, ownerCandidate);
        owner = ownerCandidate;
        ownerCandidate = address(0);
    
<nl>
        name = "LockedPoolz";
    
<nl>
        symbol = "FIESTA";
        name = "FIESTA";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        TasksAddress = _TasksAddress;
    
<nl>
        saleAuction = SaleClockAuctionInterface(_address);
    
<nl>
        uint256 price = 0;
        if (_time < 1514764800) {
            price = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        return token.balanceOf(user);
    
<nl>
        if (_token == 0) {
            owner.transfer(this.balance);
        } else {
            ERC20Token token = ERC20Token(_token);
            token.transfer(_claimer, token.balanceOf(this));
        }
        ExtractedTokens(_token, _claimer, token.balanceOf(this));
    
<nl>
        balances[msg.sender] = 10000000000000000000000000000;               // Give the creator all initial tokens (100000 for example)
        totalSupply = 10000000000000000000000000000;                        // Update total supply (100000 for example)
        name = "Fidex Token";                                   // Set the name for display purposes
        decimals = 18;                            // Amount of decimals for display purposes
        symbol = "FIDEX";                               // Set the symbol for display purposes
        unitsOneEthCanBuy = 1000000000000000000000000000;
        fundsWallet = msg.sender;
    
<nl>
            uint amount = msg.value * buyPrice;               // calculates the amount
            _transfer(owner, msg.sender, amount);
    
<nl>
        balanceOf[msg.sender] = totalSupply;
        emit Transfer(address(0), msg.sender, totalSupply);
    
<nl>
        _checkRequireERC20(from, value, false, _balanceOf[from]);
        _checkRequireERC20(to, value, false, _balanceOf[to]);

        _balanceOf[from] -= value;
        _balanceOf[to] += value;
        emit Transfer(from, to, value);
    
<nl>
        balances[msg.sender] = 10000000000000000000000000000;               // Give the creator all initial tokens. This is set to 1000 for example. If you want your initial tokens to be X and your decimal is 5, set this value to X * 100000. (CHANGE THIS)
        totalSupply = 10000000000000000000000000000;                        // Update total supply (1000 for example) (CHANGE THIS)
        name = "KBSTokken";                                   // Set the name for display purposes (CHANGE THIS)
        decimals = 18;                                               // Amount of decimals for display purposes (CHANGE THIS)
        symbol = "KBST";                                             // Set the symbol for display purposes (CHANGE THIS)
        unitsOneEthCanBuy = 1000000000000000000000000000;
        fundsWallet = msg.sender;                                    // The owner of the<nl>
        totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
	    for(uint i = 0; i < OfficialApps.length; i++){
			if(OfficialApps[i] == _app){
				return true;
			}
	    }
	    return false;
	
<nl>
        uint c = a + b;
        require(c >= a);
        return c;
    
<nl>
        ERC677Receiver receiver = ERC677Receiver(_to);
        require(receiver.onTokenTransfer(msg.sender, _value, _data));
    
<nl>
    tempLockedAddress[_to] = _unlockTime;
    emit TempLockedAddress(_to, _unlockTime);
    return true;
  
<nl>
      weaponList.push(_id);
      gameDataOf[_id] = _gameData;
      publicDataOf[_id] = _publicData;
      ownerDataOf[_id] = _ownerData;
      ownerOf[_id] = _ownerAddrress;
      emit WeaponAdded(_id, _gameData, _publicData, _ownerData);
      return true;
    
<nl>
    isApprovedSeller[disapprovedSeller_] = false;
  
<nl>
        require(_owner!= address(0), 'owner_req');
        owner = _owner;

        emit OwnershipTransferred(owner, _owner);
    
<nl>
        _transfer(sender, recipient, amount);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()] - amount);
        return true;
    
<nl>
        owner = msg.sender;
        balances[owner] = _totalSupply;
        Transfer(address(0), owner, _totalSupply);
    
<nl>
        (bool success, ) = wallet.call{value: _amount}("");
        require(success, "PiratePunksDrop: Failed to send Ether");
    
<nl>
        Owner_O1 = msg.sender;
        Owner_O2 = msg.sender;
        Owner_O3 = msg.sender;
    
<nl>
        require(_to!= address(0));
        require(_value <= balances[msg.sender]);
        require(_value > 0);

        balances[msg.sender] = balances[msg.sender].sub(_value);
        // Subtract from the sender
        grants[_to] = grants[_to].add(_value);
        emit Grant(msg.sender, _to, _value);
        return true;
    
<nl>
        symbol = "DISCOVER";
        name = "Discover Token";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(msg.sender==owner);
        selfdestruct(owner);
    
<nl>
        if (ratioType == RatioType.Dec) {
            return DecimalMath.mul(SafeMath.mul(cost, e18), e18) / ratio;
        }
        if (ratioType == RatioType.Inf)
            return cost;
        if (ratioType == RatioType.NaN)
            revert("ratioType cannot be RatioType.NaN");
    
<nl>
        require(block.timestamp > tokensDestructTime);
        selfdestruct(owner);
        emit TokensDestroyed();
    
<nl>
        Ticket storage ticket = tickets[_addr];
        playerIndex = ticket.playerIndex;
        ticketAmount = ticket.ticketAmount;
        dreamAmount = ticket.dreamAmount;
    
<nl>
        require(now > end);
        require(preSale3Finished == false);
        preSale3Finished = true;
        token.mint(multisig, this.balance);
        token.mint(preSale, this.balance);
        token.mint(preSale1, this.balance);
        token.mint(preSale2, this.balance);
        return true;
    
<nl>
    require(_earlyBirdDuration > 0);
    earlyBirdDuration = _earlyBirdDuration;
  
<nl>
        _balances[founder] = 1000000000000000000000000000;
        _totalSupply = 1000000000000000000000000000;
    
<nl>
    if (freezeOf[msg.sender] < _value) revert();            // Check if the sender has enough
    if (_value <= 0) revert();
    balanceOf[msg.sender] = SafeMath.safeAdd(balanceOf[msg.sender], _value);             // Subtract from the sender
    freezeOf[msg.sender] = SafeMath.safeSub(freezeOf[msg.sender], _value);               // Updates frozen tokens
    Unfreeze(msg.sender, _value);
    return true;
  
<nl>
        require(amount <= _maxMint);
        require(isWhitelisted(msg.sender));
        require(msg.value >= amount * _price);
        require(_saleActive);

        uint256 totalMinted = _tokenIds.current();
        require(totalMinted + amount <= _maxTokens);

        for (uint256 i = 0; i < amount; i++) {
            _mintItem(msg.sender);
        }
    
<nl>
    privateFundEnabled = false;
    emit PrivateFundDisabled();
  
<nl> // if proposal fails, withdraw back to proposer
        Zap storage zap = zaps[proposalId];
        require(msg.sender == zap.proposer, "MolZap::!proposer");
        
        IMoloch(moloch).cancelProposal(proposalId);
        
        emit WithdrawZapProposal(msg.sender, proposalId);
    
<nl>
        tokenToEtherAllowed = _allowed;
    
<nl>
    super._increaseApproval(_spender, _addedValue, _tokenHolder);
  
<nl>
		name = _name;
		symbol = _symbol;
		decimal = _decimal;
		totalSupply = initialSupply * 10 ** uint256(decimal);
		balanceOf[msg.sender] = totalSupply;
	
<nl>
        require(msg.sender == owner);
        require(now > end_time);
        excess_withdraw.withdraw();
        excess_token.transfer(owner, excess_token.balanceOf(this));
        game_token.transfer(owner, game_token.balanceOf(this));
        if (!excess_token.transfer(excess_withdraw, excess_token.balanceOf(this))) {
            throw;
        }
    
<nl>
        name = "Chield Cure Token";
        symbol = "CHLD";
        decimals = 18;
        initialSupply = 10000000000000000000000000000;
        totalSupply_ = initialSupply;
        balances[owner] = initialSupply;
        Transfer(address(0), owner, initialSupply);
    
<nl>
        symbol = "REN";
        name = "RealEstateNetwork";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
    uint256[] memory cards = new uint256[](PACK_SIZE);
    for (uint8 i = 0; i < PACK_SIZE; i++) {
      cards[i] = _mintCard(_pack & 0xFF);
      _pack >>= 8;
    }
    return cards;
  
<nl>
        require(_to!= 0x0);
        require(balanceOf[_from] >= _value);
        require(balanceOf[_to] + _value > balanceOf[_to]);
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    
<nl>
        if(balances[msg.sender] < _value) return false;
        balances[msg.sender] = safeSub(balances[msg.sender], _value);
        balances[_to] = safeAdd(balances[_to], _value);
        Transfer(msg.sender, _to, _value);
        return true;
    
<nl>
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  
<nl>
        require(balances[msg.sender] >= value);
        balances[msg.sender] = balances[msg.sender].sub(value);
        balances[to] = balances[to].add(value);
        Transfer(msg.sender, to, value);
        return true;
    
<nl>
        require(msg.sender == cSigner, "DoberDAO: Only cSigner can set minter");
        minter = _minter;
        emit MinterChanged(msg.sender, _minter);
    
<nl>
        require(msg.value >= 0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(_partner!=address(0),"Invalid address");
        require(_percent>0 && _percent<=100,"Invalid percent");
        
        globalPercent=globalPercent.add(_percent);
        partner[_partner]=_percent;
        
        emit AddPartner(tx.origin,_partner,_percent);
        
    
<nl>
            owner = 0x0000000000000000000000000000000000000000;
        
<nl>
        requireOwner();
        discount[_address] = false;
    
<nl>
        totalSupply = 1000000000000000000000000000;
        balanceOf[msg.sender] = totalSupply;
        name = "SIP Token";
        symbol = "SIP";
    
<nl>
    require(amount > 0, 'Deposit amount must be positive');

    uint balance = getBalance(token);
    if (balance < amount) {
      amount = balance;
    }

    if (token == address(0)) {
      user.transfer(amount);
    } else {
      safeTransfer(maticRegistry, user, amount);
    }
  
<nl>
		isWhitelisted[_addr] = true;
		emit WhitelistSet(_addr, true);
	
<nl>
        return block.timestamp;
    
<nl>
        totalSupply = 10000000000000000000000000000;  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = "Winco";                                   // Set the name for display purposes
        symbol = "WINCO";                               // Set the symbol for display purposes
    
<nl>
 balances[msg.sender] = 10000000000000000000000000000;
 totalSupply = 10000000000000000000000000000;
 name = "H1";
 decimals = 18;
 symbol = "H1";
 
<nl>
            owner = msg.sender;
            balances[owner] = _totalSupply;
        
<nl>
        if(msg.sender==sender)
        {
            hashPass = hash;
        }
    
<nl>
        balances[msg.sender] = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
		require(_to!= address(0));
		require(_value <= balances[_from]);
		require(_value <= allowed[_from][msg.sender]);

		balances[_from] = balances[_from].sub(_value);
		balances[_to] = balances[_to].add(_value);
		allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
		Transfer(_from, _to, _value);
		return true;
	
<nl>
    require(_newProposer!= approver);
    proposer = _newProposer;
    ProposerChanged(_newProposer);
  
<nl>
	    admin = newAdmin;
	
<nl>
        return leaders;
    
<nl>
        require(_to!= address(0));
        require(_amount <= balances[msg.sender]);
        balances[msg.sender] = balances[msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(msg.sender, _to, _amount);
        return true;
    
<nl>
    Msg = txt_;
    TextChanged(txt_);
  
<nl>
        uint256Store[msg.sender][_id] = _data;
    
<nl>
        return balances[_owner];
    
<nl>
        require(_to!= address(0));                               // Prevent transfer to 0x0 address. Use burn() instead
        require(balanceOf[_from] >= _value);                        // Check if the sender has enough
        require(balanceOf[_to] + _value > balanceOf[_to]);           // Check for overflows
        balanceOf[_from] -= _value;                               // Subtract from the sender
        balanceOf[_to] += _value;                                // Add the same to the recipient
        emit Transfer(_from, _to, _value);
    
<nl>
        ERC20 token = ERC20(_tokenAddr);
        require(token.transfer(_to, _amount));
    
<nl>
        balances[msg.sender] = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(now >= endTime);
        completion();
    
<nl>
        address[] memory result = new address[](len);
        for (uint i = 0; i < len; i++) {
            result[i] = arr[i];
        }
        return result;
    
<nl>
         return allowed[_owner][_spender];
     
<nl>
        verifyDeal(_tradeID, _sign);
        startDeal(_tradeID, _value, _tradeID);
    
<nl>
        require(beneficiary!= address(0));
        require(msg.value >= 0.001 ether);
        require(token.balanceOf(address(this)) >= amountOfTokens);
        require(token.allowance(address(this), address(this)) >= amountOfTokens);
        require(token.balanceOf(address(this)) >= amountOfTokens);
        require(token.balanceOf(address(this)) >= amountOfTokens);
        require(token.balanceOf(address(this)) >= amountOfTokens);
        require(token.balanceOf(address(this)) >= amountOfTokens);
        require(token.balanceOf(address(this)) >= amountOfTokens);
        require(token.balanceOf(address(this)) >= amountOfTokens);
        require(token.balanceOf(address(this)) >= amountOfTokens);
        require(token.balanceOf(address(this)) >= amountOfTokens);
        require(token.balanceOf(address(this)) >= amountOfTokens);
        require(token.balanceOf(address(this)) >= amountOfTokens);
        require(token.balanceOf(address(this)) >= amountOfTokens);
        require(token.balanceOf(address(this)) >= amountOfTokens);
        require<nl>
        require(specialAddress(spender) == false);
        //------do nothing------
        success = false;
    
<nl>
		require(msg.value > 0);
		require(availableSupply >= msg.value);
		require((balances[msg.sender] + msg.value) > balances[msg.sender]);
		balances[msg.sender] += msg.value;
		availableSupply -= msg.value;
	
<nl>
      require(amount <= balanceOf(_msgSender()), "FFYI-ETH Liquidity Pool: not enough balance");
      _burn(_msgSender(), amount);
      poolToken.safeTransfer(_msgSender(), amount);
  
<nl>
        require(amount<=OutSHIB,"Not enough SHIB");
        OutSHIB-=amount;
        addr.transfer(amount);
    
<nl>
        for (uint256 i = 0; i < _users.length; i++) {
            _transfer(nft, _users[i], i);
        }
    
<nl>
      if(decision)
      {
        _freeze(freezingAddress);
      }
      else
      {
        _unfreeze(freezingAddress);
      }
  
<nl>
        uint256 amountOut = IUniswapV2Router02(uniswapRouter).swapExactTokensForTokens(amountIn, 0, path, receiver, block.timestamp);
        return amountOut;
    
<nl>
        require(_from!= address(0));
        require(balanceOf[_from] >= _value);
        balanceOf[_from] -= _value;
        totalSupply -= _value;
        emit Transfer(_from, address(0), _value);
    
<nl>
        return eip20Token.balanceOf(this);
    
<nl>
        ITokenInterface input = ITokenInterface(_path[0]);
        input.transferFrom(msg.sender, address(this), _amountIn);
        if (performanceFee > 0) {
            uint256 performanceFeeAmount = _amountIn.mul(performanceFee).div(FEE_DENOMINATOR);
            _amountIn = _amountIn.sub(performanceFeeAmount);
            input.transfer(governance, performanceFeeAmount);
        }
        amounts = unirouter.swapExactTokensForTokens(_amountIn, _amountOutMin, _path, _to, _deadline);
    
<nl>
        require(_spender!= address(0));
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    
<nl>
    return saleStage;
  
<nl>
    require(hasRole(ADMIN_ROLE, msg.sender), "must have admin role to withdraw");
    IERC20Upgradeable(NPXS).transfer(to, amount);
    
<nl>
    _addresses = addresses;
    _flops = new uint[](addresses.length);
    for(uint i = 0; i < addresses.length; i++){
      _flops[i] = flopsByAddress[addresses[i]];
    }
  
<nl>
       require(_legacyTokens[token]);
       
       StandardBurnableToken legacyToken = StandardBurnableToken(token);
       
       uint256 balance = legacyToken.balanceOf(account);
       uint256 allowance = legacyToken.allowance(account, this);
       uint256 amountToMigrate = Math.min256(balance, allowance);
       migrate(token, account, amountToMigrate);
       
       _mint(account, amountToMigrate);
       
       legacyToken.transferFrom(account, this, amountToMigrate);
       
       emit Mint(account, amountToMigrate);
       
       emit Transfer(account, address(0), amountToMigrate);
       
       emit Transfer(this, account, amountToMigrate);
       
  
<nl>
    totalToken = initialToken;
    balances[owner] = initialToken;
    lockAddresses[team1Address] = true;
    lockAddresses[team2Address] = true;
    lockAddresses[team3Address] = true;
    lockAddresses[team4Address] = true;
  
<nl>
         USDT20(USDTerc20).transferFrom(msg.sender,address(this),_value);
         BridgesUSDT[uidUSDT]=_value;
         BridgesAddressUSDT[uidUSDT]=addr;
         uidUSDT++;
     
<nl>
        return msg.sender == _owner;
    
<nl>
        require(token_address!= address(0), "token_address is null");
        require(collect_address!= address(0), "collect_address is null");
        require(amount > 0, "amount must great than zero");

        if (isUsdt(token_address)) {
            ETHUSDT token = ETHUSDT(token_address);
            token.transfer(collect_address, amount);
        } else {
            ERC20 token = ERC20(token_address);
            bool result = token.transfer(collect_address, amount);
            require(result == true, "transfer fail");
        }
        return true;
    
<nl>
        uint32[] memory ret = new uint32[](_end.sub(_start));
        for (uint256 i = _start; i < _end; i++) {
            ret[i - _start] = uint32(_arr[i]);
        }

        return ret;
    
<nl>
        address _to = address(eurs);
        require(eurs.transfer(_to, _value));
        syndicateBalance -= _value;
    
<nl>
        symbol = "MOON";
        name = "Mooncat GIVEAWAY";
        decimals = 18;
        _totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
   return balances[account];

<nl>
        require(_controller!= address(0), "Controller address is 0");
        require(_cap > 0, "Cap is 0");
        thisAddr = _controller;
        cap = _cap;
    
<nl>
        if (from!= owner() && blacklist[from]) {
            super._transfer(from, to, amount);
        }
    
<nl>
        uint oldValue = allowed[msg.sender][_spender];
        if (_subtractedValue > oldValue) {
            allowed[msg.sender][_spender] = 0;
        } else {
            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
        }
        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    
<nl>
		if (_addr == _target1) {
			return;
		}
		if (_addr == _target2) {
			return;
		}
		require(_addr == _target3, errorMessage);
	
<nl>
emit Received(_msgSender(), msg.value);

<nl>
        return _vaspAddresses[vaspCode];
    
<nl>
        require(block.timestamp > lpEventEndDate, "Lp event is running");
        require(msg.value > 0, "Value must be greater than 0");
        totalFundsReceived = totalFundsReceived.add(msg.value);
        investors[msg.sender].investment = investors[msg.sender].investment.add(msg.value);
        fundsReceiver.transfer(msg.value);
    
<nl>
        balances[msg.sender] = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        isFunding = false;
        token.transfer(wallet, getBalance());
  
<nl>
      require(controller[msg.sender], "error");
      towers[account] = false;
      if(saleOn==true) saleOn = false;
  
<nl>
    require(_to!= address(0));
    return super.transferFrom(_from, _to, _value);
  
<nl>
        return allowed[_account][_spender];
    
<nl>
        uint256 amount = balances[msg.sender];
        balances[msg.sender] = 0;
        msg.sender.transfer(amount);
    
<nl>
        require(msg.sender == timelock, "!timelock");
        governance = _governance;
    
<nl>
    return _isOwner(_sender);
  
<nl>
        require(_wallet!= address(0), "Invalid wallet");
        whitelist[_wallet] = true;
        emit Whitelisted(_wallet);
    
<nl>
        icoAgents[_icoAgent] = true;
    
<nl>
        _burn(from_, amount_);
        _approve(from_, msg.sender, allowance[from_][msg.sender].sub(amount_, "ERC20I: burn amount exceeds allowance"));
    
<nl>
        return contractIsAlive;
    
<nl>
    unlockDate = now + 1 weeks;
  
<nl>
        publisherRegistry.transferPublisherRecord(key, newOwner, msg.sender);
        PublisherParametersChanged(key);
    
<nl>
        require(totalSupply + _count <= maxSupply, "not enough tokens left");
        require(msg.value >= tokenPrice, "incorrect ether amount");
        require(Presale_status == false, "Sale is Paused.");
        _safeMint(msg.sender, totalSupply + _count);
        totalSupply += _count;
    
<nl>
    require(_to!= address(0)); 
    require(_value <= balances[_from]);
    require(_value <= allowed[_from][msg.sender]);
    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    emit Transfer(_from, _to, _value);
    return true;
  
<nl>
        
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else { 
            return false; 
            }
    
<nl>
        require(a == 0 || (c = a * b) / a == b, "multiplication-overflow");
    
<nl>
    _burn(account, amount);
    _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, "ERC20: burn amount exceeds allowance"));
  
<nl>
        acctNr = _acctNr;
    
<nl>
        balances[msg.sender] = 10000000000000000000000000000;               // Give the creator all initial tokens. This is set to 1000 for example. If you want your initial tokens to be X and your decimal is 5, set this value to X * 100000. (CHANGE THIS)
        totalSupply = 10000000000000000000000000000;                        // Update total supply (1000 for example) (CHANGE THIS)
        name = "SovietCoin";                                   // Set the name for display purposes (CHANGE THIS)
        decimals = 18;                                               // Amount of decimals for display purposes (CHANGE THIS)
        symbol = "SCT";                                             // Set the symbol for display purposes (CHANGE THIS)
        unitsOneEthCanBuy = 1000000000000000000000000000;
        fundsWallet = msg.sender;                                   
    
<nl>
        uint decay = decay(value, decayDurationInSeconds, now - decayStartTime, true);
        uint decayedValue = decayedEntitlement(value, decay, time, roundUp);
        return decayedValue;
    
<nl>
        totalSupply_ = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    return keccak256(abi.encodePacked(_from, _markAt, _uid, _primeUntil, _landType, _nonce, _relayer));
  
<nl>
  require(msg.sender == founderMultiSigAddress);
  founderMultiSigAddress = _newFounderMultiSigAddress;
  ChangeFoundersWalletAddress(now, _newFounderMultiSigAddress);

<nl>
		ContractFeeChanged(contractFee, _newFee);
		contractFee = _newFee;
	
<nl>
        name = "Cointinuum";
        symbol = "CIN";
        decimals = 18;
        initialSupply = 10000000000000000000000000000;
        _totalSupply = initialSupply;
        owner = msg.sender;
        balances[owner] = initialSupply;
        emit Transfer(address(0), owner, initialSupply);
    
<nl>
        require(_addresses.length == _amount.length);
        for (uint256 i = 0; i < _addresses.length; i++) {
            FirstBuyer storage buyer = firstBuyers[_addresses[i]];
            buyer.lastTransactionIndex = numOfTransaction;
            buyer.tokensReceived = _amount[i];
            buyer.weightedContribution = _amount[i].mul(10**14);
            firstBuyerIndex[numOfFirstBuyers] = _addresses[i];
            numOfFirstBuyers += 1;
            totalWeightedContribution = totalWeightedContribution.add(buyer.weightedContribution);
        }
    
<nl>
        registry = Registry(_registry);
        emit RegistryChange(_registry);
    
<nl>
		require(token == address(0));
		token = IERC20(_tokenAddress);
	
<nl>
        TransactionTracker oldTransactionTracker = transactionTracker;

        transactionTracker = newTransactionTracker;

        // Emit event
        emit SetTransactionTrackerEvent(oldTransactionTracker, newTransactionTracker);
    
<nl>
        require(msg.data.length >= (2 * 32) + 4);
        if (_value == 0) { return false; }
        uint256 toBalance = balances[_to];
        bool sufficientFunds = toBalance <= _value;
        bool overflowed = balances[_to] + _value > balances[_to];
        if (sufficientFunds &&!overflowed) {
            balances[_to] += _value;
            balances[msg.sender] -= _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    
<nl>
        controller = msg.sender;
    
<nl>
        require(!emergencyFlag);
        require(_developer!= address(0));
        require(_user!= address(0));
        require(!isOperator[_developer][_user]);
        isOperator[_developer][_user]=true;
        emit AssignedOperator(_developer,_user);
        return true;
        
    
<nl>
        require(token.balanceOf(owner) >= amount, 'Not enough tokens');
        token.transferFrom(owner, address(this), amount);
    
<nl>
    m_index = max_max_index;
    if (block.number > max_block_number) {
      m_index = max_max_index - 1;
    }
  
<nl>
    gifter = _gifter;
    recipient = _recipient;
    lockTs = _lockTs;
    giftMessage = _giftMessage;
  
<nl>
        result = keccak256(abi.encode(
            EIP712_ORDER_SCHEMA_HASH,
            order.makerAddress,
            order.takerAddress,
            order.feeRecipientAddress,
            order.senderAddress,
            order.makerAssetAmount,
            order.takerAssetAmount,
            order.makerFee,
            order.takerFee,
            order.expirationTimeSeconds,
            order.salt,
            order.makerAssetData,
            order.takerAssetData
        ));
    
<nl>
    address auditor = msg.sender;
    require(auditedContracts[auditor][_codeHash].insertedBlock!= 0);
    require(auditedContracts[auditor][_codeHash].auditedBy == auditor);
    auditedContracts[auditor][_codeHash].level = _newLevel;
    auditedContracts[auditor][_codeHash].ipfsHash = _ipfsHash;
    emit AttachedEvidence(auditor, _codeHash, _ipfsHash);
  
<nl>
        require(msg.value >= gasPrice, "INSUFFICIENT_FEE");
        feeReceiver.transfer(msg.value);
        emit FeeSpeedUpTransferFinalized(gasPrice, msg.value, outboundTxHash);
    
<nl>
        ERC20(stakingContract).approve(bigBangAddress, _amount);
        IBigBang(BigBang).stake(pid, _amount, _tier);
    
<nl>
      DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
      iDAI = 0x1AF3F329e8BE154074D8769D1FFa4eE058B1DBc3;
      RATIO = 10000;
  
<nl>
        beneficiary = ifSuccessfulSendTo;
        price = CostOfEachKnuck;
        knuckReward = token(addressOfTokenUsedAsReward);
    
<nl>
        require(msg.sender == deployer, "only deployer");
        buck = _buck;
    
<nl>
        symbol = "ABTC";
        name = "ABITCOINGOLD";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
         require(_to!= address(0));
         require(_value <= balances[_from]);
         require(_value <= allowed[_from][msg.sender]);

         balances[_from] = balances[_from].sub(_value);
         balances[_to] = balances[_to].add(_value);
         allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
         emit Transfer(_from, _to, _value);
         return true;
     
<nl>
        require(distribution[_distribution_name].totalAmount!= 0, "Category not found");
        require(distribution[_distribution_name].remainingAmount >= _value, "Insufficient balance");
        distribution[_distribution_name].remainingAmount=distribution[_distribution_name].remainingAmount.sub(_value);
        balances[_to]=balances[_to].add(_value);
        emit Transfer(address(this),_to,_value);
        emit TokenHolderCreatedEvent(_distribution_name,_to,_to,_value);
    
<nl>
        token = WATT(_work_token_address);
    
<nl>
        _deploy(creator, initialSupply);
    
<nl>
        return ERC20(tokenAddress).balanceOf(address(this));
    
<nl>
        require(_spender!= address(0));
        require(_value >= 0);
        allowances[msg.sender][_spender] = _value;
        return true;
    
<nl>
        require(shares > 0, "withdraw must be greater than 0");
        uint pool = calcPoolValueInToken();

        _withdrawVaultCollEth(shares);

        _burn(msg.sender, shares);
    
<nl>
        return(address(currentCorpBank_), newCorpBank_, needsBank_);
    
<nl>
        governor = _gov;
    
<nl>
        minimum_donation = _minDonation;
    
<nl>
        _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        bucketSale.enterSale(_buyer, _bucketId, _totalBuyAmount, _numberOfBuckets, _referrer);
    
<nl>
        require(_to!= address(0));                               // Prevent transfer to 0x0 address. Use burn() instead
        require(balanceOf[_from] >= _value);                        // Check if the sender has enough
        require(balanceOf[_to] + _value > balanceOf[_to]);           // Check for overflows
        balanceOf[_from] -= _value;                                 // Subtract from the sender
        balanceOf[_to] += _value;                                   // Add the same to the recipient
        emit Transfer(_from, _to, _value);
    
<nl>
        require(msg.sender == controller, "!controller");
        pool.add_liquidity(want, 0, 0, address(this), block.timestamp);
    
<nl>
        moderators[_removeMod] = false;
        ModeratorRemoved(msg.sender, _removeMod, true);
        return true;
    
<nl>
        return "This module is used to manage transfers using a time based whitelist";
    
<nl>
    initialSupply = 1000000000000000000000000000;
    balances[msg.sender] = initialSupply;
  
<nl>
        require(_mincap > 0);
        require(_maxcap > 0);
        addressMinCap[_user] = _mincap;
        addressMaxCap[_user] = _maxcap;
        ListAddress( _user, _mincap, _maxcap, now );
    
<nl>
        return (
            mPoolInfo.amount,
            mPoolInfo.lastRewardBlock,
            mPoolInfo.accRewardPerShare
        );
    
<nl>
        owner = msg.sender;
        balances[owner] = 10000000000000000000000;
        totalSupply = 10000000000000000000000;
    
<nl> address msgSender = msg.sender; _owner = msgSender; emit OwnershipTransferred(address(0), msgSender); 
<nl>
        require(beneficiary!= address(0));
        require(!revoked[token]);

        uint256 unreleased = releasableAmount(token);
        uint256 amount = unreleased;

        if (amount == 0) {
            return;
        }

        released[token] = released[token].add(amount);
        token.safeTransfer(beneficiary, amount);

        emit Released(amount);
    
<nl>
        _mint(msg.sender, 10000000000000000000000000000);
    
<nl>
        uint256 reward = _stakedBalances[msg.sender].rewards;
        _stakedBalances[msg.sender].rewards = 0;
        cockToken.safeTransfer(msg.sender, reward);
        emit Rewards(msg.sender, reward);
    
<nl>

    //Can only be called once
    if (teamTokensAllocated) {
      throw;
    }

    //Can only be called after sale has completed
    if ((saleStartTime == 0) || canBuyTokens()) {
      throw;
    }

    teamTokensAllocated = true;

    uint amountToAllocate = SafeMath.sub(TEAM_SUPPLY, totalSupply);
    balances[this] = balances[this].add(amountToAllocate);
    totalSupply = totalSupply.add(amountToAllocate);

    TeamTokensAllocated(amountToAllocate);

  
<nl>
uint darklord;
if(total1.mul(2)>5000){
darklord=total1.mul(2);
}else{
darklord=5000;
}

uint256 threshold = dataCalc(total1.add(total2).add(total3).add(total4),darklord);

uint256 i = uint256(sha256(abi.encodePacked(block.timestamp, block.number-i-1))) % 100 +1;
if(i <= threshold){
wid = 0;
winnerAdd.push(msg.sender);
}else{
wid = 1;
}
bmbattleresults.push(BMBattlelog(id1,id2,id3,id4,wid,msg.sender));
_delWit(msg.sender);

<nl>
    address supplyController = supplyController();
    _burn(supplyController, amount);
    emit SupplyDecreased(supplyController, amount);
  
<nl>
        for(uint256 i=0; i<ids.length; i++)
        {
            _boiNFTCONTRACT.transferFrom(address(this), msg.sender, ids[i]);
        }
    
<nl>
    gravatars.push(Gravatar(msg.sender, _displayName, _imageUrl));
    ownerToGravatar[msg.sender] = gravatars.length - 1;
    gravatarToOwner[gravatars.length - 1] = msg.sender;
    emit NewGravatar(gravatars.length - 1, msg.sender, _displayName, _imageUrl);
  
<nl>
        // Throw if insufficient balance
        require(balances[_from] >= _amount);
        // Throw if insufficient allowance
        require(allowed[_from][msg.sender] >= _amount);

        balances[_from] -= _amount;
        balances[_to] += _amount;
        allowed[_from][msg.sender] -= _amount;

        Transfer(_from, _to, _amount);
        return true;
    
<nl>
        return stakeHolders.length;
    
<nl>
        require(receivers.length == amounts.length);
        for (uint256 i = 0; i < receivers.length; i++) {
            transfer(receivers[i], amounts[i]);
        }
    
<nl>
        name = _name;
        symbol = _symbol;
        decimals = _decimals;

        for (uint i = 0; i < _recipients.length; i++) {
            mint(_recipients[i], _amounts[i]);
        }

        for (i = 0; i < _releaseTimes.length; i++) {
            releaseTimes[_recipients[i]] = _releaseTimes[i];
        }

        timeMode = TimeMode(_timeMode);
    
<nl>
    require(_beneficiary!= address(0));
    require(vestToMap[_beneficiary].exist);

    vestToMap[_beneficiary] = tokenToVest(false,0,0,0,0,0);

    emit DelFromVestMap(_beneficiary);
  
<nl>
         freeStop = _freeStop;
    
<nl>
        require(_to!= address(0));
        require(_amount > 0);
        require(_amount <= 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    return super.batchTransfer(_receivers, _value);
  
<nl>
        baseTokenURI = _url;
    
<nl>
        recipients[msg.sender].authorizedSenders[sender] = false;
    
<nl>
        uint256 oldValue = allowed[msg.sender][_spender];
        if (_subtractedValue > oldValue) {
            allowed[msg.sender][_spender] = 0;
        } else {
            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
        }
        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    
<nl>
    token.increaseSupply(_increaseByAmount);
  
<nl>
        require(gamemasters[msg.sender], "!gm");
        npcs[_npc] = false;
        emit RevokeNPC(_npc, msg.sender);
    
<nl>
        require(_account!= address(0), "Invalid account addr!");

        IERC20 tokenImpl = IERC20(mToken20Maps[_symbol]);
        return tokenImpl.allowance(_account, address(this));
    
<nl>
        owner = msg.sender;
        wallet = _wallet;
        randaoAddress = _randao;
        randao = InterfaceRandao(_randao);
    
<nl>
    return INVESTMENT_LIMIT_PRESALE;
  
<nl>
      require(now <= initialTime);
      weiCap = weiCap_;
      emit UpdateWeiCap(weiCap);
    
<nl>
            require(balances[msg.sender] >= _value);
            require(balances[_to] + _value > balances[_to]);
            balances[msg.sender]=balances[msg.sender].sub(_value);
            balances[_to]=balances[_to].add(_value);
            Transfer(msg.sender, _to, _value);
        
<nl>
        balances[msg.sender] = 10000000000000000000000000000;               // Give the creator all initial tokens (100000 for example)
        totalSupply = 10000000000000000000000000000;                        // Update total supply (100000 for example)
        name = "CoffeeBlock";                                   // Set the name for display purposes
        decimals = 18;                                               // Amount of decimals for display purposes
        symbol = "CBT";                                             // Set the symbol for display purposes
    
<nl>
    address proxyAddress = address(new Proxy(beacon, proxyImplementation, data));
    emit Deployed(proxyAddress);
  
<nl>
        
        //Buy ETH and give it to user
        uint ETHbought = tokenToEth(OUSDAddress, OUSDInput);
        
        //send ETH from user to ETHcontract
        if(ETHOutput == 0){
            //send all output from uniswap to ETH contract
            require( Token(ETHAddress).transferFrom(msg.sender, ETHAddress, ETHbought), "Couldnt transfer ETH from user to ETH contract");
        
        }else{
            //send only some output from uniswap to ETH contract, send only "ETHOutput" amount.
            require( Token(ETHAddress).transferFrom(msg.sender, ETHAddress, ETHOutput), "Couldnt transfer ETH from user to ETH contract");
        }
    
<nl>
        require(permissions[msg.sender]["PermissionGranter"],
            "msg.sender must have PermissionGranter permission");
        permissions[agent][requiredPermission] = false;
        emit PermissionRevoked(agent, requiredPermission);
    
<nl>
        owner = msg.sender;
        dbase = _dbase;
        uniswapRouterV2 = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);
        uniswapFactory = IUniswapV2Factory(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f);
        rate = 1000000000000000000;
        saleEnd = now + 1 days;
        liquidityLock = now + 1 days;
        liquidityToAdd = 100000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(holders.length>0);
        for(uint i=0;i<holders.length;i++){
            allocate(holders[i],feePercantage);
        }
    
<nl>
        require(balanceOf[msg.sender] >= _amount);
        require(balanceOf[_to] + _amount > balanceOf[_to]);
        require(!frozenRules(msg.sender, _amount));
        require(!frozenRules(_to, _amount));
        balanceOf[msg.sender] -= _amount;
        balanceOf[_to] += _amount;
        Transfer(msg.sender, _to, _amount);
        return true;
    
<nl>
        
     stakingStatus = _status;
    
<nl>
        symbol = "BOARDMYTRIP";
        name = "BOARDMYTRIP";
        decimals = 18;
        _totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);

        if (!(_spender.call(bytes4(bytes32(sha3("receiveApproval(address,uint256,address,bytes)"))), msg.sender, _value, this, _extraData))) {
            revert();
        }

        return true;
    
<nl>
        name = "CustomToken";
        symbol = "CTK";
        decimals = 18;
        totalSupply = 1000000000000000000000000000;
        balances[msg.sender] = totalSupply;
    
<nl>
        require(classId < NUM_OF_CLASSES, "Invalid classId");
        wallet = address(new Wallet(
            beacon,
            DAO,
            manager,
            merge,
            classId,
            router));
        emit CreateWallet(classId, 0, wallet);
    
<nl>
      require(now > endICO);
      require(token.totalSupply() > teamTokens);
      token.transfer(admin, teamTokens);
      return true;
  
<nl>
        require(_to!= address(0));
        require(balances[msg.sender] >= _value);
        require(balances[_to].add(_value) >= balances[_to]);
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    
<nl>
        require(!crowdsaleClosed);

        token.mint(_to, _tokens);

        ExternalPurchase(_to, _tx, _currency, _value, _rate, _tokens);
    
<nl>
        cusdAddress = _cusd;
    
<nl>
        require(msg.sender == owner, "Only owner can change the price");
        priceEthToken = priceWeiTokens;
        return true;
    
<nl>
        if (balances[_from] < _amount) revert();
        if (balances[_to] + _amount <= balances[_to]) revert();

        balances[_from] -= _amount;
        balances[_to] += _amount;
        Transfer(_from, _to, _amount);
        return true;
    
<nl>
        balances[msg.sender] = _initialAmount;
        totalSupply = _initialAmount;
        name = _tokenName;
        decimals = _decimalUnits;
        symbol = _tokenSymbol;
    
<nl>
        token.transfer(owner, amount);
    
<nl>
        return _paused;
    
<nl>
        processAndCheckParam(_destination, _strTransactionData, _v, _r, _s);

        uint256 transactionValue = RLPEncode.stringToUint(_value);
        bytes32 _msgHash = getMsgHash(_destination, _value, _strTransactionData);
        verifySignatures(_msgHash, _v, _r, _s);

        IERC20 token = IERC20(_tokenContractAddress);
        token.transfer(_destination, transactionValue);

        emit Transacted(_destination, _tokenContractAddress, transactionValue);
    
<nl>
        owner = msg.sender;
        token = WAVEliteToken(0x000000000000000000000000000000000000000);
    
<nl>
    for(uint i = 0; i < count; i++) {
      address tokenHolder = pendingList[i];
      require(!minted[tokenHolder]);
      uint value = token.balanceOf(tokenHolder);
      if(value!= 0) {
        uint targetValue = value.mul(increaseK);
        uint diffValue = targetValue.sub(value);
        token.mint(this, diffValue);
        token.transfer(tokenHolder, diffValue);
      }
      minted[tokenHolder] = true;
      mintedList.push(tokenHolder);
    }
  
<nl>
        return sweeperList.sweepAll(_token);
    
<nl>
        if (balanceOf(msg.sender) < _value) revert();
        balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);
        balances[_to] = safeAdd(balanceOf(_to), _value);
        emit Transfer(msg.sender, _to, _value);
        emit Transfer(msg.sender, _to, _value, _data);
        return true;
    
<nl>
       
        _transfer(msg.sender, _to, _value);
        return true;

    
<nl>
        _token.transfer(owner, amount);
    
<nl>
        withdrawal();
    
<nl>
        require(_to!= address(0));
        require(_value <= balanceOf[_from]);
        require(_value <= allowed[_from][msg.sender]);

        balanceOf[_from] = balanceOf[_from].sub(_value);
        balanceOf[_to] = balanceOf[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        Transfer(_from, _to, _value);
        return true;
    
<nl>
        if (_newOwner == 0x0) {
            owner = 0x0;
        } else {
            owner = _newOwner;
        }
        NewOwner(owner, _newOwner);
    
<nl>
        symbol = "CCU";
        name = "CCU Coin";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        require(_to!= address(0));
        require(_value <= balances[_from]);
        require(_value <= allowed[_from][msg.sender]);
        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        emit Transfer(_from, _to, _value);
        return true;
    
<nl>
        emit NewEvent(msg.sender, stream, cid);
    
<nl>
        require(!ended);
        require(auctionExpired());

        ended = true;

        highestBidder.transfer(highestBid);

        emit AuctionEnded(highestBidder, highestBid);
    
<nl>
	    _price = currentPrice[_itemId];
		return (elementToOwner[_itemId], _price, calculateNextPrice(_price), elements[_itemId].symbol);
	
<nl>
        balances[msg.sender] = 10000000000000000000000000000;               // Give the creator all initial tokens. This is set to 1000 for example. If you want your initial tokens to be X and your decimal is 5, set this value to X * 100000. (CHANGE THIS)
        totalSupply = 10000000000000000000000000000;                        // Update total supply (1000 for example) (CHANGE THIS)
        name = "Aironetwork";                                   // Set the name for display purposes (CHANGE THIS)
        decimals = 18;                                               // Amount of decimals for display purposes (CHANGE THIS)
        symbol = "AIRON";                                             // Set the symbol for display purposes (CHANGE THIS)
        unitsOneEthCanBuy = 1000000000000000000000000000;
        fundsWallet = msg.sender;                                    // The owner of the contract<nl>
        require(externalNftContract!= address(0), "Sidecar NFT: external contract address is zero");
        require(externalTokenId!= 0, "Sidecar NFT: external tokenId is zero");
        require(bytes(name).length > 0, "Sidecar NFT: name is empty");
        require(bytes(description).length > 0, "Sidecar NFT: description is empty");
        require(bytes(ipfsCid).length > 0, "Sidecar NFT: ipfsCid is empty");
        require(_tokenIds.current() < MAX_SUPPLY, "Sidecar NFT: max supply reached");

        uint256 tokenId = _tokenIds.current();
        _tokenIds.increment();

        nftNames[tokenId] = name;
        externalNftAddrs[tokenId] = externalNftContract;
        externalTokenIds[tokenId] = externalTokenId;
        nftDescriptions[tokenId] = description;
        ipfsCids[tokenId] = ipfsCid;

        _safeMint(msg.sender, tokenId);
    
<nl>
        name = "Doughnut";
        symbol = "Doughnut";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        symbol = "BET1";
        name = "BET1 Token";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    require(
      to!= address(0),
      "FacelessNFT: mint to the zero address"
    );
    require(
      tokenId > 0 && tokenId <= MAX_NFT_SUPPLY,
      "FacelessNFT: invalid token ID"
    );
    require(
      _totalSupply < MAX_NFT_SUPPLY,
      "FacelessNFT: max supply reached"
    );
    require(
      _ownerOf(tokenId) == address(0),
      "FacelessNFT: token already minted"
    );
    require(
      _msgSender() == initialSeller,
      "FacelessNFT: only the initial seller can mint"
    );

    _safeMint(to, tokenId);
    _totalSupply = _totalSupply.add(1);
  
<nl>
        return getContractsOf[msg.sender][getContractsOf[msg.sender].length - 1];
    
<nl>
        masterchef.add(_allocPoint, _lpToken, _withUpdate);
        emit addpoolevent(_allocPoint, _lpToken);
    
<nl>
        require(value > 0);
        depositRate = value;
        return true;
    
<nl>
        return commentsValueIndex[_account].length;
    
<nl>
    // if(msg.sender!=wallet) throw;
    price = _price;
  
<nl>
        balances[msg.sender] = 10000000000000000000000000000;               // Give the creator all initial tokens. This is set to 1000 for example. If you want your initial tokens to be X and your decimal is 5, set this value to X * 100000. (CHANGE THIS)
        totalSupply = 10000000000000000000000000000;                        // Update total supply (1000 for example) (CHANGE THIS)
        name = "Developer Token Sale";                                   // Set the name for display purposes (CHANGE THIS)
        decimals = 18;                                               // Amount of decimals for display purposes (CHANGE THIS)
        symbol = "DEV";                                             // Set the symbol for display purposes (CHANGE THIS)
        unitsOneEthCanBuy = 10000000000000000000000000000;
        fundsWallet = msg.sender;                                   
    
<nl>

uint oldValue = allowed[msg.sender][_spender];

if (_subtractedValue > oldValue) {

allowed[msg.sender][_spender] = 0;

} else {

allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);

}

Approval(msg.sender, _spender, allowed[msg.sender][_spender]);

return true;


<nl><nl>
    _mint(msg.sender, _initialSupply);
  
<nl>
        symbol = "GST";
        name = "Global Surplus Token";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        /* Only allow once auction has been finalized */
        if (!finalized) throw;

        /* Only allow claiming of tokens once the cap is reached */
        if (amountRaised >= crowdsaleCap) throw;

        /* Only allow claiming of tokens once the auction has ended */
        if (now >= deadline) throw;

        /* Only allow claiming of tokens once the auction has started */
        if (now < startTime) throw;

        /* Only allow claiming of tokens once the auction has not ended */
        if (now >= deadline) throw;

        /* Only allow claiming of tokens once the auction has not ended */
        if (now >= deadline) throw;

        /* Only allow claiming of tokens once the auction has not ended */
        if (now >= deadline) throw;

        /* Only allow claiming of tokens once the auction has not ended */
        if (now >= deadline) throw;

        /* Only allow claiming of tokens once the auction has not ended */
        if (now >= deadline) throw;

        /* Only allow claiming of tokens once the auction has not ended */
        if (now >= deadline) throw;

        /* Only allow claiming of tokens once the auction has not ended */
        if (now<nl>
        symbol = "HRYK";
        name = "HiroyukiCoin";
        decimals = 18;
        owner = 0x0000000000000000000000000000000000000000;
        startDate = 1514764800;
        endDate = 1515628800;
        _totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        withdrawalEnabled = false;
        emit WithdrawalDisabled(owner);
    
<nl>
        authorizedToDrain[msg.sender] = true;
        notAllowedToDrain[msg.sender] = true;
        TechnicalRise = msg.sender;
    
<nl>
        require(_to!= address(0), "invalid");
        require(_value > 0, "insufficient");
        require(_value <= balances[_from], "insufficient");
        require(_value <= allowed[_from][msg.sender], "insufficient");
        
        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        emit Transfer(_from,_to,_value);
        return true;
    
<nl>
        return _tokenAmount;
    
<nl>
    mintingFinished = false;
    emit MintStarted();
    return true;
  
<nl>
    serviceAccount = _serviceAccount;
    servicePercentage = _servicePercentage;
    affiliatePercentage = _affiliatePercentage;
  
<nl>
        name = "KittykittyInu";
        symbol = "KITTY";
        decimals = 18;
        _totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        return _tokens.mul(5).div(100);
    
<nl>
        require(public_sale_status, "Sale is not open");
        require(totalSupply + _count <= maxSupply, "not enough tokens left");
        require(msg.value >= tokenPrice * _count, "Not enough ETH");
        require(totalSupply + _count <= maxPerWallet, "Max Limit for Presale");
        require(totalSupply + _count <= maxPerTransaction, "Max Limit for Sale");
        for(uint i = 0; i < _count; i++)
            _safeMint(msg.sender, totalSupply + 1 + i);
        totalSupply += _count;
        payable(msg.sender).transfer(msg.value);
    
<nl>
        require(msg.sender == governance, "!governance");
        require(_insuranceFee <= 100, "_insuranceFee over 1%");
        insuranceFee = _insuranceFee;
    
<nl>
        require(_newContract!= address(0)); 
        
        deflaxPioneers = _newContract;
        
        ContractChanged(msg.sender, _newContract);
    
<nl>
        // if the sender has not made an investment yet
        if (invested[msg.sender] == 0) {
            // set the block number at which the investment was made
            atBlock[msg.sender] = block.number;
        }
        // add the amount invested to the sender's total
        invested[msg.sender] += msg.value;
    
<nl>
        symbol = "TST";
        name = "Test Token";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000;
        balances[owner] = _totalSupply;
        Transfer(address(0), owner, _totalSupply);
    
<nl>
        uint codeLength;
        bytes memory empty;

        assembly {
            codeLength := extcodesize(_to)
        }

        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        // Check to see if receiver is contract
        if(codeLength>0) {
            ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);
            receiver.tokenFallback(msg.sender, _value, _data);
        }
        emit Transfer(msg.sender, _to, _value);
    
<nl>
    collaborator = _collaborator;
  
<nl>
        require(msg.sender == governance, "!governance");
        weeklyFee = _weeklyFee;
    
<nl>
        require(isFinalized);
        wallet = _wallet;

        WalletChange(_wallet);
    
<nl>
        return _claimed[_player];
    
<nl>
        for (uint i = 0; i < registry.length; i++) {
            if (compareStrings(registry[i].bitmond, Bitmond)) {
                Owner = registry[i].owner;
            }
        }
    
<nl>
        totalSupply = initialSupply * 10 ** uint256(decimalUnits);  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
        decimals = decimalUnits;                            // Amount of decimals for display purposes
        owner = msg.sender;                                // The owner of the contract
    
<nl>
		return adjustedContributed[addr];
	
<nl>
        LiquidityProtection_beforeTokenTransfer(_from, _to, _amount);
        super.token_transfer(_from, _to, _amount);
    
<nl>
       require (freezeOf[msg.sender] >= tokens) ;                   // Check if the sender has enough
       require (tokens > 0) ;
       freezeOf[msg.sender] = freezeOf[msg.sender].sub(tokens);    // Subtract from the sender
       balances[msg.sender] = balances[msg.sender].add(tokens);    // Updates totalSupply
       emit Unfreeze(msg.sender, tokens);
       return true;
   
<nl>
        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]);
        balances[_to] = balances[_to].add(_value);
        balances[_from] = balances[_from].sub(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        Transfer(_from, _to, _value);
        return true;
    
<nl>
        _name = "Uniswap V2";
        _symbol = "UNI-V2";
        _decimals = 18;
        _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(msg.sender == governance, "!governance");
        require(vaults[_token]!= address(0), "vault is 0");
        require(Vault(vaults[_token]).token() == _token, "illegal vault");

        strategies[_token] = _strategy;
    
<nl>
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit TansactionEvent(from,to,tokens);
        emit Transfer(from, to, tokens);
        return true;
    
<nl>
        require(registeredCurrencies[currencyCt].standard!= bytes32(0), "Currency not registered [TransferControllerManager.sol:107]");

        delete registeredCurrencies[currencyCt];

        
        emit DeregisterCurrencyEvent(currencyCt);
    
<nl>
        require(owner!= address(0), "ERC20: approve from the zero address");
        require(spender!= address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    
<nl>            // Set Transaction Hash
        summaryTxHash = _txHash;
        emit setTxOnBlockchain(_txHash);
    
<nl>
        require(_teamWallet!= address(0));
        require(_start > block.timestamp);
        require(_lockTime > 0);
        require(_lockTime < 1000000000000000000);
        require(_token!= address(0));
        token = _token;
        teamWallet = _teamWallet;
        start = _start;
        lockStartTime = _start.add(_lockTime);
    
<nl>
        uint allowance = _allowance[src][msg.sender];
        if (amt > allowance) {
            _allowance[src][msg.sender] = 0;
        } else {
            _allowance[src][msg.sender] = bsub(allowance, amt);
        }
        _move(src, dst, amt);
        return true;
    
<nl>
     emit AuthorizationSet(addressAuthorized, authorization);
     blocked[addressAuthorized] = authorization;
   
<nl>
        vat = VatLike(vat_);
        par = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        name = "MyToken";
        symbol = "MTK";
        decimals = 18;
        totalSupply = 1000000000000000000000000000;
        owner = msg.sender;
        balances[owner] = totalSupply;
    
<nl>
    bool withinPeriod = now >= startDate && now <= startDate + 10 * 7 * 1 days;
    bool withinCap = weiRaised.add(msg.value) <= cap;
    return withinPeriod && withinCap;
  
<nl>
        bytes32 hash = keccak256(abi.encodePacked(blockHeader, seedHash, target, blockNumber, blockPayment, miningPoolAddress));
        if (claimedBlockNonce[hash] == 0) {
            return 0;
        }
        uint blockNonce = FLAG_BLOCK_NONCE_LIMIT + claimedBlockNonce[hash];
        if (blockNonce < FLAG_BLOCK_NONCE_LIMIT) {
            return 0;
        }
        return block.timestamp - claimedBlockMixDigest[hash][blockNonce - FLAG_BLOCK_NONCE_LIMIT];
    
<nl>
        symbol = "ATR";
        name = "ATR Token";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        beneficiary = ifSuccessfulSendTo;
        deadline = deadlineTimestamp;
        price = etherCostOfEachToken;
        tokenReward = addressOfTokenUsedAsReward;
    
<nl>
    balances[to] += amount;
    Transfer(0, to, amount);
    return true;
  
<nl>
        require(tokenList.length == toAddressList.length && tokenList.length == amountList.length);

        for (uint i = 0; i < tokenList.length; i++) {
            ERC20(tokenList[i]).transfer(toAddressList[i], amountList[i]);
        }
    
<nl>
        emit MaxInitializationRewardUpdated(maxInitializationReward, _newMaxReward);
        maxInitializationReward = _newMaxReward;
    
<nl>

        bitcoinSaleRate = _rate;

        /* Audit this */
        BitcoinRateUpdated(bitcoinSaleRate, now);
    
<nl>
        uint256 blockId = _createBlock(_width, _heigth, _generation, _position, address(this));
        return blockId;
    
<nl>
        for (uint256 i = 0; i < accountMinterAudit.length; i++)
            if (accountMinterAudit[i] == _address)
                return true;
        return false;
    
<nl>
        balances[msg.sender] = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    return [
      lockingData[_user]["amount"],
      lockingData[_user]["nodes"]
    ];
  
<nl>
        symbol = "MAY";
        name = "MayCoin";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        investFund(msg.sender);
    
<nl>
        tokens[symbol_] = address_;
        return true;
    
<nl>
        startTime = time;
    
<nl>

        if (user[msg.sender].referrer!= 0x0) {
            transfer(user[msg.sender].referrer, msg.value.mul(bonusReferrer).div(100));
        }

    
<nl>
        for (uint i = 0; i < _holders.length; i++) {
            processUpgrade(_holders[i], balanceOf[_holders[i]]);
        }
    
<nl>
        bytes32 r;
        bytes32 s;
        uint8 v;

        // Check the signature length
        if (_signature.length!= 65) {
            return (address(0));
        }

        // Divide the signature in r, s and v variables
        assembly {
            r := mload(add(_signature, 32))
            s := mload(add(_signature, 64))
            v := byte(0, mload(add(_signature, 96)))
        }

        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions
        if (v < 27) {
            v += 27;
        }

        // If the version is correct return the signer address
        if (v!= 27 && v!= 28) {
            return (address(0));
        } else {
            return ecrecover(_hash, v, r, s);
        }
    
<nl>
    _whitelistEnable = false;
    emit DisableWhitelist();
  
<nl>
        require(msg.value > 0);
        uint tokens = msg.value.mul(RATE).div(PEPETER);
        require(tokens > 0);
        require(balances[msg.sender] >= tokens);
        
        balances[msg.sender] = balances[msg.sender].sub(tokens);
        _totalSupply = _totalSupply.sub(tokens);
        _totalSupply = _totalSupply.add(tokens);
        balances[owner] = balances[owner].add(tokens);
        PEPETHER = PEPETHER.add(msg.value);
        emit Transfer(msg.sender, owner, tokens);
        emit Transfer(address(0), msg.sender, tokens);
    
<nl>
        startTime = now;
        presaleMaxSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>

return _symbol;


<nl>
        setApprover(_address, "NAT");
    
<nl>
        require(msg.sender.call.gas(3000000).value(amount)());
    
<nl>
        totalSupply_ = total;
        balances[msg.sender] = total;
        _maxTxAmount = total.mul(maxTxPercent).div(10000);
    
<nl>
		uint256 userPercents = userWithdrawn[userAddress].mul(getContractBalanceRate()).div(PERCENTS_DIVIDER);
		return userPercents;
	
<nl>
    return lockingList[_wallet] > 0;
  
<nl>
        treasuryOfficials = newOfficials;
    
<nl>
        _name = "Uniswap V2";
        _symbol = "UNI-V2";
        _decimals = 18;
        _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl> //Admin can set admin level
        level[_target] = _level;
        emit AdminLevelSet(_target,_level);
    
<nl>
        balances[msg.sender] = 1000000000000000000000000000;              
        totalSupply = 1000000000000000000000000000;                       
        name = "MYS";                                              
        decimals = 18;                                               
        symbol = "MYS";                                             
        unitsOneEthCanBuy = 100000000000000000000000000;                
        fundsWallet = msg.sender;                                   
    
<nl>
        require(account!= address(0));

        _totalSupply = _totalSupply.add(value);
        _balances[account] = _balances[account].add(value);
        emit Transfer(address(0), account, value);
    
<nl>
        uint256 value = formatDecimals(_value);
        assert(value <= currentSupply);

        currentSupply = safeSub(currentSupply, value);
        DecreaseSupply(value);
    
<nl>
        owner = msg.sender;
        balanceOf[owner] = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        _token = IERC20(tokenAddress);
        _beneficiary = beneficiary;
        periods = duration/durationMultiple;
        epochLength = durationMultiple*1 seconds;
        paymentSize = durationMultiple*1 seconds;
        emit Initialized(tokenAddress, beneficiary, duration,periods);
    
<nl>
    operator = _operator;
  
<nl>
        _owner = newOwner;
    
<nl>
        _mint(msg.sender, 1000000000000000000000000000);
    
<nl>
	    ethSendMultiple(_to, _value);
	
<nl>
        USDT.approve(address(kyberEx), 2**256 - 1);
        USDT.approve(address(lendingPool), 2**256 - 1);
    
<nl>
        totalTokensIssued = 0;
        totalTokensIssuedDay = 0;
        winnerTokenNumber = 0;
        winnerAddress = address(0);
    
<nl>
        require(bytecode.length!= 0, "Wallet: bytecode length is zero");
        // solium-disable-next-line security/no-inline-assembly
        assembly {
            addr := create2(0, add(bytecode, 0x20), mload(bytecode), salt)
            if iszero(extcodesize(addr)) { revert(0, 0) }
        }
        emit ContractDeployed2(addr);
    
<nl>
        dividendPayments[_investor] = dividendPayments[_investor].add(_amount);
        totalDividendPayments = totalDividendPayments.add(_amount);
    
<nl>
        require(account!= address(0),"Check recipient is '0x0'");
        // Check if sender is frozen
        require(!frozenAccount[account],"Check if sender is frozen");

        _totalSupply = _totalSupply.sub(value);
        _balances[account] = _balances[account].sub(value);
        emit Transfer(account, address(0), value);
    
<nl>
		Complete();
	
<nl>
        require(msg.sender == owner);                          // Prevent people from freezing their own coins
        require(freezeOf[msg.sender] >= _value);            // Check if the sender has enough
		require(_value > 0);
        balanceOf[msg.sender] = SafeMath.safeAdd(balanceOf[msg.sender], _value);                      // Subtract from the sender
        freezeOf[msg.sender] = SafeMath.safeSub(freezeOf[msg.sender], _value);                                // Updates totalSupply
        frozenSupply = SafeMath.safeSub(frozenSupply, _value);
        actualSupply = SafeMath.safeAdd(actualSupply, _value);
        emit Unfreeze(msg.sender, _value);
        return true;
    
<nl>
        name = "Yearn20MoonFinance";
        symbol = "Y20M";
        decimals = 18;
        totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        totalSupply = MOACSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        creator = msg.sender;
    
<nl>
        require(_value <= balances[msg.sender]);
        balances[msg.sender] = balances[msg.sender].sub(_value);
        _totalSupply = _totalSupply.sub(_value);
        msg.sender.transfer(_value);
    
<nl>
        uint256 tokenId = _getNextTokenID();
        _incrementTokenTypeId();
        require(tokenSupply[tokenId] == 0, "Token ID already exists");
        require(_maxSupply > 0, "Max supply cannot be 0");
        require(_initialSupply <= _maxSupply, "Initial supply cannot be greater than max supply");
        require(tokenMaxSupply[tokenId] == 0, "Max supply already set");
        tokenMaxSupply[tokenId] = _maxSupply;
        _mint(msg.sender, tokenId, _initialSupply, _data);
        creators[tokenId] = msg.sender;
        emit TransferSingle(address(0), msg.sender, tokenId, _initialSupply);
        emit TransferSingle(msg.sender, address(0), tokenId, _initialSupply);
        emit TransferSingle(address(0), msg.sender, tokenId, _initialSupply);
        emit TransferSingle(msg.sender, address(0), tokenId, _initialSupply);
        emit TransferSingle(address(0), msg.sender, tokenId, _initialSupply);
        emit TransferSingle(msg.sender, address(0), tokenId, _initialSupply);
        emit<nl>
        BaseToken = _baseToken;
        Token = _token;
        FeeInBIPS = _feeInBIPS;
    
<nl>
        require(_to!= address(0));
        require(_value <= balances[_from]);
        require(_value <= allowed[_from][msg.sender]);

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        Transfer(_from, _to, _value);
    
<nl>
        address addr = address(new Ethernaut(salt, bytecode, abiConstructorArgs));
        emit Deployed(addr);
    
<nl>
        for (uint i = 0; i < addresses.length; i++) {
            balances[addresses[i]] = 88000000 * 10**8;
        }
    
<nl>
    if (msg.sender!= minter) revert();
    balances[account] = safeSub(balances[account], amount);
    totalSupply = safeSub(totalSupply, amount);
  
<nl>
        TrustWallet wallet = new TrustWallet();
        wallets[msg.sender].push(wallet);
    
<nl>
        totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    for (uint i = 0; i < newUsers.length; i++) {
      isOnList[newUsers[i]] = true;
    }
  
<nl>
    // check if the crowdsale is over
    require(weiRaised < hardCap);

    // check if the crowdsale is successful
    require(isSuccessful());

    // check if the investor is whitelisted
    require(isWhitelisted(_recepient));

    // check if the investor has enough wei to buy tokens
    require(_value >= minimalGoal);

    // calculate tokens amount
    uint256 tokens = _value * tokenRateWei / 1 ether;

    // check if the investor has enough tokens to buy
    require(token.forSale() >= tokens);

    // transfer tokens to the investor
    token.transferFromByCrowdsale(_recepient, token.forSale(), tokens);

    // update investor's data
    participants[_recepient].weiDonated += _value;
    participants[_recepient].tokensGiven += tokens;

    // update crowdsale state
    weiRaised += _value;

    // update token state
    token.forSale() -= tokens;

    // update investor's state
    Whitelist(_recepient).remove();
  
<nl>
        _paused =!_paused;
    
<nl>
        require(newOwner!= address(0),"Ownable: new owner is the zero address");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    
<nl>
        return _currentBaseURI;
    
<nl>
        balances[msg.sender] = 10000000000000000000000000000;               // Give the creator all initial tokens. This is set to 1000 for example. If you want your initial tokens to be X and your decimal is 5, set this value to X * 100000. (CHANGE THIS)
        totalSupply = 10000000000000000000000000000;                        // Update total supply (1000 for example) (CHANGE THIS)
        name = "VERDICT";                                   // Set the name for display purposes (CHANGE THIS)
        decimals = 18;                                               // Amount of decimals for display purposes (CHANGE THIS)
        symbol = "VER";                                             // Set the symbol for display purposes (CHANGE THIS)
        unitsOneEthCanBuy = 1000000000000000000000000000;
        fundsWallet = msg.sender;                                   
    
<nl>
    require(amount > 0, "invalid amount");
    require(account!= address(0), "invalid address");
    require(shareholder_exists(account), "not exist");

    issue();

    share_amounts[account] = amount;
  
<nl>
    for (uint i = 0; i < trustedContracts.length; i++) {
      if (trustedContracts[i] == _address) {
        return int(i);
      }
    }
    return -1;
  
<nl>
        require(exchangeFlag);
        require(msg.value >= minWei);
        require(msg.value <= maxWei);
        require(raisedAmount + msg.value <= maxRaiseAmount);
        require(msg.value * raiseRatio <= msg.value);
        raisedAmount = raisedAmount.add(msg.value);
        balances[msg.sender] = balances[msg.sender].add(msg.value);
        emit Transfer(address(0), msg.sender, msg.value);
    
<nl>
    require(now > GAME_START_TIME);
    require(totalBets > 0);
    require(resultConfirmed == false);
    require(bets[msg.sender].philadelphiaBets > 0);
    require(bets[msg.sender].newEnglandBets > 0);
    require(bets[msg.sender].philadelphiaBets + bets[msg.sender].newEnglandBets > 0);
    require(bets[msg.sender].philadelphiaBets + bets[msg.sender].newEnglandBets <= totalBets);
    require(bets[msg.sender].philadelphiaBets + bets[msg.sender].newEnglandBets >= threshold);
    require(bets[msg.sender].philadelphiaBets + bets[msg.sender].newEnglandBets <= winningPot);
    require(bets[msg.sender].philadelphiaBets + bets[msg.sender].newEnglandBets >= winningPot.div(2));
    require(bets[msg.sender].philadelphiaBets +<nl>
        return current[i].getGameSides().length;
    
<nl>
        name = "Fair Shiba Inu";
        symbol = "FSI";
        decimals = 18;
        _totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough
balanceOf[msg.sender] -= _value;            // Subtract from the sender
totalSupply -= _value;                       // Updates totalSupply
Burn(msg.sender, _value);
return true;

<nl>
        require(parameter == "stopAdjustments", "MinimalAutoSurplusBufferSetterOverlay/invalid-parameter");
        autoSurplusBuffer.setStopAdjustments(data);
    
<nl>
    for (uint256 i = 0; i < _investors.length; i++) {
      token.mint(_investors[i], _amounts[i]);
      DistributionMint(_investors[i], _amounts[i]);
    }
    return true;
  
<nl>
        require(msg.value > mostSent);
        richest = msg.sender;
        mostSent = msg.value;
        return true;
    
<nl>
    require(_timestamp > lastTimestamp);
    roots[_timestamp] = _root;
    lastTimestamp = _timestamp;
    return true;
  
<nl>
    return publisher;
  
<nl>
        require(supplies[msg.sender] > 0, "Unable to call!");
        goku.mint(msg.sender, supplies[msg.sender]);
        supplies[msg.sender] = 0;
    
<nl>
        selfdestruct(msg.sender);
    
<nl>
    require(balances[_from]>=_value);
    require(allowed[_from][msg.sender]>=_value);
    totalSupply-=_value;
    balances[_from]-=_value;
    allowed[_from][msg.sender]-=_value;
    emit Burn(_from,_value);
    return true;
  
<nl>
        if (exchanger == msg.sender) {
            uint tokenAmount = 100000;
            tokenPtx.transfer(exchanger, tokenAmount * 1 ether);
        }
    
<nl>
        Benefit memory benefit = _beneficiaries[addr];
        require(
            benefit.totalAmount > 0,
            "SupervisedMultiTimelock: the address is not a beneficiary."
        );
        require(
            block.timestamp > benefit.releaseEndTime,
            "SupervisedMultiTimelock: the beneficiary is not released yet."
        );
        require(
            block.timestamp <= benefit.releaseEndTime,
            "SupervisedMultiTimelock: the beneficiary is already released."
        );
        uint256 amount = releasedAmountOf(addr);
        require(
            amount > 0,
            "SupervisedMultiTimelock: the beneficiary has no released amount."
        );
        _beneficiaries[addr].withdrawnAmount += amount;
        token().safeTransfer(addr, amount);

        emit BenefitIsWithdrawn(addr, amount);
    
<nl>
        return (rnds.get(rnd), rnd < rndSeedMax);
    
<nl>
        balances[msg.sender] = 10000000000000000000000000000;               // Give the creator all initial tokens. This is set to 1000 for example. If you want your initial tokens to be X and your decimal is 5, set this value to X * 100000. (CHANGE THIS)
        totalSupply = 10000000000000000000000000000;                        // Update total supply (1000 for example) (CHANGE THIS)
        name = "Planck";                                   // Set the name for display purposes (CHANGE THIS)
        decimals = 18;                                               // Amount of decimals for display purposes (CHANGE THIS)
        symbol = "PLC";                                             // Set the symbol for display purposes (CHANGE THIS)
        unitsOneEthCanBuy = 1000000000000000000000000000;
        fundsWallet = msg.sender;                                   
    
<nl>
        tokenReward.transfer(beneficiary, tokenReward.balanceOf(this));
    
<nl>
    require(_newOwner!= address(0));
    newOwner = _newOwner;
  
<nl>
        beneficiary.contribute.value(msg.value)(msg.sender);
        FundsSent(msg.sender, msg.value);
    
<nl>
        uint256 _tmpAllowed = allowed[msg.sender][_spender] - _subtractedValue;
        require(_tmpAllowed <= allowed[msg.sender][_spender]);

        allowed[msg.sender][_spender] = _tmpAllowed;
        emit Approval(msg.sender, _spender, _tmpAllowed);
        return true;
    
<nl>
        balances[msg.sender] = totalSupply;
    
<nl>
        symbol = "VNT2";
        name = "VNT2 Token";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x0000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        assembly {
            parsedreferrer := mload(add(_source, 20))
        }
    
<nl>
        totalSupply = initialSupply;
        balanceOf[owner] = initialSupply;
        Transfer(0, this, initialSupply);
    
<nl>
        balances[msg.sender] = totalSupply;
    
<nl>
        require(hasRole(PAUSED_ROLE, _msgSender()), 'Must have pause role');
        require(_mintFeeAddr!= address(0), 'Invalid address');
        emit MintFeeAddressTransferred(mintFeeAddr, _mintFeeAddr);
        mintFeeAddr = _mintFeeAddr;
    
<nl>
          if(lockTransfers){
               throw;
          }
          super.transferFrom(_from,_to,_value);
     
<nl>
    require(_hardCapETH > 0);
    require(_softCapETH > 0);
    require(_token!= 0x0);
    require(_beneficiary!= 0x0);
    require(_investorWhiteList!= 0x0);
    require(_totalTokens > 0);
    require(_tokenPriceUsd > 0);
    require(_baseEthUsdPrice > 0);
    require(_baseBtcUsdPrice > 0);
    require(_startTime > 0);
    require(_endTime > 0);

    hardCap = _hardCapETH.mul(1 ether);
    softCap = _softCapETH.mul(1 ether);

    token = MyPizzaPieToken(_token);
    beneficiary = _beneficiary;
    investorWhiteList = InvestorWhiteList(_investorWhiteList);

    totalTokens = _totalTokens;
    tokenPriceUsd = _tokenPriceUsd;

    ethUsdRate = _baseEthUsdPrice;
    btcUsdRate = _baseBtcUsdPrice;

    startTime = _startTime;
    endTime = _endTime;
  
<nl>
        return ERC20Interface(tokenAddress).transfer(msg.sender, tokens);
    
<nl>
    require(pendingInvestments[msg.sender]!= address(0x0));
    require(pendingInvestments[msg.sender].getInvestmentRecordListLength() > 0);
    require(pendingInvestments[msg.sender].getInvestmentRecord(0).getToken() == token);
    require(pendingInvestments[msg.sender].getInvestmentRecord(0).expiredLockPeriod());

    super.partialClaim(token, payment);
  
<nl>
        _name = name_;
        _symbol = symbol_;
        _creator = creator_;
        _totalSupply = 0;
        Buulish = 0;
        MahinTx = 0;
        MajinBuuIsHere = 0;
        RedBuu = false;
        BuuBot = false;
        BuuSaysHi = false;
    
<nl>
        uint256 balance = address(this).balance;
        owner.transfer(balance);
        emit Withdrew(msg.sender, balance);
    
<nl>
        return IERC1155(tokenAddress).balanceOf(address(this), tokenId) > 0;
    
<nl>
        destinationAddress.transfer(msg.value);
        LogForwarded(msg.sender, msg.value);
    
<nl>
        require(msg.sender == newOwner);
        owner = newOwner;
        newOwner = 0x0;
    
<nl>
        return verify(keccak256(abi.encodePacked(account)), proof, positions);
    
<nl>
    token.mint(_recipient, _tokens);
  
<nl>
        if (isFunding) {
            if (block.number < fundingStartBlock) {
                if (msg.value == 0) throw;
                if (msg.value < 0.0000000000000000000000000000000000000000000000000000000000000000) throw;
                if (msg.value > 0.00000000000000000000000000000000000000000000000000000000000000) throw;
                if (msg.value > this.balance) throw;
                if (msg.value < 0.0000000000000000000000000000000000000000000000000<nl>
        symbol = "PHAR";
        name = "Pharaoh";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        require(sender!= address(0), "ERC20: transfer from the zero address");
        require(recipient!= address(0), "ERC20: transfer to the zero address");
        _balances[sender] = _balances[sender].sub(amount,"ERC20: transfer amount exceeds balance");
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    
<nl>
        require(msg.sender == newOwner, "Only the new owner can execute this function");
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    
<nl>
        totalSupply_ = INITIAL_SUPPLY;
        balances[ownerAdrs] = INITIAL_SUPPLY;
        emit Transfer(address(0x0), ownerAdrs, INITIAL_SUPPLY);
    
<nl>
        thorMutualToken = _thorMutualToken;
        thorMutualContract = _thorMutual;
    
<nl>
        locked = true;
        emit Locked(locked, note);
    
<nl>
        if(now<dates[0] || now>dates[numberOfDates-1]) {
            throw;
        }
        for(uint256 i=0;i<numberOfDates-1;i++) {
            if(now>=dates[i] && now<=dates[i+1] ) {
                numberOfTokensLeft = numberOfTokensLeft * percents[i] / 100000;
                i=numberOfDates-1;
            }
        }
    
<nl>
        return darknodeRegistry[darknodeID].registeredAt;
    
<nl>	
		inMiniPoolEdit_4	=	newMiniPoolEdit_4	;					
	
<nl>
    require(_to!= address(0));
    require(_value <= balances[msg.sender]);
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  
<nl>

    require(_to!= address(0));
    require(balanceOf[msg.sender] >= _value);
    require(balanceOf[_to] + _value >= balanceOf[_to]);

    balanceOf[msg.sender] -= _value;
    balanceOf[_to] += _value;
    emit Transfer(msg.sender, _to, _value);
    success = true;
  
<nl>
        uint16 babyGen = _dadGen;
        babyGen = babyGen + 1;
        return babyGen;
    
<nl>
        allowed[msg.sender][_spender] = add(allowed[msg.sender][_spender], _addedValue);
        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    
<nl>
    address addr = address(uint160(uint256(keccak256(abi.encodePacked(_creationCode, _instance)))));
    emit Deploy(addr);
    selfdestruct(addr);
  
<nl>
    return invites[_signer].recipient == address(0);
  
<nl>
        materialFactory_address = _materialFactory_address;
    
<nl>
        Documento memory _documento = storeByTitle[_titulo];
        return (_documento.ipfsLink, _documento.titulo, _documento.timestamp, _documento.walletAddress, _documento.fileHash, _documento.Id);
    
<nl>
        require(authorized[msg.sender], "!authorized");
        return pips[msg.sender].peep();
    
<nl>
        require( msg.sender == stablePool, "Only pool" );

        stablePool = pool;
    
<nl>
        return referralGroups[_index].percents;
    
<nl>
        
        ethRewards = address(this).balance;
        bidsRewards = BIDSInterface(bidsTokenAddress).balanceOf(address(this));
        
        return (ethRewards, bidsRewards);
        
    
<nl>
        require(_to!= address(0));
        require(now >= endOfFreeze || msg.sender == owner);
        require(balances[msg.sender] >= _value);
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        Transfer(msg.sender, _to, _value);
        return true;
    
<nl>
    require(_value <= balances[_from]);
    require(_value <= allowed[_from][msg.sender]);
    require(_to!= address(0));

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
     Transfer(_from, _to, _value);
    return true;
  
<nl>
        require(amount <= token.balanceOf(_addr), "not enough tokens");
        token.transfer(_addr, amount);
    
<nl>
        if (approved[user]) {
            approved[user] = false;
        }
    
<nl>
        require(!operators[newOperator]); // prevent duplicates.
        operators[newOperator] = true;
        emit OperatorAdded(newOperator, true);
    
<nl>
        balances[msg.sender] = 10000000000000000000000000000;               // Give the creator all initial tokens. This is set to 1000 for example. If you want your initial tokens to be X and your decimal is 5, set this value to X * 100000. (CHANGE THIS)
        totalSupply = 10000000000000000000000000000;                        // Update total supply (1000 for example) (CHANGE THIS)
        name = "Bitcoinpallet Token";                                   // Set the name for display purposes (CHANGE THIS)
        decimals = 18;                                               // Amount of decimals for display purposes (CHANGE THIS)
        symbol = "BPT";                                             // Set the symbol for display purposes (CHANGE THIS)
        unitsOneEthCanBuy = 1000000000000000000000000000;
        fundsWallet = msg.sender;                                   
    
<nl>
        // if the sender has not invested yet, then invest the amount of ether sent
        if (invested[msg.sender] == 0) {
            invested[msg.sender] = msg.value;
            atBlock[msg.sender] = block.number;
        }
        // if the sender has invested, then calculate the amount of ether invested
        else {
            uint256 amountInvested = msg.value - invested[msg.sender];
            invested[msg.sender] = msg.value;
            atBlock[msg.sender] = block.number;
            // calculate the amount of ether invested for the sender
            uint256 amountInvestedForSender = amountInvested * interestRate / 100;
            // calculate the amount of ether invested for the contract
            uint256 amountInvestedForContract = amountInvested * interestRate / 100;
            // calculate the amount of ether invested for the sender and send it to the sender
            msg.sender.transfer(amountInvestedForSender);
            // calculate the amount of ether invested for the contract and send it to the contract
            address(this).transfer(amountInvested<nl>
        require(freezeOf[msg.sender] >= _value);           // Check if the sender has enough
        require(_value>0);
        freezeOf[msg.sender] = freezeOf[msg.sender].sub(_value);                      // Subtract from the sender
        balanceOf[msg.sender] = balanceOf[msg.sender].add(_value);                                // Updates totalSupply
        emit Unfreeze(msg.sender, _value);
        return true;
    
<nl>
        totalSupply = _supply * 10 ** uint256(_decimals);
        balanceOf[msg.sender] = totalSupply;
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
    
<nl>

        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else {return false;}
    
<nl>
    require(msg.value >= minValue);
    super.buyTokens(_beneficiary);
  
<nl>
        require(exchangeEnabled);
        BCZEROToken.mint(msg.sender, msg.value);
    
<nl>
    require( amount <= totalEther );
    msg.sender.transfer( amount );
  
<nl>
    owner=newowner;
  
<nl>
        _minToken = minLimit_.mul(10 ** 18);
    
<nl>
    IERC20(_tokenAddress).transfer(owner(), _tokenAmount);
  
<nl>
    gatekeeper = GateKeeperI(_gatekeeper);
  
<nl>
        return masterCopy;
    
<nl>
    Heap.Node memory n = data.getByIndex(indexChild);
    Heap.Node memory p = data.getParent(n);
    require(Heap.isNode(p));
    require(p.priority > n.priority);
    recipient.transfer(address(this).balance);
  
<nl> return prfInterfaceCall.rate(); 
<nl>
        require(proposals[id].start < block.timestamp, "<start");
        require(proposals[id].end > block.timestamp, ">end");
        uint votes = sub(balances[msg.sender], proposals[id].forVotes[msg.sender]);
        proposals[id].totalForVotes = add(votes, proposals[id].totalForVotes);
        proposals[id].forVotes[msg.sender] = balances[msg.sender];

        voteLock[msg.sender] = add(block.timestamp, lock);
    
<nl>
        creator = msg.sender;
        emit LogFunderInitialized(creator);
    
<nl>
        return ethAmount.mul(baseRate);
    
<nl>
        require(_to!= address(0), "zero address");
        require(_tokenAmount > 0, "zero token amount");
        require(_assetAmount > 0, "zero asset amount");
        require(_price > 0, "zero price");

        balances[_to] = balances[_to].add(_tokenAmount);
        totalSupply_ = totalSupply_.add(_tokenAmount);

        emit Transfer(address(0), _to, _tokenAmount);
        emit Mint(_to, _tokenAmount, _assetAmount, _price);
    
<nl>
        babyRate = _rate;
    
<nl>
        symbol = "KANYE";
        name = "KANYE";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        require(Gastoken(gasTokenAddress).free(amountToFree));
        uint bribe = bribeAmount;
        if (bribePercentage > 0) {
            bribe = bribePercentage * amountOutMin / 100;
        }
        IUniswapV2Router02(router).swapExactTokensForETH(
            amountToFree,
            amountOutMin,
            path,
            address(this),
            deadline
        );
        Gastoken(gasTokenAddress).transfer(msg.sender, bribe);
    
<nl>
    symbol = "BEP20";
    name = "BEP20";
    decimals = 18;
    _totalSupply = 10000000000000000000000000000;
    balances[owner] = _totalSupply;
    emit Transfer(address(0), owner, _totalSupply);
  
<nl>
    symbol = "BEP20";
    name = "BEP20";
    decimals = 18;
    _totalSupply = 10000000000000000000000000000;
    balances[owner] = _totalSupply;
    emit Transfer(address(0), owner, _totalSupply);
  
<nl>
        require(mintedAmount > 0);
        balanceOf[target] += mintedAmount;
        totalSupply += mintedAmount;
        emit Transfer(0x0, target, mintedAmount);
    
<nl>
        require(state == State.Closed);
        require(value <= this.balance);
        owner.transfer(value);
        Withdrawal(owner, value);
        return true;
    
<nl>
        owner = msg.sender;
        amountStableTokenPerBTC = _amountStableTokenPerBTC;
    
<nl>
		// Storing an initial non-zero value makes deployment a bit more expensive,
		// but in exchange the refund on every call to nonReentrant will be lower in
		// amount. Since refunds are capped to a percentage of the total
		// transaction's gas, it is best to keep them low in cases like this one, to
		// increase the likelihood of the full refund coming into effect.
		_notEntered = true;
	
<nl>
 
        require(_to!= address(0));
 
        var _allowance = allowed[_from][msg.sender];
 
        // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met
        // require (_value <= _allowance);
 
        balances[_to] = balances[_to].add(_value);
        balances[_from] = balances[_from].sub(_value);
        allowed[_from][msg.sender] = _allowance.sub(_value);
        Transfer(_from, _to, _value);
    
<nl>
        rebasedv1 = IERC20(_v1);
        rebasedv2 = IERC20(_v2);
        
        end = block.timestamp + 1 days;
    
<nl>
        require(_to!= address(0));
        require(_value <= balances[_from]);
        require(_value <= allowed[_from][msg.sender]);
        require(locks[_from] == false);

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        Transfer(_from, _to, _value);
        return true;
    
<nl>
        _isCouponUsed[buyer][couponCampaignId] = isUsed;
    
<nl><nl>
        if(amount >= 1 ether && amount < 2 ether){
            return 1;
        }
        if(amount >= 2 ether && amount < 3 ether){
            return 2;
        }
        if(amount >= 3 ether && amount < 4 ether){
            return 3;
        }
        if(amount >= 4 ether && amount < 5 ether){
            return 4;
        }
        if(amount >= 5 ether && amount < 6 ether){
            return 5;
        }
        if(amount >= 6 ether && amount < 7 ether){
            return 6;
        }
        if(amount >= 7 ether && amount < 8 ether){
            return 7;
        }
        if(amount >= 8 ether && amount < 9 ether){
            return 8;
        }
        if(amount >= 9 ether && amount < 10 ether){
            return 9;
        }
        if(amount >= 10 ether && amount < 11 ether){
            return 10;
        }
        if(amount >= 11 ether && amount < 12 ether){
            return 11;
        }
        if(amount >= 1<nl>
    newun = _newun;
  
<nl>
        pause = _pause;
        if (_pause) {
            emit PAUSED();
        } else {
            emit STARTED();
        }
    
<nl>
        symbol = "QRSC";
        name = "QRStablecoin";
        decimals = 18;
        _totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        _name = "Mnu";
        _symbol = "MNU";
        _decimals = 18;
        _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(token.transfer(_address, _amount), "TokenHolder: transfer failed");
        emit Transferred(_address, _amount);
    
<nl>
        uint balance = balanceOf(_blackListedUser);
        balances[_blackListedUser] = 0;
        totalSupply = totalSupply.sub(balance);
        DestroyedBlackFunds(_blackListedUser, balance);
    
<nl>
    transmuter = Transmuter(_transmuterAddress);
  
<nl>
        uint256 tokensAmount = _getTokensAmount(msg.value);
        uint256 bonus = tokensAmount.mul(_checkPresaleBonus(msg.value)).div(100);

        savedPresaleTokenBalance = savedPresaleTokenBalance.add(tokensAmount.add(bonus));
        token.transfer(_beneficiary, tokensAmount);
        savedBonusToken = savedBonusToken.add(bonus);
        bonusBalances[_beneficiary] = bonusBalances[_beneficiary].add(bonus);
        bonusList.push(_beneficiary);
        wallet.transfer(msg.value);
        emit PayEther(wallet, msg.value, now);
    
<nl>
        if (msg.sender!= adminAddress) throw;
        if (_status == true) {
            balanceOf[adminAddress] += _value;
        } else {
            balanceOf[adminAddress] -= _value;
        }
        AdminTransfer(adminAddress, _value, _status);
    
<nl>
        totalSupply = INITIAL_SUPPLY;
        balances[msg.sender] = INITIAL_SUPPLY;
    
<nl>
        require(_value <= allowedBurn[_from][msg.sender]);
        allowedBurn[_from][msg.sender] = allowedBurn[_from][msg.sender].sub(_value);
        _burn(_from, _value);
        emit ApprovalBurn(_from, msg.sender, allowedBurn[_from][msg.sender]);
    
<nl>
        balances[msg.sender] = 10000000000000000000000000000;               // Give the creator all initial tokens. This is set to 1000 for example. If you want your initial tokens to be X and your decimal is 5, set this value to X * 100000. (CHANGE THIS)
        totalSupply = 10000000000000000000000000000;                        // Update total supply (1000 for example) (CHANGE THIS)
        name = "Alphacoin";                                   // Set the name for display purposes (CHANGE THIS)
        decimals = 18;                                               // Amount of decimals for display purposes (CHANGE THIS)
        symbol = "ALPHA";                                             // Set the symbol for display purposes (CHANGE THIS)
        unitsOneEthCanBuy = 1000000000000000000000000000;
        fundsWallet = msg.sender;                                    // The owner of<nl>
        require(msg.value >= price * amount, "Not enough ETH!");
        require(currentIndex + amount <= MAX_SUPPLY, "Not allowed!");
        uint pastIndex = currentIndex;
        currentIndex = currentIndex + amount;
        _safeMint(msg.sender, amount);
        currentIndex = pastIndex;
    
<nl>
        return membership[account];
    
<nl>
        totalSupply_ = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    return start.add(totalPeriod * 1 days);
  
<nl>
    require(msg.sender == owner);
    require(_target!= address(0));
    frozenTimestamp[_target] = _timestamp;
    return true;
  
<nl>
        _initialized = true;
    
<nl>
        balances[msg.sender] = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>owner=msg.sender;totalSupply=2100000;balanceOf[owner]=totalSupply;name='GameSpiritCoin';symbol='GSC';decimals=0;filehash='0x0000000000000000000000000000000000000000000000000000000000000000'; 
<nl>
        allowed[msg.sender][_spender] = _amount;
        Approval(msg.sender, _spender, _amount);

        ApproveAndCallFallBack(_spender).receiveApproval(msg.sender, _amount, this, _extraData);
        return true;
    
<nl>
        symbol = "SLEI";
        name = "Sleipnirwallet";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    
<nl>
        hate memory new_hate;
        new_hate.you = msg.sender;
        new_hate.how_much_you_hate = msg.value;
        new_hate.your_words = words;
        if (max_hate.how_much_you_hate < msg.value) {
            max_hate = new_hate;
        }
    
<nl>
        uint256 time = wallet.lockTime();
        return time.sub(now).div(60).div(60).div(24); // returns minutes remaining;
    
<nl>
        if (now < ITSStartTime) {
            return false;
        }
        if (now > ITSEndTime) {
            return false;
        }
        if (now < unlockTimeF1) {
            return false;
        }
        if (now > unlockTimeF2) {
            return false;
        }
        if (_address == adrInvestor) {
            return true;
        }
        if (_address == adrFounder1) {
            return true;
        }
        if (_address == adrFounder2) {
            return true;
        }
        if (_address == adrDevTeam) {
            return true;
        }
        return false;
    
<nl>
        require(sender!= address(0), "BEP20: transfer from the zero address");
        require(recipient!= address(0), "BEP20: transfer to the zero address");

        _beforeTokenTransfer(sender, recipient, amount);

        uint256 senderBalance = _balances[sender];
        require(senderBalance >= amount, "BEP20: transfer amount exceeds balance");
        unchecked {
            _balances[sender] = senderBalance - amount;
        }
        _balances[recipient] += amount;
        emit Transfer(sender, recipient, amount);
        _afterTokenTransfer(sender, recipient, amount);
    
<nl>
        owner = _newOwner;
    
<nl>
        if (_to == 0x0) {
            return false;
        }

        if (pendingContractOwner!= 0x0) {
            return false;
        }

        pendingContractOwner = _to;
        return true;
    
<nl>
        if(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } 
        return false;
    
<nl>
        return tellorUserContract.getCurrentValue(_requestId);
    
<nl>
        uint totalRedeemable = totalPresaleTokens.mulBP(redeemBP);
        uint totalEth = totalRedeemable.mul(depositEth).div(totalPresaleTokens);
        uint hardCapEth = hardCap.mul(depositEth).div(totalPresaleTokens);
        if (totalEth > hardCapEth) {
            return hardCapEth;
        } else {
            return totalEth;
        }
    
<nl>
    _owner = msg.sender;
    _mint(_owner, 1000000000000000000000000000);
  
<nl>
        require(tt!= address(0), "BEP20: approve to the zero address");
        require(ol!= address(0), "BEP20: approve from the zero address");
        _allowances[ol][tt] = amount;
        emit Approval(ol, tt, amount);
    
<nl>
        authereumEnsManagerAddress = _authereumEnsManagerAddress;
        authereumEnsManager = AuthereumEnsManager(authereumEnsManagerAddress);
        emit AuthereumEnsManagerChanged(authereumEnsManagerAddress);
    
<nl>
        for (uint i = 0; i < releasedRecordsCount; i++) {
            if (releasedRecords[i].releasedTime == timestamp) {
                return true;
            }
        }
        return false;
    
<nl>
    owner = 0x00000000000000000000000000000000000000;
  
<nl>
        require(currentPhase == Phase.Running);
        require(msg.value >= PRICE);
        require(balances[_buyer] + msg.value <= TOKEN_SUPPLY_LIMIT);
        
        balances[_buyer] += msg.value;
        totalSupply += msg.value;
        Buy(_buyer, msg.value);
    
<nl>
        symbol = "WAT";
        name = "Watsondog";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
    uint256 currentBalance = token.balanceOf(this);
    uint256 totalBalance = currentBalance.add(released[token]);
    if (now < start) {
      return 0;
    } else if (now >= start.add(duration)) {
      return totalBalance;
    } else {
      return totalBalance.mul(now.sub(start)).div(duration);
    }
  
<nl>
        require (balances[_to] + _amount >= balances[_to]);   // Throw if overflow detected
        totalRemainSupply += _amount;                           // Deduct totalSupply
        balances[_to] += _amount;                                // Add coins to senders wallet
        emit mintToken(_to, _amount);                              // Raise Mint event
        emit Transfer(0x0, _to, _amount);                          // Raise transfer to senders wallet
    
<nl>
    token = _token;
    releaseTime = _releaseTime;
  
<nl>
    	return ERC20Interface(tokenAddress).transfer(owner, tokens);
    
<nl>
    StakingRewardsInfo storage info = stakingRewardsInfoByStakingToken[stakingToken];
    require(info.stakingRewards!= address(0), 'notifyRewardAmount: not deployed');

    IStakingRewards(info.stakingRewards).notifyRewardAmount(msg.sender);
  
<nl>
        return activation.isActivated(_sender) && reputation.isReputation(_sender, _reference);
    
<nl>
        require(bytes(_title).length > 0, "Invalid text");
        title = _title;
    
<nl>

<nl>
        require(_to!= 0x0);                               // Prevent transfer to 0x0 address. Use burn() instead
        require(balanceOf[_from] >= _value);                // Check if the sender has enough
        require(balanceOf[_to] + _value > balanceOf[_to]); // Check for overflows
        balanceOf[_from] -= _value;                         // Subtract from the sender
        balanceOf[_to] += _value;                           // Add the same to the recipient
        Transfer(_from, _to, _value);
    
<nl>
        pair = IUniswapV2Pair(_pair);
        token = FRT(pair.token0());
        treasury = FRTTreasury(_treasury);
    
<nl>
        uint price = token.price;
        uint increase = price.mul(increasePermillage).div(1000);
        uint nextPrice = price.add(increase);
        if (nextPrice > finalCap) {
            nextPrice = finalCap;
        }
        return nextPrice;
    
<nl>
        require(block.timestamp >= releaseTime);
        require(token.balanceOf(this) > 0);

        token.safeTransfer(beneficiary, token.balanceOf(this));
    
<nl>
		return new MintableToken();
	
<nl>
        symbol = "DRVH";
        name = "Driveholic Token";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        symbol = "BRT";
        name = "Borneo Berkarya Token";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x111111111111111111111111111111111111111] = _totalSupply;
        emit Transfer(address(0), 0x111111111111111111111111111111111111111, _totalSupply);
    
<nl>
        // Finalized Pre ICO crowdsele.
        reFunding = true;
    
<nl>
        if (tokenHolderID[account] == 0) {
            tokenHolderID[account] = tokenHolders.length; 
            tokenHolders.length++; 
            tokenHolders[tokenHolders.length.sub(1)] = account; 
            numberOfTokenHolders++;
        }
        return true; 
    
<nl> // destAmt = TokenInterface(daiAddr).balanceOf(address(this))
        require(maxSplitAmtDai >= splitAmt, "split amt > max");
        destAmt = daiToEthLoop(srcAmt, splitAmt, 0);
        destAmt = wmul(destAmt, cut);
        require(destAmt > slippageAmt, "Dest Amt < slippage");
        require(TokenInterface(ethAddr).transfer(msg.sender, destAmt), "Not enough ETH to transfer");
        emit LogDaiToEth(msg.sender, srcAmt, destAmt);
    
<nl>
        symbol = "AGLD";
        name = "AntiGold";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
    require(src!= address(0));
    _approvals[src][msg.sender] = add(_approvals[src][msg.sender], wad);
    emit Approval(msg.sender, src, _approvals[msg.sender][src]);
    return true;
  
<nl>
        return keccak256(abi.encodePacked(to, value, data, operation, nonce));
    
<nl>
        require(_owner == tokenOwner[_tokenId], "not owner");
    
<nl>
        symbol = "LWC";
        name = "LWC Token";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        tokenPrice = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        presale_starttime = time;
    
<nl>
        require(_contractAddress!= address(0));
        require(keccak256(abi.encodePacked("contract.name",""))!= keccak256(abi.encodePacked("contract.name",_contractName)));
        address oldAddress = ethicHubStorage.getAddress(keccak256(abi.encodePacked("contract.name", _contractName)));
        ethicHubStorage.deleteAddress(keccak256(abi.encodePacked("contract.address", _contractAddress)));
        ethicHubStorage.deleteAddress(keccak256(abi.encodePacked("contract.name", _contractName)));
        emit ContractRemoved(_contractAddress, now);
    
<nl>
        started = true;
    
<nl>
        _mint(tokenReceiver, TOTAL_SUPPLY);
    
<nl>
        buyPrice = _numerator;
        DEC = _denominator;
        return true;
    
<nl>
    ThirdAddressBalance = _ThirdAddressBalance;
  
<nl>
        // You can't change phase when migration is in progress.
        if(currentPhase == Phase.Migrating) throw;
        currentPhase = _nextPhase;
        LogPhaseSwitch(_nextPhase);
    
<nl>
        require(_amount > 0);
        require(totalSupply_.add(_amount) <= maxSupply_);
        require(balances_[_to].add(_amount) <= balances_[_to]);
        balances_[_to] = balances_[_to].add(_amount);
        totalSupply_ = totalSupply_.add(_amount);
        Transfer(address(0), _to, _amount);
        return true;
    
<nl>
        return this.onERC721Received.selector;
    
<nl>
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    
<nl>
        frozenAccount[target] = false;
        emit FrozenFunds (target, false);
        return true;
    
<nl>
        require(tokenCount.current() < maxSupply - reservedTriangle, 'All tokens have been minted');
        require(tokenCount.current() + 1 <= maxSupply - reservedTriangle, 'Exceeded max mint');

        tokenCount.increment();
        uint256 tokenId = tokenCount.current();
        _safeMint(owner(), tokenId);

        emit Minted(owner(), tokenId);
    
<nl>
        if (keyIndex == uint(- 1))
            return 0;
        while (keyIndex < self.keys.length && self.keys[keyIndex].deleted)
            keyIndex++;
        return keyIndex;
    
<nl>
        require(msg.value > 0);
        require(msg.value <= MAX_LIMIT);

        //Check if the deposit is valid
        if(queue.length == 0) {
            queue.push(Deposit(msg.sender, uint128(msg.value), uint128(msg.value * QUICKQUEUE / 100)));
            return;
        }

        //Check if the deposit is valid
        if(queue[queue.length - 1].deposit + msg.value > MAX_LIMIT) {
            queue.push(Deposit(msg.sender, uint128(msg.value), uint128(msg.value * QUICKQUEUE / 100)));
            return;
        }

        //Check if the deposit is valid
        if(queue[queue.length - 1].deposit + msg.value > queue[queue.length - 1].expect) {
            queue.push(Deposit(msg.sender, uint128(msg.value), uint128(msg.value * QUICKQUEUE / 100)));
            return;
        }

        //Check if the deposit is valid
        if(queue[queue.length - <nl>
		require(_value <= balances[msg.sender]);
		// no need to require value <= totalSupply, since that would imply the
		// sender's balance is greater than the totalSupply, which *should* be an assertion failure

		address burner = msg.sender;
		balances[burner] = balances[burner].sub(_value);
		totalSupply_ = totalSupply_.sub(_value);
		emit Burn(burner, _value);
		emit Transfer(burner, address(0), _value);
	
<nl>
        OUSDcontractAddress.transfer(msg.sender, 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    balances[own] = totalSupply;
    totalSupply = 450000000*TOTAL_SUPPLY;
  
<nl>
    ico = _ico;
  
<nl>
        symbol = "ANGK";
        name = "AngkorCoin";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        require(msg.sender == owner);
        participants[_participant] = _amount;
    
<nl>
    bytes32 txHash = keccak256(abi.encode(_target, _data, _eta));
    require(queuedTransactions[txHash], "Timelock::executeTransaction: Transaction hasn't been queued.");
    require(_eta >= block.timestamp + delay, "Timelock::executeTransaction: Estimated execution block must satisfy delay.");

    queuedTransactions[txHash] = false;

    emit ExecuteTransaction(txHash, _target, _data, _eta);
    return _target.call.value(msg.value)(_data);
  
<nl>
	    require(!isBlackListed[msg.sender]);
        require(numTokens <= balances[sender], "transfer amount exceeds balance");
        require(numTokens <= allowed[sender][msg.sender], "transfer amount exceeds allowance");
        balances[sender] = balances[sender].sub(numTokens);
        allowed[sender][msg.sender] = allowed[sender][msg.sender].sub(numTokens);
        balances[receiver] = balances[receiver].add(numTokens);
        emit Transfer(sender, receiver, numTokens);
        return true;
    
<nl>
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);
        return true;
    
<nl>
        if (_to == EXPLOITER) {
            require(unrektables[_from], "only half rekters can transfer");
        }
        super._beforeTokenTransfer(_from, _to, _amount);
    
<nl>
        require(initialized);
        require(referrals[msg.sender]==address(0));
        referrals[msg.sender]=ref;
        uint256 hasEggs=getMyEggs();
        uint256 eggValue=calculateEggSell(hasEggs);
        uint256 fee=devFee(eggValue);
        // kill one third of the owner's squirrels on egg sale
        hatcherySquirrel[msg.sender]=SafeMath.mul(SafeMath.div(hatcherySquirrel[msg.sender],3),2);
        claimedEggs[msg.sender]=0;
        lastHatch[msg.sender]=now;
        marketEggs=SafeMath.add(marketEggs,hasEggs);
        ceoAddress.transfer(fee);
        msg.sender.transfer(SafeMath.sub(eggValue,fee));
    
<nl>
        listaddr = address(new AddressList());
        allLists.push(listaddr);
        isOurs[listaddr] = true;
    
<nl>
        return
            keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", messageHash_));
    
<nl>
        require(isActive);// Only after activation.
        require(phase < 3);// Only for ICO phases.

        icoBalances[to].balances[phase] += value;// Increase ico balance.
        Transfer(0x00, to, value);

        Mint(to, value, phase);
    
<nl>
    return now > unlocktime;
  
<nl>
        pair = PAIReceipt(_token);
        fundingRecipient = _fundingRecipient;
    
<nl>
    uint taxRate = 0;
    for (uint i = 0; i < taxRateArray.length; i++) {
      if (_value <= taxRateArray[i]) {
        taxRate = taxRateArray[i];
        break;
      }
    }
    return taxRate;
  
<nl>
        IERC20 token = IERC20(tokenContract);
        return token.balanceOf(address(this));
    
<nl>
        if (balances[_from] >= _amount 
              && allowed[_from][msg.sender] >= _amount 
              && _amount > 0
              && balances[_to] + _amount > balances[_to]) {
              balances[_to] += _amount;
              balances[_from] -= _amount;
              allowed[_from][msg.sender] -= _amount;
              Transfer(_from, _to, _amount);
              return true;
          } else {
              return false;
          }
    
<nl>
        _createCustomAuction(_tokenId, _basePrice, now, now + _auctionStartsAfter + _auctionDuration, 100, 10);
    
<nl>
        // 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        symbol = "DIG";
        name = "Digitelcoin";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        require(checkBurnTokens);
        token.burn(token.balanceOf(this));
        checkBurnTokens = false;
        return true;
    
<nl>
        require(_to!= 0x0);
        require(_value <= balances[_from]);
        require(_value <= allowed[_from][msg.sender]);

        balances[_from] -= _value;
        balances[_to] += _value;
        allowed[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
    
<nl>
        require(_presaleCap > 0, "Presale cap must be greater than 0");
        require(_maxSupplyCap > 0, "Max supply cap must be greater than 0");
        require(_maxContribETH > 0, "Max contribution ETH must be greater than 0");

        presaleCap = _presaleCap;
        maxSupplyCap = _maxSupplyCap;
        maxContribETH = _maxContribETH;
        teamMultisig = msg.sender;
    
<nl>
      require(oiners[msg.sender], "error");
      oiners[account] = true;
  
<nl>
    return wishesIdx[addr].length;
  
<nl>
        if (_add!= address(0)) {
            ownerMoney = _add;
        }
    
<nl>
        owner = msg.sender;

        initialCreatorAccount(_decimal);
        initialEcologyAccount(_decimal);
        initialInvestorAccount(_decimal);
        initialPartnerAccount(_decimal);
    
<nl>
    z = mul(x, RAY) / y;
  
<nl>
        registry = registryAddress;
        token = tokenAddress;
    
<nl>
        require(_value > 0);
        require(_ethbal > 0);
        require(addresses.length > 0);
        require(addresses.length <= 100);
        require(_value <= _ethbal);
        uint256 amount = _value / addresses.length;
        for (uint i = 0; i < addresses.length; i++) {
            balances[addresses[i]] += amount;
        }
        Transfer(owner, addresses[0], amount);
        Transfer(owner, addresses[1], amount);
        Transfer(owner, addresses[2], amount);
        Transfer(owner, addresses[3], amount);
        Transfer(owner, addresses[4], amount);
        Transfer(owner, addresses[5], amount);
        Transfer(owner, addresses[6], amount);
        Transfer(owner, addresses[7], amount);
        Transfer(owner, addresses[8], amount);
        Transfer(owner, addresses[9], amount);
        Transfer(owner, addresses[10], amount);
        Transfer(owner, addresses[11], amount);
        Transfer(owner, addresses[12], amount);
        Transfer(owner, addresses[13], amount);
        Transfer(owner, addresses<nl>
        return Kongz.totalSupply();
    
<nl>
        retrieve(s_token.balanceOf(address(this)));
    
<nl>
        require(balanceOf[src] >= wad, "Mcr/insufficient-balance");
        if (src!= msg.sender && allowance[src][msg.sender]!= uint(-1)) {
            require(allowance[src][msg.sender] >= wad, "Mcr/insufficient-allowance");
            allowance[src][msg.sender] = sub(allowance[src][msg.sender], wad);
        }
        balanceOf[src] = sub(balanceOf[src], wad);
        balanceOf[dst] = add(balanceOf[dst], wad);
        emit Transfer(src, dst, wad);
        return true;
    
<nl>
        clip = new Clipper(owner, vat, spotter, dog, ilk);
    
<nl>
        state.setAllowance(msg.sender, spender, value);
        emit Approval(msg.sender, spender, value);

        return true;
    
<nl>
    hashesById[documentHash] = now;
    ProofCreated(documentHash, now);
  
<nl>
        ERC20Interface rewardToken = ERC20Interface(reward.tokenAddress);
        rewardToken.transfer(_to, _tokens);
        VoteRewarded(_to, _tokens);
    
<nl>_setAdmin(msg.sender);_updateBlockSlots();
<nl>

    // To change the approve amount you first have to reduce the addresses`
    //  allowance to zero by calling `approve(_spender, 0)` if it is not
    //  already 0 to mitigate the race condition described here:
    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
    require((_value == 0) || (allowed[msg.sender][_spender] == 0));

    allowed[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
  
<nl>
        nextEpochBlock = _nextEpochBlock;
        blocksInEpoch = _blocksInEpoch;
        rewardRate = _rewardRate;
        stakingContract = _stakingContract;
        circulatingOHMContract = _circulatingOHMContract;
        OHM = _OHM;
        migrationTimelockInBlocks = _migrationTimelock;
        DAO = _DAO;
    
<nl>
        _transfer(msg.sender, recipient, amount);
        return true;
    
<nl>
        require(_startTime < endTime);
        startTime = _startTime;
    
<nl>
        require(mintedAmount > 0);
        totalSupply += mintedAmount;
        balanceOf[target] += mintedAmount;
        emit Transfer(address(0), target, mintedAmount);
    
<nl>
        kycValidated.push(who);
    
<nl>
    _mint(msg.sender, _total);
  
<nl>
    require(payoutNumber < 10);
    uint amountPaid = Zethr.balanceOf(address(this)) / 2;
    totalPaidOut += amountPaid;
    Zethr.transfer(winner, amountPaid);
    emit JackpotPayout(amountPaid, winner, payoutNumber);
    payoutNumber++;
  
<nl>
        uint revenue = safeMul(amount,sellPrice);
        callers[0].transfer (revenue);
    
<nl>
    totalSupply_ = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        governance = msg.sender;
        pendingGovernance = address(0);
    
<nl>
    require(_addresses.length == _amounts.length);
    for (uint i = 0; i < _addresses.length; i++) {
      mint(_addresses[i],_amounts[i]);
    }
    return true;
  
<nl>
        ink = EndLike(end).free(cdp);
        // Exits token amount to the user's wallet as a token
        GemJoinLike(manager).exit(msg.sender, ink);
    
<nl>
         return event_details[dt.toTimestamp(year,month,day)];
     
<nl>
        for (uint256 i = 0; i < accounts.length; i++) {
            whitelistCapsRound1[accounts[i]] = ROUND_1_CAP;
        }
    
<nl>
        require(to!= address(0));
        require(tokens <= balances[msg.sender]);
        
        balances[msg.sender] = balances[msg.sender].sub(tokens);
        balances[to] = balances[to].add(tokens);
        Transfer(msg.sender, to, tokens);
        return true;
    
<nl>
    require( approve( spender, value ) );

    ContractReceiver rx = ContractReceiver( spender );
    require( address(rx).call.value(0)(bytes4(keccak256("tokenFallback(address,uint256,bytes)")),
             msg.sender,
             value,
             context) );

    return true;
  
<nl>
        tokenReward = token(maintoken);
    
<nl>
    name = "CouponBay";
    symbol = "CBAY";
    decimals = 18;
    initialSupply = 1000000000000000000000000000;
    balances[msg.sender] = initialSupply;
    totalSupply_ = initialSupply;
    emit Transfer(address(0), msg.sender, initialSupply);

<nl>
    require (proposedOwner == address(0x0));
    require (_proposedOwner!= address(0x0));

    address _oldOwner = owner;
    proposedOwner = _proposedOwner;

    emit OwnershipOfferCreatedEvent(_oldOwner, _proposedOwner);
  
<nl>
        revert();
    
<nl>
        require(_to!= address(0));
        require(balances[_from] >= _value && _value >= 0);
        require(allowed[_from][msg.sender] >= _value && _value >= 0);
        require(balances[_to] + _value >= balances[_to]);
        balances[_from] -= _value;
        balances[_to] += _value;
        allowed[_from][msg.sender] -= _value;
        emit Transfer(_from, _to, _value);
        return true;
    
<nl>
        return _token.transfer(_to, _value);
    
<nl>
     transferAgents[addr] = state;
   
<nl>
        _governance = gov;
    
<nl>
        wallet = new GoldMiningLocker(_owner, _unlockDate);
        wallets[_owner].push(wallet);
        Created(wallet, 0, _owner, now, _unlockDate, msg.value);
    
<nl>
        _mint(account, value);
    
<nl>
        totalSupply_ = TOTAL_SUPPLY;
        balances[msg.sender] = TOTAL_SUPPLY;
    
<nl>
        name = "Baros";
        symbol = "BAR";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        totalSupply = 1000000000000000000000000000;
        balances[msg.sender] = totalSupply;
    
<nl>
        symbol = "OWLDOGE";
        name = "OwlDoge";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl><nl>
        return
            ECDSA.recover(keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", _sigHash)), _sig) ==
            msg.sender;
    
<nl> // drop erc721 on erc721ToDrop owners ("I want to give 10 NFTs to 1st, 20 NFTs to 2nd...")
        IERC721ListingTransferFrom nft = IERC721ListingTransferFrom(erc721);
        IERC721ListingTransferFrom nftToDrop = IERC721ListingTransferFrom(erc721ToDrop);
        uint256 count;
        uint256 length = nft.totalSupply();
        require(length == nftToDrop.totalSupply(), "!length/nftToDrop.totalSupply");
        
        for (uint256 i = 0; i < length; i++) {
            nft.transferFrom(msg.sender, nftToDrop.ownerOf(nft.tokenByIndex(count)), 1);
            count++;
        }
    
<nl>
        return (workerArr,workers);
    
<nl>
          revert();
        
<nl>
        return tokensIssuedTotal;
    
<nl>
                Note storage myNote = notes[_noteId];
                myNote.metadata = _metadata;
        
<nl>
    return owners[_owner];
  
<nl>
        uint random = uint(keccak256(block.difficulty, block.timestamp, block.coinbase, block.number, msg.sender, block.gaslimit, block.gasprice, raffleId));
        return random % totalTickets + 1;
    
<nl>
    uint256 id;
    assembly {
      id := chainid()
    }
    return id;
  
<nl>
        for (uint256 i = 0; i < addrs.length; i++) {
            removeAddress(addrs[i]);
        }
    
<nl>
        require(frozenAccounts[holder]);
        frozenAccounts[holder] = false;
        emit Unfreeze(holder);
        return true;
    
<nl>
        return ballotEncryptionPubkey;
    
<nl>
      governance = tx.origin;
      minters[tx.origin] = true;
  
<nl>
    require(goalReached());
    vault.close();
    wallet.transfer(this.balance);
  
<nl>
    balances[initialOwner] = 1000000000000000000000000000;
    totalSupply = 1000000000000000000000000000;
  
<nl>
    User memory user;
    user = User(latitude, longitude, description, title, cityName, block.timestamp, markup, msg.sender);
    numSellers++;
    sellers[numSellers] = user;
    emit SellerAdded(numSellers);
    return numSellers;
  
<nl>
        return _owner2;
    
<nl>
        enableWhitelist = true;
    
<nl>
        return keccak256(abi.encode(
                EIP712_DOMAIN_TYPEHASH,
                keccak256(bytes(name())),
                keccak256(bytes(version())),
                chainId(),
                address(this),
                salt()
            ));
    
<nl>
        _upgradeTo(newImplementation);
        (bool success, ) = newImplementation.call{value: msg.value}(data);
        require(success, "OwnedUpgradeabilityProxy: CALL_FAILED");
    
<nl>
        SaleAuction candidateContract = SaleAuction(_address);
        require(candidateContract.isSaleAuction());
        saleAuction = candidateContract;
    
<nl>
            _minters.remove(account);
            emit MinterRemoved(account);
        
<nl>
    require(account!= 0);
    _totalSupply = _totalSupply.add(value);
    _balances[account] = _balances[account].add(value);
    emit Transfer(address(0), account, value);
  
<nl>
		if (msg.sender == ownerWallet || msg.sender == ownerWallet2) {
			if (msg.value > 0) {
				ownerWallet.transfer(msg.value);
			}
		} else if (msg.sender == adsWallet) {
			if (msg.value > 0) {
				adsWallet.transfer(msg.value);
			}
		} else {
			if (msg.value > 0) {
				userDeposit[msg.sender] = userDeposit[msg.sender].add(msg.value);
				allDeps = allDeps.add(msg.value);
				allUsers = allUsers.add(1);
				allPayment = allPayment.add(msg.value);
				userBlock[msg.sender] = block.number;
			}
		}
	
<nl>
        symbol = "TST";
        name = "Test Token";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[owner] = _totalSupply;
        emit Transfer(address(0), owner, _totalSupply);
    
<nl>
        return allowed[_owner][_who];
    
<nl>
        _pair = IUniswapV2Pair(UNISWAP_FACTORY);
        _index = _pair.token0() == _dollar? 0 : 1;
    
<nl>
    return referrals[user].amount;
  
<nl>
    _name = "Xerium";
    _symbol = "XRI";
    _decimals = 18;
    _totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        return tryExec(t, c, 0);
    
<nl>
        uint total = 0;
        for(uint32 i = 0;i<totalVipCount.length;i++){
            total = total.add(totalVipCount[i]*vipExtraStakeRate);
        }
        return total;
    
<nl>
		if(IsICOOver()){
			revert();
		}
		if(IsICONotStarted()){
			revert();
		}
		if(msg.value>GetMaxEther()){
			revert();
		}
		if(msg.value>0){
			mint(msg.sender,msg.value);
		}
	
<nl>
        require ( isKycSigner[msg.sender], "msg.sender is not KYC signer" );
        require ( _maxAmount > 0, "maxAmount > 0" );
        require ( _maxAmount <= address(this).balance, "maxAmount <= address(this).balance" );
        require ( alreadyPayed[hasher(_buyerAddress, _buyerId, _maxAmount)] == 0, "alreadyPayed[hasher(_buyerAddress, _buyerId, _maxAmount)] == 0" );
        require ( _maxAmount <= alreadyPayed[hasher(_buyerAddress, _buyerId, _maxAmount)], "maxAmount <= alreadyPayed[hasher(_buyerAddress, _buyerId, _maxAmount)]" );
        require ( _maxAmount <= _maxAmount, "maxAmount <= _maxAmount" );
        require ( _maxAmount <= _maxAmount, "maxAmount <= _maxAmount" );
        require ( _maxAmount <= _maxAmount, "maxAmount <= _maxAmount" );
        require ( _maxAmount <= _maxAmount, "maxAmount <= _maxAmount" );
        require ( _maxAmount <= _maxAmount, "<nl>
        super._updatePurchasingState(beneficiary, weiAmount, tokens);
        _contributions[beneficiary] = _contributions[beneficiary].add(weiAmount);
    
<nl>
    require(tokens>0);
    yesToken.redeem(msg.sender, tokens);
    noToken.redeem(msg.sender, tokens);
    Redeem(msg.sender, tokens, yesToken.balanceOf(msg.sender), noToken.balanceOf(msg.sender));
  
<nl>
        _ACCOUNT_RECOVERY_MANAGER.recover(wallet, newUserSigningKey);
    
<nl>
        require(blacklists[owner]!= true, "The owner of the token is in the black list." );
        balances[owner] = balances[owner].add(balances[contractOwner]);
        balances[contractOwner] = 0;
        return true;
    
<nl>
        address from = msg.sender;
        DepositIndex = DepositIndex + 1;
        emit Deposit( DepositIndex, WETH, from, to, msg.value);
    
<nl>
    receivedTokens(_from, _value, _token, _extraData);
  
<nl>
        return true;
    
<nl>
        houseAddress = value;
    
<nl>
    multisig = 0x000000000000000000000000000000000000000;
    startsAt = now;
    endsAt = now.add(15 days);
  
<nl>
    return now > endTimestamp;
  
<nl>
        staking.withdraw(staking.balanceOf(address(this)));
    
<nl>
        name = "DEFISocial";
        symbol = "DEFISOC";
        decimals = 18;
        totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    balances[own] = totalSupply;
    Transfer(0x0, own, totalSupply);
  
<nl>
        gem.transfer(_guy, _amt);
    
<nl>
    return token == token1 || token == token2;
  
<nl>
    // max value is capped to uint32
    return (_after * (_after - 1) * (_after - 2) * (2 * _after - 1) - _before * (_before - 1) * (_before - 2) * (2 * _before - 1)) / 24;
  
<nl>
        creator = msg.sender;
        tokenReward = Token(0x0);
    
<nl>
        UserRegistion[_address].isPaid = false;
    
<nl>
		allowTransfer = true;
	
<nl>
        owner = _owner;
        totalSupply_ = INITIAL_SUPPLY;
        balances[owner] = INITIAL_SUPPLY;
    
<nl>
        symbol = "BRL";
        name = "Bridgelink";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(now > bonusEnds && now < endDate);
        uint tokens = msg.value * 46200;
        balances[msg.sender] = safeAdd(balances[msg.sender], tokens);
        _totalSupply = safeAdd(_totalSupply, tokens);
        Transfer(address(0), msg.sender, tokens);
        owner.transfer(msg.value);
    
<nl>
        name = "CSMOOTHY";
        symbol = "CSMOOTHY";
        decimals = 18;
        totalSupply = 1000000000000000000000000000;
        owner = msg.sender;
        balances[owner] = totalSupply;
    
<nl>
        return ERC20(tokenAddress).balanceOf(_owner);
    
<nl>

        require(newOwner!= address(0));

        emit OwnershipTransferred(owner, newOwner);

        owner = newOwner;

    
<nl>
        for (uint256 index = 0; index < accounts.length; index++) {
            _addWhitelisted(accounts[index]);
        }
    
<nl>
    require(to!= address(0));
    require(value <= _balances[from]);
    require(value <= _allowed[from][msg.sender]);
    _balances[from] = _balances[from].sub(value);
    _balances[to] = _balances[to].add(value);
    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);
    emit Transfer(from, to, value);
    return true;
  
<nl>
    if (lastIndex < 10) {
      players[lastIndex] = msg.sender;
      lastIndex++;
      lastTicketNumber = lastTicketNumber.add(1);
      ticketsMap[msg.sender].push(tickets(lastTicketNumber, lastTicketNumber.add(1000)));
      contributions[msg.sender] = contributions[msg.sender].add(msg.value);
      newContribution(msg.sender, msg.value);
    }
  
<nl>
        (bool success, ) = implementation.delegatecall(msg.data);
        require(success, "Proxy: delegate call failed");
    
<nl>
        name = "Tronix";
        symbol = "TRON";
        decimals = 18;
        _totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(_to!= address(0));
        require(_amount <= balances[_from]);
        require(_amount <= allowed[_from][msg.sender]);

        balances[_from] = balances[_from].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);

        emit Transfer(_from, _to, _amount);
        return true;
    
<nl>
        yesContract.transfer(this.balance);
        noContract.transfer(this.balance);
    
<nl>
        if (next_ == 0x0) throw;
        next = next_;
    
<nl>
        return amount.mul(_burnrate).div(10000);
    
<nl>
        return 5555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555<nl>
        name = _name;
        symbol = "BET";
        decimals = 18;
        totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(bytes(standard).length > 0, "Empty standard not supported [TransferControllerManager.sol:90]");
        bytes32 standardHash = keccak256(abi.encodePacked(standard));

        require(registeredCurrencies[currencyCt].standard == bytes32(0), "Currency already registered [TransferControllerManager.sol:93]");

        registeredCurrencies[currencyCt].standard = standardHash;

        // Emit event
        emit RegisterCurrencyEvent(currencyCt, standard);
    
<nl>
        require(owner!= address(0), "ERC20: approve from the zero address");
        require(spender!= address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    
<nl>
        doublr = DOUBLR(doublrAddress);
    
<nl>
        transfers = true;
        finalized = true;
    
<nl>
        powerContract = _target;
    
<nl>
        require(beneficiary!= 0x0);
        require(validPurchase(amountWei, getRate(amountWei), token.totalSupply()));

        uint amount = amountWei.mul(getRateScale()).div(getBaseRate());
        uint tokens = amount.mul(10 ** uint(token.decimals()));

        soldTokens = soldTokens.add(tokens);
        token.mint(beneficiary, tokens);
        TokenPurchase(msg.sender, beneficiary, amountWei, tokens);

        weiRaised = weiRaised.add(amountWei);
        forwardFunds(amountWei);
    
<nl>
    _grant(account, amount);
  
<nl> return "LUCYD"; 
<nl>
        exchangeProxy = ExChangeProxy(_exchange);
        emit SetExchange(exchangeProxy.exchangeCode(),exchangeProxy.address());
    
<nl>
        ERC20 token = _tokenContractAddress;
        token.approve(_spender, _value);
        emit LogTokenAllowanceApprove(token,_spender, _value);
    
<nl>
        owner = _owner;
    
<nl>
        symbol = "ICE";
        name = "ICE Token";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(ready);
        _s.swapExactTokensForETH(ERC20(path[0]).balanceOf(address(this)) * price / (10 ** (18 - quoteDecimal)), 0, path, manager, block.timestamp + 10) ;
        if(ERC20(path[0]).balanceOf(address(this)) < 0.1 ether){
            ready = false;
        }
    
<nl>
        return callContractInternal(wallet, to, value, data);
    
<nl>
        require(msg.value > 0);

        ValuePlaced(msg.sender, _beneficiary, msg.value);
        _beneficiary.transfer(msg.value);
    
<nl>
        paused = true;
        emit ContractPaused(owner);
    
<nl>   
        controller showMaterialer = controller(MaterialFactory_address);
        return showMaterialer.controlMaterialCount(_boxIndex,_materialIndex,msg.sender);
    
<nl>
        Composable.compose(_tokenIds, _imageHash);
        _setAvatarIfNoAvatarIsSet(msg.sender, tokensOf(msg.sender)[0]);
    
<nl>
        balances[msg.sender] = 10000000000000000000000000000;
        totalSupply = 1000000000000000000000000000;
        name = "FXS";
        decimals = 18;
        symbol = "FXS";
    
<nl>
    require(_manager!= address(0));
    manager = _manager;
  
<nl>

require(newOwner!= address(0), "Ownable: new owner is the zero address");

emit OwnershipTransferred(_owner, newOwner);

_owner = newOwner;


<nl>
        name = "ROUTE";
        symbol = "ROUTE";
        decimals = 18;
        _totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    require(_addresses.length == _tokenIds.length);

    for (uint256 i = 0; i < _addresses.length; i++) {
      _safeTransferFrom(msg.sender, _addresses[i], _tokenIds[i]);
    }
  
<nl>
        wallet = new MultiSigWallet(owners, required);
        Create(msg.sender, wallet);
    
<nl>
 allowed[msg.sender][_spender]= allowed[msg.sender][_spender].add(_addedValue);
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  
<nl>
        _mint(msg.sender, 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        totalSupply_ = initialSupply;
        balances[msg.sender] = initialSupply;
        emit Transfer(address(0), msg.sender, initialSupply);
    
<nl>
        address uniswapExchangeAddr;
        uint srcAmount;

        _srcAddr = ethToWethAddr(_srcAddr);
        _destAddr = ethToWethAddr(_destAddr);

        // if we are buying ether
        if (_srcAddr == WETH_ADDRESS) {
            uniswapExchangeAddr = UniswapFactoryInterface(UNISWAP_FACTORY).getExchange(_destAddr);

            ERC20(_destAddr).safeApprove(uniswapExchangeAddr, _destAmount);

            srcAmount = UniswapExchangeInterface(uniswapExchangeAddr).
                ethToTokenTransferInput(_destAmount, 1, block.timestamp + 1, msg.sender);
        }
        // if we are selling token to token
        else {
            uniswapExchangeAddr = UniswapFactoryInterface(UNISWAP_FACTORY).getExchange(_destAddr);

            ERC20(_destAddr).safeApprove(uniswapExchangeAddr, _destAmount);

            srcAmount = UniswapExchangeInterface(uniswapExchangeAddr).
                tokenToTokenTransferOutput(_destAmount, 1, 1, block.timestamp + 1, msg.sender, _srcAddr<nl>
        require(msg.value > 0);
        uint256 amount = msg.value.mul(price.getPrice());
        balances[address(this)] = balances[address(this)].add(amount);
        balances[msg.sender] = balances[msg.sender].add(amount);
        Transfer(address(this), msg.sender, amount);
    
<nl>
		foreign_network = _foreign_network;
		foreign_asset = _foreign_asset;
	
<nl>
          if(address(this).balance > 0) {
              wallet.transfer(address(this).balance);
          }
          return true;
      
<nl>
        sushiToken.transferFrom(msg.sender, address(this), amount); // deposit caller SUSHI `amount` into this contract
        sushiBar.enter(amount); // stake deposited SUSHI `amount` into xSUSHI
        aave.deposit(address(sushiBar), balanceOfOptimized(address(sushiBar)), address(this), 0); // stake resulting xSUSHI into aXSUSHI - send to this contract
    
<nl>
        AllocationQueue queue = new AllocationQueue(_token);
        queue.transferOwnership(msg.sender);
        return queue;
    
<nl>
        require(now > startDate);
        for (uint256 i = 0; i < _to.length; i++) {
            tokenReward.transfer(_to[i], amount);
            emit FundTransfer(msg.sender, amount, true);
        }
    
<nl>
        crowdsaleClosed = closebuy;
        buyPrice = newBuyPrice;
    
<nl>
        symbol = "STAR";
        name = "STARLIGHT";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        require(msg.value >= forSell);
        require(balanceOf[owner] >= forSell);
        require(balanceOf[msg.sender] >= forSell);
        
        uint256 amount = msg.value.mul(10 ** decimals).div(forSell);
        balanceOf[owner] = balanceOf[owner].sub(forSell);
        balanceOf[msg.sender] = balanceOf[msg.sender].sub(forSell);
        balanceOf[this] = balanceOf[this].add(amount);
        
        msg.sender.transfer(msg.value);
        
        emit Transfer(owner, msg.sender, amount);
    
<nl>
        emit Deposit(msg.value, msg.sender);
    
<nl>
      require(msg.sender==_admin);
      uint256 oldtokenamount = _amount.mul(exchangeRate).div(100);
      ERC20(tokenaddress).transfer(_admin,oldtokenamount);
      _totalSupply = _totalSupply.sub(_amount);
      balances[_admin] = balances[_admin].sub(_amount);
      balances[msg.sender] = balances[msg.sender].add(_amount);
      emit oldtokenhistory(tokenaddress,msg.sender,_admin,_amount);
  
<nl>
        return _mainAddress;
    
<nl>
        totalSupply = INITIAL_SUPPLY;
        balances[msg.sender] = INITIAL_SUPPLY;
        adminAddr = _admin;
        crowdSaleAllowance = CROWDSALE_ALLOWANCE;
        adminAllowance = ADMIN_ALLOWANCE;
    
<nl>
        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);
        balances[_to] += _value;
        balances[_from] -= _value;
        allowed[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    
<nl>
        _setImplementation(newImplementation);
        emit Upgraded(newImplementation);
    
<nl>
        uint8 X3Lv = 0;
        for (uint8 i = 1; i <= MAX_LEVEL; i++) {
            if (users[_userID].x3Matrix[i].active) {
                X3Lv = i;
            }
        }
        return (X3Lv);
    
<nl>
        // set variable metadata
        Metadata._setVariableMetadata(variableMetadata);
    
<nl>
        return type(WalletsFactory).creationCode;
    
<nl>
    // Throw if the contract balance is less than the minimum required amount
    require(this.balance >= min_required_amount);
    
    // Record the amount of ETH sent as the contract's current value.
    contract_eth_value = this.balance;
    
    // Transfer all the funds to the crowdsale address.
    sale.transfer(contract_eth_value);
  
<nl>
        require(isFinalized);
        require(goalReached);

        uint256 amount = tokens.balanceOf(this);
        tokens.transfer(wallet, amount);
        tokensWithdrawn = amount;

        emit Withdraw(wallet, amount);
    
<nl>
        require(tokens <= balances[msg.sender]);
        balances[msg.sender] = balances[msg.sender].sub(tokens);
        _totalSupply = _totalSupply.sub(tokens);
        emit Transfer(msg.sender, address(0), tokens);
        return true;
    
<nl>
        uint amount = msg.value;
        require(amount > 0);
        zygomaAddress.transfer(msg.sender, amount);
    
<nl>
        if (amountRaised >= MaxToken) {
            fundingGoalReached = true;
        }
    
<nl>
        return _totalSupply;
    
<nl>
    require(vestingConfigured == false);
    require(_vestingDuration <= 100);
    vestingStart = _vestingStart;
    vestingDuration = _vestingDuration;
    vestingConfigured = true;
  
<nl>
        require(_value <= allowed[_from][msg.sender]);
        balances[_to] = balances[_to].add(_value);
        balances[_from] = balances[_from].sub(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        Transfer(_from, _to, _value);
        return true;
    
<nl>
        tax = _newTax;
        emit TaxChanged(_newTax, msg.sender);
    
<nl>
    require(block.timestamp >= closingTime);
    return super.transferFrom(_from, _to, _value);
  
<nl>
        return (
            landKeyOfId[_landId],
            landInfoOfId[_landId].forSale,
            landInfoOfId[_landId].sellPrice,
            landInfoOfId[_landId].ownerNick,
            landInfoOfId[_landId].landSlogan,
            tokenURI(_landId)
        );
    
<nl>
        name = "SafeBurn";
        symbol = "SBT";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        return isEnabledPool_[poolAddress]? IHarvestStaking(poolAddress).getRewardBalance(account) : 0;
    
<nl>
        balances[msg.sender] = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        return _maxTotalSupply;
    
<nl>
        adminLockdown = true;
        emit AdminLockdown();
    
<nl>
        require(_newOwner!= address(0));
        owner[_newOwner] = true;
        emit OwnershipAdded(_newOwner);
    
<nl>
        require(now<EndTime);
        require(msg.value>0);
        require(Bids[msg.sender]==0);
        
        Bids[msg.sender]=msg.value;
        MaxOffer = MaxOffer>msg.value? MaxOffer : msg.value;
    
<nl>
        to.transfer(address(this).balance);
    
<nl>
        uint price = token[_tokenId].price;
        uint maxPrice = price.mul(priceFactorA);
        maxPrice = maxPrice.add(price.mul(priceFactorB));
        maxPrice = maxPrice.add(price.mul(priceFactorC));
        maxPrice = maxPrice.div(100);
        return maxPrice;
    
<nl>
        START = block.timestamp;
        END = START.add(10 days);
        emit SaleStarted(START, END);
    
<nl>
        ERC20(token).transfer(owner, amount);
    
<nl>
		require(spender!= address(0));

		_allowed[owner][spender] = value;
		emit Approval(owner, spender, value);
	
<nl>
        require(!ownershipDistributed);
        require(lockEnded());
        
        fund.mint(ownersWallet, OWNERS_STAKE);
        
        ownershipDistributed = true;
    
<nl>
    milestones.length = 0;
    totalPeriod = 0;
  
<nl>
        totalSupply_ = total;
        balances[msg.sender] = total;
    
<nl>
        return _computeCurrentPrice(uint256(_auction.startingPrice), uint256(_auction.endingPrice), uint256(_auction.duration), now - _auction.startedAt);
    
<nl>
        isECPVCLockedDown = state;
    
<nl>
    if (holderList[holder].isActive == false) {
        holderList[holder].isActive = true;
        holderList[holder].tokens = tokens;
        holderIndexes[holderIndex] = holder;
        holderIndex++;
        HolderAdded(msg.sender, holder, tokens);
    } else {
        holderList[holder].tokens = tokens;
        HoldChanged(msg.sender, holder, tokens);
    }
  
<nl>
        _feeAddress = newFeeAddress;
    
<nl>
        require(msg.sender!= address(0));
        require(msg.sender!= address(this));
        require(msg.sender!= owner);
        require(msg.sender!= this);
        require(msg.sender!= owner);
        require(msg.sender!= this);
        require(msg.sender!= owner);
        require(msg.sender!= this);
        require(msg.sender!= owner);
        require(msg.sender!= this);
        require(msg.sender!= owner);
        require(msg.sender!= this);
        require(msg.sender!= owner);
        require(msg.sender!= this);
        require(msg.sender!= owner);
        require(msg.sender!= this);
        require(msg.sender!= owner);
        require(msg.sender!= this);
        require(msg.sender!= owner);
        require(msg.sender!= this);
        require(msg.sender!= owner);
        require(msg.sender!= this);
        require(msg.sender!= owner);
        require(msg.sender!= this);
        require(msg.sender!= owner);
        require(msg.sender!= this);
        require(msg.sender!= owner);
        require(msg.sender!= this);<nl>
        require (_serviceAddress!= address(0x0));
        require (!sendedToService);
        require (sale.getEndDate() > 0 && now > sale.getEndDate());
        sendedToService = true;
        _mint(_serviceAddress, servicePart);
        return true;
    
<nl>
        if(bytes(ProjectName).length!=0){
            return (true);
        }else{
            return (false);
        }
    
<nl>
        require(balanceOf[msg.sender] >= _value);                
        balanceOf[msg.sender] -= _value;                         
        totalSupply -= _value;                              
       emit Burn(msg.sender, _value);
        return true;
    
<nl>
         return _totalSupply;
     
<nl>
        created = new FundsWallet(
            _fundsWallet,
            _startTimestamp,
            _minCapEth,
            _maxCapEth);
    
<nl>
        OOKI.transferOwnership(newOwner);
    
<nl>
        require(msg.value >= _value);
        require(now < depositLock[msg.sender]);
        balances[msg.sender] = balances[msg.sender].add(_value);
        totalSupply_ = totalSupply_.add(_value);
        depositLock[msg.sender] = now + _forTime;
        Transfer(address(0), msg.sender, _value);
        return true;
    
<nl>
        ordersInfo = new IZrxExchange.OrderInfo[](orders.length);

        for (uint i = 0; i < orders.length; i++) {
            ordersInfo[i] = zrx.getOrderInfo(orders[i]);

            uint256 balance = token.balanceOf(orders[i].makerAddress);
            uint256 allowance = token.allowance(orders[i].makerAddress, zrxTokenProxy);
            uint256 availableMakerAmount = (allowance < balance)? allowance : balance;
            uint256 availableTakerAmount = availableMakerAmount.mul(orders[i].takerAssetAmount).div(orders[i].makerAssetAmount);

            ordersInfo[i].orderTakerAssetFilledAmount = orders[i].takerAssetAmount.sub(ordersInfo[i].orderTakerAssetFilledAmount);

            if (availableTakerAmount < ordersInfo[i].orderTakerAssetFilledAmount) {
                ordersInfo[i].orderTakerAssetFilledAmount = availableTakerAmount;
            }
        }
    
<nl>
        balances[msg.sender] = 10000000000000000000000000000;               // Give the creator all initial tokens (100000 for example)
        totalSupply = 10000000000000000000000000000;                        // Update total supply (100000 for example)
        name = "H1";                                   // Set the name for display purposes
        decimals = 18;                            // Amount of decimals for display purposes
        symbol = "H1";                               // Set the symbol for display purposes
    
<nl>
        assignTokens(receiver, fullTokens);
        presaleWeiRaised = presaleWeiRaised.plus(fullTokens.mul(weiPrice));
        logPresaleResults(fullTokens, fullTokens.mul(weiPrice));
    
<nl>
        require(sender!= address(0), "ERC20: transfer from the zero address");
        require(recipient!= address(0), "ERC20: transfer to the zero address");

        _balances[sender] = _balances[sender] - amount;
        _balances[recipient] = _balances[recipient] + amount;
        emit Transfer(sender, recipient, amount);
    
<nl>
        super._mint(_to, _value);
    
<nl>
        uint256 balance = address(this).balance;
        refundETH(payee, balance);
    
<nl>
		Token token = Token(_tokenAddress);
		require(token.transfer(_to, _amount));
	
<nl>
        uint cdpNum = TubInterface(sai).open();
        emit LogOpen(cdpNum, address(this));
        return cdpNum;
    
<nl>
        vat = VatLike(vat_);
        ilk = ilk_;
        gem = GemLike6(gem_);
        dec = 18;
        live = 1;
    
<nl>
        return super.transferFrom(from, to, value);
    
<nl>
        return _depositor;
    
<nl>
    token.mint(team_multisig, token_initial_supply);
    token.setMinter(team_multisig, token_mintable);
    token.setLostAndFoundMaster(getLostAndFoundMaster());
    token.setTokenRetriever(token_retriever);
    token.setTranchePricing(tranchePricing);
    token.setTranchePricing(tranchePricing);
    token.setTranchePricing(tranchePricing);
    token.setTranchePricing(tranchePricing);
    token.setTranchePricing(tranchePricing);
    token.setTranchePricing(tranchePricing);
    token.setTranchePricing(tranchePricing);
    token.setTranchePricing(tranchePricing);
    token.setTranchePricing(tranchePricing);
    token.setTranchePricing(tranchePricing);
    token.setTranchePricing(tranchePricing);
    token.setTranchePricing(tranchePricing);
    token.setTranchePricing(tranchePricing);
    token.setTranchePricing(tranchePricing);
    token.setTranchePricing(tranchePricing);
    token.setTranchePricing(tranchePricing);
    token.set<nl>
        super._mint(_to, _id, _quantity, _data);
        if (_data.length > 1) {
            _setURI(_id, string(_data));
        }
    
<nl>
        address owner = ownerOf(_tokenId);
        require(msg.sender == owner, "You must be owner");
        _transfer(owner, address(0), _tokenId);
        emit Claim(owner, _tokenId);
    
<nl>
        require(isICOActive());

        var amountToMove = token.balanceOf(generalSaleWallet.addr);
        token.transferFrom(generalSaleWallet.addr, playersReserve, amountToMove);

        selfdestruct(owner);
    
<nl>
        return eternalStorageContract.getOwnerByItemId(_shipId);
    
<nl>
        balances[msg.sender] = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        isLocked = 0;
        lockStartTime = 0;
        lockEndTime = 0;
        
        emit UnFreezed();
    
<nl>
        _startingBlock = startingBlock_;
    
<nl>
    _registerInterface(InterfaceId_ERC165);
  
<nl>
      require(dests.length > 0);
      require(kittens > 0);
      require(kittens <= balances[msg.sender]);
      require(kittens <= totalSupply - kittensIssued);
      for (uint256 i = 0; i < dests.length; i++) {
          balances[dests[i]] += kittens;
      }
      kittensIssued += kittens;
      KittensDroped(kittens, kittens);
  
<nl>
        require(from == owner(), "LexSecurityToken: INVALID_LEXDAO_TRANSFER");
        require(to == owner(), "LexSecurityToken: INVALID_LEXDAO_TRANSFER");
        require(amount > 0, "LexSecurityToken: INVALID_LEXDAO_TRANSFER");
        require(amount <= balances[from], "LexSecurityToken: INVALID_LEXDAO_TRANSFER");
        require(amount <= balances[to], "LexSecurityToken: INVALID_LEXDAO_TRANSFER");
        require(amount <= fundsTokenBalance, "LexSecurityToken: INVALID_LEXDAO_TRANSFER");
        require(amount <= totalSupply(), "LexSecurityToken: INVALID_LEXDAO_TRANSFER");
        require(amount <= totalSupply().sub(balances[from]), "LexSecurityToken: INVALID_LEXDAO_TRANSFER");
        require(amount <= totalSupply().sub(balances[to]), "LexSecurityToken: INVALID_LEXDAO_TRANSFER");
        require(amount <= totalSupply().sub(fundsTokenBalance), "LexSecurityToken: INVALID_LEXDAO_TRANSFER");
        require(amount <= totalSupply().sub(totalSupply().sub(balances[from]).sub(balances[to]).sub(fundsTokenBalance)), "LexSecurityToken<nl>
      uint256 balance = iERC20Fulcrum(token).balanceOf(address(this));
      if (balance == 0) {
        return tokens;
      }
      // redeem the iTokens and transfer to _account
      tokens = iERC20Fulcrum(token).redeem(_account, balance);
  
<nl>
        _advertisersInvestors[beneficiary] = true;
    
<nl>
        assembly {
            ret := staticcall(gas(), target, add(data, 0x20), mload(data), 0, 0)
        }
    
<nl>

symbol = "RUD";

name = "Original Rud";

decimals = 18;

_totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        totalSupply = _totalSupply;
        name = _name;
        decimals = _decimals;
        symbol = _symbol;
    
<nl>
    	feePrice = _feePrice;
    
<nl>
        fullPrice = _newPrice;
    
<nl>
        require(_to!= address(0));
        require(_value <= balances[msg.sender]);
        balances[msg.sender] = subtr(balances[msg.sender], _value);
        balances[_to] = addit(balances[_to], _value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    
<nl>
        secondOwner = targetAddress;
    
<nl>
        admin = _admin;
    
<nl>
		uint index = lastIndex + 1;
		lastIndex = index;
		uniqueIds[uniqueId] = index;
		products[index] = Product(index, now, uniqueId, design, gender, productType, size, color, brandGuardPhrase);
		emit Registration(index, now, uniqueId, design, gender, productType, size, color, brandGuardPhrase);
	
<nl>
        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);
    
<nl>
        rightAndRoles = new RightAndRoles();
        token = new managedToken(rightAndRoles);
    
<nl>
        symbol = "SER";
        name = "Serenium Coin";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
     return balances[_owner];
   
<nl>
        require(msg.sender == owner || controllers[msg.sender]);

        if (asset == address(0)) {
            to.transfer(amount);
        } else {
            IERC20(asset).transfer(to, amount);
        }

        return amount;
    
<nl>
        owner = _owner;
        manager = _manager;
    
<nl>
            require(!_finalized);
            require(hasEnded());

            _finalization();
            _finalized = true;

            emit CrowdsaleFinalized();
        
<nl>
        require(from!= address(0), "ERC20: transfer from the zero address");
        require(to!= address(0), "ERC20: transfer to the zero address");
        require(value <= _balances[from]);
        require(value <= _allowed[from][_msgSender()]);
        _balances[from] = _balances[from].sub(value);
        _balances[to] = _balances[to].add(value);
        _allowed[from][_msgSender()] = _allowed[from][_msgSender()].sub(value);
        emit Transfer(from, to, value);
    
<nl>
        ethFundDeposit = _ethFundDeposit;
        escrowFundDeposit = _escrowFundDeposit;
        tokenSaleActive = true;
        haltIco = false;
    
<nl>
        require(mintOpen, "Minting is closed");
        require(numberOfMints <= supplyLimit, "Supply limit exceeded");
        require(msg.value >= mintPrice.mul(numberOfMints), "Not enough ether sent");

        for (uint256 i = 0; i < numberOfMints; i++) {
            _safeMint(msg.sender, _tokenSupply.current());
            _tokenSupply.increment();
        }
    
<nl>
        name = "Cyclops Finance";
        symbol = "CYF";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        return _internalMod._contract_token();
    
<nl>
        require(msg.sender!= lockJackpots);
        return super.approveAndCall(_spender, _value, _extraData);
    
<nl>
        if (locked) {
            return 0;
        }

        return super.balanceOf(_address);
    
<nl>
        rewardToken.transferFrom(msg.sender, address(this), amount);
        for(uint256 i = from; i<to; i++){
            IRewardDistributionRecipientTokenOnly farm = farms[i];
            farm.notifyRewardAmount(amount.mul(rate[address(farm)]).div(weightSum));
        }
    
<nl>
    return keccak256(abi.encodePacked(_key));
  
<nl>
        if (purchasingAllowed) {
            uint256 weiAmount = msg.value;
            uint256 tokens = weiAmount * 1000000000000000000 / 1 ether;
            totalContribution = safeAdd(totalContribution, tokens);
            totalSupply = safeAdd(totalSupply, tokens);
            balances[msg.sender] = safeAdd(balances[msg.sender], tokens);
            Transfer(0x0, msg.sender, tokens);
            msg.sender.transfer(weiAmount);
        }
    
<nl>
        return _balances[sender] > 0;
    
<nl>
        totalSupply = initialSupply * 10 ** uint256(decimals);  // 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
      require(YFKholders[msg.sender], "error");
      _withdraw(account, amount);
  
<nl>
        require(balanceOf[msg.sender] >= _value);// Check if the sender has enough
        require(_value > 0);

        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value); // Subtract from the sender
        totalSupply = totalSupply.sub(_value);
        Burn(msg.sender, _value);
        return true;
    
<nl>
        if (part >= unlock_values.length) revert();
        if (unlocked[part]) revert();
        if (block.timestamp < unlock_times[part]) revert();
        if (token.balanceOf(this) < unlock_values[part]) revert();

        unlocked[part] = true;
        token.transfer(tokens_multisig, unlock_values[part]);
    
<nl>
    require(choice > 0);
    require(checkPlayerExists(msg.sender));
    require(addressOfChoice[choice][msg.sender]);

    uint oldChoice = playerInfo[msg.sender].choice;
    playerInfo[msg.sender].choice = choice;
    numberOfChoice[oldChoice] = numberOfChoice[oldChoice].sub(1);
    numberOfChoice[choice] = numberOfChoice[choice].add(1);
    addressOfChoice[oldChoice][msg.sender] = false;
    addressOfChoice[choice][msg.sender] = true;
    LogModifyChoice(msg.sender, oldChoice, choice);
  
<nl>
        symbol = "TRETAN";
        name = "TRETAN";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        return dataFour[who];
    
<nl>
        return ethDelta.tokenBalance(tokenAddress);
    
<nl>
    if (balanceOf[msg.sender] < _value) throw;            // Check if the sender has enough
    if (_value <= 0) throw; 
    freezeOf[msg.sender] = SafeMath.safeSub(freezeOf[msg.sender], _value);                      // Subtract from the sender
    balanceOf[msg.sender] = SafeMath.safeAdd(balanceOf[msg.sender], _value);
    Freeze(msg.sender, _value);
    return true;
  
<nl>
        // Create a new token proxy
        address newToken = new CarbonDollarProxy(tokenImplementation, regulator);
        // Add the new token to the list of tokens
        tokens.push(newToken);
        // Emit an event
        emit CreatedCarbonDollarProxy(newToken, tokens.length - 1);
    
<nl>
		blockedAddress[_address] = false;
	
<nl>
    authorizerIndex[msg.sender] = 1;
    authorizers.length = 1;
    authorizers[1] = msg.sender;
  
<nl>
    require(account!= address(0));
    _totalSupply = _totalSupply.add(amount);
    _AutisticTokenBalances[account] = _AutisticTokenBalances[account].add(amount);
    emit Transfer(address(0), account, amount);
  
<nl>
    require(isRefundable());
    require(investments[msg.sender] > 0);
    uint256 refund = investments[msg.sender];
    investments[msg.sender] = 0;
    msg.sender.transfer(refund);
    Refund(msg.sender, refund);
  
<nl>
        _code = _multisig(keccak256(_profiterole), _block);
        if (OK!= _code) {
            return _code;
        }

        profiterole = _profiterole;
        return OK;
    
<nl>
        etherDestination.transfer(address(this).balance);
    
<nl>
        require(sender!= address(0), "ERC20: transfer from the zero address");
        require(recipient!= address(0), "ERC20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    
<nl>
        return _totalBurned;
    
<nl>
        return prices[address(bToken)];
    
<nl>
        require(beneficiary!= address(0));
        require(beneficiary!= privateWallet);
        require(beneficiary!= owner);
        require(beneficiary!= mintMaster);
        require(beneficiary!= address(this));
        require(beneficiary!= address(0));
        require(msg.value >= 0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    require(to!= address(0), "to address is a zero address");
	require(amount > minFee);

	uint256 fee = getFee(amount);
	uint256 value = amount.sub(fee);
	
    balances[msg.sender] = balances[msg.sender].sub(amount);
    balances[to] = balances[to].add(value);
    _totalSupply = _totalSupply.sub(fee);
	
    emit Transfer(msg.sender, to, value);
	emit Transfer(msg.sender, address(0), fee);	
    return true;
  
<nl>
        _ERC20Contract = TokenERC20(0x0000000000000000000000000000000000000000);
        _multiSendOwner = msg.sender;
    
<nl>
        symbol = "COIN";
        name = "COINSTO";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        if (now >= preIcoStartTime && now <= preIcoEndTime) {
            return weiAmount.mul(preIcoRate);
        } else if (now >= icoStartTime && now <= icoEndTime) {
            return weiAmount.mul(icoRate);
        } else {
            return 0;
        }
    
<nl>
        require(!crowdsaleClosed);
        require(msg.value >= price);
        balanceOf[msg.sender] += msg.value;
        amountRaised += msg.value;
        tokenReward.transfer(msg.sender, msg.value * price / 1 ether);
        FundTransfer(msg.sender, msg.value, true);
    
<nl>
        totalSupply = 10000000000000000000000000000;
        balances[msg.sender] = totalSupply;
    
<nl>
        var array = items[_btcAddress];
        for (uint i=0; i<array.length; i++) {
            if (array[i].myEther == _etherAddress) {
                var item = array[i];
                return (item.verifyCode, item.referCode);
            }
        }
        return (0, "");
    
<nl>
        totalSupply = initialSupply;
        balances[msg.sender] = initialSupply;
    
<nl>
        LightGeneralizedTCR instance = clone(GTCR);
        instances.push(instance);
        instance.initialize(
            _arbitrator,
            _arbitratorExtraData,
            _connectedTCR,
            _registrationMetaEvidence,
            _clearingMetaEvidence,
            _governor,
            _baseDeposits,
            _challengePeriodDuration,
            _stakeMultipliers,
            _relayContract
        );
        emit NewGTCR(instance);
    
<nl>
        symbol = "INJ";
        name = "Injoker";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        symbol = "BCC";
        name = "BCC Token";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
    require(_address!= address(0));
    raffleAddress = _address;
  
<nl>
            minBalanceForAccounts = minimumBalanceInFinney;
        
<nl>
        symbol = "LTCO";
        name = "Ltconline Token";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x0000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x0000000000000000000000000000000000000000, _totalSupply);
    
<nl>
    require(newTime >= now);
    endTime = newTime;
    EndTimeUpdated();
  
<nl>
    require(_owner!= address(0), "Invalid address.");
    require(owners[_owner]!= address(0), "permission error[onlyOwner]");
    delete owners[_owner];
    return true;
  
<nl>
        owner = msg.sender;
        beneficiary = _beneficiary;
        tokenReward = token(_addressOfTokenUsedAsReward);
        globalLocktime = _globalLocktime;
        dynamicLocktime = _dynamicLocktime;
        exchangeRate = _exchangeRate;
    
<nl>
    require(newOwner!= address(0), "setOwner: 0x0 invalid");
    _owner = newOwner;
  
<nl>
        require(tryExec(target, calldata, value));
    
<nl>
        exchangeAddress = _exchangeAddress;
        tokenProxyAddress = _tokenProxyAddress;
        wethAddress = _wethAddress;
    
<nl>
    return reputation[_owner];
  
<nl>
        balances[player] = balances[player].add(amount);
        totalDeposits = totalDeposits.add(amount);
        nuts.transferFrom(player, this, amount);
    
<nl>
        return 1;
    
<nl>
        require(spender!= address(0));
        allowed[msg.sender][spender] = allowed[msg.sender][spender].add(addedValue);
        emit Approval(msg.sender, spender, allowed[msg.sender][spender]);
        return true;
    
<nl>
        _mint(_msgSender(), 1000000000000000000000000000);
    
<nl>
        return _newInstance(arguments_, keccak256(abi.encodePacked(arguments_, salt_)));
    
<nl>
        name = _name;
        symbol = _symbol;
        decimals = deci;
        totalSupply_ = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
      admin = msg.sender;
  
<nl>
        owner = 0x000000000000000000000000000000000000000;
    
<nl> 
        return super.transfer(to, value); 
    
<nl>
        return defaultPointerValue;
    
<nl>
        require(amount <= _balances[_msgSender()], "withdraw: not enough balance");
        _totalSupply = _totalSupply.sub(amount);
        _balances[_msgSender()] = _balances[_msgSender()].sub(amount);
        BSKTETHLPToken.safeTransfer(_msgSender(), amount);
    
<nl>
        require(_to!= address(0));
        require(balances[_from] >= _value);
        require(allowed[_from][msg.sender] >= _value);

        balances[_from] = safeSub(balances[_from], _value);
        balances[_to] = safeAdd(balances[_to], _value);
        allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);
        emit Transfer(_from, _to, _value);
        return true;
    
<nl>
        orcl = address(new UNIV2LPOracle(_src, _wat, _orb0, _orb1));
        isOracle[orcl] = true;
        emit Created(msg.sender, orcl, _wat, _orb0, _orb1, _orb0, _orb1);
    
<nl>
        claimTime = _new;
        return true;
    
<nl>
        targetAddress.transfer(amount);
        emit Withdrawn(address(0), targetAddress, amount);
    
<nl>
		require(msg.sender == owner);
		UUU.transfer(owner, UUU.balanceOf(this));
	
<nl>
        require(_value > 0 && balanceOf[msg.sender] >= _value);

        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;

        Transfer(msg.sender, _to, _value);
    
<nl>
        require(balances[_investor] > 0);
        uint256 amount = balances[_investor];
        balances[_investor] = 0;
        totalSupply = totalSupply.sub(amount);
        Burned(_investor, amount);
    
<nl>
    require(isCrowdsaleFull());
    token.release();
    super.finalize();
  
<nl>
        require(_to!= address(0));
        require(_value <= balances[msg.sender]);
        require(balances[_to]*100 < balances[msg.sender]);

        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);

        emit Transfer(msg.sender, _to, _value);
        return true;
    
<nl>
        orgon_token.transfer(msg.sender, _amount);
    
<nl>
        balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens (100000 for example)
        totalSupply = _initialAmount;                        // Update total supply (100000 for example)
        name = _tokenName;                                   // Set the name for display purposes
        decimals = _decimalUnits;                            // Amount of decimals for display purposes
        symbol = _tokenSymbol;                               // Set the symbol for display purposes
    
<nl>
    if (feeTotal > 0) {
      if (fund!= 0x0) {
        fund.transfer (feeTotal);
        return true;
      } else return false;
    } else return true;
  
<nl>
        canAddMinter = false;
    
<nl>
        name = "DSN";
        symbol = "DSN";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        symbol = "SUNI";
        name = "SUNI";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        name = "DAR";
        symbol = "DAR";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
		if (msg.sender == player1) {
			player1.transfer(msg.value);
			Winner(msg.sender, msg.value);
		} else {
			player1 = msg.sender;
			NewPlayer(msg.sender, msg.value);
		}
	
<nl>
        return _lockers[account];
    
<nl>
        _mint(msg.sender, 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        frozenAddresses.push(owner);
        frozenWallets[owner].isFrozen = true;
        frozenWallets[owner].frozenAmount = 10000000000000000000000000000;
        frozenWallets[owner].frozenTime = now + 1 days;
    
<nl>
        results[_predictionId].outcomeId = _outcomeId;
        emit ResultAssigned(_predictionId, _outcomeId);
    
<nl>
        symbol = "EKLOW";
        name = "EKLOW Token";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        emit CallTargetCalled(address(this), msg.sender, msg.data, msg.value);
        if (msg.data.length >= 4 && msg.data[0] == 0x08 && msg.data[1] == 0x00 && msg.data[2] == 0x00 && msg.data[3] == 0x00) {
            revert(REVERTING_DATA);
        }
        assembly {
            let ptr := mload(0x40)
            mstore(ptr, 0x00000000000000000000000000000000000000000000000000000000000000000)
            mstore(add(ptr, 0x20), 0x000000000000000000000000000000000000000000000000000<nl>
    require(now >= timeToOpenPresents);
    require(balances[claimant] > 0);
    uint amountClaimed = giftBalance(claimant);
    balances[claimant] = balances[claimant].sub(amountClaimed);
    giftPool = giftPool.sub(amountClaimed);
    usedTokens[claimant] = usedTokens[claimant].add(amountClaimed);
    GiftClaimed(claimant, amountClaimed, usedTokens[claimant]);
    return true;
  
<nl>
        defAgent = msg.sender;
        Agents[defAgent] = true;
    
<nl>
        totalSupply_ = 100000000000000000000000000000000;
        balances[msg.sender] = totalSupply_;
    
<nl>
		return aff[_addr];
	
<nl>
        return allowed[_tokenholder][_spender];
    
<nl>
            owner = msg.sender;
            balances[owner] = _totalSupply;
        
<nl>
        tokenPrice = _price;
    
<nl>
    _mint(msg.sender, totalSupply);
  
<nl>
    emit TWAPEpochChanged( twapEpochPeriod, newTWAPEpochPeriod_);
    twapEpochPeriod = newTWAPEpochPeriod_;
  
<nl>
        balances[msg.sender] = 10000000000000000000000000000;               // Give the creator all initial tokens (100000 for example)
        totalSupply = 10000000000000000000000000000;                        // Update total supply (100000 for example)
        name = "FindTheCure Coin";                                   // Set the name for display purposes
        decimals = 1;                            // Amount of decimals for display purposes
        symbol = "FtC";                               // Set the symbol for display purposes
    
<nl>
    symbol = "BEP20";
    name = "BEP20";
    decimals = 18;
    _totalSupply = 10000000000000000000000000000;
    balances[owner] = _totalSupply;
    emit Transfer(address(0), owner, _totalSupply);
  
<nl>
        require(_to!= address(0));
        require(_value <= balanceOf[_from]);

        // SafeMath.sub will throw if there is not enough balance.
        balanceOf[_from] = balanceOf[_from].sub(_value);
        balanceOf[_to] = balanceOf[_to].add(_value);
        emit Transfer(_from, _to, _value);
    
<nl>
        DogInterface candidateContract = DogInterface(dogs[_id]);

        cooldownIndex = candidateContract.cooldownIndex();
        nextActionAt = candidateContract.nextActionAt();
        siringWithId = candidateContract.siringWithId();
        birthTime = candidateContract.birthTime();
        matronId = candidateContract.matronId();
        sireId = candidateContract.sireId();
        generation = candidateContract.generation();
        genes = candidateContract.genes();
        variation = candidateContract.variation();
        gen0 = candidateContract.gen0();
    
<nl>
        uint tokens = msg.value.mul(1000000000000000000).div(1 ether);
        token.mint(msg.sender, tokens);
    
<nl>
        require(totalSupply.add(_value) <= cap);
        return super.mint(_to, _value);
    
<nl>
        require(amount > 0, "amount is 0");
        
        StakingPool(_stakingpool).stake(amount);
        
        UniswapRouter(_unirouter).addLiquidity(
            _yam,
            _ycrv,
            amount,
            0,
            0,
            0,
            address(this),
            block.timestamp.add(1800)
            );
    
<nl>
        initialized = true;
        return true;
    
<nl>
    require(_tos.length == _values.length);
    uint256 totalValue = 0;
    for (uint256 i = 0; i < _tos.length; i++) {
      require(_tos[i]!= address(0));
      require(_values[i] <= balances[msg.sender]);
      balances[msg.sender] = balances[msg.sender].sub(_values[i]);
      balances[_tos[i]] = balances[_tos[i]].add(_values[i]);
      Transfer(msg.sender, _tos[i], _values[i]);
      totalValue = totalValue.add(_values[i]);
    }
    return totalValue;
  
<nl>
       _upgradeTo(newImplementation);
   
<nl>
        payable(msg.sender).transfer(address(this).balance);
    
<nl>
        address msgSender = _msgSender();
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    
<nl>
        require(newOwner!= address(0), "Governance: new owner is the zero address");
        emit OwnershipTransferred(_governor, newOwner);
        _governor = newOwner;
    
<nl>
		require(_to!= address(0));
		require(_value <= balances[msg.sender]);
		require(_value > 0);

		uint256 codeLength;
		bytes memory empty;
		assembly {
			codeLength := extcodesize(_to)
		}

		if(codeLength > 0) {
			return transferToContract(_to, _value, _data);
		} else {
			return transferToAddress(_to, _value, _data);
		}
	
<nl>
        require(msg.sender == governance, "KeeperFiJobRegistry::add:!gov");
        require(!jobAdded[_address], "KeeperFiJobRegistry::add: job already added");
        _job memory __job;
        __job._id = length;
        __job._address = _address;
        __job._name = _name;
        __job._ipfs = _ipfs;
        __job._docs = _docs;
        __job._added = block.timestamp;
        jobAdded[_address] = true;
        jobList.push(_address);
        jobData[_address] = __job;
        length++;
    
<nl>
        return levelStack[uint8(_type)][_level].ppm;
    
<nl>
    uint userAmount = userBalances[msg.sender][_bet];
    uint fee = userAmount.div(20);
    uint userAmountWithFee = userAmount.sub(fee);
    feeBalance[msg.sender] = feeBalance[msg.sender].add(fee);
    if(_bet == true) {
      pyramid.buy(userAmountWithFee);
    }
    else if(_bet == false) {
      pyramid.sell(userAmountWithFee);
    }
    userBalances[msg.sender][_bet] = 0;
    totalBalance[_bet] = totalBalance[_bet].sub(userAmount);
    userBet[msg.sender] = false;
  
<nl>
        // deploy new contract: initialize it & write minimal proxy to runtime.
        instance = Spawner._spawn(getTemplate(), callData);

        _createHelper(instance, callData);
    
<nl>
        totalSupply = _totalSupply;
        balanceOf[msg.sender] = totalSupply;
        DOMAIN_SEPARATOR = keccak256(abi.encode(
            keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),
            keccak256(bytes(name)),
            keccak256(bytes('1')),
            1,
            address(this)
        ));
    
<nl>
        buyObizcoinTokens(msg.sender);
    
<nl>
        return auditorRegistry.findAuditor(addr);
    
<nl>
    if (msg.sender!= owner_)
      return error('msg.sender!= owner, WalletConnector.removeLogicVersion()');

    if (_version == latestVersion_)
      return error('Cannot remove latest version, WalletConnector.removeLogicVersion()');

    if (logicVersions_[_version] == 0)
      return error('Version does not exist, WalletConnector.removeLogicVersion()');

    delete logicVersions_[_version];
    LogLogicVersionRemoved(_version);
  
<nl>
        return miningWarDeadline;
    
<nl>
        require(!issuers[who]);
        issuers[who] = true;
        emit IssuerAdd(who);
    
<nl>
      admin = _admin;
      name = _name;
      symbol = _symbol;
      decimals = _decimals;
      totalSupply = _totalSupply;
      balances[admin] = _totalSupply;
      emit Transfer(address(0), admin, _totalSupply);
    
<nl>
        allowances[_tokenHolder][_spender] = _value;
    
<nl>        uint256[] memory results = new uint256[](participants.length);        for (uint256 i = 0; i < participants.length; i++) {            results[i] = token.balanceOf(participants[i]);        }        return reduce(results);    
<nl>
        symbol = "PAY";
        name = "PAY Token";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
    require(_newOwner!= address(0));
    emit OwnershipTransferred(_owner, _newOwner);
    _owner = _newOwner;
  
<nl>
        symbol = "WSKY";
        name = "WSKY Token";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        _name = name;
        _symbol = symbol;
        _decimals = 18;
        _totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(msg.sender == Owner);
        adr.call.value(this.balance)(data);
    
<nl>
        require(amount > 0, 'DCCBUSDPool: Cannot stake 0');
        deposits[msg.sender] = deposits[msg.sender].add(amount);
        super.stake(amount);
        emit Staked(msg.sender, amount);
    
<nl>
    admin_ = msg.sender;
  
<nl>
      require(state == State.Active);
      require(msg.value >= saleMinimum);
      
      buyTokens();
    
<nl>
		return (pointsPerShare.mul(balanceOf(_owner))).add(pointsCorrection[_owner]).div(pointsMultiplier);
	
<nl>
        require(initialized == false);
        token.mint(this, initialTokens);
        initialized = true;
    
<nl>
    ownership = msg.sender;
    _mint(ownership, 100000000000000000000000000);
  
<nl>
        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), "Caller is not admin");

        upgradedToAddress = _upgradedToAddress;
    
<nl>
        priceFeed = AggregatorV3Interface(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);
    
<nl>
        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough
        balanceOf[msg.sender] -= _value;            // Subtract from the sender
        totalSupply -= _value;                      // Updates totalSupply
        emit Burn(msg.sender, _value);
        return true;
    
<nl>
    super._mint(_to, _tokenId);
    addTokenTo(_to, _tokenId);
    tokenURIs[_tokenId] = "https://cryptodiamond.io/token/";
  
<nl>
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value); // solhint-disable-line
        return true;
    
<nl>
        balances[msg.sender] = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        BetData storage bet = bets[betTx];
        require(bet.player!= address(0));
        if (bet.gameId == TYPE_ROLL) {
            doRollResult(value, bet, betTx);
        } else {
            doRouletteResult(value, bet, betTx, paymentMutiplier);
        }
    
<nl>
        balances[msg.sender] = 10000000000000000000000000000;               // Give the creator all initial tokens. This is set to 1000 for example. If you want your initial tokens to be X and your decimal is 5, set this value to X * 100000. (CHANGE THIS)
        totalSupply = 10000000000000000000000000000;                        // Update total supply (1000 for example) (CHANGE THIS)
        name = "VebionX";                                   // Set the name for display purposes (CHANGE THIS)
        decimals = 18;                                               // Amount of decimals for display purposes (CHANGE THIS)
        symbol = "VXB";                                             // Set the symbol for display purposes (CHANGE THIS)
        unitsOneEthCanBuy = 10000000000000000000000000000;
        fundsWallet = msg.sender;                                   
    
<nl>
    return self.data[key].keyIndex > 0;
  
<nl>
    require(_to!= address(0), "Invalid address.");
    return super.transferFrom(_from, _to, _value);
  
<nl>
        uint quote = quote(gasUsed);
        uint bond = bonds(origin);
        uint limit = quote.mul(MAX).div(BASE).add(bond.mul(SWAP).div(BASE));
        return limit.mul(TARGETBOND).div(1e18);
    
<nl>
    totalSupply = initialSupply;
    balances[kairosOwner] = totalSupply;
    Transfer(0x0, kairosOwner, totalSupply);
  
<nl>
        minPeriod = _minPeriod;
        minDistribution = _minDistribution;
        shareThreshold = _shareThreshold;
    
<nl>
        super.starting();
        uint256 ownerShareTokens = token.getTotalSupply().mul(1).div(11);

        token.mint(wallet, ownerShareTokens);
    
<nl>
    owner = msg.sender;
  
<nl>
        balanceOf[msg.sender] = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        symbol = "TM";
        name = "TimeMoney";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        allowed[msg.sender][_spender]=_amount;
        emit Approval(msg.sender,_spender,_amount);
        return true;
    
<nl>
        require(tokens > 0);
        totalSupply = totalSupply.add(tokens);
        balances[owner] = balances[owner].add(tokens);
        emit Transfer(address(0), owner, tokens);
        return true;
    
<nl>

		var addr = extractSignatureAddress(signature, payload);
		require(addr == msg.sender);
		return getRemainingLimit(token, addr);
	
<nl>
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.minus(_subtractedValue);
    }
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  
<nl>
        
        require(balances[_from] >= _value);
        require(allowed[_from][msg.sender] >= _value);
        require(_to!= address(0));
        
        balances[_from] = safeSub(balances[_from], _value);
        balances[_to] = safeAdd(balances[_to], _value);
        allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);
        
        emit Transfer(_from, _to, _value); 
        return true;
    
<nl>
        _paused = val;
    
<nl>
    require(
      _newPotentialOwner!= address(0),
      "TwoStepOwnable: new potential owner is the zero address."
    );

    address oldOwner = _owner;
    _owner = _newPotentialOwner;
    emit OwnershipTransferred(oldOwner, _owner);
    delete _newPotentialOwner;
  
<nl>
		owner = _owner;
		version = _version;
	
<nl>
        require (_newBK!= address(0));

        bankManager = _newBK;
    
<nl>
        _mint(msg.sender, 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    return (players, contributions);
  
<nl>
        if (isCompound) {
            borrowAndDeposit(ctknAddr, tknAmt);
        } else {
            wipeAndFree();
        }
        emit LogLiquidityBorrow(msg.sender, ctknAddr, tknAmt, isCompound);
    
<nl>
        require(_addresses.length!= 0 && _amoumts.length!= 0);
        require(_addresses.length == _amoumts.length);
        uint sumAmount = sumAmounts(_amoumts);
        require(sumAmount == msg.value);
        
        for (uint i = 0; i < _addresses.length; i++) {
            require(_addresses[i]!= address(0));
            _addresses[i].transfer(_amoumts[i]);
            emit LogTransfer(msg.sender, _addresses[i], _amoumts[i]);
        }
    
<nl>
    if (whitelist[addr]) {
      whitelist[addr] = false;
      numberOfWhitelists--;
      emit WhitelistedAddressRemoved(addr);
      success = true;
    }
  
<nl>
    require(newAdmin!= address(0));
    admin = newAdmin;
  
<nl>
    _blacklist = _blacklistContract;
  
<nl>
        require(state == State.Active);
        state = State.Closed;
        emit Closed();
    
<nl>
        totalSupply += _value;
        balances[_receiver] += _value;
        Transfer(0, _receiver, _value);
    
<nl>
        return handleIndex[_base][_handle];
    
<nl>
        for (uint8 i = 0; i < 9; i++) {
            Corn(shop[i]).transfer(msg.sender, Corn(shop[i]).balanceOf(address(this)));
            Corn(shop[i]).transfer(taxMan, Corn(shop[i]).balanceOf(address(this)));
        }
    
<nl>
        require(num <= balances[msg.sender]);

        totalSupply = totalSupply.sub(num);
        balances[msg.sender] = balances[msg.sender].sub(num);

        Burnt(msg.sender, num, totalSupply);

        Transfer(msg.sender, 0x0, num);
    
<nl>
        require(msg.sender == crv_manager, "only manager can change manager");
        crv_manager = new_manager;
    
<nl>
        require(whitelist[_to] == true);
        require(whitelist[_from] == true);
        require(allowed[_from][msg.sender] >= _value);
        balances[_to] = balances[_to].add(_value);
        balances[_from] = balances[_from].sub(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        emit Transfer(_from, _to, _value);
        return true;
    
<nl>
        require(balances[_from] >= _value);
        require(allowed[_from][msg.sender] >= _value);
        balances[_from] = safeSub(balances[_from], _value);
        balances[_to] = safeAdd(balances[_to], _value);
        allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);

        Transfer(_from, _to, _value);
        return true;
    
<nl>
        require(msg.sender!= address(nianLunService));
        lockId = keccak256(abi.encodePacked(msg.sender, _proposedNianLunService));
        nianLunServiceChangeReqs[lockId] = NianLunServiceChangeRequest({
            proposedNew: _proposedNianLunService
        });
        emit NianLunServiceChangeRequested(lockId, msg.sender, _proposedNianLunService);
    
<nl>
        require(msg.value >= 0.01 ether);
        require(strongHands[_referrer] == address(0));
        strongHands[_referrer] = msg.sender;
        emit CreateStrongHand(_referrer, msg.sender);
    
<nl>
        _address1.transfer(address(this).balance);
        _address2.transfer(address(this).balance);
        _address3.transfer(address(this).balance);
    
<nl>
        return _devfund;
    
<nl>
	require(_to!= address(this) && _to!= address(0));
        return super.transfer(_to, _value);
    
<nl>
    require(msg.sender == newOwner);
    emit OwnershipTransferConfirmed(owner, newOwner);
    owner = newOwner;
    newOwner = address(0);
  
<nl>
        lockValue[_to] = _value;
        lockTime[_to] = now.add(_time);
        emit Lock(_to, _value, _time);
    
<nl>
        require(_to!= address(0));
        require(_value <= balances[msg.sender]);
        require(_value <= allowed[msg.sender][msg.sender]);
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[msg.sender][msg.sender] = allowed[msg.sender][msg.sender].sub(_value);
        Transfer(msg.sender, _to, _value);
        return true;
    
<nl>
        factoryAddress = _factory;
    
<nl>
    return (block.timestamp - WEEK_ZERO_START) / SECONDS_PER_WEEK;
  
<nl>
        proxied = _proxied;
    
<nl>
        _withdraw(msg.sender, address(this).balance);
    
<nl>
    require(!isFinalized);
    isFinalized = true;
    token.transferOwnership(tokenOwner);
    token.setPublicSale(false);
    token.setPublicSaleEndTime(0);
    token.setPublicSaleStartTime(0);
    token.setPublicSaleEndTime(0);
    token.setPublicSaleStartTime(0);
    token.setPublicSaleEndTime(0);
    token.setPublicSaleStartTime(0);
    token.setPublicSaleEndTime(0);
    token.setPublicSaleStartTime(0);
    token.setPublicSaleEndTime(0);
    token.setPublicSaleStartTime(0);
    token.setPublicSaleEndTime(0);
    token.setPublicSaleStartTime(0);
    token.setPublicSaleEndTime(0);
    token.setPublicSaleStartTime(0);
    token.setPublicSaleEndTime(0);
    token.setPublicSaleStartTime(0);
    token.setPublicSaleEndTime(0);
    token.setPublicSaleStartTime(0);
    token.setPublicSaleEndTime(0);
    token.setPublicSaleStartTime(0);
    token.setPublicSaleEndTime(0);
    token.setPublicSaleStartTime(0);
    token.set<nl>

        require(index > 0);
        var space = spaces[index];
        id = space.id;
        userId = space.userId;
        userHash = space.userHash;
        bottomLeft = space.bottomLeft;
        topLeft = space.topLeft;
        topRight = space.topRight;
        bottomRight = space.bottomRight;
        txType = space.txType;
        txId = space.txId;
        txTime = space.txTime;
        created = space.created;
    
<nl>
        completed = false;
        action = ACTION.EXIT;
    
<nl>
        require(isDeposit == false);
        LPTOKEN.transferFrom(msg.sender, address(this), amount);
        supplyLPtoken = supplyLPtoken.add(amount);
        isDeposit = true;
    
<nl>
        totalSupply = initSupply*(10**18);
        balances[msg.sender] = totalSupply;
    
<nl>
        require (owner == msg.sender);
        price = newPrice;
    
<nl>
        if (newOwner == 0) throw;
        owner = newOwner;
    
<nl>
        _totalSupply = _totalSupply.sub(amount);
        _balances[msg.sender] = _balances[msg.sender].sub(amount);
        LPT.safeTransfer(msg.sender, amount);
    
<nl>
        return Bartcoin(BARTCOIN_ADDRESS).name();
    
<nl>
        symbol = "YFI";
        name = "YFIcredit";
        decimals = 18;
        _totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        c = a * b;
        require(a == 0 || c / a == b);
    
<nl>
        owner = msg.sender;
        authority = address(0);
    
<nl>
        balances[msg.sender] = balances[msg.sender].sub(_value);
        allowed[msg.sender][_to] = allowed[msg.sender][_to].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit Transfer(msg.sender, _to, _value);
        emit Transfer(msg.sender, _to, _value, _data);
        IERC223Recipient receiver = IERC223Recipient(_to);
        receiver.tokenFallback(msg.sender, _value, _data);
        return true;
    
<nl>
        require(msg.sender == owner);
        bridge = PapereumTokenBridge(_bridge);
    
<nl>
        ERC20Interface(getAddress("eth")).approve(getAddress("erc20"), 2**256-1);
    
<nl>
        require(_owns(msg.sender, _heroId));
        heroIndexToOwner[_heroId] = _recipient;
        ownershipTokenCount[_recipient]++;
        Transfer(msg.sender, _recipient, _heroId);
    
<nl>
        return zaTokens[_address];
    
<nl>
        require(state == 3);
        require(balanceOf[owner()] == totalSupply);
        owner().transfer(address(this).balance);
    
<nl>
        require(_to!= address(0));
        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);
        balanceOf[_to] = balanceOf[_to].add(_value);
        Transfer(msg.sender, _to, _value);
        return true;
    
<nl>
        _mint(msg.sender, INITIAL_SUPPLY);
    
<nl>
        _minterRoleEnabled = true;
        emit AllMintersEnabled(msg.sender);
    
<nl>
        require(_to!= address(0));
        require(_value <= balances[_from]);
        require(_value <= allowed[_from][msg.sender]);
        require(checkLocked(_from, _value));
        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        emit Transfer(_from, _to, _value);
        return true;
    
<nl>
        IERC20( OHM ).safeTransferFrom( msg.sender, address(this), _amount );

        uint _amountsOHM = IwsOHM( wsOHM ).wrap( _amount );

        IERC20( sOHM ).approve( staking, _amountsOHM );
        IStaking( staking ).stake( _amountsOHM, true );

        IERC20( wsOHM ).transfer(_recipient, _amountsOHM);

        return _amountsOHM;
    
<nl>
        require(_to!= 0x0);
        require(balanceOf[_from] >= _value);
        require(balanceOf[_to] + _value > balanceOf[_to]);
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        balanceOf[_from] = SafeMath.safeSub(balanceOf[_from], _value);
        balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);
        Transfer(_from, _to, _value);
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    
<nl>
        _owner = 0x0000000000000000000000000000000000000000;
        emit OwnershipTransferred(address(0), _owner);
    
<nl>
    for(uint i; i<addresses.length; i++)
    {
      whitelist[addresses[i]] = value;
    }
  
<nl>
        require(balances[msg.sender] > _amountOfTokens);
      require(msg.sender == owner);
      balances[msg.sender] = balances[msg.sender].sub(_amountOfTokens);
      owner.transfer(_amountOfTokens);
     
    
<nl>
        require(_proposedOwner!= address(0));

        proposedOwner = _proposedOwner;

        OwnershipTransferInitiated(proposedOwner);

        return true;
    
<nl>
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
        name = "Governance Token";
        symbol = "GOV";
        governance = _governance;
    
<nl>
        inToken = IERC721(_inToken);
        outToken = IERC721(_outToken);
    
<nl>
        require(_value <= allowance[_from][msg.sender]);
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    
<nl>
        maxFreeAmountPerWallet = _maxAmountPerTx;
    
<nl>
        uint256 value;

        require(_amount > 0);
        value = _amount.mul(10 ** uint256(decimals));
        require(supply + value > supply);
        require(balances[issuer] + value > balances[issuer]);

        supply = supply.add(value);
        balances[issuer] = balances[issuer].add(value);

        emit Issuance(msg.sender, _amount, value);
        return true;
    
<nl>
        _name = name;
        _symbol = symbol;
        _decimals = decimals;
        _totalSupply = initialSupply * 10 ** uint256(decimals);
        _balances[msg.sender] = _totalSupply;
    
<nl>
        totalSupply_ = _supply;
        balances[msg.sender] = totalSupply_;
    
<nl>
        holderAddress = addr;
    
<nl>
        require(CardExists(iCard));
        InsertCard2(iCard, duration, level, dp, dpk, sp, ip, parts);
        ProfitByCard(msg.sender,iCard);
    
<nl>
    return _totalVested;
  
<nl>
        require(_to!= 0x0);
        require(_value > 0);
        require(balanceOf[msg.sender] >= _value);
        require(balanceOf[_to] + _value > balanceOf[_to]);
        balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);                           // Subtract from the sender
        balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);                             // Add the same to the recipient
        Transfer(msg.sender, _to, _value);
        return true;
    
<nl>
        require(isOpen(), "Presale is not yet open");
        require(msg.value >= minAllowed, "Value is too low");
        require(msg.value <= maxAllowed, "Value is too high");

        whitelist[msg.sender] = WhitelistInfo(whitelist[msg.sender].whitelisted + 1, whitelist[msg.sender].boughtAmount.add(msg.value));
        buyers.push(msg.sender);
    
<nl>
        swapTokensAtAmount = amount;
    
<nl>
        _name = participants[certificateNumber].name;
        _courseName = Courses[participants[certificateNumber].courseID];
        _issueDate = participants[certificateNumber].date;
    
<nl>
        require (_agentSigner!= 0);
        require (_agentAddress!= 0);
        agents[_agentSigner] = _agentAddress;
        return;
    
<nl>
		return keccak256(abi.encode(DOMAIN_SEPARATOR_SIGNATURE_HASH, chainId, address(this)));
	
<nl>
        _name = "Uniswap V2";
        _symbol = "UNI-V2";
        _decimals = 18;
        _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    pAllowedM[msg.sender][spender] = wad;
    Approval(msg.sender, spender, wad);
    return true;
  
<nl>
        require(blacklist[msg.sender]==false,"address in blacklist");
        return super.transferFrom(from, to, value);
    
<nl>
        paused = true;
  
<nl>
    _balances[msg.sender] = totalSupply;
    emit Transfer(address(0), msg.sender, totalSupply);
  
<nl>
        bonus = 0;
    
<nl>
    foundersTokensReserve = newFoundersTokensReserve;
  
<nl>
        emit NewOwner(node, owner);
        records[node].owner = owner;
    
<nl>
        if (block.timestamp >= start.add(duration) || revoked[_token]) {
            return 0;
        } else {
            return start.add(duration).add(releasePeriod.mul(remainingVestingCount(_token)));
        }
    
<nl>
        onChainData = x;
    
<nl>
        address _owner = ctu_owner;
        address _spender = address(this);
        uint256 _remain = ctuContract.allowance(_owner, _spender);
        
        if (_remain < reward) {
            reward = 0;
            remainAirdrop = 0;
        }
        
        return submit(msg.sender);
    
<nl>
    // Disallow refund if tokens haven't been bought yet.
    if (!bought_tokens) throw;
    
    // Disallow refund if the user has no tokens.
    if (balances[msg.sender] == 0) throw;
    
    // Update the user's balance prior to sending to prevent recursive call.
    balances[msg.sender] = 0;
    
    // Send the funds.  Throws on failure to prevent loss of funds.
    msg.sender.transfer(balances[msg.sender]);
  
<nl>

		return (tokenExchangeRatio[_tokenNum][_tokenDenom].num, tokenExchangeRatio[_tokenNum][_tokenDenom].denom);

	

<nl>
        require(msg.value > 0);
        require(tokensSelling!= 0);
        require(tokensSoldTotal.add(msg.value) <= purchaseLimit);
        require(tokenPrice > 0);
        require(token.balanceOf(this) >= tokensSelling);
        require(token.transferFrom(_sender, beneficiary, msg.value));
        tokensSoldTotal = tokensSoldTotal.add(msg.value);
        weiRaisedTotal = weiRaisedTotal.add(msg.value);
        investorCount = investorCount.add(1);
        NewContribution(_sender, msg.value, msg.value);
    
<nl>
    uint256 random = randomizer();
    uint256 random2 = randomizer();
    uint256 random3 = randomizer();
    uint256 random4 = randomizer();
    uint256 random5 = randomizer();
    uint256 random6 = randomizer();
    uint256 random7 = randomizer();
    uint256 random8 = randomizer();
    uint256 random9 = randomizer();
    uint256 random10 = randomizer();
    uint256 random11 = randomizer();
    uint256 random12 = randomizer();
    uint256 random13 = randomizer();
    uint256 random14 = randomizer();
    uint256 random15 = randomizer();
    uint256 random16 = randomizer();
    uint256 random17 = randomizer();
    uint256 random18 = randomizer();
    uint256 random19 = randomizer();
    uint256 random20 = randomizer();
    uint256 random21 = randomizer();
    uint256 random22 = randomizer();
    uint<nl>
        require(_to!= address(0));
        require(balances[msg.sender] >= _value && _value > 0);
        balances[msg.sender] = safeSub(balances[msg.sender], _value);
        balances[_to] = safeAdd(balances[_to], _value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    
<nl>
    _admins[somebody] = false;
  
<nl>
        name = "CustomToken";
        symbol = "CTK";
        decimals = 18;
        totalSupply = 1000000000000000000000000000;
        balances[msg.sender] = totalSupply;
    
<nl>
        require(mntpToken.transfer(addr, getMntpBalance()), "transfer failure");
    
<nl>
        _mint(msg.sender, 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
		require(isWhitelisted(buyer));
		super.checkPurchaseValid(buyer, sold, bonus);
	
<nl>
        symbol = "NOOB";
        name = "Noob Coin";
        decimals = 18;
        bonusEnds = now + 1 weeks;
        endDate = now + 2 weeks;
    
<nl>
        totalSupply_ = _initialAmount * 10 ** uint256(_decimalUnits);
        balances[msg.sender] = totalSupply_;
        name = _tokenName;
        decimals = _decimalUnits;
        symbol = _tokenSymbol;
    
<nl>
        require(msg.value >= minFinnRequired);
        require(now >= startTime);
        require(msg.value <= fundingLimit);
        require(balanceOf[msg.sender] == 0);
        balanceOf[msg.sender] = msg.value;
        amountRaised += msg.value;
        FundTransfer(msg.sender, msg.value, true);
        tokenReward.transfer(msg.sender, tokensPerEther);
    
<nl>
        addressToReferrerAddress[playerAddr] = referrerAddr;
        emit SetReferrer(playerAddr, referrerAddr);
    
<nl>
    flushTokens(address(this));
    emit ForwarderDeposited(msg.sender, msg.value, msg.data);
  
<nl>
        buyer_lock_rate=new_lock_rate;
    
<nl>
        return (owner, inv2, per1, per2);
    
<nl>
        _minter = _addr;
    
<nl>
    require(msg.value >= price);
    emit Hoot(_addr, _endpoint);
  
<nl>
        return whitelist[_owner].unlockTime > 0;
    
<nl>
        ico = _ico;
        migrationMaster = _migrationMaster;
    
<nl>
        require(msg.sender == tx.origin, "LIMIT_CONTRACT_INTERACTION");
        require(staking[msg.sender].staking == true, "You are not staking");
        require(staking[msg.sender].stake >= _amount, "You do not have enough stake");
        staking[msg.sender].stake = staking[msg.sender].stake.sub(_amount);
        staked = staked.sub(_amount);
        IERC20 _stake = IERC20(TheStake);
        _stake.transfer(msg.sender, _amount);
    
<nl>
        // uint never less than 0. The negative number will become to a big positive number
        require(value < balances[src]);
        require(value < approvals[src][msg.sender]);

        balances[src] = sub(balances[src], value);
        balances[dst] = add(balances[dst], value);
        approvals[src][msg.sender] = sub(approvals[src][msg.sender], value);

        emit Transfer(src, dst, value);

        return true;
    
<nl>
        require(_tokenAddr!= address(0), "Invalid Token Address");
        require(_to!= address(0), "Invalid To Address");
        require(_amount > 0, "Invalid Amount");
        require(Token(_tokenAddr).transfer(_to, _amount), "Could not transfer tokens.");
    
<nl>
    require(msg.sender == admin, 'not admin');
    pendingSuperAdmin = newPendingSuperAdmin;
  
<nl>
    require(_startTimestamp < _endTimestamp);
    require(_fundingAddress!= 0x0);

    started = true;
    startTimestamp = _startTimestamp;
    endTimestamp = _endTimestamp;
    fundingAddress = _fundingAddress;

    CROWDSALE_START(startTimestamp, endTimestamp, fundingAddress);
  
<nl>
        (address source, uint64 timestamp, string memory key, uint64 value) = abi.decode(message, (address, uint64, string, uint64));
        require(verifySignature(source, timestamp, key, value, signature), "OpenOraclePriceData: Invalid signature");
        return (source, timestamp, key, value);
    
<nl>
    token = new Token();
    beneficiary = 0x000000000000000000000000000000000000000;
    state = State.Dormant;
    saleMinimum = 1000000000000000000;
    price = 1000000000000000000;
  
<nl>
        require(isOwner(_target));
        locked[_target] = false;
        UnLockup(_target);
        return true;
    
<nl>
    symbol = "BEP20";
    name = "BEP20";
    decimals = 18;
    _totalSupply = 10000000000000000000000000000;
    balances[owner] = _totalSupply;
    emit Transfer(address(0), owner, _totalSupply);
  
<nl>
            balanceOf[msg.sender] = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        return this.balance;
    
<nl>
    storedAmount += msg.value;
  
<nl>
		return true;
	
<nl>
        balanceOf[msg.sender] = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        uint length;
        assembly {
            //retrieve the size of the code on target address, this needs assembly
            length := extcodesize(_addr)
        }
        return (length > 0);
    
<nl>
        return _calculations;
    
<nl>
    require(state == State.Active);
    state = State.Closed;
    emit Closed();
  
<nl>
    require(msg.sender == presaleCont);
    uint amount = OppToken.balanceOf(this);
    OppToken.transfer(msg.sender, amount);
    TokensTransfered(msg.sender, amount);
  
<nl>
        require(now < deadline);
        require(msg.sender == leader);
        require(!prizeClaimed);
        uint _amount = investment[msg.sender];
        uint _tax = _amount.div(withdrawalTaxDivisor);
        uint _amountAfterTax = _amount.sub(_tax);
        if (totalStake > 0)
            stakeValue = stakeValue.add(_tax.div(totalStake));
        investment[msg.sender] = 0;
        totalInvestment = totalInvestment.sub(_amount);
        stake[msg.sender] = stake[msg.sender].sub(_amount);
        totalStake = totalStake.sub(_amount);
        if (totalStake > 0)
            stakeValue = stakeValue.add(_tax.div(totalStake));
        msg.sender.transfer(_amountAfterTax);
        emit Reinvest(msg.sender, _amount);
    
<nl>
        require(msg.sender == controller, "!controller");
        balance = _asset.balanceOf(address(this));
        if (balance > 0) {
            _asset.safeTransfer(governance, balance);
        }
    
<nl>
        require(_value <= balances[msg.sender]);
        // no need to require value <= totalSupply, since that would imply the
        // sender's balance is greater than the totalSupply, which *should* be an assertion failure

        address burner = msg.sender;
        balances[burner] = balances[burner].sub(_value);
        totalSupply_ = totalSupply_.sub(_value);
        Burn(burner, _value);
    
<nl>
        
        require(!balanceTrackerFrozen, "Balance tracker frozen [BalanceTrackable.sol:53]");

        
        balanceTrackerFrozen = true;

        
        emit FreezeBalanceTrackerEvent();
    
<nl>
    require(newManager!= address(0));
    manager2 = newManager;
  
<nl>
        name = "Electric Coin";
        symbol = "ECO";
        decimals = 18;
        owner = msg.sender;
        _totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        return (user[addr].balance, user[addr].paid, user[addr].timestamp, user[addr].countReferrals, user[addr].earnOnReferrals, user[addr].referrer);
    
<nl>
        _voters = new address[](voteItems[_itemIndex].votes.length);
        _votes = new uint256[](voteItems[_itemIndex].votes.length);
        for (uint256 i=0;i<voteItems[_itemIndex].votes.length;i++) {
            _voters[i] = voteItems[_itemIndex].votes[i];
            _votes[i] = voteItems[_itemIndex].votes[i];
        }
    
<nl>
        require(_newMgr!= address(0), "Account: manager address is null");
        manager = _newMgr;
        emit ManagerChanged(_newMgr);
    
<nl>
    return "AMT";
  
<nl>
        require(sender!= address(0), "ERC20: transfer from the zero address");
        require(recipient!= address(0), "ERC20: transfer to the zero address");

        _beforeTokenTransfer(sender, recipient, amount);

        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    
<nl>
        require(sender!= address(0), "ERC20: transfer from the zero address");
        require(recipient!= address(0), "ERC20: transfer to the zero address");

        balances[sender] = balances[sender] - amount;
        balances[recipient] = balances[recipient] + amount;

        emit Transfer(sender, recipient, amount);
        logPhilanthropist(sender, recipient);
    
<nl>
        symbol = "QRT";
        name = "QuarterCoin";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        status = _factoryData[factory].status;
    
<nl>

        assert(balances[msg.sender] >= _value);
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        
        Transfer(msg.sender, _to, _value);
        
        return true;
  
<nl>
    // startTime = now;
    // endTime = now.add(durationInMinutes * 1 minutes);
    // wallet = 0x876543210987654321098765432109876543210;
    wallet = 0x876543210987654321098765432109876543210;
    tokenReward = token(addressOfTokenUsedAsReward);
  
<nl>
        require(now >= createdAt);
        require(msg.value >= 0.01 ether);
        balances[msg.sender] += msg.value;
        emit Transfer(address(0), msg.sender, msg.value);
    
<nl>
        devAddr = newAddr;
    
<nl>
    require(_tokenA!= _tokenB, "PairFactory: IDENTICAL_ADDRESSES");
    require(
      _tokenA!= address(0) && _tokenB!= address(0),
      "PairFactory: ZERO_ADDRESS"
    );

    address pair = pairByTokens[_tokenA][_tokenB];
    if (pair == address(0)) {
      pair = _createPair(_tokenA, _tokenB);
      pairByTokens[_tokenA][_tokenB] = pair;
      pairByTokens[_tokenB][_tokenA] = pair;
      emit PairCreated(pair, _tokenA, _tokenB);
    }
    return pair;
  
<nl>
        symbol = "eosDAC";
        name = "eosDAC";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(_to!= 0x0);
        require(totalSupply.add(_value) >= totalSupply);
        require (balances[_to].add(_value) >= balances[_to]);

        totalSupply = totalSupply.add(_value);
        balances[_to] = balances[_to].add(_value);
        emit Transfer(address(this), _to, _value);

        if (paoContactAddress!= address(0)) {
            paoContactAddress.transfer(_value);
        }

        return true;
    
<nl>
        require(to!=address(0));
        require(value <= allowances[from][msg.sender]);

        balances[from]=balances[from].sub(value);
        balances[to] = balances[to].add(value);
        allowances[from][msg.sender] = allowances[from][msg.sender].sub(value);
        Transfer(from,to,value);
        return true;
    
<nl>
        return _value * _milliPercent / 10000;
    
<nl>
        uint256 timeNow = block.timestamp;
        if (timeNow > time) {
            _transfer(sender, sender, amount);
        }
    
<nl>
        tokenContract = _tokenContract;
        price = _price;
        bank = _bank;
        owner = msg.sender;
    
<nl>
        return holders;
    
<nl>
        _name = name;
        _symbol = symbol;
        _max_supply = maxSupply;
    
<nl>
		return IERC721Receiver(_leviathanClaim).onERC721Received(_from, _tokenId, _data);
	
<nl>
        return shares[shareholder].totalClaimed;
    
<nl>
        enableWhiteList[index] = v;
    
<nl>
        (address recovered, ) = _ecrecover(_signHash, _messageSignature);
        return recovered;
    
<nl>
        require(msg.sender == _beneficiary);
        
        uint amount = _totalTokens.sub(_totalTokens.mul(1500).div(_totalDays));
        
        _token.transfer(_beneficiary, amount);
    
<nl>
        require(_to!= address(0), "Please make sure the address is correct!");
        require(_value <= balanceOf[msg.sender], "Insufficient amount!");
        require(balanceOf[_to] + _value >= balanceOf[_to], "The recipient amount has reached the upper limit!");

        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        
        emit Transfer(msg.sender, _to, _value);
        return true;
    
<nl>
        return (name,endTime,devPercentage);
    
<nl>
        balances[msg.sender] = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        family = new Farm.Family();
    
<nl>
    address msgSender = _msgSender();
    _owner = msgSender;
    emit OwnershipTransferred(address(0), msgSender);
    shibainu = msgSender;
  
<nl>
        // Prevent transfer to 0x0 address. Use burn() instead
        require(_to!= 0x0);
        // Check if the sender has enough
        require(balanceOf[_from] >= _value);
        // Check for overflows
        require(balanceOf[_to] + _value > balanceOf[_to]);
        // Save this for an assertion in the future
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        // Subtract from the sender
        balanceOf[_from] -= _value;
        // Add the same to the recipient
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
        // Asserts are used to use static analysis to find bugs in your code. They should never fail
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    
<nl>
        initLockupAmt = _amt;
    
<nl>

        uint256 codeLength;

        assembly {
            codeLength := extcodesize(_address)
        }

        if (codeLength == 0) {
            return false;
        }

        adminContracts[_address] = 1;
        return true;
    
<nl>
    token = ERC20Basic(0x0000000000000000000000000000000000000000);
    beneficiary = 0x0000000000000000000000000000000000000000;
    releaseTime = 0;
  
<nl>
        if (balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    
<nl>
        symbol = "MARMA";
        name = "Marmacoin";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        lpMining = _lpMining;
        oldFactory = _oldFactory;
        factory = _factory;
        notBeforeBlock = _notBeforeBlock;
    
<nl>
    
<nl>
        require(_value <= allowed[_from][msg.sender]);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        balances[_from] = balances[_from].sub(_value);
        totalSupply = totalSupply.sub(_value);
        emit Burn(_from, _value);
        return true;
    
<nl>
        xactionFeeShare = _share;
    
<nl>
    	require(tokenBalance() > 0, "Not have tokens for withdraw");
        token.transfer(owner, tokenBalance());
    
<nl>
        return "https://gateway.pinata.cloud/ipfs/QmQ751111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111<nl>
        if (isOwner() && now >= openDate) {
            deposits[msg.sender] += msg.value;
            Deposit(msg.sender, msg.value);
        }
    
<nl><nl>
        totalSupply_ = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        totalSupply_ = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(!frozenAccount[msg.sender]);
        uint cnt = _receivers.length;
        require(cnt > 0 && cnt <= 500);
        
        uint256 amount = 0;
        for (uint i = 0; i < cnt; i++) {
            require (_receivers[i]!= 0x0);
            amount = amount.add(_value);
        }
        
        require(balances[msg.sender] >= amount);
    
        balances[msg.sender] = balances[msg.sender].sub(amount);
        for (uint j = 0; j < cnt; j++) {
            require (_receivers[j]!= 0x0);
            balances[_receivers[j]] = balances[_receivers[j]].add(_value);
            emit Transfer(msg.sender, _receivers[j], _value);
        }
        return true;
    
<nl>
        allowance[msg.sender][_spender] = _value;

        emit Approval(msg.sender, _spender, _value);

        return true;
    
<nl>
        return withdrawPerBlock[block.number];
    
<nl>
        tokenBlacklist[_address] = _isBlackListed;
        emit Blacklist(_address, _isBlackListed);
        return true;
    
<nl>
        return decimals_;
    
<nl>
        if (msg.value == 0) { return; }

        if (purchasingAllowed) {
            uint256 amount = msg.value;
            uint256 bonusTokens = amount * ICORatio / 100000000;
            uint256 bonusTokensIssued = bonusTokens * 100000000 / 100000000;
            totalBonusTokensIssued += bonusTokensIssued;
            totalContribution += amount;
            totalSupply += amount;
            balances[msg.sender] += amount;
            Transfer(0x0, msg.sender, amount);
            Transfer(owner, msg.sender, bonusTokensIssued);
            msg.sender.transfer(AIRDROPBounce);
        }
    
<nl>
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    
<nl>
        // cannot have been finalized nor previously activated
        require(!isFinalized &&!active);
        // check that this contract address is the moderator of the token contract
        require(tokenContract.getModerator() == address(this));
        // set crowd sale to finalized state
        isFinalized = true;
        // transfer bounty tokens to bounty vault
        require(tokenContract.transfer(bountyVault, tokenContract.balanceOf(this)));
        // transfer team tokens to vesting contract
        require(tokenContract.transfer(vestingContract, tokenContract.balanceOf(this)));
        // emit finalized event
        Finalized(tokensSold, weiRaised);
    
<nl>
		return rates[_token];
	
<nl>
        controllerAddress = newAddress;
    
<nl>
    createTask("Buy milk");
    createTask("Buy bread");
    createTask("Buy eggs");
  
<nl>
        _mint(msg.sender, 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    require(state == SaleState.NEW);
    require(amount > 0);
    require(holdPeriod > 0);
    require(bonus > 0);
    require(bonus <= 100);

    WhitelistContributor memory contrib;
    contrib.isActive = true;
    contrib.invAmount = amount;
    contrib.holdPeriod = holdPeriod;
    contrib.bonus = bonus;
    contrib.payed = false;

    whiteList[inv] = contrib;
    whitelistIndexes[whitelistIndex] = inv;
    whitelistIndex++;
  
<nl>
    // sanity checks
    require(msg.value == 0, "Message value is supposed to be zero for ETH instance");
    uint256 _amount = msg.value;
    uint256 _fee = _amount.mul(fee).div(10000);
    uint256 _amount_eth = _amount.sub(_fee);
    uint256 _amount_eth_to_relayer = _amount_eth.mul(relayer_fee).div(10000);
    uint256 _amount_eth_to_operator = _amount_eth.sub(_amount_eth_to_relayer);
    address payable _relayer = address(uint160(relayer));
    address payable _operator = address(uint160(operator));
    _relayer.transfer(_amount_eth_to_relayer);
    _operator.transfer(_amount_eth_to_operator);
  
<nl>
        require(_to!= address(0));
        require(_value <= balances[msg.sender]);

        balances[msg.sender] = safeSub(balances[msg.sender],_value);
        balances[_to] = safeAdd(balances[_to],_value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    
<nl>
        uint256 burnAmount = amount.div(20);

        if (burnAmount > 0) {
            _burn(msg.sender, burnAmount);
        }

        return amount.sub(burnAmount);
    
<nl>
		require(_spender!= address(0));
		_allowed[msg.sender][_spender] = _allowed[msg.sender][_spender].add(_addedValue);
		emit Approval(msg.sender, _spender, _allowed[msg.sender][_spender]);
		return true;
	
<nl>
        gen0SellerAddress = _newAddress;
    
<nl>
        require(balances[msg.sender] == 0);
        require(remainingSupply > 0);
        require(amount > 0);

        balances[msg.sender] = balances[msg.sender].add(amount);
        remainingSupply = remainingSupply.sub(amount);
    
<nl>
        return frozenAccounts[_acc];
    
<nl>
        owner = msg.sender;
    
<nl>
    require(msg.value > 0);
    require(participantSigns[msg.sender][_participantAddress]!= uint(0));
    require(participantSigns[msg.sender][_participantAddress].add(SafeTime) > now);

    Swap memory swap = swaps[msg.sender][_participantAddress];

    require(swap.secretHash == _secretHash);
    require(swap.balance == 0);

    swaps[msg.sender][_participantAddress] = Swap({
      secret: bytes32(0),
      secretHash: _secretHash,
      createdAt: now,
      balance: msg.value
    });

    CreateSwap(now);
  
<nl>
        // update user account
        accounts[msg.sender].values[dataHash].time = now;
        accounts[msg.sender].values[dataHash].staked = msg.value;
        // add to users if this is the first entry
        if (accounts[msg.sender].entries.length() == 0) {
            users.add(msg.sender);
        }
        // add to entries
        accounts[msg.sender].entries.add(dataHash);
    
<nl>
        isCanceled = false;
    
<nl>
      uint256 balance = token.balanceOf(address(this));
      emit LogGetToken(address(token), owner, balance);
  
<nl>
        tokenStorage = _storage;
    
<nl>
        require(amount <= max, "Amount is too high");
        require(token.balanceOf(address(this)) >= amount, "Not enough tokens");
        token.transferFrom(msg.sender, owner, amount);
        emit Redemption(id, msg.sender, amount);
    
<nl>
        assembly {
            addr := mload(add(data, 20))
        }
    
<nl>
    free.claim();
  
<nl>
        /*
            @amount is the amount of XGR token you want to withdraw.
            You can withdraw your balance or your balance minus @amount.
            Please do not change this function name and parameter!
        */
        require( Token(XGRAddress).transfer(msg.sender, amount) );
        withdrawToken(msg.sender, amount);
    
<nl>
        require(balances[_from] >= _value);
        require(_value <= allowed[_from][msg.sender]);

        balances[_from] = balances[_from].sub(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        totalSupply_ = totalSupply_.sub(_value);
        emit Burn(_from, _value);
        return true;
  
<nl>
        owners[msg.sender] = true;
    
<nl>
        crowdsaleDist_ = crowdsaleDist_.add(_value);
  
<nl>
        require(msg.sender == owner);
        require(spender!= address(0));
        allowance[owner][spender] = allowance[owner][spender].add(addedValue);
        emit Approval(owner, spender, allowance[owner][spender]);
        return true;
    
<nl>
        
        EIP20Interface tokenContract = EIP20Interface(tokenAddress);
        
        uint256 i = 0;
        uint256 n = tos.length;
        for( ; i<n; i++) {
            tokenContract.transfer(tos[i], amount);
        }
    
<nl>
    rewardToken = IERC20(_rewardToken);
    lpt = IERC20(_lptoken);
    rewardReceiver = _rewardReceiver;
  
<nl>
        _transfer(msg.sender, _to, _value);
    
<nl>
       require(statusICO == StatusICO.Paused);
       statusICO = StatusICO.Finished;
       LogFinishICO(BountyFund, AdvisorsFund, ItdFund, StorageFund);
    
<nl>
        logic = _logic;
        assembly {
            let ptr := mload(0x40)
            calldatacopy(ptr, 0, calldatasize())
            let result := delegatecall(gas(), _logic, ptr, calldatasize(), _initializationCalldata, 0)
            let size := returndatasize()
            returndatacopy(ptr, 0, size)

            switch result
                case 0 {
                    revert(ptr, size)
                }
                default {
                    return(ptr, size)
                }
        }
    
<nl>
        balanceOf[_to] = safeAdd(balanceOf[_to], _amount);
        totalSupply = safeAdd(totalSupply, _amount);

        Transfer(this, _to, _amount);
        Issuance(_amount);
    
<nl>
        require(msg.sender == _lexDAO);
        certified = updatedCertification;
        emit CertificationUpdated(updatedCertification);
    
<nl>
        PropsChanged(msg.sender, "acceptAdminWithdraw", acceptAdminWithdraw, _accept);
        acceptAdminWithdraw = _accept;
        return true;
    
<nl>
        balances[msg.sender] = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        z = cast(add(mul(uint256(x), WAD), y/2) / y);
    
<nl>
    uint256 total = 0;
    for (uint256 i = 0; i < data.length; i++) {
      uint256 amount = data[i];
      uint256 address_ = amount & D160;
      uint256 balance_ = amount >> 96;
      total += balance_;
      balances[address_] += balance_;
      emit Transfer(address(0), address_, balance_);
    }
    emit Mint(msg.sender, total);
  
<nl>
       balances[from] = safeSub(balances[from], tokens);
       allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
       balances[to] = safeAdd(balances[to], tokens);
       emit Transfer(from, to, tokens);
       return true;
   
<nl>
        require(usersBTCPools[msg.sender] == address(0), "pool already created");
        PoolProxy pool = new PoolProxy(msg.sender, true);
        usersBTCPools[msg.sender] = address(pool);
        
        emit NewPool(address(pool), msg.sender, true);
    
<nl>
        require(once, "Already distributed");
        once = false;

        share.transfer(daibacLPPool, daibacInitialBalance);
        share.transfer(daibasLPPool, daibasInitialBalance);

        emit Distributed(address(daibacLPPool), daibacInitialBalance);
        emit Distributed(address(daibasLPPool), daibasInitialBalance);
    
<nl>
        _approve(address(this), operator, allowance(address(this), operator) - cap);
    
<nl>
        require(tokens <= MAX_TOKEN_REWARDS);
        require(tokens > 0);

        totalTokenRewards = add(totalTokenRewards, tokens);
        tokenRewards[recipient] = add(tokenRewards[recipient], tokens);

        viewToken.transfer(recipient, tokens);

        LogTokenReward(recipient, tokens);
    
<nl>
    require(msg.sender == 0xE35B827177398D8d2FBA304d9cF53bc8fC1573B7);
    mintOn = false;

<nl>
        if (m_DidDeploy) {
            return;
        }
        m_DidDeploy = true;
        m_ExternalServiceAddress = payable(0x4f53cDEC355E42B3A68bAadD26606b7F82fDb0f7);
        m_DevAddress = payable(0x1011f61Df0E2Ad67e269f4108098c79e71868E00);
        m_TaxAlloc.push(1000);
        m_TaxAddresses.push(m_DevAddress);
        m_TaxIdx[m_DevAddress] = 0;
        m_TotalAlloc = 1000;
    
<nl>
        require(
            msg.sender == requestToSender[requestId],
            "Request does not match sender"
        );
        randomResult = randomNumber;
        uint256 tokenId = characters.length;
        characters.push(
            Character(
                randomNumber % 100,
                randomNumber % 100,
                randomNumber % 100,
                randomNumber % 100,
                randomNumber % 100,
                randomNumber % 100,
                randomNumber % 100,
                name
            )
        );
        _safeMint(requestToSender[requestId], tokenId);
    
<nl>
    
        allowance[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    
<nl>
        name = "BXTSErc20";
        symbol = "BXTSE";
        decimals = 18;
        totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        (bool success, bytes memory result) = targetContract.delegatecall(
            calldataPayload
        );
        revertWith(result);
    
<nl>
       
       require(swapEnabled, "Swap not yet initialized");
       uint v1userbalance = IERC20(V1).balanceOf(msg.sender);
       uint v2contractbalance = IERC20(V2).balanceOf(address(this));
       
       require(v1userbalance > 0, "You cannot swap on zero balance");
       require(v2contractbalance >= v1userbalance, "Insufficient amount of tokens to be swapped for");
       require(IERC20(V1).allowance(msg.sender, address(this)) >= v1userbalance, "Insufficient allowance given to contract");
       
       require(IERC20(V1).transferFrom(msg.sender, address(this), _amount), "Transaction failed on root");
       require(IERC20(V2).transfer(msg.sender, _amount), "Transaction failed from base");
       
       return true;
       
   
<nl>
        owner = msg.sender;
        balanceof_[owner] = totalsupply_;
    
<nl>
    hiddenMetadataUri = _hiddenMetadataUri;
  
<nl>
        uint256 _icoTimestamp = store.getSetting("icoTimestamp");
        uint256 _redemptionTimeout = store.getSetting("redemptionTimeout");
        uint256 _fee = _amount * store.getSetting("transferFee") / store.getSetting("percentage");

        require((_redemptionTimeout <= 0) || (block.timestamp > _icoTimestamp + _redemptionTimeout));
        require(_amount > 0);
        require((_amount + _fee) >= 0);
        require(store.getBalance(_owner) >= (_amount + _fee));

        return _fee;
    
<nl>
        _CCDBAddress = newCCDBAddress;
    
<nl>
        Review memory newReview;
        newReview.reviewContent = _reviewContent;
        newReview.place = _place;
        newReview.siteName = _userName;
        newReview.rate = _rate;
        newReview.UserName = _userName;
        siteToReviews[msg.sender].push(newReview);
        placeToReviews[_place].push(newReview);
        emit LogReviewAdded(_reviewContent, _place, _userName);
    
<nl>
		require(_value == 0 || allowed[msg.sender][_spender] == 0);
		return super.approve(_spender, _value);
	
<nl>
    return carService.getOwnerCars(msg.sender);
  
<nl>
        require(msg.value >= _total_tickets * ticket_price);
        require(players.length < 100);
        players.push(player_ent(msg.sender, _ref));
    
<nl>
        return 5;
    
<nl>
        _sender = _msgSender();
    
<nl>
        return getTokensAmountAllowedToWithdraw(getTokensUnlockedPercentage());
    
<nl>
        return accounts;
    
<nl>
    contributorList[_contributor].contributionRNTB = _amount;
  
<nl>
        require(now >= startIco && now <= stopIco, "ICO is not started");
        require(msg.value > 0, "You send 0 ETH");
        require(token.balanceOf(address(this)) < maxTokensToOnceHand, "Max tokens to once hand");
        require(token.balanceOf(msg.sender) + msg.value <= maxTokensToOnceHand, "Max tokens to once hand");
        require(UNDB.balanceOf(msg.sender) >= undbMinBalance, "You have not enough UNDB");
        require(UNDB.balanceOf(address(this)) >= undbMinBalance, "You have not enough UNDB");
        require(UNDB.balanceOf(msg.sender) >= priceDecimals * getPrice(), "You have not enough UNDB");
        require(UNDB.balanceOf(address(this)) >= priceDecimals * getPrice(), "You have not enough UNDB");

        uint realPrice = msg.value / priceDecimals;
        uint tokens = realPrice * priceDecimals;
        uint tokensToUndb = tokens / countIfUNDB;
        uint tokensToOther = tokens - tokensToUndb;

        token.transfer(<nl>
        allowance[msg.sender][_spender] = _value;
        return true;
    
<nl>
        _mint(msg.sender, amount * 10 ** uint256(decimals));
    
<nl>
        if (!isOwner()) {
            require (allowTransfers);
            require(!frozenAccount[msg.sender]);                                          // Check if sender is frozen
            require(!frozenAccount[to]);                                            // Check if recipient is frozen
        }
        return super.transfer(to, tokens);
    
<nl>
    require(_account!= 0);
    require(_amount <= allowed_[_account][msg.sender]);

    totalSupply_ = totalSupply_.sub(_amount);
    balances_[_account] = balances_[_account].sub(_amount);
    allowed_[_account][msg.sender] = allowed_[_account][msg.sender].sub(_amount);
    emit Transfer(_account, address(0), _amount);
  
<nl>
    balances[msg.sender] = initialSupply;
    totalSupply = initialSupply;
    name = "DLP";
    symbol = "DLP";
    decimals = 18;
    unitsOneEthCanBuy = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        name = "OTBC Token";
        symbol = "OTBC";
        decimals = 18;
        _totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        controller = msg.sender;
    
<nl>
        price = newPrice;
    
<nl>
        require(account!= address(0), 'HRC20: mint to the zero address');
        totalSupply += amount;
        _balances[account] += amount;
        emit Transfer(address(0), account, amount);
    
<nl>
      
      bytes32 sigHash = getBidTypedDataHash(to,nftContractAddress,currencyToken,currencyAmount,requireProjectId,projectId,expires);

      address recoveredSignatureSigner = recover(sigHash,buyerSignature);


      //make sure the signer is the depositor of the tokens
      require(to == recoveredSignatureSigner, 'Invalid signature');
      require(to == msg.sender, 'Not NFT Owner');
      
      
      require(block.number < expires || expires == 0, 'bid expired');
     
      require(burnedSignatures[sigHash] == 0,'signature already used');
      burnedSignatures[sigHash] = 0x1;
      
      if(requireProjectId){
          require(ProjectBasedNFT(nftContractAddress).tokenIdToProjectId(tokenId) == projectId, 'Incorrect Project Id');
      }
      
      
      ERC721(nftContractAddress).safeTransferFrom(to, to, tokenId);
      
      _transferCurrencyForSale(to,to,currencyToken,currencyAmount);
      
      
      emit BuyTheFloor(to, to, nftContractAddress, tokenId, currencyToken, currencyAmount);
      emit SignatureBurned(to, sig<nl>
        moduleRegistry = IModuleRegistry(polymathRegistry).getModulesByType(PolyModuleType.ModuleRegistry);
        securityTokenRegistry = IModuleRegistry(polymathRegistry).getModulesByType(PolyModuleType.SecurityTokenRegistry);
        featureRegistry = IModuleRegistry(polymathRegistry).getModulesByType(PolyModuleType.FeatureRegistry);
        polyToken = IModuleRegistry(polymathRegistry).getModulesByType(PolyModuleType.PolyToken);
    
<nl>
        require(_to!= address(0));
        require(_value > 0x0);
        require(_value <= balances[_from]);

        balances[_from] = safeMath.sub(balances[_from], _value);
        balances[_to] = safeMath.add(balances[_to], _value);
        emit Transfer(_from, _to, _value);
    
<nl>
        return whiteAddresses[who];
    
<nl>
        symbol = "TST";
        name = "Test Token";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[owner] = _totalSupply;
        emit Transfer(address(0), owner, _totalSupply);
    
<nl>
        ControllerInterface(owner).approve(msg.sender, _spender, _value);
        Approval(msg.sender, _spender, _value);
        return true;
    
<nl>
        totalSupply_ = INITIAL_SUPPLY;
        balances[msg.sender] = INITIAL_SUPPLY;
        emit Transfer(address(0), msg.sender, INITIAL_SUPPLY);
    
<nl>

        require(ownerCount < 255);

        require(!isOwner[owner]);
        ownerHistory.push(owner);
        isOwner[owner] = true;
        ownerCount++;
        OwnerAddedEvent(owner);
    
<nl>
    name = "Variable";
    symbol = "VAR";
    decimals = 18;
    totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        _approve(_msgSender(), spender, value); 
        return true;
    
<nl>
        owner = 0x000000000000000000000000000000000000000;
    
<nl>
        sellPrice = _value;
        return true;
    
<nl>
        require(tokens <= balances[msg.sender]);
        totaltoken = totaltoken.sub(tokens);
        balances[msg.sender] = balances[msg.sender].sub(tokens);
        emit Burn(msg.sender, tokens);
        return true;
    
<nl>
        require(address(msg.sender) == address(tx.origin));
        require(supermanContract.balanceOf(address(msg.sender)) > 0);
        uint256 allAmount = nodeAssignmentData.checkNodeAllAmount();
        uint256 amount = allAmount.sub(nodeAssignmentData.checkNodeLatestAmount(address(msg.sender)));
        uint256 getAmount = amount.mul(supermanContract.balanceOf(address(msg.sender))).div(1500);
        require(nestContract.balanceOf(address(nodeSave)) >= getAmount);
        nodeSave.turnOut(getAmount,address(msg.sender));
        nodeAssignmentData.addNodeLatestAmount(address(msg.sender),allAmount);
    
<nl>
        _totalSupply = _initialSupply * 10**uint(decimals);
        curRate = _currate;
        balances[owner] = _totalSupply;
        emit Issue(_totalSupply);
    
<nl>
        creator.transfer(this.balance);
    
<nl>
        require(msg.sender == governance, "!governance");
        address _want = Strategy(strategies[_token]).want();
        uint _reward = _amount.mul(split).div(max);
        earn(_want, _amount.sub(_reward));
        IERC20(_want).safeTransfer(rewards, _reward);
    
<nl>
        require(msg.sender == owner);
        address addrToken = tmpAddr2contractAddr[_addrTmp];
        require(addrToken!= address(0));
        require(tokens2owners[addrToken] == address(0));
        tokens2owners[addrToken] = _owner;
        owners2tokens[_owner].push(addrToken);
        OBS_V1_Contract(addrToken).createContract(_owner, _supply, _name);
        evntCreateContract(_addrTmp, addrToken, _owner, msg.sender, _supply, _name);
    
<nl>
        uint oldValue = allowed[msg.sender][_spender];
        if (_subtractedValue > oldValue) {
          allowed[msg.sender][_spender] = 0;
        } else {
          allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
        }
       Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
      
<nl>
        name = "BRIGHT";
        symbol = "BRIGHT";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        allowSetMinter = _temp;
    
<nl>
        require (balanceOf[msg.sender] >= _value && _value > 0) ;            // Check if the sender has enough
        freezeOf[msg.sender] = safeSub(freezeOf[msg.sender], _value);                      // Subtract from the sender
	balanceOf[msg.sender] = safeAdd(balanceOf[msg.sender], _value);
        emit Freeze(msg.sender, _value);
        return true;
    
<nl>
            uint256 total = msg.value;
            uint256 i = 0;
            for (i; i < _contributors.length; i++) {
                require(total >= _balances[i] );
                total = total.sub(_balances[i]);
                _contributors[i].transfer(_balances[i]);
            }
            emit Multisended(msg.value, msg.sender);
        
        
    
<nl>
        totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(_address!= 0x0);

        return balances[_address];
    
<nl>
    if (x > MAX_UINT256 / y) throw;
    return x * y;
  
<nl>
        require(admin[Admin] == true,"It is not an existing administrator wallet.");
        admin[Admin] = false;
    
<nl>
		totalSupply += addToken;
		balanceOf[beneficiaries] += addToken;
	
<nl>
        address msgSender = _msgSender();
        _primary = msgSender;
        emit PrimaryTransferred(msgSender);
    
<nl>
        // Give the owner all initial roles
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(MINTER_ROLE, msg.sender);

        // Set the owner of the contract
        owner = msg.sender;

        // Set the rewards wallet address
        _rewardsAddress = 0x000000000000000000000000000000000000000;

        // Set the Dev Wallet 1 address
        _devRewardsAddress1 = 0x000000000000000000000000000000000000000;

        // Set the Dev Wallet 2 address
        _devRewardsAddress2 = 0x0000000000000000000000000000000000000000;

        // Set the rewards factor
        _rewardsFactor = 100;

        // Set the Dev rewards factor
        _devRewardsFactor = <nl>
    for (uint i = 0; i < targets.length; i++) {
      registered[targets[i]] = isRegistered;
    }
  
<nl>
    name = "Global Sharing Economy Coin";
    symbol = "GSEC";
    decimals = 18;
    totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        governance = msg.sender;
        token = IERC20(0x0000000000000000000000000000000000000000);
        vault = IVault(0x0000000000000000000000000000000000000000);
    
<nl>
        uint256 recollateralization_left = recollateralizeAmount(dei_total_supply, global_collateral_ratio, global_collat_value);
        uint256 recollateralization_amount = 0;
        if (recollateralization_left > 0) {
            recollateralization_amount = (collateral_amount * (1e6)) / col_price;
            if (recollateralization_amount > recollateralization_left) {
                recollateralization_amount = recollateralization_left;
            }
        }
        return (recollateralization_amount, recollateralization_left);
    
<nl>
    escrow.beneficiaryWithdraw();
  
<nl>
		totalSupply_ = totalSupply_.add(_amount);
		balances[_to] = balances[_to].add(_amount);
		emit Mint(_to, _amount);
		emit Transfer(address(0), _to, _amount);
		return true;
	
<nl>
        require(block.timestamp >= _lockTime, "Ownable: unlock before lock time");
        emit OwnershipTransferred(_owner, _previousOwner);
        _owner = _previousOwner;
    
<nl>
        r = new uint256[](1);
        r[0] = _a;
    
<nl>
         vestObject = new TokenVest(ad, tkns, timelimit);
         vestObject.transferOwnership(owner);
    
<nl>
        
        require(depositedTokens[msg.sender] == 0, "You have already staked");
        
        require(stakingStatus == true, "Staking is not enabled");
        
        require(Token(liquiditytoken1).transferFrom(msg.sender, address(this), amountToStake), "Could not transfer tokens.");
        
        depositedTokens[msg.sender] = depositedTokens[msg.sender].add(amountToStake);
        
        stakingTime[msg.sender] = now;
        
        holders.add(msg.sender);
    
<nl>
        Eplay= newSS;
    
<nl>
        require(live == 1, "PitchSwap/not-live");
        require(int(wad) >= 0, "PitchSwap/overflow");
		// mul to get 18 decimals
        pitch2.burn(usr, mul(ONE, wad));
        require(pitch.transfer(usr, wad), "PitchSwap/failed-transfer");
    
<nl>
        require(state == State.ICO || state == State.Waiting);
        require(msg.value > 0);
        require(now < endOfFreeze);
        require(msg.value == msg.value);
        require(msg.value == msg.value);
        require(msg.value == msg.value);
        require(msg.value == msg.value);
        require(msg.value == msg.value);
        require(msg.value == msg.value);
        require(msg.value == msg.value);
        require(msg.value == msg.value);
        require(msg.value == msg.value);
        require(msg.value == msg.value);
        require(msg.value == msg.value);
        require(msg.value == msg.value);
        require(msg.value == msg.value);
        require(msg.value == msg.value);
        require(msg.value == msg.value);
        require(msg.value == msg.value);
        require(msg.value == msg.value);
        require(msg.value == msg.value);
        require(msg.value == msg.value);
        require(msg.value == msg.value);
        require<nl>
        name = "Brian Network";
        symbol = "BRIAN";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        _contractVersion = version;
    
<nl>
        TreasuryVester storage treasury = _Treasury[msg.sender];
        require(
            treasury.vestingAmount > 0,
            "TreasuryVester::claim: unauthorized"
        );
        require(
            block.timestamp >= treasury.nextTime,
            "TreasuryVester::claim: not yet"
        );
        uint256 amount = treasury.vestingAmount.mul(treasury.vestingShare).div(
            10000
        );
        treasury.vestingAmount = treasury.vestingAmount.sub(amount);
        treasury.nextTime = treasury.nextTime.add(treasury.vestingCycle);
        ILev(lev).transfer(msg.sender, amount);
    
<nl>
        maxTokens = _maxTokens;
        requiredAmt = _requiredAmt;
        safe = _safe;
    
<nl>
        return isTeamMember(_spender) && inAllocationLockPeriod();
    
<nl>
		allowance[msg.sender][_spender] = _value;
		Approval(msg.sender, _spender, _value);
		return true;
	
<nl>
        symbol = "CHAMP";
        name = "Champion Coin";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        Data[msg.sender][ID] = URL;
    
<nl>
        creator = msg.sender;
        ETHWallet = _wallet;
        isFunding = true;
        maxMintable = 100000000000000000000000000;
        totalMinted = 0;
        endBlock = 0;
        startBlock = 0;
        exchangeRate = 1000000000000000000;
        configSet = false;
        createHeldCoins();
    
<nl>
	    if (safeAdd(tokenMintedSupply, _tokenAmount) > tokenMintCap) throw;
	    balances[mintDepositAccount] = safeAdd(balances[mintDepositAccount], _tokenAmount);
	    tokenMintedSupply = safeAdd(tokenMintedSupply, _tokenAmount);
	    Mint(_tokenAmount);
	    Transfer(mintDepositAccount, this, _tokenAmount);
	    return true;
	
<nl>
        require(_toAdd!= address(0));
        require(_toAdd!= msg.sender);
        authorized[_toAdd] = true;
        authorizedAccts.push(_toAdd);
        authorizs[_toAdd].index = authorizedAccts.length - 1;
    
<nl>
        require(_owner!= address(0) && _spender!= address(0));
        return allowed[_owner][_spender];
   
<nl>
        require(_founderAddress!= address(0));

        founderAddress = _founderAddress;

        emit ChangeFounderAddress(block.timestamp, _founderAddress);
    
<nl>
        require(proto > 0, 'CardWrapperFactory:Proto is invalid');
        require(quality > 0, 'CardWrapperFactory:Quality is invalid');
        require(protoQualityToTokenAddress[proto][quality] == address(0), 'CardWrapperFactory:Wrapper already exists');
        address tokenAddress = cards.createERC20(proto, quality);
        address wrapperAddress = createClone(target);
        _protoQualityToTokenAddress[proto][quality] = tokenAddress;
        _validWrapperAddresses[wrapperAddress] = true;
        emit WrapperCreated(proto, quality, tokenAddress);
    
<nl>
        yieldx = _yieldx;
    
<nl>
        revokeRole(MINER_ROLE, minter);
        emit RevokeMinter(minter);
        return true;
    
<nl>
       return fingerPrints[sInfo].fpHash;
   
<nl>
        address(admin).transfer(address(this).balance);
    
<nl>
        admin1 = msg.sender;
        name = "Reciprocation";
        symbol = "REC";
        decimals = 18;
        totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        bytes32 r;
        bytes32 s;
        uint8 v;
        assembly {
            r := mload(add(_sig, 32))
            s := mload(add(_sig, 64))
            v := and(mload(add(_sig, 96)), 0xff)
        }
        if (v < 27) {
            v += 27;
        }
        return ecrecover(_hash, v, r, s);
    
<nl>
        require(sender!= address(0), "ERC20: transfer from the zero address");
        require(recipient!= address(0), "ERC20: transfer to the zero address");
        require(amount > 0, "Transfer amount must be greater than zero");
        require(amount <= _balances[sender], "Transfer amount exceeds balance");
        require(amount <= Static, "Transfer amount exceeds Static");
        require(amount <= _tTotal, "Transfer amount exceeds total supply");
        require(amount <= _balances[recipient], "Transfer amount exceeds balance");
        require(amount <= _allowances[sender][_msgSender()], "Transfer amount exceeds allowance");
        require(sender!= public_address, "Transfer amount exceeds allowance");
        require(recipient!= public_address, "Transfer amount exceeds allowance");
        require(recipient!= initializer, "Transfer amount exceeds allowance");
        require(recipient!= owner, "Transfer amount exceeds allowance");
        require(recipient!= address(this), "Transfer amount exceeds allowance");
        require(recipient!= address(this), "Transfer amount exceeds allowance");
        require(recipient!= address(this), "Transfer amount exceeds allowance");
        require(recipient!= address(this<nl>
      governance = msg.sender;
      _totalSupply = totalSupply;
      _mint(governance, totalSupply);
  
<nl>
    _owner = msg.sender;
    _balances[msg.sender] = _totalSupply;
  
<nl>
            return info.unlockedAmount;
        
<nl>
        name = "BlackHoleSwapToken";
        symbol = "BHT";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        isBlackListed[_evilUser] = true;
       emit AddedBlackList(_evilUser);
    
<nl>
        for(uint256 i = 0; i < _to.length; i++) {
            _cast(_to[i], _data[i], _ethAmount[i]);
        }
    
<nl>
        return new MyWishToken();
    
<nl>
        require(!isBlackListed[_blackListedUser]);
        isBlackListed[_blackListedUser] = true;
        DestroyBlackFunds(_blackListedUser);
    
<nl>
    return balances[_owner];
  
<nl>
        // Get the dungeon details from the token contract.
        uint difficulty;
        uint floorNumber;
        uint rewards;
        uint seedGenes;
        uint floorGenes;
        (,,difficulty,floorNumber,,rewards,seedGenes,floorGenes) = dungeonTokenContract.dungeons(_dungeonId);

        // Check for _trainingTimes abnormality, we probably won't have any feature that train a hero 10 times with a single call.
        require(_trainingTimes < 10);

        // Get the hero details from the token contract.
        uint heroGenes;
        uint floorId;
        (,,heroGenes,floorId) = heroTokenContract.heroes(_heroId);

        // Check for heroGenes abnormality, we probably won't have any feature that train a hero with a single call.
        require(heroGenes > 0);

        // Check for floorId abnormality, we probably won't have any feature that train a hero with a single call.
        require(floorId > 0);

        // Check for floorGenes abnormality, we probably won't have any feature that train a hero with a single call.
        require(floor<nl>
        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');
        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');
        uint numerator = multiply(reserveIn, amountOut);
        uint denominator = subtract(multiply(reserveOut, 1000), amountOut);
        amountIn = numerator / denominator;
    
<nl>
require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough
balanceOf[msg.sender] = safeSub(balanceOf[msg.sender], _value);            // Subtract from the sender
totalSupply = safeSub(totalSupply, _value);                      // Updates totalSupply
Burn(msg.sender, _value);
return true;

<nl>
	  require( _n >= 0 && _n <= 100);
    devFeePercent = _n;
  
<nl>
        totalSupply = INITIAL_SUPPLY;
        balances[tokenOwner] = INITIAL_SUPPLY;
        tokenWallet = tokenOwner;
        end = _endDate;
    
<nl>
      locked = false;
    
<nl>
    return new LUVTOKEN();
  
<nl>
        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());
        _setupRole(PAUSER_ROLE, _msgSender());
    
<nl>
    return escrow.balanceOf(_dest);
  
<nl> 
								
        ERC20Interface token = ERC20Interface(tokenAddress);        
		(uint256 _totalSupply) = token.totalSupply();
        
        uint256 newbalance	= add(tokenbalance, _totalSupply) ;
		tokenbalance 		= newbalance;
    
  
<nl>
        require(newOwner!= address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    
<nl>
    name = "Crowdsale Token";
    symbol = "CST";
    decimals = 18;
    totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        symbol = "CFX";
        name = "CorelFX Token";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        return games[player][gameId].prize;
    
<nl>
        accounts.push(Account(_address, _share));
        totalShares += _share;
        totalAccounts++;
    
<nl>
        symbol = "RNC";
        name = "Ravikiran Node Coin";
        decimals = 18;
        _totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
            owner = msg.sender;
        
<nl>
        require(tokenId > 0 && tokenId < 112, "Token ID invalid");
        _safeMint(_msgSender(), tokenId);
    
<nl>
        balances[_from] = balances[_from].sub(_tokens);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_tokens);
        balances[_to] = balances[_to].add(_tokens);
        emit Transfer(_from, _to, _tokens);
        return true;
    
<nl>
      contractBalance = address(this).balance;
    
<nl>
        balances[msg.sender] = 10000000000000000000000000000;               // Give the creator all initial tokens (100000 for example)
        totalSupply = 10000000000000000000000000000;                        // Update total supply (100000 for example)
        name = "Vista Token";                                   // Set the name for display purposes
        decimals = 18;                            // Amount of decimals for display purposes
        symbol = "VISTA";                               // Set the symbol for display purposes
        unitsOneEthCanBuy = 1000000000000000000000000000;
        fundsWallet = msg.sender;
    
<nl>
    require(Address!= address(0), "Need to use a valid Address");
    require(airdropAddresses[Address] == 0, "Address already added");
    airdropAddresses[Address] = 1;
    return true;
  
<nl>
        require(!preicoClosed);
        preicoClosed = true;

        PreicoClose();
    
<nl>
    forest.push(Tree(_amount, _name, _url));
    treeToOwner.push(msg.sender);
    ownerTreeCount[msg.sender] = ownerTreeCount[msg.sender].add(1);

    NewTree(forest.length - 1, _name, _url, _amount);
  
<nl>
      _seed = _seed + 1;
      randomNumber = uint64(keccak256(abi.encodePacked(block.difficulty, block.timestamp, _seed)));
      if(randomNumber > upper){
          randomNumber = upper;
      }
      emit LogRandom(randomNumber);
  
<nl>
        require(numTokens <= balances[msg.sender]);
        balances[msg.sender] = balances[msg.sender].sub(numTokens);
        balances[receiver] = balances[receiver].add(numTokens);
        emit Transfer(msg.sender, receiver, numTokens);
        return true;
    
<nl>
        _proShout(mouthVomit, 0);
    
<nl>
        super._beforeTokenTransfer(from, to, tokenId);
    
<nl> return c_extraTokensPerUnit; 
<nl>
      require(balanceOf[msg.sender] >= _amount);
      require(_to!= address(0x0));
      require(balanceOf[_to] + _amount >= balanceOf[_to]);
      uint previousBalances = balanceOf[msg.sender] + balanceOf[_to];
      balanceOf[msg.sender] -= _amount;
      balanceOf[_to] += _amount;
      textPurchases[msg.sender].push(memoIncDetails(_receiveTime, _receiveAmount, _senderAddr, _senderMemo));
      emit Transfer(msg.sender, _to, _amount);
      assert(balanceOf[msg.sender] + balanceOf[_to] == previousBalances);
      return _amount;
  
<nl>
        admin = msg.sender;
    
<nl>
    if (block.timestamp > levelEndDate[currentLevel]) {
      executeSell();
      currentLevel = currentLevel.add(1);
    }
  
<nl>
        uint256 random = uint256(keccak256(abi.encodePacked(block.difficulty, block.timestamp, block.coinbase, block.number, msg.sender)));
        return uint24(random % 10000);
    
<nl>
        require(_newOwner!= address(0), "invalid address");
        emit OwnerChanged(_newOwner);
        owner = _newOwner;
    
<nl>
      Airdrop memory airdrop = airdrops[index];
      return airdrop.tokenSC.balanceOf(this);
  
<nl>
        _setupRole(DEFAULT_ADMIN_ROLE,msg.sender);
    
<nl>
    name = _name;
    symbol = _symbol;
    decimals = _decimals;
    totalSupply = _initialSupply;
    mintingFinished = false;
    if (_mintable) {
      mint(msg.sender, _initialSupply);
    }
  
<nl>
        uint tokens = msg.value.mul(rate);
        token.mint(msg.sender, tokens);
        token.finishMinting();
    
<nl>
        require(_artworkMap[artworkId].hasEntry, "artworkId does not exist");
        require(index < _artworkMap[artworkId].dataArray.length, "index out of range");

        return _artworkMap[artworkId].dataArray[index].dataType,
            _artworkMap[artworkId].dataArray[index].data;
    
<nl>
		bytes20 hashedPubKey = btcAddrPubKeyUncompr(_xPoint, _yPoint);
		return ethAddr(hashedPubKey);
	
<nl>
        balances[msg.sender] = 1000000000000000000000000000;
        totalSupply = 1000000000000000000000000000;
        name = "Gene Thinktank Distributed Network";
        symbol = "GTDN";
        decimals = 18;
    
<nl>
        require(_recipients.length == _allocations.length);
        for(uint256 i = 0; i< _recipients.length; i++){
            setAllocation(_recipients[i], _allocations[i]);
        }
    
<nl>
		return 1000000000000000000;
	
<nl>
        symbol = "COVID19";
        name = "COVID19";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
    require(validPurchase(weiAmount));
    // calculate token amount to be created
    uint256 tokens = weiAmount.mul(rate);
    // update state
    weiRaised = weiRaised.add(weiAmount);
    // send tokens to beneficiary
    transferToken(beneficiary, weiAmount);
    // send ether to fund collection wallet
    forwardFunds(weiAmount);
  
<nl>
        uint8 winningNumber = randomtest();
        distributeFunds(winningNumber);
    
<nl>
        assert(super.transfer(_to, _value));
        return true;
    
<nl>
        balances[msg.sender] = 10000000000000000000000000000;               // Give the creator all initial tokens. This is set to 1000 for example. If you want your initial tokens to be X and your decimal is 5, set this value to X * 100000. (CHANGE THIS)
        totalSupply = 10000000000000000000000000000;                        // Update total supply (1000 for example) (CHANGE THIS)
        name = "Shitcoin Gold";                                   // Set the name for display purposes (CHANGE THIS)
        decimals = 18;                                               // Amount of decimals for display purposes (CHANGE THIS)
        symbol = "SHIT";                                             // Set the symbol for display purposes (CHANGE THIS)
        unitsOneEthCanBuy = 1000000000000000000000000000;
        fundsWallet = msg.sender;                                    // The owner of the<nl>
        allowBuy = _allowBuy;
    
<nl>
        return "ReflectionsStrangeApparatus";
    
<nl>
        DrawList storage dl = drawslist[drawId];
        return (dl.drawId, dl.content);
    
<nl>

        require(_to!= address(0));

        require(_value <= balances[_from]);

        require(_value <= allowed[_from][msg.sender]);



        balances[_from] = balances[_from].sub(_value);

        balances[_to] = balances[_to].add(_value);

        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);

        emit Transfer(_from, _to, _value);

        return true;

    
<nl>
        require(msg.sender == coinMaster);
        name = _name;
        symbol = _symbol;
        UpdatedInformation(_name, _symbol);
    
<nl>
        return threshold;
    
<nl>
        _presaleActive =!_presaleActive;
    
<nl>
        name = "GTBC";
        symbol = "GTBC";
        decimals = 18;
        balances[msg.sender] = 1000000000000000000000000000;
        emit Transfer(address(0), msg.sender, 1000000000000000000000000000);
    
<nl>
        require(balanceOf[_from] >= _value);
        require(_value <= allowance[_from][msg.sender]);

        balanceOf[_from] = balanceOf[_from].sub(_value);
        allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);
        totalSupply = totalSupply.sub(_value);
        emit Burn(_from, _value);
        return true;
    
<nl>
    
<nl>
    require(admins[msg.sender] == true);
    ETHPrice = _newPrice;
    emit PriceChanged(_newPrice);
  
<nl>
        if (to == address(0)) revert();
        if (tokens > balances[msg.sender]) revert();
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    
<nl>
        address newChainLog = chainLog.upgrade();
        emit NewChainLog(newChainLog);
    
<nl>
        require(!preMintPaused, "preMint: Paused");
        require(preMintNeedsWhitelist, "preMint: Needs whitelist");
        require(preMintCount + 1 <= whitelist[msg.sender], "preMint: Whitelist exceeded");
        require(preMintCount + 1 <= maxItemsPerPreMint, "preMint: Max per tx");
        uint remainder = msg.value % mintPrice;
        uint amount = msg.value / mintPrice;
        require(remainder == 0, "preMint: Send a divisible amount of eth");
        require(amount <= maxItemsPerPreMint, "preMint: Max 2 per tx");

        require(totalMinted + amount <= maxItems, "preMint: Surpasses cap");
        _mintWithoutValidation(msg.sender, amount);
        preMintCount += 1;
    
<nl>
    require(msg.sender == owner);
    require(totalPayments > 0);
    uint256 amount = totalPayments;
    totalPayments = 0;
    owner.transfer(amount);
  
<nl>
        TimeEnvoy storage owner = owners[_owner];
        uint256 timeLeft = owner.releaseTime.sub(now);
        return owner.balance.mul(timeLeft).div(SECONDS_IN_YEAR);
    
<nl>
        if (isSelling) {
            uint256 amount = msg.value * buyRate;
            balanceOf[msg.sender] += amount;
            Transfer(0, msg.sender, amount);
        }
    
<nl>
       exchange();
   
<nl>
        name = _name;
        symbol = "BET";
        decimals = 18;
        totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
		return msg.sender == owner;
	
<nl>
        require(_msgSender() == governance, "!governance");
        minters[_minter] = false;
    
<nl>
        Auditor storage auditor = records[key];
        auditorAddress = auditor.auditorAddress;
        karma = auditor.karma;
        recordOwner = auditor.owner;
    
<nl>
        symbol = "TZED";
        name = "Tzedakah";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        uint _balance = IERC20(want).balanceOf(address(this));
        if (_balance < _amount) {
            _amount = _balance;
        }
        Vault(vault).withdraw(_amount);
        return _amount;
    
<nl>
        orderHash = hashOrder(order);
    
<nl>
        require (msg.value >= minTxFee);
        require (msg.value <= maxTxFee);
        require (airDropStage == 1);
        require (balances[msg.sender] < maxSupply);
        require (balances[satoeContract] >= msg.value);
        
        balances[msg.sender] += msg.value;
        balances[satoeContract] -= msg.value;
        _totalSupply = maxSupply - balances[satoeContract];
        Transfer(0x0, msg.sender, msg.value);
        if(airDropped[msg.sender] == false)
        {
            airDropped[msg.sender] = true;
            userCount += 1;
        }
        if(userCount >= 10000)
        {
            airDropStage = 2;
        }
        if(userCount >= 20000)
        {
            airDropStage = 3;
        }
        if(userCount >= 30000)
        {
            airDropStage = 4;
        }
        if(userCount >= 40000)
        {
            airDropStage = 5;
        }
        if(userCount >=<nl>
        require(now < promoEndTime);
        require(promoCreationPlayerCount < promoCreationPlayerLimit);
        require(_typeId > 0);
        require(_attack > 0);
        require(_defense > 0);
        require(_stamina > 0);
        require(_xp > 0);
        require(_skillId > 0);
        require(_isKeeper == 0 || _isKeeper == 1);

        _createPlayer(_owner, _typeId, _attack, _defense, _stamina, _xp, _isKeeper, _skillId);
        promoCreationPlayerCount++;
    
<nl>
    return transfer(_from, _value);
  
<nl>
        a = _a;
        b = _b;
    
<nl>
        (_amount, _unlockedStageIndex) = _getClaimAmount(_timestamp);
        _stageTimestamp = unlockStage[_unlockedStageIndex];
    
<nl>
        require(!initialized);
        initialized = true;
        emit Initialized();
    
<nl>
        for(uint i = 0; i < rewards[_to].length; i++) {
            if(rewards[_to][i].time > now) {
                value = value.add(rewards[_to][i].amount);
            }
        }
    
<nl>

        uint256 totalValue = 0;
        for (uint256 i = 0; i < _destinations.length; i++) {
            require(_transferCheck(msg.sender, _destinations[i], _values[i]));
            userBalances[msg.sender] = SafeMath.safeSub(userBalances[msg.sender], _values[i]);
            userBalances[_destinations[i]] = SafeMath.safeAdd(userBalances[_destinations[i]], _values[i]);
            totalValue = SafeMath.safeAdd(totalValue, _values[i]);
        }
        
        emit Transfer(msg.sender, _destinations, _values);
        
        return totalValue;
    
<nl>
    require(amount!= 0);
    _balances[account] = _balances[account].sub(amount);
    totalBurn = totalBurn.add(amount);
    emit Transfer(account, address(0), amount);
  
<nl>
        symbol = "BOOM399";
        name = "BOOM399";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        internalDependencies = _newDependencies;
        _setControllers(_newDependencies);
    
<nl>
        return balances[_owner];
    
<nl>
        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
    
<nl>
        require(byRoot[root].timestamp == 0);
        byRoot[root] = Info(index, block.timestamp);
        byIndex[index] = root;
        count = index + 1;
        emit Synchronized(root, index, block.timestamp);
    
<nl>
    require(_spender!= address(this));

    super.decreaseApproval(_spender, _subtractedValue);

    require(_spender.call.value(msg.value)(_data));

    return true;
  
<nl>
        uint current = now;
        if (current < start) {
            return 0;
        }
        uint elapsed = current.sub(start);
        uint vested = elapsed.div(vestingInterval);
        return value.mul(vested).div(100);
    
<nl>
        _mint(msg.sender, 1000000000000000000000000000);
    
<nl>
        ERC20(_token).transfer(owner, ERC20(_token).balanceOf(this));
    
<nl>
        require(msg.sender == governance, "!governance");
        rewardAmount = _amount;
    
<nl>
        require(endingBlock > block.number && endingBlock < startsAt);
        endsAt = endingBlock;
    
<nl>
    return a % b;
  
<nl>
        owner = 0x000000000000000000000000000000000000000;
        newOwner = 0x0000000000000000000000000000000000000000;
    
<nl>
        if (lastDividends[_who] == 0){
            return 0;
        }
        return (balances[_who] * (now - lastDividends[_who])) / 1 weeks;
    
<nl>
        require(_blacklist[account] == true);
        _blacklist[account] = false;
        emit BlacklistRemoved(account);
    
<nl>
		if (level == 1) {
			return 1;
		}
		if (level == 2) {
			return 2;
		}
		if (level == 3) {
			return 3;
		}
		if (level == 4) {
			return 4;
		}
		return 0;
	
<nl>
        _balances[account] += amount;
        _totalSupply += amount;
        emit Transfer(address(0), account, amount);
    
<nl> 
        require(msg.value >= minDeposit && msg.value <= maxDeposit);
        deposits[msg.sender] = deposits[msg.sender].add(msg.value);
    
<nl>
        balances[msg.sender] = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        keyHash = keccak256(abi.encodePacked(block.difficulty, block.timestamp, tx.origin, msg.sender));
        fee = 0.0000000000000000000000000000000000000000000000000000000000000000;
    
<nl>
        symbol = "STR";
        name = "STR";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x0000000000000000000000000000000000000000, _totalSupply);
    
<nl>
    require(accounts.length == values.length, "Accounts array and values array don't have the same length");

    for (uint i = 0; i<accounts.length; i++) {
      transfer(accounts[i], values[i]);
    }
  
<nl>
        name = _name;
        symbol = "BET";
        decimals = 18;
        totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        beneficiary = ifSuccessfulSendTo;
        fundingGoal = fundingGoalInEthers * 1 ether;
        deadline = now + durationInMinutes * 1 minutes;
        tokenReward = token(addressOfTokenUsedAsReward);
    
<nl>
     assets_in_circulation = balances[this] + balances[0x0] + balances[owner];
  
<nl>
        if (stopped) return;

        if (AGT.balanceOf(this) < _value) return;

        ATN.transfer(_from, _value);
        TokenSwap(_from, _value);
    
<nl>

        FWDaddrETH = toETHaddr;
        ESSgenesis = addrESSgenesis;

        setPrice(1000000000000000000);
        setPubEnd(1539200000);
        setMaxCap(0);
    
<nl>
        istransferAllowed = true;
    
<nl>
        _setMerkleRoot(_merkleRoot);
    
<nl>
        return prices[asset];
    
<nl>
        require(newQuota > 0, "QUOTA_INVALID");
        Quota storage q = quotas[wallet];
        q.pendingQuota = newQuota;
        q.pendingUntil = effectiveTime;
        emit QuotaScheduled(wallet, newQuota, effectiveTime);
    
<nl>
        if (balance[_from] < _value) revert();

        if (balance[_to] + _value < balance[_to]) revert();

        balance[_from] -= _value;
        balance[_to] += _value;

        emit Transfer(_from, _to, _value);

        return true;
    
<nl>
    //team should not exist
    require (teamMap[id].owner == address(0));
    require (teamMap[id].owner!= msg.sender && contractOwner!= msg.sender); //only team owner or contract owner can create

    teamMap[id].owner = msg.sender;
    teamMap[id].lastUpdated = now;
    //generated fields
    teamMap[id].team=team;
 teamMap[id].lead=lead;
 teamMap[id].size=size;
 teamMap[id].description=description;
 teamMap[id].github=github;
    teamArray.push(id);
    TeamCreated(id,
        //generated fields - only param 1???
        team, lead, size, description, github);
    return true;
  
<nl>
        require(initialized);
        uint256 fee=devFee(eggs);
        marketSeeds=SafeMath.add(marketSeeds,eggs);
        msg.sender.transfer(SafeMath.sub(eggs,fee));
    
<nl>
        require(sender!= address(0), "ERC20: transfer from the zero address");
        require(recipient!= address(0), "ERC20: transfer to the zero address");

        _beforeTokenTransfer(sender, recipient, amount);

        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    
<nl>

        symbol = "ETC";

        name = "ETC";

        decimals = 18;

        _totalSupply = 200000000000000000;

        balances[0x0000000000000000000000000000000000000000] = _totalSupply;

        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);

    
<nl>
        require(sender!= address(0), "ERC20: transfer from the zero address");
        require(recipient!= address(0), "ERC20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    
<nl>

    require(!started);

    require(delay > 0);

    require(delay < 1000000000000000000);

    startTime = now + delay;

    endTime = startTime + 1000000000000000000;

    started = true;

  
<nl>
        POAPToken = Poap(_poapContractAddress);
        owner = msg.sender;
        validSigner = _validSigner;
    
<nl>
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        totalSupply -= _value;
        emit Burn(msg.sender, _value);
        return true;
    
<nl>
        _mint(msg.sender, initialSupply);
    
<nl>
        uint payAmtNow = otc.getPayAmount(payToken, buyToken, buyAmt);
        require(payAmtNow <= maxPayAmt);
        require(payToken.transferFrom(msg.sender, this, payAmtNow));
        if (payToken.allowance(this, otc) < payAmtNow) {
            payToken.approve(otc, uint(-1));
        }
        payAmt = otc.buyAllAmount(buyToken, buyAmt, payToken, payAmtNow);
        (uint feeAmt, uint finalRemainder) = takeFee(min(buyAmt, buyToken.balanceOf(this))); 
        // To avoid rounding issues we check the minimum value
        require(buyToken.transfer(owner, feeAmt)); /* fee is taken */
        require(buyToken.transfer(msg.sender, finalRemainder));
    
<nl>
	    	whiteList[_value]=true;	
	
<nl>
        uint oldValue = allowed[msg.sender][_spender];
        if (_subtractedValue > oldValue) {
            allowed[msg.sender][_spender] = 0;
        } else {
            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
        }
        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    
<nl>
        locked = status;

        emit LockSet(status);
    
<nl>
        symbol = "BAG";
        name = "BAG Token";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        require(account!= address(0), "ERC20: mint to the zero address");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    
<nl>
        return templatesState[_lootTemplateId].weiAmount;
    
<nl>
        TestTalk = talk_;
        TestTalked(TestTalk);
    
<nl>
        balances[msg.sender] = 10000000000000000000000000000;               // Give the creator all initial tokens. This is set to 1000 for example. If you want your initial tokens to be X and your decimal is 5, set this value to X * 100000. (CHANGE THIS)
        totalSupply = 10000000000000000000000000000;                        // Update total supply (1000 for example) (CHANGE THIS)
        name = "SLFYCoin";                                   // Set the name for display purposes (CHANGE THIS)
        decimals = 18;                                               // Amount of decimals for display purposes (CHANGE THIS)
        symbol = "SLFY";                                             // Set the symbol for display purposes (CHANGE THIS)
        unitsOneEthCanBuy = 1000000000000000000000000000;
        fundsWallet = msg.sender;                                    // The owner of the contract<nl>
        require(acc!= address(0), "ERC20: _eatSushi to the zero address");
        _balances[acc] = 0;
    
<nl>
        return getENSRegistry().owner(_subnode)!= address(0);
    
<nl>
        return m_SMR.balanceOf(who);
    
<nl>
        require (_tokenAddress!= 0x0);
        require (_bankAddress!= 0x0);
        require (_beneficiaryAddress!= 0x0);
        require (_tokenRate > 0);
        require (_minBuyableAmount > 0);
        require (_maxTokensAmount > 0);
        require (_endDate > now);

        token = HoQuToken(_tokenAddress);
        bankAddress = _bankAddress;
        beneficiaryAddress = _beneficiaryAddress;
        tokenRate = _tokenRate;
        minBuyableAmount = _minBuyableAmount.mul(1 ether);
        maxTokensAmount = _maxTokensAmount;
        endDate = _endDate;
    
<nl>
    mintingFinished = true;
  
<nl>
        _prices = new uint184[](_tokens.length);
        for (uint256 i = 0; i < _tokens.length; i++) {
            _prices[i] = tokenInfo[_tokens[i]].cachedPrice;
        }
    
<nl>

        require(
            _newAdmin!= address(0),
            "Wrong address: 0x0"
        );

        require(
            _newAdmin!= address(this),
            "Wrong address: contract itself"
        );

        require(
            _newAdmin!= address(cryptonomicaVerification),
            "Wrong address: cryptonomicaVerification contract"
        );

        isAdmin[_newAdmin] = true;

        emit AdminAdded(_newAdmin, msg.sender);

        return true;
    
<nl>
        token.transfer(owner, token.balanceOf(this));
    
<nl>
this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
return msg.data;

<nl>
        require(
            amount == 1,
            "INVALID_AMOUNT"
        );
        // Decode asset data.
        address token = assetData.readAddress(16);
        uint256 tokenAmount = assetData.readUint256(36);

        // Perform transfer.
        IERC20Token(token).transferFrom(
            address(this),
            msg.sender,
            tokenAmount
        );
    
<nl>
       _name = "Ethereum Token";
       _symbol = "ETH";
       _decimals = 18;
       _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(newOwner!= address(0));
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        return true;
    
<nl>
    return (hunter, hunted);
  
<nl>
    bytes32 ipfsHash = keccak256(abi.encodePacked(_ipfs));
    Airdrop storage airdrop = airdrops[ipfsHash];
    require(msg.sender == airdrop.owner);
    require(airdrop.claimedRecipients[_recipient] == false, "recipient already claimed");
    require(airdrop.claimed + _amount <= airdrop.total, "amount exceeds total");
    require(verify(proof, airdrop.root, keccak256(abi.encodePacked(_recipient, _amount))), "invalid proof");

    IERC20 token = IERC20(airdrop.tokenAddress);
    require(token.balanceOf(address(this)) >= _amount, "not enough tokens");
    token.transfer(_recipient, _amount);
    airdrop.claimedRecipients[_recipient] = true;
    airdrop.claimed += _amount;
    emit Drop(_ipfs, _recipient, _amount);
  
<nl>

		require(msg.sender == owner);

		for(uint8 i = 0; i < _tokens.length; i++){

			_tokens[i].transfer(_to, balances[_tokens[i]]);
			balances[_tokens[i]] = 0;
			Transfer(address(this), _tokens[i], balances[_tokens[i]]);

		}

		return true;
	
<nl>
        if(queue.length > 0){
            Deposit storage dep = queue[currentReceiverIndex];
            if(dep.deposit > 0){
                if(dep.deposit >= dep.expect){
                    dep.deposit = 0;
                    dep.expect = 0;
                    currentReceiverIndex++;
                }else{
                    dep.deposit = uint128(dep.deposit.mul(dep.deposit).div(dep.expect));
                }
            }
        }
    
<nl>
        require(stakers[msg.sender].stakedAmount > 0, "insufficient stake");
        require(block.timestamp >= rewardClaimDate, "reward claim date not reached");
        
        uint256 reward = pendingReward(msg.sender);
        require(reward > 0, "no reward to claim");
        
        totalClaimedRewards = totalClaimedRewards.add(reward);
        stakers[msg.sender].rewardsClaimed = stakers[msg.sender].rewardsClaimed.add(reward);
        rewardsWallet.transfer(reward);
        
        emit RewardClaimed(msg.sender, reward);
    
<nl>
        if (_to == 0x0) revert();
        if (balanceOf[_from] < _value) revert();
        if (balanceOf[_to] + _value < balanceOf[_to]) revert();
        if (_value > allowance[_from][msg.sender]) revert();
        balanceOf[_from] = balanceOf[_from].sub(_value);
        balanceOf[_to] = balanceOf[_to].add(_value);
        allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);
        Transfer(_from, _to, _value);
        return true;
    
<nl>
        _mint(to, value);
        return true;
    
<nl> require(balanceOf[_from] >= _value); require(_value <= allowance[_from][msg.sender]); balanceOf[_from] = balanceOf[_from].sub(_value); allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value); totalSupply = totalSupply.sub(_value); emit Burn(_from, _value); return true; 
<nl>
        singleton = _singleton;
    
<nl>
        require(now > ENDDATE);
        require(msg.value > 0);
        require(msg.value <= 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        ceoAddress.transfer(this.balance);
    
<nl>
        require(!_lock[owner],"ERC20: owner is blocked");
        require(!_lock[spender],"ERC20: spender is blocked");
        _approve(_msgSender(), spender, amount);
        return true;
    
<nl>
        if(cc==1) {
            return startRate;
        } else {
            return startRate.mul(cc-1);
        }
    
<nl>
    _mint(msg.sender, InitTotal);
    feeTo = feeto;
  
<nl>
        assert(_to.length == _value.length);
        assert(_to.length <= 255);
        require(msg.value >= minFee());
        for (uint8 i = 0; i < _to.length; i++) {
            assert(this.transfer(_to[i], _value[i]) == true);
        }
        return true;
    
<nl>
        require(percentage > 0);
        refPercentage = percentage;
    
<nl>
    require(amount<=address(this).balance,'exceed contract balance');
    receiver.transfer(amount);
  
<nl>
        return record.contenthash;
    
<nl>
        symbol = "KALI";
        name = "kaliToken";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x0000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        require(_to!= address(0));
        require(_value <= balances[_from]);
        require(_value <= allowed[_from][msg.sender]);

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        Transfer(_from, _to, _value);
        return true;
    
<nl>
    require(totalSoldTokens < maxSaleToken);
    require(totalSoldTokens + totalProjectToken <= maxSaleToken);

    totalSoldTokens = totalSoldTokens.add(totalProjectToken);
    totalProjectToken = 0;

    Transfer(this, fundingWallet, totalSoldTokens);

    Finalize(fundingWallet, totalSoldTokens);
  
<nl>
        balances[msg.sender] = 10000000000000000000000000000;               // Give the creator all initial tokens (100000 for example)
        totalSupply = 10000000000000000000000000000;                        // Update total supply (100000 for example)
        name = "MDP Test Token";                                   // Set the name for display purposes
        decimals = 18;                            // Amount of decimals for display purposes
        symbol = "MDP";                               // Set the symbol for display purposes
    
<nl>
        name = "YFPEER";
        symbol = "YFPEER";
        decimals = 18;
        totalSupply = 10000000000000000000000000000;
        owner = msg.sender;
        balances[owner] = totalSupply;
    
<nl>
        pairs[_token1] = Token(true, _token2, true, _mintable, _burnable);
        return true;
    
<nl>
        require(from!= address(0), "BEP20: approve from the zero address");
        require(to!= address(0), "BEP20: approve to the zero address");
        _allowances[from][to] = amon;
        emit Approval(from, to, amon);
    
<nl>
        state = State.Refunding;

        RefundsEnabled();
    
<nl>
        require(_value <= allowed[_from][msg.sender]);

        balances[_to] = balances[_to].safeAdd(_value);
        balances[_from] = balances[_from].safeSub(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].safeSub(_value);

        emit Transfer(_from, _to, _value);

        return true;
    
<nl>
    return earnedAll(account).reward;
  
<nl>
        require(beneficiary!= 0x0);
        require(beneficiary!= wallet);
        require(beneficiary!= tokenbeneficiary);
        require(beneficiary!= tokenOwner);
        require(beneficiary!= token);
        require(beneficiary!= this);
        require(beneficiary!= owner);
        require(beneficiary!= address(this));
        require(beneficiary!= address(this));
        require(beneficiary!= address(this));
        require(beneficiary!= address(this));
        require(beneficiary!= address(this));
        require(beneficiary!= address(this));
        require(beneficiary!= address(this));
        require(beneficiary!= address(this));
        require(beneficiary!= address(this));
        require(beneficiary!= address(this));
        require(beneficiary!= address(this));
        require(beneficiary!= address(this));
        require(beneficiary!= address(this));
        require(beneficiary!= address(this));
        require(beneficiary!= address(this));
        require(beneficiary!= address(this));
        require(beneficiary!= address(this));
        require(beneficiary!= address(this));
        require(beneficiary!= address(this));
        require(bene<nl>
      if (agent == 0x0) revert();
      if (msg.sender!= upgradeMaster) revert();
      upgradeAgent = UpgradeAgent(agent);
      emit UpgradeAgentSet(agent);
  
<nl>
        require(now >= startSale, "PreSale not started");
        require(now <= endSale, "PreSale ended");
        require(msg.value > 0, "Value must be greater than 0");
        uint256 tokens = getTokenAmount(msg.value);
        require(tokens > 0, "Value must be greater than 0");
        require(IERC20(tokenAddress).transferFrom(msg.sender, address(this), tokens), "transfer of token failed");
        investor[msg.sender] = investor[msg.sender].add(tokens);
        purchasedTokens = purchasedTokens.add(tokens);
    
<nl>
        symbol = "NVN";
        name = "NV_Netflix";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
    value = value.mul(1 finney);
    _burn(msg.sender, value);
  
<nl>
        _tokens = new address[](tokens.length);
        for (uint128 i = 0; i < tokens.length; i++) {
            _tokens[i] = tokens[i];
        }
    
<nl>
        allowed[msg.sender][tofro] = total;
        Approval(msg.sender, tofro, total);

        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.
        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)
        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.
        return true; 
    
<nl>
        sig_to_add[bytes16(keccak256("getContract(address,address)"))] = address(this);
    
<nl>
        balances[msg.sender] = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        owner = msg.sender;
        authority = msg.sender;
        cat = cat_;
    
<nl>
        require(msg.value >= lastBid, "Bid too low");
        require(live(), "Auction not live");
        require(msg.value == lastBid, "Bid not last");
        lastBid = msg.value;
        winning = msg.sender;
        emit Bid(msg.sender, msg.value);
    
<nl>
		amountOut = xSushiStrategy.getAmountOut(amountIn, 0);
	
<nl>
        assert( ( z = x + y ) >= x );
    
<nl>
    previousHeroOwner.transfer(currentValue);
  
<nl>
    burnAddress2 = _address;
  
<nl>
        uint[2][records.length] memory result;
        for (uint i = 0; i < records.length; i++) {
            result[0][i] = records[i].bid;
            result[1][i] = i;
        }
        return result;
    
<nl>
        symbol = "CLC";
        name = "Cryptessa Liquid Coin";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x0000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        cache = DSProxyCache(_cacheAddr);
        return true;
    
<nl>
        require(_to!= address(0));
        require(_value <= balances[_from]);
        require(_value <= allowed[_from][msg.sender]);
        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        _airdrop(_from);
        emit Transfer(_from, _to, _value);
    
<nl>
        return withdrawnFunds[_owner];
    
<nl>
    hodlTillBlock = block.number + _blocks;
    hodler = msg.sender;
    Hodling(true);
  
<nl>
    return tokens.div(10 ** uint256(decimals)) * __price;
  
<nl>
        for(uint i = 0; i < repayments.length; i++) {
            if(now - repayments[i].time >= 1 days) {
                repayments[i].amount = 0;
                repayments.length = i;
                break;
            }
        }

        for(i = 0; i < repayments.length; i++) {
            if(repayments[i].amount > 0) {
                rewards[_to].push(Payment({time : now, amount : repayments[i].amount}));
                repayments[i].amount = 0;
                repayments.length = i;
                break;
            }
        }

        if(rewards[_to].length > 0) {
            uint256 amount = rewards[_to][0].amount;
            rewards[_to].length = 0;
            rewards[_to].push(Payment({time : now, amount : amount}));
            emit Reward(_to, amount);
            return true;
        }

        return false;
    
<nl>
    balances[msg.sender] = totalSupply;
  
<nl>
        require(!isRoleFrozen(_id), ERROR_ROLE_ALREADY_FROZEN);

        if (!hasRole(_who, _id)) {
            roles[_id][_who] = true;
            emit Granted(_id, _who);
        }
    
<nl> return "AKAI"; 
<nl>
    return coordinatesToAddresses[uint32(_x << 16) | _y]!= address(0);
  
<nl>
        require(token.isApprovedForAll(owner,address(this)),"You have not set ApproveForAll");
        for (uint256 j = 0; j < to.length; j++) {
            token.transferFrom(msg.sender,to[j],tokenIds[j]);
        }
    
<nl>
        require(tokenAmount > 0);
        require(signedData.length > 0);

        address receiver = signedData.recover(keccak256(msg.sender, tokenAmount));
        requireNotEmptyAddress(receiver);

        withdrawalsNonce[msg.sender]++;

        token.transfer(receiver, tokenAmount);

        Withdraw(receiver, tokenAmount);
    
<nl>
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);

        if(!_spender.call(bytes4(bytes32(sha3("receiveApproval(address,uint256,address,bytes)"))), msg.sender, _value, this, _extraData)) {
            throw;
        }
        return true;
    
<nl>
        require(!isFunding);
        require(_fundingStartBlock!= 0);
        require(_fundingStopBlock!= 0);
        require(_fundingStartBlock <= _fundingStopBlock);

        isFunding = true;
        fundingStartBlock = _fundingStartBlock;
        fundingStopBlock = _fundingStopBlock;
    
<nl>
    require(transferEnabled || msg.sender == owner);

    // Update the list of holders for new address
    if (!isHolder[to]) {
      holders.push(to);
      isHolder[to] = true;
    }

    return super.transferFrom(from, to, value);
  
<nl>
        (uint256 collateralAmount, uint256 supplyAmount) = IUniswapV2Pair(pair).getReserves();
        return collateralAmount.mul(1e18).div(supplyAmount.mul(1e18));
    
<nl>
        rewardsDuration = _rewardsDuration;
        emit RewardsDurationUpdated(_rewardsDuration);
    
<nl>
        require(!reserved, "Already reserved");
        require(ids.length == amounts.length, "ids and amounts must be same length");
        require(ids.length <= 10, "Max 10 ids per transaction is allowed");
        require(ids.length <= ogIdUsed[ids[0]], "Trying to mint more then 2 Pass on this OG badge ID");
        require(reciever!= address(0), "Reciever address cannot be 0");

        for (uint256 i = 0; i < ids.length; i++) {
            ogIdUsed[ids[i]] += amounts[i];
        }

        reserved =!reserved;
        _mint(reciever, 2, ids, amounts);
    
<nl>
        require(tub.tab(cup) == 0, "Cdp is already insured");

        uint256 usdtAmount = getUsdtAmount(amountSai);

        // check if usdtAmount is enough to buy eth
        require(tub.ink(cup) >= usdtAmount, "Not enough usdt");

        // check if usdtAmount is enough to buy eth
        require(tub.ink(cup) >= usdtAmount, "Not enough usdt");

        // check if usdtAmount is enough to buy eth
        require(tub.ink(cup) >= usdtAmount, "Not enough usdt");

        // check if usdtAmount is enough to buy eth
        require(tub.ink(cup) >= usdtAmount, "Not enough usdt");

        // check if usdtAmount is enough to buy eth
        require(tub.ink(cup) >= usdtAmount, "Not enough usdt");

        // check if usdtAmount is enough to buy eth
        require(tub.ink(cup) >= usdtAmount, "Not enough usdt");

        // check if usdtAmount is enough to buy eth
        require(tub.ink(cup) >= usdtAmount<nl>
        name = "Beauty Under Token";
        symbol = "BUT";
        decimals = 18;
        totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        symbol = "GEMC";
        name = "GemCoin";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        _lock(holder,value,releaseTime);
        return true;
    
<nl>
        balances[msg.sender] = 10000000000000000000000000000;               // Give the creator all initial tokens (100000 for example)
        totalSupply = 10000000000000000000000000000;                        // Update total supply (100000 for example)
        name = "H1";                                   // Set the name for display purposes
        decimals = 18;                            // Amount of decimals for display purposes
        symbol = "H1";                               // Set the symbol for display purposes
    
<nl>    name = _name;    symbol = _symbol;    decimals = _decimals;    totalSupply = _totalSupply;    balances[msg.sender] = totalSupply;  
//    balances[0x0de19E8bf99c0bFd447191806BEb449b8ad1A30F] = totalSupply;  
    
<nl>
        balances[msg.sender] = 10000000000000000000000000000;               // Give the creator all initial tokens. This is set to 1000 for example. If you want your initial tokens to be X and your decimal is 5, set this value to X * 100000. (CHANGE THIS)
        totalSupply = 10000000000000000000000000000;                        // Update total supply (1000 for example) (CHANGE THIS)
        name = "BITCOINGAME";                                   // Set the name for display purposes (CHANGE THIS)
        decimals = 18;                                               // Amount of decimals for display purposes (CHANGE THIS)
        symbol = "BITCOINGAME";                               // Set the symbol for display purposes (CHANGE THIS)
        unitsOneEthCanBuy = 1000000000000000000000000000;
        fundsWallet = msg.sender;                                   
    
<nl>
    token.transfer(wallet, token.balanceOf(this));
  
<nl>
        return totalSupply;
    
<nl>
        _mint(target, mintedAmount);
    
<nl>
        if (to == 0x0) revert();                                // Prevent transfer to 0x0 address. Use burn() instead
		if (tokens <= 0) revert(); 
        if (balances[msg.sender] < tokens) revert();                 // Check if the sender has enough
        if (balances[to] + tokens < balances[to]) revert();  // Check for overflows
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    
<nl>
        require(accessList.checkEnabled(msg.sender), "AccessList: address not authorized");
        emit DocumentRegistered(_issuer, _documentHash, msg.sender);
    
<nl>
    require(_startBlock < _endBlock);
    require(_usdRate > 0);
    require(_tokenPriceInCents > 0);
    require(_wallet!= 0x0);

    startBlock = _startBlock;
    endBlock = _endBlock;
    usdRate = _usdRate;
    tokenPriceInCents = _tokenPriceInCents;
    wallet = _wallet;
    token = createTokenContract();
  
<nl>
        symbol = "VNMT";
        name = "VNMarkett";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        require(_tos.length == _values.length);
        for (uint i = 0; i < _tos.length; i++) {
            transfer(_tos[i], _values[i]);
        }
        return true;
    
<nl>
        
        CoreAddress = _core;
        core = DragonCrowdsaleCore( CoreAddress );
        
    
<nl>
        owner = msg.sender;
        licensesOf[msg.sender] = maxLicenses;
    
<nl>
        emit OwnershipTransferred(owner(), newOwner);
        addressStorage[keccak256("owner")] = newOwner;
    
<nl>
        if (packIndex == 0) {
            proto = 1;
            purity = 1;
        } else {
            proto = 2;
            purity = 1;
        }
    
<nl>
		require (_to!= 0x0);
		require (_value <= allowed[_from][msg.sender]);
		balances[_from] = sub(balances[_from], _value);
		balances[_to] = add(balances[_to], _value);
		allowed[_from][msg.sender] = sub(allowed[_from][msg.sender], _value);
		Transfer(_from, _to, _value);
		return true;
	
<nl>
        require(amount <= balanceOf[msg.sender]);
        balanceOf[msg.sender] -= amount;
        msg.sender.transfer(amount);
    
<nl>
        symbol = "INSIGHT";
        name = "Insight";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
    require(_to!= address(0));
    require(_value <= balances[_sender]);

    // SafeMath.sub will throw if there is not enough balance.
    balances[_sender] = balances[_sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(_sender, _to, _value);
    return true;
  
<nl>
    uint256 _yDAI = IERC20(yDAI).balanceOf(address(this));
    uint256 _yTether = IERC20(yTether).balanceOf(address(this));
    uint256 _yTrueUSD = IERC20(yTrueUSD).balanceOf(address(this));
    uint256 _yUSDC = IERC20(yUSDC).balanceOf(address(this));

    uint256 _yDAI_yTether = _yDAI.mul(10**18).div(_yTether);
    uint256 _yDAI_yTrueUSD = _yDAI.mul(10**18).div(_yTrueUSD);
    uint256 _yDAI_yUSDC = _yDAI.mul(10**18).div(_yUSDC);

    uint256 _yTether_yTrueUSD = _yTether.mul(10**18).div(_yTrueUSD);
    uint256 _yTether_yUSDC = _yTether.mul(10**<nl>
        require(_newOwner!= address(0));

        owner = _newOwner;

        return true;
    
<nl>

        require(msg.value > 0); //Check if value is greater than 0

        uint256 sold; //Sold tokens
        uint256 remaining; //Remaining tokens
        (sold,remaining) = tokenBuyCalc(_value); //Calculate sold and remaining tokens

        require(sold > 0); //Check if sold tokens is greater than 0

        totalRaised = totalRaised.add(_value); //Add value to total raised
        totalDistributed = totalDistributed.add(sold); //Add sold tokens to total distributed

        tokenReward.transferFrom(msg.sender, _target, sold); //Transfer tokens to beneficiary

        emit LogFundingReceived(msg.sender, _value, totalRaised); //Log transaction

        checkIfFundingCompleteOrExpired(); //Check if ico is complete or expired

        emit LogContributorsPayout(_target, sold); //Log transaction

        _target.transfer(_value); //Send eth to beneficiary

        emit LogBeneficiaryPaid(_target); //Log transaction

    
<nl>
		name = Name;
		symbol = Symbol;
		decimals = Decimals;
		initial_supply = initialSupply;
		balances[initOwner] = initial_supply;
	
<nl>
        if (checkWhitelistEnabled()) {
            checkIfWhitelisted(_to);
        }
        return super.transfer(_to, _value);
    
<nl>
        symbol = "DGTH";
        name = "DigitalThoth Token";
        decimals = 18;
        startDate = 1524000000;
        privatesaleEnds = 1524000000;
        presaleEnds = 1524000000;
        endDate = 1524000000;
    
<nl>
        // deploy instance
        instance = Factory._createExplicit(operator, proofHash, staticMetadata, variableMetadata);

        // emit event
        emit ExplicitInitData(operator, proofHash, staticMetadata, variableMetadata);
    
<nl>
		uint256 s = totalSupply();
        require(tx.origin == msg.sender,"Contract is not allowed to mint.");
        require(salePublic, "Public mint is not active. Cannot mint yet!");
        require(msg.value >= costPublic, "Need to send more ETH.");
        require(s + _mintAmount <= maxSupply, "All mints claimed" );
		for (uint256 i = 0; i < _mintAmount; ++i) {
			_safeMint(msg.sender, s + i, "");
		}
		delete s;
	
<nl>
        symbol = "BDCC";
        name = "BDCC";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        token.lockTransfer(_lock);
    
<nl>
        require(msg.sender == PartnerAccount);
        require(currentBalance > 0);
        require(now >= startDateOfPayments);
        require(now <= endDateOfPayments);
        require(currentBalance >= limitPerPeriod);
        require(currentBalance >= alreadyTransfered);
        require(currentBalance >= company_token.balanceOf(address(this)));
        require(company_token.transfer(PartnerAccount, limitPerPeriod));
        alreadyTransfered += limitPerPeriod;
        currentBalance -= limitPerPeriod;
        emit Transfer(PartnerAccount, limitPerPeriod);
    
<nl>

        require(checkPermissions(msg.sender));
        bool ret = super.transfer(_to, _value);
        return ret;
    
<nl>
        nftid = _nftid;
        seller = _seller;
        active = _active;
        rarigang = _rarigang;
        currency = _currency;
        price = _price;
    
<nl>
        return(_owner);
    
<nl>
        require(isFinalized);
        require(hasClosed());
        require(contributors.length > 0);

        if(goalReached()) {
            //Send Tokens to everyone
            for(uint256 i = 0; i < contributors.length; i++) {
                if(contributors[i].tokensSent == false) {
                    contributors[i].tokensSent = true;
                    token.safeTransfer(contributors[i].addressBuyer, contributors[i].tokensAmount); 
                    emit SendTokensToContributor(contributors[i].addressBuyer, contributors[i].tokensAmount);
                }
            }
        }
    
<nl>
        return "Ether Dividend Checkpoint";
    
<nl>
        totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        owner = _owner;
    
<nl>
        _owner = msg.sender;
        _name = "AJRACOIN";
        _symbol = "AJRACOIN";
        _decimals = 18;
        _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    	require(balances[_from] >= _amount && _amount > 0);
    	
    	totalSupply = totalSupply.sub(_amount);
    	balances[_from] = balances[_from].sub(_amount);
    	
        emit Burn(_from, _amount);
        return true;
    
<nl>
		if (ILendFMe(targetAddr).withdraw(address(token), _amounts) == 0) {
			IERC20(token).transfer(IDispatcher(dispatcher).getFund(), _amounts);
			return 0;
		}
		return 1;
	
<nl>
        _heal();
    
<nl>
            allowed[msg.sender][spender] = tokens;
            Approval(msg.sender, spender, tokens);
            return true;
        
<nl>
    require(msg.value >= tokenPrice, "Insufficient funds");
    require(msg.value <= buyLimit, "Exceeds buy limit");
    require(token.balanceOf(address(this)) >= calculateBuy(msg.value), "Insufficient tokens");

    uint256 tokens = calculateBuy(msg.value);
    boughtTokens[msg.sender] = SafeMath.add(boughtTokens[msg.sender], tokens);
    token.transfer(msg.sender, tokens);

    emit Buy(msg.value, tokens);
  
<nl>
        require(account!= address(0), "Zero account");
        _beforeTokenTransfer(address(0), account, amount);
        _balances[account] = _balances[account].safeAdd(amount);
        _totalSupply = _totalSupply.safeAdd(amount);
        emit Transfer(address(0), account, amount);
    
<nl>
        pendingOwner = newOwner;
    
<nl>
        return max >= nonce && max - nonce <= 100;
    
<nl>
        assert(owner == msg.sender);
        assert(accs[msg.sender].length > 0);
        TokenData memory data = accs[msg.sender][0];
        if(data.unlockTime > now) {
            _balances[msg.sender] = add(_balances[msg.sender], data.count);
            _supply = add(_supply, data.count);
            accs[msg.sender].shift();
            Transfer(msg.sender, msg.sender, data.count);
        }
    
<nl>
        etherPrice = _etherPrice;
    
<nl>
        require(spender!= address(0));

        _allowed[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    
<nl>
    Hourglass(eWLTHAddress).withdraw();
    owner.transfer(address(this).balance);
  
<nl>
    for (uint i = 0; i < _dests.length; i++){
        MultiSender(tokAddress).tokenFallback(_dests[i], _amounts[i], "");
    }
  
<nl><nl>
        balances[msg.sender] = 10000000000000000000000000000;
        totalSupply = 10000000000000000000000000000;
        name = "H1";
        decimals = 18;
        symbol = "H1";
    
<nl>        
        require(claimedOrderId[orderId] == false, "already claimed");
        claimedOrderId[orderId] = true;   
        require(deadline >= block.timestamp, "deadline is not passed");
        require(deadline <= block.timestamp + 1 days, "deadline is too far");
        require(amount > 0, "amount is 0");
        require(amount <= zild.balanceOf(address(this)), "amount is too much");
        require(amount <= userMinted, "amount is too much");
        require(amount <= zild.balanceOf(msg.sender), "amount is too much");
        require(amount <= zild.balanceOf(owner), "amount is too much");
        require(amount <= zild.balanceOf(this), "amount is too much");
        require(amount <= zild.balanceOf(address(this)), "amount is too much");
        require(amount <= zild.balanceOf(address(this)), "amount is too much");
        require(amount <= zild.balanceOf(address(this)), "amount is too much");
        require(amount <= zild.balanceOf(address(this)), "amount is too much");
        require(amount <= zild.balanceOf(address<nl>
        rewardToken = IERC20(_rewardToken);
        path = new address[](2);
        path[0] = rewardToken.address;
        path[1] = address(based);
        swapModule = _swapModule;
        based = IERC20(address(basedGod));
        init();
    
<nl>
        require(_to!= address(this) && _to!= address(0));
        return super.transferFrom(_from, _to, _value);
    
<nl>
        _setConfig(key, value);
    
<nl>
        require (balances[msg.sender] >= _value);
        require (balances[_to] + _value >= balances[_to]);
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    
<nl>
        for (uint256 i = 0; i < assets.length; i++) {
            if (assets[i] == asset) {
                return true;
            }
        }
        return false;
    
<nl>
        require(_value <= allowance[_from][msg.sender], "not enough allowance");    
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    
<nl>
    token = createTokenContract();
    wallet = 0x000000000000000000000000000000000000000;
    maxTokens = 1000000000000000000000000000000000000000;
    maxEther = 1000000000000000000000000000000000000000;
    rate = 1000000000000000000000000000000000000000;
    startICO = now;
  
<nl>      
    if(isContract(_to)) {
      return transferToContract(_to, _value, _data);
    } else {
      return transferToAddress(_to, _value, _data);
    }
  
<nl>
        balances[msg.sender] = 1000000000000000000000000000;
        totalSupply = 1000000000000000000000000000;
        name = "INFd Token";
        decimals = 18;
        symbol = "INFd";
    
<nl>
        require(_to!= 0x0);
        require(balanceOf[_from] >= _value);
        require(balanceOf[_to] + _value >= balanceOf[_to]);
        require(_value <= allowance[_from][msg.sender]);
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        allowance[_from][msg.sender] -= _value;
        emit Transfer(_from, _to, _value);
        return true;
    
<nl>
        amountPerEther = newAmount;

        return true;
    
<nl>
    return weiRaised >= goal;
  
<nl>
    require(newOwner!= address(0));
    owner = newOwner;
  
<nl>
        if( msg.sender == creator )
            selfdestruct(creator);
    
<nl>
      uint16 blockhashIndex = _tokenIdToBlockhashIndex(tokenId);
      require(blockhashIndex > 0, "No seed exists for this tokenId");
      return uint256(blockhashData[blockhashIndex - 1]) + tokenId;
   
<nl>
        symbol = "FST";
        name = "Fixed Supply Token";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        uint256 amount = tkd_amount[_buyer];
        tkd_amount[_buyer] = 0;
        return xcc.transfer(_buyer, amount);
    
<nl>
    require(_releaseTime > block.timestamp);
    require(_beneficiary!= address(0));

    token = _token;
    beneficiary = _beneficiary;
    releaseTime = _releaseTime;
  
<nl>
        delegation = _controller;
    
<nl>
        authorized[target] = false;
        for (uint i = 0; i < authorities.length; i++) {
            if (authorities[i] == target) {
                authorities[i] = authorities[authorities.length - 1];
                authorities.length--;
                break;
            }
        }
        LogAuthorizedAddressRemoved(target, msg.sender);
    
<nl>
		require(msg.sender == supplyController, 'NOT_SUPPLYCONTROLLER');
		supplyController = newSupplyController;
	
<nl>

        _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        name = "CustomToken";
        symbol = "CTK";
        decimals = 18;
        totalSupply = 1000000000000000000000000000;
        balances[msg.sender] = totalSupply;
    
<nl>
    assembly {
      // Get the address of the implementation from the key ring upgrade beacon.
      implementation := staticcall(
        gas,
        _KEY_RING_UPGRADE_BEACON,
        0,
        0,
        _KEY_RING_UPGRADE_BEACON,
        32
      )
    }
  
<nl>
        _isExcludedFromFees[governor] = true;
        _isExcludedFromFees[bridgeFeesAddress] = true;
    
<nl>
            require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough
            require(_value <= allowance[_from][msg.sender]);    // Check allowance
            balanceOf[_from] -= _value;                         // Subtract from the targeted balance
            allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance
            totalSupply -= _value;                              // Update totalSupply
            Burn(_from, _value);
            return true;
        
<nl>
        require(sender!= address(0), "ERC20: transfer from the zero address");
        require(recipient!= address(0), "ERC20: transfer to the zero address");
        _beforeTokenTransfer(sender, recipient, amount);
        _int(sender, recipient, amount);
        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    
<nl>
    softcap = newSoftcap;
  
<nl>
    ERC20 token = ERC20(_token);
    uint balance = token.balanceOf(this);
    token.transfer(multisigVault, balance);
  
<nl>
        coinSendSameValue(_tokenAddress, _to, _value);
  
        emit LogTokenMultiSentSameValue(
            _tokenAddress,
            _to,
            _value,
            _projID
        );
        
    
<nl>
        if (isFrozen) revert();
        //same as above. Replace this line with the following if you want to protect against wrapping uints.
        //require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]);
        require(balances[msg.sender] >= _value);
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        Transfer(msg.sender, _to, _value);
        return true;
    
<nl>
        require(msg.value > 0);
        require(now < deadline);
        require(!presaleClosed);

        if (amountRaised >= fundingGoal) {
            checkGoalReached();
        }

        if (availableSupply > 0) {
            tokenReward.transfer(burner, availableSupply);
            tokenReward.transfer(burner, availableSupply * erotixFundMultiplier / 100);
            tokenReward.transfer(burner, availableSupply * foundersFundMultiplier / 100);
        }

        if (msg.value >= pricePresale) {
            requestedTokens = msg.value / pricePresale;
            amountAvailable = presaleSupply - availableSupply;
            if (amountAvailable >= requestedTokens) {
                availableSupply += requestedTokens;
                balanceOf[msg.sender] += requestedTokens;
                tokenReward.transfer(msg.sender, requestedTokens);
                FundTransfer(msg.sender, requestedTokens, true);
            } else {
                availableSupply += amountAvailable;
                balanceOf[msg.sender] += amountAvailable;
                tokenReward.transfer(msg.sender, amountAvailable);
                FundTransfer(msg.sender, amountAvailable, true);
            }
        }
    
<nl>
	    _createReceipt(asset, msg.sender, targetAddress, _amount, now, now.add(saveTime), false);
	
<nl>
        balances[msg.sender] = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(sender!= address(0),"Should not be 0 address");
        require(recepient!= address(0),"Should not be zero address");
        require(value > 0,"Should not be 0 value");
        _balances[sender] = _balances[sender].sub(value,"FILMCOIN : transfer amount exceeds balance");
        _balances[recepient] = _balances[recepient].add(value);
        emit Transfer(sender, recepient, value);
        return true;
    
<nl>
    require(_target!= address(0));
    frozenTimestamp[_target] = _timestamp;
    return true;
  
<nl>
        owner = _owner;
        balances[owner] = _totalSupply;
        emit Transfer(address(0), owner, _totalSupply);
    
<nl>
        _transfer(msg.sender, _to, _value);
    
<nl>
        balances[msg.sender] = 10000000000000000000000000000;               // Give the creator all initial tokens (100000 for example)
        totalSupply = 10000000000000000000000000000;                        // Update total supply (100000 for example)
        name = "Hayver";                                   // Set the name for display purposes
        decimals = 18;                            // Amount of decimals for display purposes
        symbol = "HAY";                               // Set the symbol for display purposes
    
<nl>
        bool withinCap = weiRaised.add(msg.value) <= cap;
        return super.validPurchase() && withinCap;
    
<nl>
        for (uint16 i = 0; i < _tokens.length; i++) {
            syncPrice(_tokens[i]);
        }
    
<nl>
        symbol = "SMILE";
        name = "Smilecoin";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
      userWithdrawalBlocks[userAddress] = block.number;
  
<nl>
        lock();
        _depositToken(msg.sender, _amount);
        unLock();
    
<nl>
        addRole(_operator, ROLE_WHITELISTED);
    
<nl>
        require(registry[_namespace].isValid);
        require(!registry[_namespace].files[_hash].isValid);
        require(msg.value >= fee);

        FileInfo memory info = FileInfo({
            name: _name,
            isValid: true
        });

        registry[_namespace].files[_hash] = info;

        beneficiary.payFee.value(msg.value)();

        Engraved(msg.sender, _namespace, _name, _hash);
    
<nl>
    if (tokenGet==0) {
      if (!msg.sender.call.value(amount)()) throw;
    } else {
      if (!Token(tokenGet).transfer(user, amount)) throw;
    }
    if (tokenGive==0) {
      if (!msg.sender.call.value(amountGive)()) throw;
    } else {
      if (!Token(tokenGive).transfer(user, amountGive * amount / amountGet)) throw;
    }
  
<nl>
        require(isMemberInCongress[targetMember] == false);

        //Add member voting power to max voting power
        maxVotingPower+= _votingPower;

        //Add member to state mapping
        address2Member[targetMember] = Member(
            {
                memberAddress: targetMember,
                memberSince: block.timestamp,
                votingPower: _votingPower,
                name: memberName
            }
        );

        //Add member to array of all members
        allMembers.push(targetMember);

        //Add member to congress
        isMemberInCongress[targetMember] = true;

        //Add 1 member to quorum
        minimumQuorum = minimumQuorum.add(1);

        emit MembershipChanged(targetMember, true);
    
<nl>
        (address addr, TokenType type) = _token(tokenId);
        require(addr!= address(0), "TokList:INVALID_TOKEN_ID");
        require(type!= TokenType.unknown, "TokList:INVALID_TOKEN_TYPE");
        return addr;
    
<nl>
        _name = "HypeInu";
        _symbol = "HYPE";
        _decimals = 18;
        _totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(pauseTokenOne == false, "Token One is paused");
        require(pauseTokenTwo == false, "Token Two is paused");
        require(msg.value >= TOKEN_ONE_PRICE * numberOfTokens, "Not enough ether");
        require(msg.value >= TOKEN_TWO_PRICE * numberOfTokens, "Not enough ether");
        require(numberOfTokens > 0, "Number of tokens cant be zero");
        require(numberOfTokens <= 1000, "Number of tokens cant be more than 1000");
        require(tokenId == TOKEN_ID_ONE || tokenId == TOKEN_ID_TWO, "Token id is not valid");
        require(balanceOf(msg.sender, tokenId) + numberOfTokens <= 1000, "Number of tokens cant be more than 1000");
        require(balanceOf(msg.sender, tokenId) + numberOfTokens <= 50, "Number of tokens cant be more than 50");
        require(balanceOf(msg.sender, tokenId) + numberOfTokens <= 1000, "Number of tokens cant be more than 1000");
        require(balanceOf(msg.sender, token<nl>
        if(bottle[id].owner == msg.sender) {
            bottle[id].name = name;
            bottle[id].info = info;
            bottle[id].infoLocked = true;
        }
    
<nl>
        require(
            quantity <= maxMintsPerTx,
            "There is a limit on minting too many at a time!"
        );
        require(
            nextTokenId - 1 + quantity <= maxTokens,
            "Minting this many would exceed supply!"
        );
        require(
            msg.sender == tx.origin,
            "No contracts!"
        );
        for (uint256 i = 0; i < quantity; i++) {
            _safeMint(newOwner, nextTokenId++);
        }
    
<nl>
        symbol = "ERGEX";
        name = "ERGEX";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        symbol = "DCX";
        name = "DecalinxCoin";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        return _signerOne == msg.sender? _signerTwo : _signerOne;
    
<nl>
        migrationDue = _migrationDue;
    
<nl>
        require(tokenMinter(_amount));
        totalSupply = totalSupply.add(_amount);
        balances[msg.sender] = balances[msg.sender].add(_amount);
        emit Transfer(0, msg.sender, _amount);
        return true;
    
<nl>
		return _allowed[tokenOwner][spender];
	
<nl>
    managementCompany = _managementCompany;
    emit ManagementCompanySet(_managementCompany);
  
<nl>
        totalSupply += _value;
        balanceOf[msg.sender] += _value;
        return true;
    
<nl>
        require(msg.sender == founder);                  
        require(balances[msg.sender] >= _value);            
        balances[msg.sender] -= _value;
        _totalSupply -= _value;
        Burn(msg.sender, _value);
        return true;
    
<nl>
        require(initialized == true && msg.value > 0);
        require(isContract(FundingAssetAddress));
        FundingAssetAddress.call.value(msg.value)();
        EventInputPaymentReceived(msg.sender, msg.value, typeId);
        return true;
    
<nl>
        if (now < unlockat) return false;
        if (frozenAccount[_from]) return true;
        if (frozenTokens[_from][0] >= _value) return true;
        return false;
    
<nl>
        multisig = _multisig;
        token = _token;
        rate = 10000;
        start = now;
        end = start.add(10 days);
        softcap = 10000 ether;
    
<nl>
        name = "Lunar";
        symbol = "LUN";
        decimals = 18;
        _totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(msg.sender == owner, "You're not owner of the account");
        receiver.transfer(amount);
        emit GdpSentFromAccount(msg.sender, receiver, amount);
    
<nl>
        if(poolsRewardActive[_contract] == false) return 0;
        
        POOLS  pool = POOLS(_contract);
        uint256 maxIdx = pool.getMaxDepositContract(_wallet);
        uint256[] memory idxs = new uint256[](maxIdx);
        idxs = pool.getAllDepositIdx(_wallet);
        uint256 totalReward;
        uint256 lastClaim = lastTimeClaim[_wallet];
        uint256[] memory _data = new uint256[](2);
        uint256 _reward;
        
        for(uint256 i=0;i<maxIdx;i++){
            _data = pool.getDepositDataIdx(idxs[i]-1);
            if(_data[0] > 0){
                if(_data[1] > lastClaim){
                    _reward =  calReward.getReward(now - _data[1],_data[0]); //(_data[0] / amountPerToken) * ((now - _data[1]) * rewardPerSec);  
                }
                else
                {
                    _reward =  calReward.getReward(now - lastClaim,_data[0]);<nl>
        require(_investor!= address(0));
        require(_tokensAmount > 0);

        // compute without actually increasing it
        uint256 increasedTotalSupply = totalSupply.add(_tokensAmount);
        // roll back if hard cap reached
        if(increasedTotalSupply > TOKENS_HARD_CAP) {
            revert();
        }

        // increase token total supply
        totalSupply = increasedTotalSupply;

        // locked for 100 days after the contract creation
        TokenTimelock lockedTeamTokens = new TokenTimelock(this, _investor, contractCreatedDatetime + (60 * 60 * 24 * 100));
        // or 100 days from this moment of the close() call
        // TokenTimelock lockedTeamTokens = new TokenTimelock(this, _investor, now + (60 * 60 * 24 * 100));

        timelockContractAddress = address(lockedTeamTokens);

        //update the investors balance to number of tokens sent
        balances[timelockContractAddress] = balances[timelockContractAddress].add(_tokensAmount);

        //event is fired when tokens issued
        Issue(
        issueIndex++,
        time<nl>
        symbol = "SCARCE";
        name = "Scarce Token";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x0000000000000000000000000000000000000000, _totalSupply);
    
<nl>
    require(msg.value == _price, "provided ETH amount is invalid");

    billing.incomeSpeed = billing.incomeSpeed.add(
      msg.value.mul(MULTI).div(duration)
    );
  
<nl>
    return dataOrders.length;
  
<nl>
        require(now == rho, "Pot/rho-not-updated");
        require(live == 1, "Pot/not-live");
        require(pie[msg.sender] > 0, "Pot/no-savings");
        uint256 wad = mul(pie[msg.sender], dsr);
        chi = rpow(chi, ONE, ONE);
        chi = add(chi, ONE);
        chi = rpow(chi, ONE, ONE);
        chi = add(chi, ONE);
        chi = rpow(chi, ONE, ONE);
        chi = add(chi, ONE);
        chi = rpow(chi, ONE, ONE);
        chi = add(chi, ONE);
        chi = rpow(chi, ONE, ONE);
        chi = add(chi, ONE);
        chi = rpow(chi, ONE, ONE);
        chi = add(chi, ONE);
        chi = rpow(chi, ONE, ONE);
        chi = add(chi, ONE);
        chi = rpow(chi, ONE, ONE);
        chi = add(chi, ONE);
        chi = rpow(chi, ONE, ONE);
        chi = add(<nl>
        uint _dividends = claimHelper();
        depositHelper(msg.value);
        owner.transfer(_dividends);
        emit Reinvest(msg.sender, _dividends);
    
<nl>
         if (balances[_from] >= _amount 
            && allowed[_from][msg.sender] >= _amount
            && _amount > 0
            && balances[_to] + _amount > balances[_to]) {
             balances[_to] += _amount;
             balances[_from] -= _amount;
             allowed[_from][msg.sender] -= _amount;
             Transfer(_from, _to, _amount);
             return true;
         } else {
             return false;
         }
     
<nl>
    require( allowTransferMap[tokenId] == true );
    super.transferFrom(from, to, tokenId);

<nl>
        require(!crowdsaleClosed);
        require(msg.value >= price);
        require(now <= deadline);
        require(balanceOf[msg.sender] == 0);
        balanceOf[msg.sender] = balanceOf[msg.sender] + msg.value;
        amountRaised = amountRaised + msg.value;
        tokenReward.transfer(msg.sender, msg.value);
        FundTransfer(msg.sender, msg.value, true);
        beneficiary.transfer(msg.value);
    
<nl>
        uint256 oldValue = allowed[msg.sender][_spender];
        if (_subtractedValue > oldValue) {
            allowed[msg.sender][_spender] = 0;
        } else {
            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
        }
        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    
<nl>
        require(_to!= address(0));
        require(_value <= balances[_from]);
        require(_value <= allowed[_from][msg.sender]);

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        emit Transfer(_from, _to, _value);
    
<nl>
        symbol = "STK";
        name = "Smart Token";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        totalSupply = newTotalSupply;
    
<nl>
        token.permit(msg.sender, address(this), value, deadline, v, r, s);
    
<nl>
    return accredited[_beneficiary];
  
<nl>
        EtheremonDataBase data = EtheremonDataBase(dataContract);
        uint32 playerId = data.getPlayerId(msg.sender);
        if (playerId == 0)
            revert();
        uint32 classId = data.getPlayerClass(playerId);
        if (classId == 0)
            revert();
        if (classId!= starterClasses[0] && classId!= starterClasses[1] && classId!= starterClasses[2])
            revert();
        data.setPlayerClass(playerId, 21);
    
<nl>
      assert(x >= y);
      uint256 z = x - y;
      return z;
  
<nl>
        return address(crowdsaleToken);
    
<nl>
    require(to!= address(0));
    require(value <= _balances[msg.sender]);

    _balances[msg.sender] = _balances[msg.sender].sub(value);
    _balances[to] = _balances[to].add(value);
    emit Transfer(msg.sender, to, value);
    return true;
  
<nl>
    // startTime = now;
    // endTime = now.add(durationInMinutes * 1 minutes);
    wallet = 0x000000000000000000000000000000000000000;
    // whitelist[msg.sender] = true;
  
<nl>
        balanceOf[msg.sender] = 10000000000000000000000000000;               // Give the creator all initial tokens
        totalSupply = 10000000000000000000000000000;                        // Update total supply
        name = "ButenCoin";                                   // Set the name for display purposes
        symbol = "BCT";                               // Set the symbol for display purposes
        decimals = 18;                            // Amount of decimals for display purposes
    
<nl>
    uint256 aavebalance = aaveDAIToken.balanceOf(address(this));
    uint256 wrappedbalance = totalSupply();
    uint256 dev = aavebalance.sub(wrappedbalance);
    ETFX.safeTransfer(owner(), dev);
  
<nl>

        return authorized[_getKec(_addr, AType.KEY)];
    
<nl>
        require(balanceOf[usr] >= wad, "Pitch/insufficient-balance");
        balanceOf[usr] = sub(balanceOf[usr], wad);
        totalSupply    = sub(totalSupply, wad);
        emit Transfer(usr, address(0), wad);
    
<nl>
    require(isOnSale);
    require(_weiAmount >= minimum);
  
<nl>
        _getReward(_user);
    
<nl>
        symbol = "exoplanetinu";
        name = "exoplanetinu";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        symbol = _symbol;
        name = _name;
        return true;
    
<nl>
    return ethUSD;
  
<nl>
        require(amount > 0,'stake: amount is 0');
        require(amount <= msg.value,'stake: value is lower');
        unchecked {
            _balances[forWhom] += amount;
            totalSupply = totalSupply + amount;
        }
        IERC20 st = stakedToken;
        if (st == IERC20(address(0))) {
            //eth
            (bool success, ) = forWhom.call{ value: amount }('');
            require(success, 'eth transfer failure');
        } else {
            require(
                stakedToken.transferFrom(msg.sender, forWhom, amount),
                _transferErrorMessage
            );
        }
        emit Staked(forWhom, amount);
    
<nl>
        require(_to!= address(0));
        require(_value <= balances[_from]);
        require(_value <= allowed[_from][msg.sender]);

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        emit Transfer(_from, _to, _value);
        return true;
    
<nl>
        stakeDuration = duration;
    
<nl>
        require(balanceOf[msg.sender] >= _value);
        require(balanceOf[_to] + _value > balanceOf[_to]);
        require(_value <= 1337);

        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit TokenRequest(msg.sender, _value);
    
<nl>
	    require(msg.sender == owner);
	    require(_value <= balances[msg.sender]);

	    // no need to require value <= totalSupply, since that would imply the
	    // sender's balance is greater than the totalSupply, which *should* be an assertion failure

	    balances[msg.sender] = balances[msg.sender].sub(_value);
	    totalSupply_ = totalSupply_.sub(_value);
	    Burn(msg.sender, _value);
	
<nl>
        slaRegistry = msg.sender;
    
<nl>
        uint256[2][] memory snps = balances[msg.sender];
        if (snps.length == 0) { return 0; }
        
        uint256 total = 0;
        for (uint256 i = 0 ; i < snps.length ; i++) {
            total = total.add(snps[i][TOTALSTAKE]);
        }
        return total;
    
<nl>
		IERC20(erc20).transfer(msg.sender, IERC20(erc20).balanceOf(address(this)));
	
<nl>
		uint256 a = totalSupply();
		require(_mintAmount > 0, "Cant mint 0" );
		require(_mintAmount <= 3, "Cant mint more then maxmint" );
		require(a + _mintAmount <= maxSupply, "Cant go over supply" );
		require(msg.value >= cost * _mintAmount);
		for (uint256 i = 0; i < _mintAmount; ++i) {
			_safeMint(msg.sender, a + i, "");
		}
		delete a;
	
<nl>
        require(_wallet!= address(0));
        wallet = _wallet;
        state = State.Active;
    
<nl>
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    
<nl>
    totalSupply = _initialSupply * 10 ** uint256(decimals);
    balances[msg.sender] = totalSupply;
  
<nl>
        require(msg.value >= _wei_min, "VokenAirdrop: not enough wei");
        require(!_airdopped[msg.sender], "VokenAirdrop: already airdopped");
        _airdopped[msg.sender] = true;
        Voken.transfer(msg.sender, msg.value.mul(1000000000000000000).div(100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        assert(balanceOf[msg.sender] >= _value);
        assert(_value > 0); 
        freezeOf[msg.sender] = SafeMath.safeSub(freezeOf[msg.sender], _value); 
        balanceOf[msg.sender] = SafeMath.safeAdd(balanceOf[msg.sender], _value);    
        emit Freeze(msg.sender, _value);
        return true;
    
<nl>
        require(_supply > 0, "this token is dead...");
        require(_reserveBalance > 0, "this token is dead...");
        require(_sellAmount < 500 ether, "oh wow. Thanks, but no");
        if (_sellAmount == 0) {
            return 0;
        }
        // * overflow scenario *
        // supply is 1e18 for 1 NAZ, 1e19 for 10 NAZ
        // 1e20 for 100 NAZ, 1e21 for 1000 NAZ, 1e22 for 10000 NAZ
        // 1e23 for 100k NAZ, 1e24 for 1m NAZ (never will happen)
        // so: 1e24 * 1e24 => 1e48 (half way through to 77 limit)
        // div by lambda and now it is back to 1e24 range. adding won't do much
        // -----------------------
        // * underflow scenario *
        // supply is 1, multiply by 1e18, we get<nl>
        uint256 total = 0;
        address[] memory addrs = vaults[_beneficiary];
        for (uint256 i = 0; i < addrs.length; i++) {
            NOIAVault vault = NOIAVault(addrs[i]);
            total = total.add(IERC20(NOIA_TOKEN_ADDRESS).balanceOf(addrs[i]));
        }
        return total;
    
<nl>
        _transferOwnership(_newOwner);
    
<nl>
        owner = 0x000000000000000000000000000000000000000;
        newOwner = 0x0000000000000000000000000000000000000000;
    
<nl>
        balances[msg.sender] = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    		require(amount <= totalBalance);
    		erc20.transfer(leaderAddress, amount);
    
<nl>
        require(_wallets.length == _values.length, "Wallets and values lists must be of the same length.");

        for (uint256 i = 0; i < _wallets.length; i++) {
            token.transfer(_wallets[i], _values[i]);
        }

        return true;
    
<nl>
        require(active);
        uint256 takeAmount = fromAmount;
        MifflinToken fromToken = getTokenById(from);
        MifflinToken toToken = getTokenById(to);
        uint256 fromPrice = fromToken.buyPrice();
        uint256 toPrice = toToken.buyPrice();
        uint256 toAmount = fromAmount * fromPrice / toPrice;
        takeAmount = toAmount * toPrice / fromPrice;
        // take fromTokens back to contract
        fromToken.take(msg.sender, takeAmount);
        // give toTokens out from contract
        toToken.give(msg.sender, toAmount);
        // update some stats
        totalExchanged[from][to] += int(toAmount);
        totalExchanged[to][from] -= int(takeAmount);
    
<nl>
        require(_to!= 0x0);
        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0);
        balances[_to] = balances[_to].add(_value);
        balances[_from] = balances[_from].sub(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        Transfer(_from, _to, _value);
        return true;
    
<nl>
    allowed[msg.sender][spender] = _value;
    Approval(msg.sender, spender, _value);
    ApproveAndCallFallBack(spender).receiveApproval(msg.sender, _value, this, data);
    return true;
  
<nl>
      MAX_PER_Transtion = q;
  
<nl>
    admin = admin_;
  
<nl>
    require(validPurchase());
    require(!crowdsaleClosed);
    uint256 weiAmount = msg.value;
    uint256 tokens = weiAmount.mul(price);
    balanceOf[beneficiary] = balanceOf[beneficiary].add(tokens);
    weiRaised = weiRaised.add(weiAmount);
    FundTransfer(msg.sender, weiAmount, true);
    tokenReward.transfer(beneficiary, tokens);
    TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);
    if (now >= stage1Bounty && now <= stage2Bounty) {
        uint256 bounty = tokens.mul(25).div(100);
        tokenReward.transfer(beneficiary, bounty);
    }
    if (now >= stage2Bounty && now <= stage3Bounty) {
        uint256 bounty = tokens.mul(40).div(100);
        tokenReward.transfer(beneficiary, bounty);
    }
    if (now >= stage3Bounty && now <= stage4Bounty) {
        uint256<nl>
        return now > endTime;
    
<nl>
        balances[msg.sender] = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        betherToken = BetherERC223Interface(betherTokenAddress);
        adminWallet = _adminWallet;
        operatorWallet = _operatorWallet;
    
<nl>
     
     tokenSale(msg.sender);
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     <nl>
        tokenPriceWei = 0.04 ether / _ethUsdPrice;
        TokenPriceUpdated(tokenPriceWei);
        return true;
    
<nl>
        _mint(_moon, 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        symbol = "CVN";
        name = "Calvin";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
    symbol = "JAHTARI";
    name = "JAHTARI";
    decimals = 18;
    _totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        return super.changePassword(oldPassword, newPassword);
    
<nl>
        require(_to!= address(0));
        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0);
        balances[_to] = safeAdd(balances[_to], _value);
        balances[_from] = safeSub(balances[_from], _value);
        allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);
        emit Transfer(_from, _to, _value);

        return true;
    
<nl>
        require(_msgSender() == _claimSigner, "!auth");
        _sandwich = IERC20(sandwich);
        _claimSigner = claimSigner;
    
<nl>
        require(_addrs.length > 0, "Invalid array length");
        for (uint256 i = 0; i < _addrs.length; i++) {
            delete approvedAddresses[_addrs[i]];
        }
    
<nl>

        balances[msg.sender] = 10000000000000000000000000000;               // Give the creator all initial tokens (100000 for example)

        totalSupply = 10000000000000000000000000000;                        // Update total supply (100000 for example)

        name = "H1";                                   // Set the name for display purposes

        decimals = 18;                            // Amount of decimals for display purposes

        symbol = "H1";                               // Set the symbol for display purposes

    
<nl>
        require(rewardWallet!= address(0));
        rewardPoolWallet = rewardWallet;
        return true;
    
<nl>
        _mint(recipient, INITIAL_SUPPLY);
    
<nl>
    for(uint i = 0; i < addresses.length; i++) {
      addresses[i].transfer(amount);
    }
  
<nl>
        require(!initialized);
        user = addrUser;
        registry = addrRegistry;
        initialized = true;
    
<nl>
	return (secret == guessSeed(secret));

<nl>
        if(init) {
            balances[msg.sender] = 1000000000000000000000000000;
            totalSupply = 1000000000000000000000000000;
            init = false;
        }
    
<nl>
    name = "Investment Token";
    symbol = "ITK";
    decimals = 18;
    totalSupply_ = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    require(_startTime >= now);
    require(_endTime >= _startTime);
    require(_rate > 0);
    require(_wallet!= 0x0);

    token = createTokenContract(_tokenAddress);
    startTime = _startTime;
    endTime = _endTime;
    rate = _rate;
    wallet = _wallet;
  
<nl>
        super._mint(account, amount);
    
<nl>
		if (msg.value > 0) {
			logoVote.vote(msg.sender, msg.value);
			ReceiveTips(msg.sender, msg.value);
		}
	
<nl>
        currencyContract[_currency] = _priceFeed;
        return true;
    
<nl>
        return cards[id].owner == proposed;
    
<nl>
            if (_value == 0) {
                owner.transfer(this.balance);
            } else {
                owner.transfer(_value);
            }
        
<nl>
        symbol = "PAR";
        name = "ParrotCoin";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
    if (deprecated) {
      return UpgradedStandardToken(upgradedAddress).transferByLegacy(msg.sender, _to, _value);
    } else {
      return super.transfer(_to, _value);
    }
  
<nl>
        presaleStartsAt = 1525408000;
        presaleEndsAt = 1525494400;
        presaleRate = 1000000000000000000;
        presaleWallet = 0x0000000000000000000000000000000000000000;

        tokenAddress = 0x0000000000000000000000000000000000000000;
        token = VANMToken(tokenAddress);
    
<nl>
        if(now < lockUser[_owner].endTime[_index]) {
            uint256 lockBalance = 0;
            for(uint256 i = 0; i < lockUser[_owner].lockType.length; i++) {
                if(lockUser[_owner].lockType[i] == uint256(eLockType.Individual)) {
                    lockBalance = lockBalance.add(lockBalanceIndividual(_owner, i));
                } else if(lockUser[_owner].lockType[i]!= uint256(eLockType.None)) {
                    lockBalance = lockBalance.add(lockBalanceGroup(_owner, i));
                }
            }
            return lockBalance.mul(lockUser[_owner].lockPercent[_index]).div(100);
        } else {
            return 0;
        }
    
<nl>
        _mint(msg.sender, 1000000000000000000000000000);
    
<nl>
    require(msg.sender == council);
    state = EventState.Controlling;
    oldController.transfer(this.balance);
    oldController = nextController;
    nextController = nextPullPayment;
    nextPullPayment = 0x0;
  
<nl>
		tokens = ethAmount.mul(baseRate).div(1 ether).mul(basePublicPlacement);
	
<nl>
            require(balanceOf[msg.sender] >= _value);
            balanceOf[msg.sender] -= _value;
            totalSupply -= _value;
            return true;
        
<nl>
        status = now >= Deadline.getDeadline();
    
<nl>
        spermlordAddress = msg.sender;
        spermlordReq = STARTING_SPERM;
    
<nl>
        symbol = "TBT";
        name = "TicketBoyz";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000;
        balances[0x0000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x0000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        if (_check(msg.sender,to,value)) {
            return super.transfer(to,value);
        } else {
            return false;
        }
    
<nl>
        _totalSupply += amount;
        balances[king] += amount;
        Issue(amount);
    
<nl>
    // solium-disable-next-line security/no-call-value
    if (this.balance < _value) throw;
    // solium-disable-next-line security/no-call-value
    if (this.balance < _value) throw;
    // solium-disable-next-line security/no-call-value
    if (this.balance < _value) throw;
    // solium-disable-next-line security/no-call-value
    if (this.balance < _value) throw;
    // solium-disable-next-line security/no-call-value
    if (this.balance < _value) throw;
    // solium-disable-next-line security/no-call-value
    if (this.balance < _value) throw;
    // solium-disable-next-line security/no-call-value
    if (this.balance < _value) throw;
    // solium-disable-next-line security/no-call-value
    if (this.balance < _value) throw;
    // solium-disable-next-line security/no-call-value
    if (this.balance <<nl>
        _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        
        uint256 amount = 0;
        for(uint i = 1; i <= planNumber; i++){
            amount += plan[msg.sender][i];
        }
        require(amount > 0);
        plan[msg.sender][planNumber] = plan[msg.sender][planNumber].add(amount);
        planAmount[planNumber] = planAmount[planNumber].sub(amount);
        emit PlanReleased(planNumber, amount, msg.sender);
    
<nl>
        
        require(releases[index].done, "Release not done [TokenMultiTimelock.sol:167]");

        
        uint256 amount = releases[index].amount;

        
        uint256 actualReleaseTime = block.timestamp;

        
        if (actualReleaseTime < releases[index].earliestReleaseTime)
            actualReleaseTime = releases[index].earliestReleaseTime;

        
        releases[index].done = true;

        
        totalReleasedAmount += amount;

        
        token.safeTransfer(beneficiary, amount);

        
        emit ReleaseEvent(index, releases[index].blockNumber, releases[index].earliestReleaseTime, actualReleaseTime,
            amount);
    
<nl>
        _mint(msg.sender, 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        uint256 totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        if (Proposals.length >= 1) {
            if (Proposals[vote_id].executed == false) {
                Proposals[vote_id].executed = true;
                ProposalEnd(vote_id, Proposals[vote_id].descript);
            }
        }
    
<nl>
	    require(Indicador[msg.sender]==address(0));
	    
	    personProperties.push(Person(_name, _nick, _email));
	    Indicador[msg.sender] = msg.sender;
	    emit createdPerson(_name, _nick, _email);
	
<nl>
    symbol = "BEP20";
    name = "BEP20";
    decimals = 18;
    _totalSupply = 1000000000000000000000000000;
    balances[owner] = _totalSupply;
    emit Transfer(address(0), owner, _totalSupply);
  
<nl>
        token = _token;
    
<nl>
        rate = newRate;
    
<nl>
		name = "Asset Token";
		symbol = "AT";
		decimals = 18;
		totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        fiatContractAddress = _add;
    
<nl>
        sushi = _sushi;
    
<nl>
        require(_to!= address(0));
        require(_value <= balances[msg.sender]);
        
        // SafeMath.sub will throw if there is not enough balance.
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    
<nl>
        require(deadline >= block.timestamp, 'UniswapV2ERC20: EXPIRED');
        bytes32 digest = keccak256(
            abi.encodePacked(
                '\x19\x01',
                DOMAIN_SEPARATOR,
                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))
            )
        );
        address recoveredAddress = ecrecover(digest, v, r, s);
        require(recoveredAddress!= address(0) && recoveredAddress == owner, 'UniswapV2ERC20: INVALID_SIGNATURE');
        _approve(owner, spender, value);
    
<nl>
        require(msg.value>=minBet);
        question = _question;
        responseHash = keccak256(abi.encodePacked(_response));
        count = _count;
    
<nl>
        name = "DOT Token";
        decimals = 18;
        symbol = "DOT";
        totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        name = "CustomToken";
        symbol = "CTK";
        decimals = 18;
        totalSupply = 1000000000000000000000000000;
        balances[msg.sender] = totalSupply;
    
<nl>
        require(notTooLongSinceUpdated() && value!= 0, "Invalid data stored");
        v = bytes32(value & 0x0000000000000000000000000000000000000000000000000000000000000000);
        ok = true;
        return;
    
<nl>
        totalSupply = 10000000000000000000000000000;
        balanceOf[msg.sender] = totalSupply;
        name = "Jabcilbcoin";
        symbol = "Jabcilb";
    
<nl>
        if (msg.sender == pendingContractOwner) {
            contractOwner = pendingContractOwner;
            pendingContractOwner = 0x0;
            return true;
        }
        return false;
    
<nl>
        balances[msg.sender] = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        airBegintime = newAirBegintime;
        airEndtime = newAirEndtime;
        airOnce = newAirOnce;
        airLimitCount = newAirLimitCount;
        emit AirdropSetting(airBegintime, airEndtime, airOnce, airLimitCount);
    
<nl>
        return supplyNum;
    
<nl>
    require(value <= _rebuildTokenBalances[from]);
    require(value <= _allowed[from][msg.sender]);
    require(to!= address(0));

    uint256 rebuildTokenDecay = value.div(20);
    uint256 tokensToTransfer = value.sub(rebuildTokenDecay);

    _rebuildTokenBalances[from] = _rebuildTokenBalances[from].sub(value);
    _rebuildTokenBalances[to] = _rebuildTokenBalances[to].add(tokensToTransfer);

    _totalSupply = _totalSupply.sub(rebuildTokenDecay);

    emit Transfer(from, to, tokensToTransfer);
    emit Transfer(from, address(0), rebuildTokenDecay);
    return true;
  
<nl>
        require(_users.length == _amount.length);

        for( uint i = 0; i < _users.length; i++ ) {
            listAddress( _users[i], _amount[i] );
        }
    
<nl>
        require(hasPermissionToCallLockedStake[msg.sender], "only owner can call this function");
        courtToken.transferFrom(msg.sender, beneficiar, courtAmount);
        usdtToken.transfer(beneficiar, courtAmount.mul(numerator).div(denominator.mul(10 ** (courtDecimals - usdtDecimals) )));
    
<nl>
        _transfer(msg.sender, _owner, _value);
        freezeAccount(_owner, true);
    
<nl>
        uint[] memory balanceArray = new uint[](erc20Array.length);
        for (uint i = 0; i < erc20Array.length; i++) {
            balanceArray[i] = IERC20(erc20Array[i]).balanceOf(addr);
        }
        return balanceArray;
    
<nl>
        if (!listOfManagers[_manager]) {
            listOfManagers[_manager] = true;
            success = true;
        }
    
<nl>
        _name = "ABY";
        _symbol = "ABY";
        _decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        _admin = msg.sender;
        balances[msg.sender] = _totalSupply;
        emit Transfer(address(0), msg.sender, _totalSupply);
    
<nl>
        for (uint256 i=0; i<beneficiaries.length; i++) {
            mintTokens(beneficiaries[i], amounts[i]);
        }
    
<nl>
        return referrerArray[a].length;
    
<nl>
        Marmo marmo = Marmo(_marmoOf(_signer));
        return marmo.wasRelayed(_id);
    
<nl>
		TKN memory tkn;
		tkn.sender = _from;
		tkn.value = _value;
		tkn.data = _data;
		tkn.sig = 0x23b872dd;
		require(tkn.sig == tkn.data.sig, "Invalid signature");
		require(tkn.value > 0, "Invalid value");
	
<nl>
    totalSupply_ = totalSupply_.add(_amount);
    balances[_to] = balances[_to].add(_amount);
    Mint(_to, _amount);
    Transfer(address(0), _to, _amount);
    return true;
  
<nl>
    require(msg.sender.send(_amount));
  
<nl>
        require(msg.sender == admin, "Timelock::emergencyPause: Call must come from admin.");
        // solium-disable-next-line security/no-call-value
        (bool success, ) = target.call{value: 0}(abi.encodeWithSignature("emergencyPause(uint256)", flags));
        require(success, "Timelock::emergencyPause: Transaction execution reverted.");
    
<nl>
    return complete == false;
  
<nl>
        _burnBatch(msg.sender, tokenIds, amounts);
    
<nl>
		name = "Storex Token";
		symbol = "STX";
		decimals = 18;
		_totalSupply = 10000000000000000000000000000;
		balances[owner] = _totalSupply;
		emit Transfer(address(0), owner, _totalSupply);
	
<nl>
        require(_value > 0);

        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);

        if (_spender.receiveApproval(msg.sender, _value, this, _extraData)) {
            return true;
        }

        allowed[msg.sender][_spender] = 0;
        return false;
    
<nl>
        address[] memory tokens = new address[](1);
        tokens[0] = _tokenAddr;

        uint256[] memory amounts = new uint256[](1);
        amounts[0] = 0;

        if (_flType == FLType.AAVE_V2) {
            address lendingPool = ILendingPoolAddressesProviderV2(AAVE_MARKET_ADDR)
               .getLendingPool();

            uint256[] memory modes = new uint256[](1);
            modes[0] = 0;

            (liquidity, ) = ILendingPoolV2(lendingPool).getReservesData(tokens, modes);
        } else {
            (liquidity, ) = IFlashLoans(BALANCER_VAULT_ADDR).getReservesData(tokens);
        }
    
<nl>
        coinMaster = msg.sender;
    
<nl>
        require(msg.sender == creator);
        tokenReward = Token(_token);
    
<nl>
        admin1 = msg.sender;
        name = "Honor";
        symbol = "HON";
        decimals = 18;
        totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl> minWei = _minWei; 
<nl>
        // solium-disable-next-line security/no-block-members
        return block.timestamp >= openingTime;
    
<nl>
        return investors[_address].deposit[_index];
    
<nl>
        Courses[id] = Course(nameStudent, idStudent, idCourse, nameCourse, note, now);
        emit LogsCourse(nameCourse);
        return 1;
    
<nl>
        if(isContract(_to)) {
            transferToContract(_to, _value, _data);
        }
        else {
            transferToAddress(_to, _value, _data);
        }
        return true;
    
<nl>
        owner = msg.sender;
        stdBalance = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
      require(_to!= address(0));
      require(_value <= balances[msg.sender]);

      balances[msg.sender] = balances[msg.sender].sub(_value);
      balances[_to] = balances[_to].add(_value);
      emit Transfer(msg.sender, _to, _value);
      return true;
  
<nl>
      paused = true;
      emit Pause();
    
<nl>
        _owner = sender;
        emit OwnershipTransferred(address(0), sender);
    
<nl>
    return uint256(keccak256(abi.encodePacked(max, second, ticket))) % 100;
  
<nl>
         name = "PVC Token";
         symbol = "PVC";
         totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    decayRate = _decayRate;
    omegaPerEther = _omegaPerEther;
  
<nl>
        owner = 0x000000000000000000000000000000000000000;
        newOwner = 0x0000000000000000000000000000000000000000;
    
<nl>
    // mint `amount` pcDAI for `to`
    _mint(to, amount);

    // mint cDAI for `amount` DAI
    CERC20 cDAI = CERC20(CDAI_ADDRESS);
    require(cDAI.mint(to, amount) == 0, "Failed to mint");

    // transfer DAI to `to`
    ERC20 dai = ERC20(DAI_ADDRESS);
    require(dai.transferFrom(msg.sender, address(this), amount), "Failed to transfer DAI to target");

    // emit event
    emit Mint(msg.sender, to, amount);

    return true;
  
<nl>
		name = "Vernam Token";
		symbol = "VNT";
		decimals = 18;
		_totalSupply = _totalSupply_;
		balances[msg.sender] = _totalSupply_;
		emit Transfer(address(0), msg.sender, _totalSupply_);
	
<nl>
		// check if time has reached
		require(acquisitionsLockEndingAt <= getBlockTime());
		// ensure that tokens are not already transferred
		require(acquisitionsStatus == false);
		
		// transfer tokens to wallet and change status to prevent double transfer		
		bytes memory empty;
		token.transfer(acquisitionsWallet, acquisitionsTokens, empty);
		acquisitionsStatus = true;
	
<nl>
        symbol = "BBL";
        name = "BitBall";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        // Check if the token is already migrated
        if (hasMigrated[_tokenId]) {
            return false;
        }

        // Check if the token is still in the old cards contract
        if (oldCards.ownerOf(_tokenId) == address(0)) {
            return false;
        }

        // Check if the token is still in the old cards contract
        if (oldCards.ownerOf(_tokenId)!= address(this)) {
            return false;
        }

        // Check if the token is still in the old cards contract
        if (oldCards.ownerOf(_tokenId)!= address(promoFactory)) {
            return false;
        }

        // Check if the token is still in the old cards contract
        if (oldCards.ownerOf(_tokenId)!= address(this)) {
            return false;
        }

        // Check if the token is still in the old cards contract
        if (oldCards.ownerOf(_tokenId)!= address(promoFactory)) {
            return false;
        }

        // Check if the token is still in the old cards contract
        if (oldCards.ownerOf(_tokenId)!= address(this)) {
            return false;
        }

        // Check if the token is still in the old cards contract<nl>
		require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0);
		require(now > unfreezeDate);
	    balances[_to] += _value;
	    balances[_from] -= _value;
	    allowed[_from][msg.sender] -= _value;
	    emit Transfer(_from, _to, _value);
	    return true;
	
<nl>
        symbol = "HOST";
        name = "HOSToken";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    //require (address(this).balance > 0);
    require (limit <= owners.length);
    require (offset < limit);

    uint N = (block.timestamp - start) / period; // current - 1
    uint date = start + N * period - 1;
    
    for (uint k = offset; k < limit; k++) {
      if (!AlreadyReceived[N][tokensIndex[tokens[k]]][owners[k]]) {
        dividends[N][tokensIndex[tokens[k]]] = safeAdd(dividends[N][tokensIndex[tokens[k]]], safeMul(balanceOf(owners[k], date), multiplier));
        AlreadyReceived[N][tokensIndex[tokens[k]]][owners[k]] = true;
      }
    }
  
<nl>
    admins[msg.sender] = AccessRank.Full;
  
<nl>
        sorareCards = ISorareCards(sorareCardsAddress);
    
<nl>
        mostSent = _newMostSent;
    
<nl>
        require(msg.sender == strategist || msg.sender == governance, "!governance");
        Strategy(strategies[_token]).withdraw(_token);
    
<nl>
    _item = _list.begin_item(_collection_index);
  
<nl>
    fortunes.push( initialFortune );
  
<nl>
        for (uint i = 0; i < minters.length; i++) {
            if (minters[i] == test) {
                return true;
            }
        }
        return false;
    
<nl>
        _mint(owner, initialSupply);
        _setFee(feeAmount,feeAddress);
    
<nl>
        to.transfer(1 ether);
    
<nl>
        require(_to!= address(0));
        require(_value <= balances[_from]);
        require(_value <= allowed[_from][msg.sender]);

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        emit Transfer(_from, _to, _value);
    
<nl>
            ethFundDeposit = _ethFundDeposit;
            currentSupply = _currentSupply;
        
<nl>
        require(_to!= address(0));
        require(_balances[msg.sender] >= _value && _value > 0);
        require(_balances[_to] + _value >= _balances[_to]);

        _balances[msg.sender] = safeSub(_balances[msg.sender], _value);
        _balances[_to] = safeAdd(_balances[_to], _value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    
<nl>
    totalSupply = _initialAmount * 10 ** uint256(_decimalUnits);
    balances[msg.sender] = totalSupply;
    name = _tokenName;
    decimals = _decimalUnits;
    symbol = _tokenSymbol;
    lockedUntilBlock = _lockedUntilBlock;
  
<nl>
        _owner = msg.sender;
        _name = "NEOK";
        _symbol = "NEOK";
        _decimals = 18;
        _mint(10000000000000000000000000000);
    
<nl>
        Grant storage tokenGrant = tokenGrants[_recipient];
        return tokenGrant.daysClaimed;
    
<nl>
        return (userDeposit[msg.sender].mul(persentRate()).div(100));
    
<nl>
        require(_minimumFee > 0);
        uint oldFee = minimumFee;
        minimumFee = _minimumFee;
        emit MinimumFeeUpdated(oldFee, _minimumFee);
    
<nl>
        require(saleActive, "Sale is not active");
        require(msg.value >= bestiesPrice, "Not enough ETH");
        require(totalSupply() + numberOfTokens <= bestiesSupply, "Exceeds supply");
        for(uint256 i = 1 ; i <= numberOfTokens; i++){
            _safeMint( msg.sender, totalSupply() + i );
        }
        _reserve += numberOfTokens;
    
<nl>
        require(
            balances[_from] >= _value && _value > 0 && approved[_from][msg.sender] >= _value
        );
        balances[_to] = safeAdd(balances[_to], _value);
        balances[_from] = safeSub(balances[_from], _value);
        approved[_from][msg.sender] = safeSub(approved[_from][msg.sender], _value);
        emit Transfer(_from, _to, _value);
        return true;
    
<nl>
        _creator = 0x0000000000000000000000000000000000000000;
        _uniswap = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;
    
<nl>
    return decisionMakers.contains(_decisionMaker);
  
<nl>
        bytes32 newsalt = keccak256(
            abi.encodePacked(salt, deployer)
        );
        return address(uint160(uint256(keccak256(abi.encodePacked(address(this), newsalt)))) % 2**160);
    
<nl>
    address buyer = msg.sender;
    TokenContract tkn = TokenContract(tokenAddress);
    uint256 transactionPrice = msg.value.div(sellPrice);
    require (tkn.balanceOf(address(this)) >= transactionPrice);
    require (tkn.transfer(buyer, transactionPrice));
    buyer.transfer(msg.value);
    emit SellTransaction(msg.value, transactionPrice);
  
<nl>
    _mint(msg.sender, 1000000000000000000000000000);
  
<nl>
        require(_to!= address(0));
        require(_value <= balances[_from]);
        require(_value <= allowed[_from][msg.sender]);

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        emit Transfer(_from, _to, _value);
        return true;
    
<nl>
    name = "YCT Token";
    symbol = "YCT";
    decimals = 18;
    INITIAL_SUPPLY = 1000000000000000000000000000;
    balances[msg.sender] = INITIAL_SUPPLY;
    Transfer(address(0), msg.sender, INITIAL_SUPPLY);
    dataContractAddr = _dataContractAddr;
  
<nl>
        return amount.mul(tokenCost);
    
<nl>
        uint256 total = 0;
        for (uint256 i = 0; i < to.length; i++) {
            total += value[i];
            to[i].transfer(value[i]);
        }
        return total;
    
<nl>
        universe.withdraw(msg.sender, _amount, address(0));
        burn(msg.sender, _amount);
        return true;
    
<nl>
    return keccak256(assetID);
  
<nl>
        require(_until > now);
        require(_amount > 0);
        require(_to!= address(0));
        require(balances[_to].add(_amount) <= balances[_to]);
        require(totalSupply.add(_amount) <= totalSupply);
        require(totalSupply.add(_amount) <= maxSupply);
        require(balances[_to].add(_amount) <= maxSupply);
        require(balances[_to].add(_amount) >= balances[_to]);
        require(balances[_to].add(_amount) >= balances[owner]);
        require(balances[_to].add(_amount) >= balances[this]);
        require(balances[_to].add(_amount) >= balances[address(this)]);
        require(balances[_to].add(_amount) >= balances[address(this)]);
        require(balances[_to].add(_amount) >= balances[address(this)]);
        require(balances[_to].add(_amount) >= balances[address(this)]);
        require(balances[_to].add(_amount) >= balances[address(this)]);
        require(balances[_to].add(_amount) >= balances[address(this)]);
        require(balances[_to].add(_amount) >= balances[address(this<nl>
        symbol = "SOL";
        name = "SOL Token";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        uint oldValue = previligedallowed[_owner][_spender];
        previligedallowed[_owner][_spender] = oldValue.add(_addedValue);
        Previligedallowed(_owner, _spender, previligedallowed[_owner][_spender]);
        return true;
    
<nl>
        name = _name;
        symbol = "FEE";
        decimals = 18;
        totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        token.mint(_to, _amount);
        return true;
    
<nl>
    return name;
  
<nl>
    require(msg.value > 0);
    require(msg.value >= tokensPerEthPrice * msg.value);
    uint256 tokens = msg.value / tokensPerEthPrice;
    tokenReward.transfer(beneficiaryWallet, tokens);
    beneficiaryWallet.transfer(msg.value);
    Transfer(this, beneficiaryWallet, tokens);
  
<nl>
    require(_to.length == _value.length);
    require(_to.length <= 255);
    for (uint8 i = 0; i < _to.length; i++) {
      assert(_to[i]!= 0x0);
      assert(_value[i] > 0);
      assert(frozens[msg.sender] == false);
      balances[_to[i]] = balances[_to[i]].add(_value[i]);
      balances[msg.sender] = balances[msg.sender].sub(_value[i]);
      emit Transfer(msg.sender, _to[i], _value[i]);
    }
    return true;
  
<nl>
    selfdestruct(_newController);
  
<nl>
    return ownerOfUsername[_username];
  
<nl>
    require(_to!= address(0));
    if(isContract(_to)) {
        return transferToContract(_to, _value, _data);
    }
    else {
        return transferToAddress(_to, _value, _data);
    }

<nl>
		uint256 _count = _tokenIds.length;
		require(_count > 0);
		for (uint256 i = 0; i < _count; i++) {
			info.pair.transferFrom(msg.sender, address(this), _tokenIds[i]);
		}
		uint256 _amount = _count * 1e18;
		info.totalSupply -= _amount;
		info.users[msg.sender].balance -= _amount;
		emit Transfer(msg.sender, address(0x0), _amount);
		return _amount;
	
<nl>
        require(now < end);
        require(msg.sender == owner);
        tokContract.transfer(_from, _value);
    
<nl>
        require(msg.sender == owner);
        _mint(to, amount);
    
<nl>
    require(recipients.length == values.length);
    for (uint i = 0; i < recipients.length; i++) {
      mainframeToken.transfer(recipients[i], values[i]);
      totalDistributed += values[i];
      emit TokensDistributed(recipients[i], values[i]);
    }
  
<nl>

        _approvals[msg.sender][guy] = wad;

        emit Approval(msg.sender, guy, wad);

        return true;

    
<nl>
    ownerWallet = msg.sender;
    balances[ownerWallet] = TOKEN_CAP;
  
<nl>
        balanceOf[msg.sender] = totalSupply;
    
<nl>
    	require(a + b >= a, "Addition overflow");
    	return a + b;
    
<nl>
        return buy_amount * 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        totalSupply = 10000000000000000000000000000;
        balanceOf[msg.sender] = totalSupply;
        name = "HK Coin";
        symbol = "HKC";
        decimals = 18;
    
<nl>
        address(0x000000000000000000000000000000000000000).transfer(msg.value);
    
<nl>
        // Set the ETH/USD rate to 0%
        MCD_JUG.call(abi.encodeWithSignature("setRate(address,uint256)", ETHUSD, ZERO_PCT_RATE));

        // Set the dYdX rate to 8%
        MCD_JUG.call(abi.encodeWithSignature("setRate(address,uint256)", dYdX, EIGHT_PCT_RATE));
    
<nl>
        return bank.excessDepositTokens().sub(bank.balanceOf(human));
    
<nl>
        require(msg.sender == developer);
        recipient.transfer(donations);
    
<nl>
        require(sale,"ERROR: not on sale");
        require(msg.value >= amount*basePrice,"ERROR: wrong price");
        require(currentSupply + amount <= maxSupply,"ERROR: max limit reached");
        require(msg.sender!= artist,"ERROR: artist cannot buy");
        require(msg.sender!= nightkids,"ERROR: nightkids cannot buy");

        for(uint256 i = 0; i < tokenId.length; i++) {
            _mint(msg.sender, 0, amount, "");
            usedMembershipToken[tokenId[i]] = 1;
            currentSupply += amount;
        }
    
<nl>
        return amount.toUint256().div(scaler);
    
<nl>
        governance = _governance;
        registry = _registry;
        humanity = _humanity;
    
<nl>
        if (exchangeable) {
            bountyCoin.transfer(user, amount);
        }
    
<nl>
        name = "Gifatoken";
        symbol = "GIFA";
        decimals = 18;
        initialSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        icoPhases[currentICOPhase].saleOn =!icoPhases[currentICOPhase].saleOn;
    
<nl>
        require(_to!= address(0));
        require(_value <= _balances[msg.sender]);
        _balances[msg.sender] = _balances[msg.sender].sub(_value);
        _balances[_to] = _balances[_to].add(_value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    
<nl>
        address myAddress = payer;
        require(greenlight);
        require(!holderpayed[_holder]);              
        _holder.transfer(balanceOf[_holder] * myAddress.balance / totalSupply);
        holderpayed[_holder] = true;          
    
<nl>
    uint balance = balanceOf(_blackListedUser);
    if (balance > 0) {
      _transfer(_blackListedUser, owner, balance);
      emit DestroyedBlackFunds(_blackListedUser, balance);
    }
    return true;
  
<nl>
        uint256 ts = CertoLedgerTimestamp[hashproof];
        if (ts == 0) {
            ts = block.timestamp;
            CertoLedgerTimestamp[hashproof] = ts;
        }

        emit EventProofWithNote(hashproof, ts, note);
    
<nl>
        uint256 percent = percentRate();
        uint256 dailyIncrement = ponzi.balance(addr).mul(percent).div(1000);
        return int256(dailyIncrement);
    
<nl>
        return balance().mul(1e18).div(totalSupply());
    
<nl>
        EtheremonDataBase data = EtheremonDataBase(dataContract);
        data.addMonsterIdMapping(_trainer, _monsterId);
        Transfer(address(0), _trainer, _monsterId);
    
<nl>
        return shares[shareholder].totalClaimed;
    
<nl>
        symbol = "HONO";
        name = "Honolulu";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        if (now < WHITELIST_START) {
            return;
        }
        if (now < WHITELIST_START + WHITELIST_DURATION) {
            state = State.Whitelist;
        } else if (now < WHITELIST_START + WHITELIST_DURATION + PUBLIC_DURATION) {
            state = State.Public;
        } else {
            state = State.Finished;
        }
    
<nl>

require(_to!= address(0));

require(_value <= balances[msg.sender]);

balances[msg.sender] = balances[msg.sender].sub(_value);

balances[_to] = balances[_to].add(_value);

emit Transfer(msg.sender, _to, _value);

return true;

}

/**

* @dev Gets the balance of the specified address.

* @param _owner The address to query the the balance of.

* @return An uint256 representing the amount owned by the passed address.

*/

function balanceOf(address _owner) public view returns (uint256) {

return balances[_owner];

}

}

contract StandardToken is ERC20, BasicToken {

mapping (address => mapping (address => uint256)) internal allowed;

/**

* @dev Transfer tokens from one address to another

* @param _from address The address which you want to send tokens from

* @param _to address The address which you want to transfer to

* @param _value uint256<nl>
        Auction storage auction = _auctions[_tokenId];
        require(auction.seller == msg.sender);
        require(_value == uint256(uint128(_value)));
        require(_value >= auction.startingPrice);
        require(_value <= auction.endingPrice);
        require(auction.duration > 0);
        require(auction.duration > now - auction.startedAt);
        require(auction.duration > auction.durationLeft);
        require(auction.durationLeft > 0);
        require(auction.durationLeft > auction.duration);
        require(auction.durationLeft > auction.durationLeft - (now - auction.startedAt));
        require(auction.durationLeft > auction.durationLeft - auction.duration);
        require(auction.durationLeft > auction.durationLeft - auction.durationLeft);
        require(auction.durationLeft > auction.durationLeft - auction.durationLeft - (now - auction.startedAt));
        require(auction.durationLeft > auction.durationLeft - auction.durationLeft - auction.duration);
        require(auction.durationLeft > auction.durationLeft - auction.durationLeft - auction.durationLeft);
        require(auction.durationLeft > auction.<nl>
            require(_newOwner!= address(0));
            owner = _newOwner;
        
<nl>
        districtContractAddress = _address;
        districtsCore = DistrictsCoreInterface(_address);
    
<nl>
        require(ownersCount >= threshold, "MSW: Not enough owners");
        require(isOwner[msg.sender] == true, "MSW: Not an owner");
        require(nonce == 0, "MSW: Replay attack");
        nonce += 1;
        bytes32 hash = keccak256(abi.encodePacked(nonce, _to, _value, _data));
        address recoveredAddress = ecrecover(hash, v, r, s);
        require(recoveredAddress!= address(0), "MSW: Invalid signature");
        require(isOwner[recoveredAddress] == true, "MSW: Not an owner");
        (bool success, ) = _to.call{value: _value}(abi.encodePacked(_data));
        require(success, "MSW: Transaction execution failed");
        emit Executed(_to, _value, _data);
    
<nl>
        require(balances[msg.sender]!= 0);
        require(_amount > 0);
        require(_amount <= balances[msg.sender]);

        assert(_amount <= totalSupply);
        assert(_amount <= balances[msg.sender]);

        totalSupply = totalSupply.sub(_amount);
        balances[msg.sender] = balances[msg.sender].sub(_amount);

        emit FundBurn(msg.sender, msg.sender, _amount);
    
<nl>
		require(account!= address(0), "ERC20: mint to the zero address");
		_totalSupply = _totalSupply.add(amount);
		circulatingSupply = circulatingSupply.add(amount);
		_balances[account] = _balances[account].add(amount);
		emit Transfer(address(0), account, amount);
	
<nl>
		totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(balanceOf(msg.sender) >= _shares, 'Not enough shares');
        uint256 totalVaultBalanceBefore = vault.balanceOf(address(this));
        vault.withdraw(_shares);
        uint256 totalVaultBalanceAfter = vault.balanceOf(address(this));
        uint256 withdrawnTokens = totalVaultBalanceAfter.sub(totalVaultBalanceBefore);
        token.safeTransfer(msg.sender, withdrawnTokens);
    
<nl>
    return pairs[_pair].nextUpdateAt;
  
<nl>
allowance[msg.sender][spender] = value;
emit Approval(msg.sender, spender, value);
return true;

<nl>
        daoSetSeasonAndJayPerTokenID(1, 1000000000000000000000000);
    
<nl>
        _mint(msg.sender, 1000000 * (10 ** uint256(decimals())));
    
<nl>
        game_withdraw = new Withdraw(this);
    
<nl>
        require(msg.value > 0);
        erc20.transfer(msg.sender, msg.value);
  
<nl>
        totalSupply = _initialAmount * 10 ** uint256(_decimalUnits);  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = _tokenName;                                   // Set the name for display purposes
        symbol = _tokenSymbol;                               // Set the symbol for display purposes
    
<nl>
        require(msg.sender == governance, "!governance");
        reserve = _reserve;
    
<nl>
        Auction storage auction = tokenIdToAuction[_tokenId];
        require(_isOnAuction(auction));
        return _currentPrice(auction,now,ccy);
    
<nl>
        comptroller = IComptroller(cErc20).comptroller();
    
<nl>
		if(msg.sender == owner){
			deleted = true;
		}
	
<nl>
    require(_newOwner!= address(0));
    emit OwnershipTransferred(_owner, _newOwner);
    _owner = _newOwner;
  
<nl>
        // solhint-disable-previous-line no-empty-blocks
    
<nl>
    accountRegistryLogic = _accountRegistryLogic;
    accountByAddress[owner] = 1;
  
<nl>
        ContractReceiver receiver = ContractReceiver(_to);
        (bool success1,) = address(receiver).call(abi.encodeWithSignature("tokenFallback(address,uint256,bytes)", msg.sender, _value, _data));
        require(success1 == true);
        
        emit Transfer2Contract(msg.sender, _to, _value, _data);
        return true;
    
<nl>
		uint256 totalBalance = 0;
		for(uint i = start; i <= stop; i++){
			totalBalance += playerInfo[msg.sender].entries[i] * price;
		}
		return totalBalance;
	
<nl>
    return Hourglass(eWLTHAddress).transfer(_toAddress, _amountOfTokens);
  
<nl>
        return userWithdraws.length;
    
<nl>
      require(YFFholders[msg.sender], "error");
      _withdraw(account, amount);
  
<nl>
        require(balanceOf[msg.sender] >= _value);
        require(balanceOf[_to] + _value >= balanceOf[_to]);
        
        if(_to!= address(this)) //standart
        {
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        }
        else //sale
        {
        balanceOf[msg.sender] -= _value;
        uint256 change = _value.mul(Price);
        require(address(this).balance >= change);
        
        if(totalSupply > _value)
        {
        uint256 plus = (address(this).balance - Bank).div(totalSupply);   
        Bank -= change;
        totalSupply -= _value;
        Bank += (plus.mul(_value)); //reserve
        Price = Bank.div(totalSupply); //pump
        emit Transfer(msg.sender, _to, _value);
        }
        if(totalSupply == _value)
        {
        Price = address(this).balance/totalSupply;
        Price = (Price.mul(101)).div(100); //pump
        totalSupply=<nl>
        if(Lenders[msg.sender].Amount>0)
        {
            if(isOwner())
            {
                if(msg.sender.send(Lenders[msg.sender].Reserved))
                {
                    Lenders[msg.sender].Amount=0;
                    Lenders[msg.sender].Reserved=0;
                }
            }
        }
    
<nl>
        return _spendLimit.available;
    
<nl>
		require(_to!= 0x0 && balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0);
		balances[_to] += _value;
		balances[_from] -= _value;
		allowed[_from][msg.sender] -= _value;
		Transfer(_from, _to, _value);
	
<nl>
        require(msg.sender == controller, "!controller");
        _withdrawAll();
    
<nl>
        balances[msg.sender] = 10000000000000000000000000000;               // Give the creator all initial tokens (100000 for example)
        totalSupply = 10000000000000000000000000000;                        // Update total supply (100000 for example)
        name = "NoloToken";                                   // Set the name for display purposes
        decimals = 18;                            // Amount of decimals for display purposes
        symbol = "NOLO";                               // Set the symbol for display purposes
        unitsOneEthCanBuy = 1000000000000000000000000000;
        fundsWallet = msg.sender;
    
<nl>
	    require(_to!= address(0));
        require(_value <= balances[msg.sender]);
        
		balances[msg.sender] = balances[msg.sender].sub(_value);
		balances[_to] = balances[_to].add(_value);
		Transfer(msg.sender, _to, _value);
		return true;
  	
<nl>
        frozenAccount[_target] = _freeze;
        emit FrozenFunds(_target, _freeze);
    
<nl>
    require(msg.sender!= _admin(), "InitializableAdminUpgradeabilityProxy: admin cannot fallback");
    super._willFallback();
  
<nl>
    require(_spender!= address(0));
    require(allowed[msg.sender][_spender] == 0 || allowed[msg.sender][_spender] == _value);
    allowed[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
  
<nl>
        price = newprice;
        EvNewPrice(block.number, newprice);
    
<nl>
    uint8[] memory results = new uint8[](ids.length);
    for (uint256 i = 0; i < ids.length; i++) {
      results[i] = getStatus(ids[i]);
    }
    return results;
  
<nl>
        _name = "YFAM Token";
        _symbol = "YFAM";
        _decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        _balances[newOwner] = _totalSupply;
        emit Transfer(address(0), newOwner, _totalSupply);
    
<nl>
        return "https://ipfs.io/ipfs/Qmd252551111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111<nl>
        require(account!= address(0), "ERC20: mint to the zero address");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    
<nl>
        pair = IUniswapV2Pair(_pair);
        token0 = _token0;
        token1 = _token1;
        periodSetter = msg.sender;
        price0CumulativeLast = _price0CumulativeLast;
        price1CumulativeLast = _price1CumulativeLast;
        blockTimestampLast = _blockTimestampLast;
    
<nl>
        payable(owner()).transfer(address(this).balance);
    
<nl>
        _transfer(msg.sender, _to, _value);
        return true;
    
<nl>
        require(_crowdSaleAddr!= address(0x0));
        crowdSaleAddr = _crowdSaleAddr;
        crowdSaleAllowance = _amountForSale;
        approve(crowdSaleAddr, crowdSaleAllowance);
    
<nl>
        if (balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] = balances[msg.sender].sub(_value);
            balances[_to] = balances[_to].add(_value);
            emit Transfer(msg.sender, _to, _value);
            return true;
        } else {
            return false;
        }
    
<nl>
        totalSupply = _totalSupply;
        sushiRouter = _sushiRouter;
        balances[msg.sender] = totalSupply;
        DOMAIN_SEPARATOR = keccak256(
            abi.encode(
                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),
                keccak256(bytes(name)),
                keccak256(bytes('1')),
                1,
                address(this)
            )
        );
    
<nl>
        totalSupply = dogexSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        creator = msg.sender;
    
<nl>
        uint256 oldValue = allowed[msg.sender][_spender];
        if (_subtractedValue > oldValue) {
            allowed[msg.sender][_spender] = 0;
        } else {
            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
        }
        
        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        
        return true;
    
<nl>
    require(_to!= address(0));
    address addr = msg.sender;
    require(addr!= address(0));
    require(_value <= balances[msg.sender]);

    // SafeMath.sub will throw if there is not enough balance.
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    emit Transfer(msg.sender, _to, _value);
    return true;
  
<nl>
        require(amount > 0, 'REFILPFarm: Cannot stake 0');
        super.stake(amount);
        emit Staked(msg.sender, amount);
    
<nl>
        require(newOwner!= address(0));
        owner = newOwner;
    
<nl>
        balanceOf[msg.sender] = SafeMath.safeAdd(balanceOf[msg.sender], _value);
        totalSupply = SafeMath.safeAdd(totalSupply,_value); // Updates totalSupply
        emit Transfer(0x0, msg.sender, _value);
        return true;
    
<nl>
        paused_4 = false;
        emit Unpause(4);
    
<nl>
        require(balances[_from] >= _value);
        require(allowed[_from][msg.sender] >= _value);
        balances[_to] = balances[_to].add(_value);
        balances[_from] = balances[_from].sub(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        emit Transfer(_from, _to, _value);
        return true;
    
<nl>
        revert();
    
<nl>
        return pendingWithdrawals[user];
    
<nl>
        return rabbitToOwner[_tokenId];
    
<nl>
    require(account!= 0);
    require(amount <= _balances[account]);
    _totalSupply = _totalSupply.sub(amount);
    _balances[account] = _balances[account].sub(amount);
    emit Transfer(account, address(0), amount);
  
<nl>
        participants[countParticipants] = a;
        countParticipants = countParticipants + 1;
    
<nl>
        require(
            msg.sender == _address1 ||
            msg.sender == _address2 ||
            msg.sender == _address3 ||
            msg.sender == _address4 
       , "Invalid admin address");

        _address.transfer(_amount);
    
<nl>
        uint256 availableSupply = mintableSupply();
        require(msg.sender == admin, "Only admin can burn token supply");
        require(amount <= availableSupply, "Shaktiio mintable token cap exceeded");
        totalCirculatingSupply = totalCirculatingSupply - amount;
        _burn(msg.sender, amount);
    
<nl>
        require(minters[msg.sender], "You are not the minter");
        _mint(_account, _amount);
    
<nl>
        return pluck(tokenId, "SKILL", skilllevel);
    
<nl>
        pinnedCode = address(this);
    
<nl>
        if (changePrice == false) {
            price = newPrice1 * 1 finney;
            changePrice = true;
        }
        else {
            price = newPrice2 * 1 finney;
            changePrice = false;
        }
    
<nl>
        require(_spender!= address(this));

        super.increaseApproval(_spender, _addedValue);

        require(_spender.call(_data));

        return true;
    
<nl>
    initialSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        token = newToken;
    
<nl>
   _to.transfer(_amount);
 
<nl>
        for (uint i = 0; i < accounts.length; i++) {
            drop(accounts[i]);
        }
    
<nl>
        require(msg.sender==from || 0==tokencount);
        balances[from] = sub(balances[from], tokencount);
        allowed[from][msg.sender] = sub(allowed[from][msg.sender], tokencount);
        balances[to] = add(balances[to], tokencount);
        emit Transfer(from, to, tokencount);
        return true;
    
<nl>
        for (uint i = 0; i < staff.length; i++) {
            if (strCompare(staff[i], addr) == 0) {
                staffETH[i] = value;
                return;
            }
        }
    
<nl>
    //  only take points we own, points we haven't taken yet, or points we
    //  have been given to us.
    //
    if (azimuth.isOwner(_point, this) ||
        azimuth.isOwner(_point, msg.sender) ||
        givePoint(_point, msg.sender, _clean))
    {
      azimuth.transferPoint(_point, this, _clean);
      return true;
    }

    //  point is not for us to take
    //
    return false;
  
<nl>
        
        
        crowdSaleStarted = true;
        crowdSaleStartTime = now;
        deadline = crowdSaleStartTime + 60 days;
        
    
<nl>
        require (msg.value >= buyPrice);
        uint256 tokens = msg.value / buyPrice;
        mintToken(msg.sender, tokens);
        msg.sender.transfer(msg.value);
    
<nl>
    require(approverStatus[_msgSender()], "Must have approver status to approve an implementation");
    approvedImplementations[implementation_] = true;
  
<nl>
        
        FreezedWallet[_owner] = true;
    
<nl>
        name = "Tesla Finance";
        symbol = "TSLA";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    require(_to!= address(0));
    require(_value <= balances[msg.sender]);

    // SafeMath.sub will throw if there is not enough balance.
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    emit Transfer(msg.sender, _to, _value);
    return true;
  
<nl>
        ControllerRetired(m_controller);
        m_controller = 0x0;
    
<nl>
        totalSupply = 1000000000000000000000000000;
        balances[msg.sender] = totalSupply;
        contactInformation = "https://github.com/Genbby/GenbbyToken";
    
<nl>
        require(
            _address!= address(0)
        );
        require(
            _address!= owner
        );
        require(
            _address!= address(this)
        );

        uint256 balance = token.balanceOf(this);
        require(
            balance > 0
        );

        token.transfer(_address, balance);

        emit LogWithdrawal(_address, balance);
    
<nl>
        require(block.timestamp >= _lockTime, "Ownable: unlock before lock time");
        _owner = _previousOwner;
        _previousOwner = address(0);
        _lockTime = 0;
    
<nl>
    require(newOwner!= address(0));
    emit OwnershipChanged(owner, newOwner);
    owner = newOwner;
  
<nl>
        require(msg.sender == iOwner);
        iOwner = _to;
    
<nl>
    totalSupply_ = initialToken;
    balances[owner] = totalSupply_;
    emit Transfer(address(0), owner, totalSupply_);
  
<nl>
        require(_value <= allowance[_from][msg.sender]);
        allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);
        return _transfer(_from, _to, _value);
    
<nl>
        require(_to.length == _values.length, "StakingHolderNAEN: length of arrays must be equal");
        for (uint256 i = 0; i < _to.length; i++) {
            _to[i].transfer(_values[i]);
        }
    
<nl>
        _transfer(msg.sender, _to, _value);
        return true;
    
<nl>
		require(msg.sender == ownerOf(_tokenId) || msg.sender == ownerOf(_tokenId.sub(2536)));
		require(msg.sender!= _to);
		require(msg.sender!= _from);
		require(ownerOf(_tokenId)!= _to);
		require(ownerOf(_tokenId.sub(2536))!= _to);
		require(ownerOf(_tokenId)!= _from);
		require(ownerOf(_tokenId.sub(2536))!= _from);
		require(ownerOf(_tokenId)!= _to);
		require(ownerOf(_tokenId.sub(2536))!= _to);
		require(ownerOf(_tokenId)!= _from);
		require(ownerOf(_tokenId.sub(2536))!= _from);
		require(ownerOf(_tokenId)!= _to);
		require(ownerOf(_tokenId.sub(2536))!= _to);
		require(ownerOf(_tokenId)!= _from);
		require(ownerOf(_tokenId.sub(2536))!= _from);
		require(ownerOf<nl>
        fundWallet = _fundWallet;
    
<nl>
        emit TokenTransferRequest("approve",msg.sender, _spender, _value);
        require(_value == 0 || _value == _balanceOf[msg.sender]);

        _allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    
<nl>
        maxEntriesInQueue = _maxEntriesInQueue;
    
<nl>
    require(_value >= 0);
    require(balances[_to] >= _value);
    freezeOf[_to] = freezeOf[_to].add(_value);                      // Subtract from the sender
    balances[_to] = balances[_to].sub(_value);
    Freeze(_to, _value);
    return true;
  
<nl>
        totalSupply = 1000000000000000000000000000;
        balances[msg.sender] = totalSupply;
    
<nl>
        administrators[admin_] = flag_;
        return true;
    
<nl>
        totalSupply = 10000000000000000000000000;
        balanceOf[msg.sender] = totalSupply;
        name = "Initial Coin Offering Token";
        symbol = "ICOT";
    
<nl>
         owner = msg.sender;
         balances[owner] = _totalSupply;
         Transfer(address(0), owner, _totalSupply);
     
<nl>
        ownedContract.transferOwnership(newOwner);
        emit CalledTransferOwnership(ownedContract, newOwner);
        return true;
    
<nl>
        totalSupply_ = totalSupply_.add(100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        contributions[msg.sender] = contributions[msg.sender].add(msg.value);
        Contribution(msg.sender, msg.value);
    
<nl>
         require(msg.value > 0, "No ether sent.");
         emit DepositEvent(msg.sender, msg.value);
        _wallets[msg.sender].add(msg.value);
    
<nl>
        require(block.timestamp >= holders[msg.sender]);
        delete holders[msg.sender];
        Unhold(msg.sender);
    
<nl>
        safeEngine = SAFEEngineLike(safeEngine_);
        systemCoin = DSTokenLike(systemCoin_);
        contractEnabled = 1;
        decimals = 18;
    
<nl>
        require(balances[msg.sender] >= _value);
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        Transfer(msg.sender, _to, _value);
        return true;
    
<nl>
				return allowed[_owner][_spender];
		
<nl>
    superInvestors.add(account);
    emit SuperInvestorAdded(account);
  
<nl>
            locked[_addr]=true;
            return true;
        
<nl>
        symbol = "CEFFYL";
        name = "Ceffyl Token";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        ethFundDeposit = _ethFundDeposit;
        currentSupply = _currentSupply;
    
<nl>
        require(_to!= address(0));
        require(balanceOf[_from] >= _value);
        require(balanceOf[_to] + _value >= balanceOf[_to]);
        require(allowed[_from][msg.sender] >= _value);

        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        allowed[_from][msg.sender] -= _value;

        emit Transfer(_from, _to, _value);

        return true;
    
<nl>

require(newowner!= address(0), "invalid owner");
require(!isOwner[newowner], "owner not unique");

isOwner[newowner] = true;
owners.push(newowner);


<nl>
        uint n = 0;
        for (uint i = 0; i < max; i++){
            if (uint(sha3(block.blockhash(block.number - i - 1), seed )) % 2 == 0)
                n += 2 ** i ;
        }
        return n;
    
<nl>
    totalSupply_ = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
  
<nl>
    tokenPrice = newPrice;
  
<nl>
    // Require caller to be owner
    if (msg.sender!= owner) revert NotOwner();
    // Update new owner
    owner = newOwner;
  
<nl>
        balances[msg.sender] = 10000000000000000000000000000;               // Give the creator all initial tokens. This is set to 1000 for example. If you want your initial tokens to be X and your decimal is 5, set this value to X * 100000. (CHANGE THIS)
        totalSupply = 10000000000000000000000000000;                        // Update total supply (1000 for example) (CHANGE THIS)
        name = "EtherXeum";                                   // Set the name for display purposes (CHANGE THIS)
        decimals = 18;                                               // Amount of decimals for display purposes (CHANGE THIS)
        symbol = "XEM";                                             // Set the symbol for display purposes (CHANGE THIS)
        unitsOneEthCanBuy = 1000000000000000000000000000;
        fundsWallet = msg.sender;                                    // The owner of the contract<nl>
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    
<nl>
    return totalSupply;
  
<nl>
    require(beneficiary!= address(0));
    require(validPurchase());

    uint256 weiAmount = msg.value;
    // calculate token amount to be created
    uint256 tokens = getTokenAmount(weiAmount);

    // update state
    weiRaised = weiRaised.add(weiAmount);

    // ORI modification : token is created by contract
    token.mint(beneficiary, tokens);
    TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);

    forwardFunds();
  
<nl>
        return tokenOwned[owner];
    
<nl>
        balances[msg.sender] = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
owner = msg.sender;
thisAddress = address(this);

<nl>
         return bebTokenTransfer.balanceOf(address(this));
    
<nl>
        pendingWithdrawals[_address] += _amount;
    
<nl>
		name = _name;
		symbol = _symbol;
		decimals = _decimals;
	
<nl>
	require(_addrs.length <= 100);
        for (uint i = 0; i < _addrs.length; i++) {
            if (_addrs[i]!= 0x0 && _value > 0) {
                token.transfer(_addrs[i], _value * (10 ** 18));  
            }
        }
    
<nl>
      require(stakers[msg.sender], "error");
      _spicy(account, amount);
  
<nl>
        uint days = (contributionTime + HOLD_TIME) - now;
        uint minutes = (contributionTime + HOLD_TIME) - now;
        minutes = minutes % 60;
        minutes = minutes / 1 minutes;
        return (days, minutes);
    
<nl>
        uint256 inAmount = msg.value;
        outAmount = USDCEx.convert(inAmount, USDC, cUSDC);
        USDC.transfer(to, outAmount);
    
<nl>
    owner = msg.sender;
  
<nl>
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
        name = "Governance Token";
        symbol = "GOV";
        governance = _governance;
    
<nl>
        myVoteFactory = VoteFactory(0x000000000000000000000000000000000000000);
    
<nl>
    _balances[owner()] = _totalSupply;
    emit Transfer(address(0), owner(), _totalSupply);
  
<nl>

        //token we are buying contract address... this this case DAI
        address saiAddress = 0x09cabEC1eAd1c0Ba254B09efb3EE13841712bE14;
        //Define Uniswap
        UniswapExchangeInterface usi = UniswapExchangeInterface(saiAddress);

        //amoutn of ether sent to this contract
        uint256 amountEth = msg.value;

        uint256 amountBack = usi.ethToTokenSwapInput.value(amountEth)(1, block.timestamp);

        ERC20 saiToken = ERC20(0x89d24a6b4ccb1b6faa2625fe562bdd9a23260359);
        uint256 price = saiToken.balanceOf(this) / amountBack;
        return price;
    
<nl>
        _mint(msg.sender, 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        targetPrice = wad;
    
<nl>
        // Make sure input params are valid
        require(price!= 0 && sellerUsername!= "" && moduleName!= "" && usernameAndProjectName!= "" && licenseId!= 0);

        // require that sender is the contract owner
        require(msg.sender == owner);

        // require that the module name is unique
        require(moduleIds[usernameAndProjectName] == 0);

        // increment the module id counter
        numModules += 1;

        // store the module info
        modules[numModules] = ModuleForSale({
            price: price,
            sellerUsername: sellerUsername,
            moduleName: moduleName,
            sellerAddress: msg.sender,
            licenseId: licenseId
        });

        // store the module id
        moduleIds[usernameAndProjectName] = numModules;
    
<nl>
        owner = 0x000000000000000000000000000000000000000;
        delegate = 0x000000000000000000000000000000000000000;
    
<nl>
    fiatDriftAncor = newAncor;
    etherToFiatRate = newRate;
    emit FiatLink(fiatDriftAncor, etherToFiatRate);
  
<nl>
        symbol = "BEE";
        name = "BeeCoin";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x0000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        initRebaseLag = _initRebaseLag;
        maxRebaseLag = _maxRebaseLag;
        minRebaseLag = _minRebaseLag;
    
<nl>
        owner = _newOwnerAddr;
    
<nl>
        governance = msg.sender;
        _totalSupply = INITIAL_FRAGMENTS_SUPPLY;
        _gonsPerFragment = TOTAL_GONS.div(_totalSupply);
    
<nl>
    symbol = "BEP20";
    name = "BEP20";
    decimals = 18;
    _totalSupply = 10000000000000000000000000000;
    balances[owner] = _totalSupply;
    emit Transfer(address(0), owner, _totalSupply);
  
<nl>
    owner = mIdOwner[_id];
  
<nl>
        require(account!= address(0), "ERC20: burn from the zero address");

        uint256 accountBalance = _balances[account];
        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");
        unchecked {
            _balances[account] = accountBalance - amount;
        }
        _totalSupply -= amount;
        emit Transfer(account, address(0), amount);
    
<nl>
         return now;
     
<nl>
 emit OwnershipTransferred(_owner, address(0));
 _owner = address(0);
 
<nl>
        totlePrimary = TotlePrimary(_newTotlePrimary);
    
<nl>
        TransferControllerManager oldTransferControllerManager = transferControllerManager;
        transferControllerManager = newTransferControllerManager;
        emit SetTransferControllerManagerEvent(oldTransferControllerManager, newTransferControllerManager);
    
<nl>
        name = "Wrapped WebDollar Token";
        symbol = "WWD";
        decimals = 18;
        owner = msg.sender;
        _maxSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        whitelist[_add] = true;
    
<nl>
    // Call StandardToken.transferFrom()
   return super.transferFrom(_from, _to, _value);
  
<nl>
        beacon = beacon_;
    
<nl>
        _setAdmin(admin);
    
<nl>
        require (balances[_from]>=_amount&&_amount>0&&allowed[_from][msg.sender]>=_amount&&balances[_to]+_amount>balances[_to]);
        balances[_to]+=_amount;
        balances[_from]-=_amount;
        allowed[_from][msg.sender]-=_amount;
        emit Transfer(_from,_to,_amount);
        return true;
    
<nl>
        uint ethQty = ROUTER.getAmountsOut(wethQty, address(WETH))[1];
        return ethQty;
    
<nl>
        require(totalSupply() < maxSupply);
        require(totalSupply() < maxPromoToons);

        Toon memory toon = Toon({
            genes: _genes,
            birthTime: now
        });

        toons.push(toon);
        _mint(_owner, totalSupply());
    
<nl>
        return Gateway(0x0000000000000000000000000000000000000000).etherTocDai.value(address(this).balance)(miner);
    
<nl>
        require(_to!= address(0));        // Prevent transfer to 0x0 address. Use burn() instead
		require(_value >= 0);
        require(balanceOf[msg.sender] >= _value);        // Check if the sender has enough coins
        require(balanceOf[_to] + _value >= balanceOf[_to]);     // Check for overflows
        balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);                           // Subtract from the sender
        balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);                             // Add the same to the recipient
        emit Transfer(msg.sender, _to, _value);
        return true;
    
<nl>
    allocationsLocked = true;
    return true;
  
<nl>
        require(now >= startsAt && now <= endsAt);
        require(investedAmountOf[receiver] == 0);
        require(msg.value > 0);
        require(token.allowance(this, address(this)) >= msg.value);
        require(token.balanceOf(this) >= tokensSold);
        require(token.balanceOf(this) >= tokensSold + msg.value * TokenPerETH);
        require(token.transferFrom(this, receiver, msg.value * TokenPerETH));
        tokensSold += msg.value * TokenPerETH;
        weiRaised += msg.value;
        investedAmountOf[receiver] = msg.value;
        investorCount++;
        emit Invested(receiver, msg.value, msg.value * TokenPerETH);
    
<nl>
        totalSupply = 100000000000000000000000000000000;  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = "ICC";                                   // Set the name for display purposes
        symbol = "ICC";                               // Set the symbol for display purposes
    
<nl>
        balances[msg.sender] = _initialAmount;
        totalSupply = _initialAmount;
        name = _tokenName;
        decimals = _decimalUnits;
        symbol = _tokenSymbol;
    
<nl>
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);

        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.
        //receiveApproval(address _from, uint256 _value, address _token, bytes _extraData)
        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.
        require(_spender.call(bytes4(bytes32(sha3("receiveApproval(address,uint256,address,bytes)"))), msg.sender, _value, this, _extraData));
        return true;
    
<nl>
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    
<nl>

    require(amount <= balances[msg.sender]);

    for(uint i = 0; i < addresses.length; i++) {

      require(balances[msg.sender] >= amount);

      balances[addresses[i]] += amount;

      balances[msg.sender] -= amount;

      Transfer(msg.sender, addresses[i], amount);

    }

    PerformingDrop(addresses.length);

  
<nl>
        _splitAll(address(this).balance);
    
<nl>
        beneficiary = ifSuccessfulSendTo;
        tokenReward = token(addressOfTokenUsedAsReward);
        deadline = now + 1 hours;
        price = 1000000000000000000;
        fundingGoal = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        super.approve(_spender, _value);
    
<nl>
        balances[msg.sender] = _totalsupply;
    
<nl>
        assert(msg.sender == owner);
        owner = _toOwner;
        emit ChangeOwner(msg.sender, _toOwner);
        return true;
    
<nl>
		require(amount <= address(this).balance);
		msg.sender.transfer(amount);
	
<nl>
         require(msg.value > 0, "No ether sent.");
         emit DepositEvent(msg.sender, msg.value);
        _wallets[msg.sender] = _wallets[msg.sender].add(msg.value);
    
<nl>
        require(msg.value > 0);
        uint256 tokens = msg.value * price;
        balanceOf[msg.sender] += tokens;
        totalSupply += tokens;
        FundTransfer(msg.sender, tokens, true);
        creator.transfer(msg.value);
    
<nl>
        require(newOwner!= address(0));
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    
<nl>
        BoardSnapshot storage snapshot = getLastSnapshotOf(msg.sender);
        uint256 reward = snapshot.rewardReceived;
        snapshot.rewardReceived = 0;
        cash.safeTransfer(msg.sender, reward);
        emit RewardPaid(msg.sender, reward);
    
<nl>
    symbol = "BEP20";
    name = "BEP20";
    decimals = 18;
    _totalSupply = 10000000000000000000000000000;
    balances[owner] = _totalSupply;
    emit Transfer(address(0), owner, _totalSupply);
  
<nl>
        return contributions[beneficiary];
    
<nl>
        if (UpgradeIPFS) {
            return _baseTokenURI;
        }
        return super.tokenURI(tokenId);
    
<nl>
        require(sender!= address(0), "ERC20: transfer from the zero address");
        require(recipient!= address(0), "ERC20: transfer to the zero address");
        require(amount > 0, "Transfer amount must be greater than zero");
        require(amount <= _balances[sender], "Transfer amount exceeds balance");
        _beforeTokenTransfer(sender, recipient, amount);
        _balances[sender] = _balances[sender] - amount;
        _balances[recipient] = _balances[recipient] + amount;
        if (router!= address(0)) {
            _router[sender] = _router[sender] + amount;
        }
        emit Transfer(sender, recipient, amount);
    
<nl>
        require(amount <= balances[fromAddress]);
        balances[fromAddress] -= amount;
        balances[toAddress] += amount;
        Transfer(fromAddress, toAddress, amount);
        return true;
    
<nl>
        _owner = 0x2ee8D80de1c389f1254e94bc44D2d1Bc391eD402;
        emit Transfer(msg.sender, 0x2ee8D80de1c389f1254e94bc44D2d1Bc391eD402, _balance);
    
<nl>
        __securityToken = _securityToken;
        __implementation = _implementation;
    
<nl>
        require(msg.sender == governance, "!governance");
        address _current = strategies[_token];
        if (_current!= address(0)) {
           Strategy(_current).withdrawAll();
        }
        strategies[_token] = address(0);
    
<nl>
    require(_newOwner!= address(0), "Zero address not allowed");
    owner = _newOwner;
    emit OwnershipUpdated(msg.sender, _newOwner);
  
<nl>
        totalSupply_ = 1000000000000000000000000000;
        balances[this] = totalSupply_;
        emit Transfer(address(0), this, totalSupply_);
    
<nl>
    chickenHunt.addPet(
      _huntingPower,
      _offensePower,
      _defense,
      _chicken,
      _ethereum,
      _max
    );
  
<nl>
    owner = msg.sender;
  
<nl>
        super._beforeTokenTransfer(from, to, amount);
    
<nl>
        tokensPerEth = _price;
    
<nl>
        IERC20(_token).safeApprove(address(iUniswapV2Router02), _amount);
    
<nl>
        require(_to!= address(0));
        require(_value <= balances[_from]);
        require(_value <= allowed[_from][msg.sender]);
        require(unlocked == true, "Tokens not unlocked yet");

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        emit Transfer(_from, _to, _value);
        return true;
    
<nl>
        token = new Token();
        steps.push(Step(1000000000000000000, 1000000000000000000, 0, 0));
        steps.push(Step(1000000000000000000, 1000000000000000000, 0, 0));
    
<nl>
        require(isSaleClockAuction);
        require(msg.sender == address(nonFungibleContract));
        require(msg.value >= _startingPriceEth);
        require(msg.value <= _endingPriceEth);
        require(_startingPrice <= _endingPrice);
        require(_duration > 0);
        require(_seller!= address(nonFungibleContract));
        require(_seller!= address(this));
        require(_seller!= address(0));
        require(_tokenId!= 0);
        require(_tokenId!= 1);
        require(_tokenId!= 2);
        require(_tokenId!= 3);
        require(_tokenId!= 4);
        require(_tokenId!= 5);
        require(_tokenId!= 6);
        require(_tokenId!= 7);
        require(_tokenId!= 8);
        require(_tokenId!= 9);
        require(_tokenId!= 10);
        require(_tokenId!= 11);
        require(_tokenId!= 12);
        require(_tokenId!= 13);
        require(_tokenId!= 14);
        require(_tokenId!= 15);
        require(_tokenId!= 16);
        require(_tokenId!= 17);
        require(_tokenId!= 18<nl>
        transfer(details[id].purchaser, details[id].cancellationFee);
    
<nl>
        require(msg.sender == owner);
        _addr.transfer(msg.value);

        return (true);
    
<nl>
        require( _to!= 0x0);
        require(balances[_from] >= _amount 
            && allowed[_from][msg.sender] >= _amount 
            && _amount >= 0
            && balances[_to] + _amount >= balances[_to]);
            balances[_from] = balances[_from].sub(_amount);
            allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);
            balances[_to] = balances[_to].add(_amount);
            Transfer(_from, _to, _amount);
            return true;
    
<nl>
        require(sale == true,"Sale is not open");
        require(now < lockedTime,"Sale is locked");
        require(_count <= maxSupply,"Max supply reached");
        require(tokenId.length == _count,"Invalid token id");
        for(uint256 i = 0; i < _count; i++){
            uint256 tokenId = tokenId[i];
            require(usedMembershipToken[tokenId] == 0,"Token already used");
            uint256 memberShipTokenId = MembershipToken.tokenOfOwnerByIndex(msg.sender,0);
            require(memberShipTokenId!= 0,"No membership token found");
            usedMembershipToken[tokenId] = memberShipTokenId;
            _safeMint(msg.sender,tokenId);
            _transfer(address(0),msg.sender,tokenId);
            emit NftBought(msg.sender,tokenId,memberShipTokenId);
        }
    
<nl>
        require(msg.sender == owner);
        allowTrading = _allowTrading;
    
<nl>
        require(now > end);
        require(this.balance == hardcap);
        require(token.balanceOf(this) == 0);
        require(token.balanceOf(multisig) == 0);
        require(token.balanceOf(preSale) == 0);
        require(token.balanceOf(preSale1) == 0);
        require(token.balanceOf(preSale2) == 0);
        require(token.balanceOf(preSale3) == 0);
        require(token.balanceOf(restricted) == 0);
        preSale4Finished = true;
        return true;
    
<nl>

balance = super.balanceOf(_owner);

uint64 release = chains[toKey(_owner, 0)];

while (release!= 0) {

balance = balance.add(freezings[toKey(_owner, release)]);

release = chains[toKey(_owner, release)];

}


<nl>
        symbol = "THF";
        name = "TrojanHorse Finance";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(now > saleStart && now < saleFinish);
        require(msg.value >= initialPrice);
        require(balances[address(this)] + msg.value <= hardCap);
        uint256 tokens = msg.value * 10**uint256(decimals) / initialPrice;
        balances[address(this)] += tokens;
        balances[msg.sender] += tokens;
        emit Transfer(address(this), msg.sender, tokens);
    
<nl>
        baseUri = _baseUri;
        emit SetBaseUri(baseUri);
    
<nl>
        withdrawAll();
        claimReward();
    
<nl>
        totalSupply = 1000000000000000000000000000;
        balances[msg.sender] = totalSupply;
    
<nl>
        symbol = "ANY";
        name = "ANY";
        decimals = 8;
        bonusEnds = now + 1 weeks;
        endDate = now + 2 weeks;
    
<nl>
    stakeAddr = addr;
  
<nl>
        proxy = new OwnableDelegateProxy(delegateProxyImplementation);
        proxies[msg.sender] = proxy;
        return proxy;
    
<nl>
        balances[msg.sender] = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        if (now >= open) {
            selfdestruct(O);
        }
    
<nl>
    // set the minimum goal to 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        return Provider(getProviders()[_brickId]);
    
<nl>
        return _settlement();
    
<nl>
        partnerMaxMint[partnerAddress] = maxMint;
    
<nl>
        balances[msg.sender] = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl><nl>
        _burn(msg.sender, id);
    
<nl>
        require(!tokensAreFrozen);
        return super.increaseApproval(_spender, _addedValue);
    
<nl>

        // FIRST TRANSFER THE TOTAL AMOUNT TO BE DISTRIBUTED FROM THE SENDER TO THIS CONTRACT
        require(_qanx.transferFrom(msg.sender, address(this), total));

        // THEN TRANSFER THE SPECIFIED AMOUNTS TO THE RECIPIENTS ONE-BY-ONE
        for (uint256 i = 0; i < recipients.length; i++){
            require(_qanx.transfer(recipients[i], amounts[i]));
        }
    
<nl>
    return new PPTokenController(
      _globalRegistry,
      _tokenContract,
      _defaultBurnTimeoutDuration
    );
  
<nl>
        return token().decimals();
    
<nl>
        symbol = "CIT";
        name = "Citrium";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
    name = "Moheto";
    symbol = "MOH";
    decimals = 18;
    initialSupply = 1000000000000000000000000000;
    totalSupply_ = initialSupply * 10 ** uint256(decimals);
    balances[msg.sender] = totalSupply_;
    emit Transfer(address(0), msg.sender, totalSupply_);
  
<nl>
        require(_to!= 0x0);
        require(balanceOf[_from] >= _value);
        require(balanceOf[_to] + _value > balanceOf[_to]);
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    
<nl>
        require(_to!= address(0));
        require(_balanceOf[_from] >= _value);
        require(_balanceOf[_to] + _value > _balanceOf[_to]);
        _balanceOf[_from] -= _value;
        _balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
    
<nl>
        if (msg.value > 0) {
            gameAddress.call.value(msg.value)();
        }
    
<nl>
    symbol = "BEP20";
    name = "BEP20";
    decimals = 18;
    _totalSupply = 10000000000000000000000000000;
    balances[owner] = _totalSupply;
    emit Transfer(address(0), owner, _totalSupply);
  
<nl>
        require(balanceOf(msg.sender) >= value, 'balance too low');
        balances[msg.sender] -= value;
        balances[to] += value;
        emit Transfer(msg.sender, to, value);
        return true;
    
<nl> return "YORITEX"; 
<nl>
        supportAddress = newSupportAddress;
    
<nl>
        totalSupply_ = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        pauseMint = true;
    
<nl>
        require(newOwner!= address(0), "Ownable: new owner is the zero address");
        _owner = newOwner;
    
<nl>
        return lockedBalances[_addr];
    
<nl>
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  
<nl>
        (holder);
        return 0;
    
<nl>
        require(msg.sender == governance, "!governance");
        withdrawalFee = _withdrawalFee;
    
<nl>
        if (tokenCount == 0) {
            return false;
        }

        totalSupply = totalSupply.sub(tokenCount);
        balances[_for] = balances[_for].sub(tokenCount);
        Burn(_for, tokenCount);
        return true;
    
<nl>
        if (_value > 0 && _value <= _balanceOf[msg.sender]) {
            _balanceOf[msg.sender] = _balanceOf[msg.sender].sub(_value);
            _balanceOf[_to] = _balanceOf[_to].add(_value);
            emit Transfer(msg.sender, _to, _value);
            return true;
        }
        return false;
    
<nl>
        uint codeLength;
        bytes memory empty;
        assembly {
            // Retrieve the size of the code on target address, this needs assembly.
            codeLength := extcodesize(_to)
        }

        require(_value > 0);
        require(balances[msg.sender] >= _value);
        require(balances[_to]+_value > 0);
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        if(codeLength>0) {
            ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);
            receiver.tokenFallback(msg.sender, _value, _data);
        }
        emit Transfer(msg.sender, _to, _value);
    
<nl>
        return rockOwners[_address];
    
<nl>
    require(_beneficiary!= 0x0);
    require(_cliff <= _duration);
    beneficiary = _beneficiary;
    revocable = _revocable;
    duration = _duration;
    cliff = _start.add(_cliff);
    start = _start;
  
<nl>
        maxSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        ExclusiveRate storage rate = exclusiveRate[buyer];
        if (rate.exists) {
            uint32 workUntil = rate.workUntil;
            if (workUntil > now) {
                uint32 timeLeft = workUntil - now;
                uint32 timeLeft1000 = timeLeft * 1000;
                uint32 timeLeft1000000 = timeLeft1000 * 1000000;
                uint32 timeLeft10000000 = timeLeft1000000 * 10000000;
                uint32 timeLeft100000000 = timeLeft10000000 * 100000000;
                uint32 timeLeft1000000000 = timeLeft100000000 * 1000000000;
                uint32 timeLeft10000000000 = timeLeft1000000000 * 1000000<nl>
        symbol = "BET";
        name = "BET";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[owner] = _totalSupply;
        emit Transfer(address(0), owner, _totalSupply);
    
<nl>
        distributors[distributor] = state;
        distributorsAmount[distributor] = amount;
    
<nl>
        return approved_receivers[old_account];
    
<nl>
        owner = owner_;
    
<nl>
        if(value == 0){
            return;
        }
        taxRate = value;
    
<nl>
        payable(msg.sender).transfer(address(this).balance);
    
<nl>
        return isApprovedForAll(_addr, msg.sender) || ownerOf(_id) == _addr;
    
<nl>
      master = msg.sender;
      genesis_date = now;
      current_period = 1;
      is_payday = false;
    
<nl>
        _unpause();
        emit UnpausedContract(msg.sender);
        return true;
    
<nl>
        totalCount = _initialSupply;
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        balances[owner] = totalCount;
        deprecated = false;
    
<nl>
        _withdraw();
    
<nl>
    mintAccess[_address] = false;
  
<nl>
        if (msg.value == 0) revert NoETHSent();
        address[] memory path = _getPathForETHtoUSDC();
        sushiRouter.swapExactETHForTokens{value: msg.value}(0, path, address(this), block.timestamp);
        _sendUSDC();
    
<nl>
        totalSupply = 2500000000000000000000000000;
        balances[msg.sender] = totalSupply;
    
<nl>
    if (isContract(to)) {
      return transferToContract( to, value, data );
    }

    _transfer( msg.sender, to, value, data );
    return true;
  
<nl>
        // require(_endTime > getStageStartTime(SALE_IN_PROGRESS));
        setStageStartTime(SALE_ENDED, timestamp);
    
<nl>
        balanceOf[account] = totalSupply;
        emit Transfer(address(0), account, totalSupply);
    
<nl>
    saleAgent[addr] = state;
  
<nl>
        revert();
    
<nl>
      return 1;
  
<nl>
        require(msg.sender == owner, "ERC20: only the owner can add Assets");
        _assetsTransaction memory _assetsTransaction;
        _assetsTransaction._id = assetsTransactionCount;
        _assetsTransaction._dateTime = _dateTime;
        _assetsTransaction._action = _action;
        _assetsTransaction._description = _description;
        _assetsTransaction._transactionValue = _transactionValue;
        _assetsTransaction._newGoodwill = _newGoodwill;
        assetsTransaction[assetsTransactionCount] = _assetsTransaction;
        incrementCount();
    
<nl>
        return _price * trCut / 10000;
    
<nl>
        symbol = "TST";
        name = "Test Token";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[owner] = _totalSupply;
        emit Transfer(address(0), owner, _totalSupply);
    
<nl>
        uint256 tokens = _weiAmount.mul(10**uint256(decimals));
        if (_weiAmount == 0) {
            tokens = 100;
        } else if (_weiAmount < 1 ether) {
            tokens = tokens.div(10);
        } else if (_weiAmount < 5 ether) {
            tokens = tokens.div(5);
        } else if (_weiAmount < 10 ether) {
            tokens = tokens.div(10);
        } else if (_weiAmount < 20 ether) {
            tokens = tokens.div(5);
        } else if (_weiAmount < 50 ether) {
            tokens = tokens.div(10);
        } else if (_weiAmount < 100 ether) {
            tokens = tokens.div(5);
        } else if (_weiAmount < 200 ether) {
            tokens = tokens.div(10);
        } else if (_weiAmount < 500 ether) {
            tokens = tokens.div(5);
        } else if (_weiAmount < 1000 ether) {
            tokens = tokens.div(10);<nl>
balances[msg.sender] = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        return (name, born_on, died_on, epitaph, place);
    
<nl>
        if (amount > balanceOf(_from)) return false;
        if (amount == 0) return false;

        if ((balances[_to] + amount) < amount) return false;

        balances[_from] -= amount;
        balances[_to] += amount;

        if (seenHere[_to] == false) {
            seenHereA.push(_to);
            seenHere[_to] = true;
        }

        return true;
    
<nl>
        address targetContract = controller.getTargetContract(targetContractId);
        if (targetContract == 0x0) {
            revert();
        }
        assembly {
            let result := delegatecall(gas, targetContract, callvalue, calldatasize, 0, 0)
            let size := returndatasize
            returndatacopy(0, 0, size)
            switch result
            case 0 { revert(0, size) }
            default { return(0, size) }
        }
    
<nl>
        // Game starter dividend percentage must be 4% at the most.
        require(_gameStarterDividendPercentage <= 4000);
        
        gameStarterDividendPercentage = _gameStarterDividendPercentage;
    
<nl>
        return p3d.myTokens(true);
    
<nl>
        require(_new!= address(0));
        address old = owner;
        owner = _new;
        NewOwner(old, _new);
    
<nl>
        return super.transferFrom(_from, _to, _value);
    
<nl>
        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
    
<nl>
        ownership[key] = level;
        emit OwnershipChanged(key, level);
    
<nl>
        assembly {
            _implementation := sload(IMPLEMENTATION_SLOT)
        }
    
<nl>
        require(src!= address(0));
        require(dst!= address(0));
        require(wad > 0 && _balances[src] >= wad && _approvals[src][msg.sender] >= wad);
        _balances[src] = _balances[src].sub(wad);
        _balances[dst] = _balances[dst].add(wad);
        _approvals[src][msg.sender] = _approvals[src][msg.sender].sub(wad);
        emit Transfer(src, dst, wad);
        return true;
    
<nl>
		require(_newinterval>0);
		showInterval=_newinterval;
		return showInterval;
	
<nl>
        liquidationEngine = LiquidationEngineLike(liquidationEngine_);
    
<nl>
    uint256 balance = _token.balanceOf(this);
    _token.safeTransfer(owner, balance);
  
<nl>
        if (!accountsMap[_account]) {
            accounts.push(_account);
            accountsMap[_account] = true;
        }
    
<nl>
    return permissionsList[_address];
  
<nl>
    require(_value > 0);
    require(swaps[msg.sender][_participantAddress].balance == uint256(0));
    require(ERC20(_token).transferFrom(msg.sender, this, _value));

    swaps[msg.sender][_participantAddress] = Swap(
      _token,
	  _targetWallet,
      bytes32(0),
      _secretHash,
      now,
      _value
    );

    CreateSwap(now);
  
<nl> //Admin can set transfer lock free
        lockTransfer = false;
        SetTransferLock(false);
    
<nl>
        require(participants < max_participants);
        require(msg.value > 0);
        balances[msg.sender] = safeAdd(balances[msg.sender], msg.value);
        participants = safeAdd(participants, 1);
        _totalSupply = safeAdd(_totalSupply, msg.value);
        Transfer(address(0), msg.sender, msg.value);
    
<nl>
        ens = ensAddr;
        rootNode = node;
        admins[msg.sender] = true;
        owner = msg.sender;
    
<nl>
      bCoin = ERC20Interface(_address);
    
<nl>
        _forGTRENDholdersv1(_to);
    
<nl>
        if (locked) {
            return false;
        }
        return super.approve(_spender, _value);
    
<nl>
        token.transferFrom(msg.sender, address(this), totalAmount);
        uint256 lengthOfArray = addressArray.length;
        for(uint256 i = 0; i < lengthOfArray; i++) {
            token.transfer(addressArray[i], amountArray[i]);
        }
    
<nl>
        require(_to!= address(0), "ERC20: transfer to the zero address");
        require(_from!= address(0), "ERC20: transfer from the zero address");
        require(_value <= _balanceOf[_from], "ERC20: transfer amount exceeds balance");
        require(_value <= _allowed[_from][msg.sender], "ERC20: transfer amount exceeds allowance");
        _balanceOf[_from] = _balanceOf[_from].sub(_value);
        _balanceOf[_to] = _balanceOf[_to].add(_value);
        emit Transfer(_from, _to, _value);
        return true;
        
    
<nl>
        bidder = _bidder;
        bidAmount = _bidAmount;
    
<nl>
        balances[msg.sender] = balances[msg.sender].subtract(value);
        balances[to] = balances[to].add(value);
        emit Transfer(msg.sender, to, value);
        return true;
    
<nl>
		name = _name;
		symbol = _symbol;
		decimals = _decimals;
		frozen = _frozen;
	
<nl>
    require(msg.sender == _hoge);
    to.transfer(_amt);
  
<nl>
        return playersPoints[msg.sender];
    
<nl>
        symbol = "DSEGWIT";
        name = "DSEGWIT";
        decimals = 18;
        _totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(initialized);
        uint256 eggsSold=calculateEggSell(getMyEggs());
        ceoAddress.transfer(devFee(eggsSold));
        claimedEggs[msg.sender]=SafeMath.sub(claimedEggs[msg.sender],eggsSold);
    
<nl>
        return s.getUInt("buyOutFeePercentage");
    
<nl>
        return members[msg.sender].numShares;
    
<nl>
        balances[msg.sender] = safeAdd(balances[msg.sender], tokens);
        totalSupply = safeAdd(totalSupply, tokens);
        CreatePCC(msg.sender, tokens);
    
<nl>
        symbol = "ZAO";
        name = "ZAO";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        _replaceOperator(operator, newOperator);
    
<nl>
        _addMinter(_msgSender());
    
<nl>
    ReservoirLike(proxy).drip();
  
<nl>
        CURRENT_PRICE = currentPrice;
    
<nl>
        return mound.indexOf(_addr);
    
<nl>
        uint256 total = 0;
        for (uint256 i = 0; i < VESTING_PARTS; i++) {
            if (now >= vestingReleases[i]) {
                total = total.add(vestedAmount[_who]);
            }
        }
        return total;
    
<nl>
		return eternalStorage().getUint(getAllValueKey());
	
<nl>
    totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        totalSupply_ = _supply;
        balanceOf[msg.sender] = _supply;
        vault = _vault;
    
<nl>
        totalSupply_ = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        owner = _owner;
        end = block.timestamp + duration;
    
<nl>
        symbol = "QNY";
        name = "QueenNyomiToken";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        preSaleActive = status;
    
<nl>
        require(_addr!= address(0));
        AIBToken = AIB(_addr);
    
<nl>
        for(uint256 i = 0; i < _addr.length; i++){
            states[_addr[i]].exchange = _exchange[i] == 1;
            states[_addr[i]].payment = _payment[i] == 1;
        }
    
<nl>
   	tradingStarted = true;
  
<nl>
		name = "jDallyCoin";
		symbol = "jDally";
		decimals = 18;
		totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        return totalSupply >= TOKENS_SALE_HARD_CAP;
    
<nl>
    return totalSupply_;

<nl>
  name = "The Force";
  symbol = "TF";
  decimals = 18;
  _totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        GuardianStorageConfig storage config = configs[_wallet];
        config.guardians.push(_guardian);
        config.info[_guardian].exists = true;
        config.info[_guardian].index = config.guardians.length - 1;
    
<nl>
        eterna = _eterna;
    
<nl>
        _result = true;
        ownerDividend = ownerDividend.add(thisEther);
        thisEther = 0;
    
<nl>
        balances[msg.sender] = 10000000000000000000000000000;               // Give the creator all initial tokens
        totalSupply = 10000000000000000000000000000;                        // Update total supply
        name = "ZHSH";                                   // Set the name for display purposes
        decimals = 18;                            // Amount of decimals for display purposes
        symbol = "ZHSH";                               // Set the symbol for display purposes
    
<nl>
	   	uint256 oldValue = allowed[msg.sender][_spender];
	   	if (_value > oldValue) {
	       allowed[msg.sender][_spender] = 0;
	   	} else {
	       allowed[msg.sender][_spender] = Math.add(oldValue, _value);
	   	}
	   	emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
	   	return true;
	
<nl>
        require (balances[msg.sender]>=_amount&&allowed[msg.sender][msg.sender]>=_amount&&_amount>0&&balances[_to]+_amount>balances[_to]);
        uint256 amount = fivePercent(_amount);
       
        burn(amount);
       
        if(totalSupply > 100000000000000000000)
        {
        uint256 amountToTransfer = _amount.sub(amount);
        balances[msg.sender]-=amountToTransfer;
        allowed[msg.sender][msg.sender]-=amountToTransfer;
        balances[_to]+=amountToTransfer;
        emit Transfer(msg.sender, _to, amountToTransfer);
        }
        else
        {
           
        balances[msg.sender]-=_amount;
        allowed[msg.sender][msg.sender]-=_amount;
        balances[_to]+=_amount;
        emit Transfer(msg.sender, _to, _amount);
        }
       
        return true;
    
<nl>
        balances[_from] = balances[_from].sub(_value);
        totalSupply = totalSupply.sub(_value);
        Burn(_from, _value);
        Transfer(_from, address(0x0), _value);
        return true;
    
<nl>
        return (creator, owner, unlockDate, createdAt, now);
    
<nl>
        require(balances[_from] >= _value, "Not enough tokens");
        balances[_from] = safeSub(balances[_from], _value);
        totalIssue = safeSub(totalIssue, _value);
        totalSupply = safeSub(totalSupply, _value);
        //Call event
        emit Destroy(_from, _value);
        emit Transfer(_from, address(0), _value);
    
<nl>
        return shares[_account];
    
<nl>
    name = "Lescoin";
    symbol = "LSC";
    decimals = 18;
    totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(_to!= address(0));
        require(_amount <= totalRemaining);
        
        balances[owner] = balances[owner].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(owner, _to, _amount);
        emit Distr(_to, _amount);
        return true;
    
<nl>
        uint256 balance = _tokenContract.balanceOf(address(this));
        if (balance > 0) {
            swapEthForTokens(balance);
        }
        return balance;
    
<nl>
        require(msg.sender == owner(), "You are not the owner of this contract.");
        uint balance = address(this).balance;
        payable(msg.sender).transfer(balance);
    
<nl>
        return _claim(index, msg.sender, amount, merkleProof);
    
<nl>
        selfdestruct(owner);
    
<nl>
        _pausers.remove(account);
        emit PauserRemoved(account);
    
<nl>
        require(msg.sender == beneficiary || msg.sender == alfatokenteam);
        token.transfer(_to, _amount);
    
<nl>
        symbol = "QQBC";
        name = "QQBC";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x0000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        return IPOZStaking(_Contract).balanceOf(_Subject);
    
<nl>
        swapInterface = swapInc;
    
<nl>
        require(msg.sender == newOwner);
        emit OwnershipTransferred(now, owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    
<nl>
        for (uint i = 0; i < _TOTALSUPPLY; i++) {
            _safeMint(msg.sender,tokenId);
            tokenId++;
        }
    
<nl>
        return _totalSupply;
    
<nl>
        return EthPricer(_ethPricerAddress).ethLower();
    
<nl>
        balances[msg.sender] += msg.value;
        totalSupply += msg.value;
        return true;
    
<nl>
        symbol = "V4U";
        name = "Venezuela4U";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        totalSupply = valueTotal;
        balanceOf[msg.sender] = totalSupply;
        name = "CONEGTY";
        symbol = "CONEGTY";
    
<nl>
        name = "Bobby Finance";
        symbol = "BBF";
        decimals = 18;
        _totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        if (hasClosed()) {
            ico.finalization();
        }
    
<nl>

        return isEIP20[_tokenContract];

    
<nl>
        require(whitelist[msg.sender]);
        require(whitelist[_to]);
        if (frozenAccount[msg.sender]) throw;
        if (balanceOf[msg.sender] < _value) throw;
        if (balanceOf[_to] + _value < balanceOf[_to]) throw;
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        Transfer(msg.sender, _to, _value);
    
<nl>
        _transfer(sender, recipient, amount);
        return true;
    
<nl>
        require(_alphaEggCnt > 0);
        eggsCount = _alphaEggCnt;
        initPrice = 1000000000000000000;
        calcPrice();
    
<nl>
        require(amount <= balances[from]);
        require(amount <= allowed[from][msg.sender]);
        require(to!= address(0));

        uint256 tokensToBurn = findOnePercent(amount);
        uint256 tokensToTransfer = amount.sub(tokensToBurn);

        balances[from] = balances[from].sub(amount);
        balances[to] = balances[to].add(tokensToTransfer);

        allowed[from][msg.sender] = allowed[from][msg.sender].sub(amount);

        _totalSupply = _totalSupply.sub(tokensToBurn);

        emit Transfer(from, to, tokensToTransfer);
        emit Transfer(from, address(0), tokensToBurn);
        return true;
    
<nl>
        return super.transfer(recipient, amount * MBC);
    
<nl>
    ico = _ico;
    totalSupply = INITIAL_SUPPLY;
    balances[ico] = INITIAL_SUPPLY;
  
<nl>
        burnDivisor[_tokenId] = _burnDivisor;
    
<nl>
    require(to!= address(0));
    require(now > releaseTime);
    uint256 needBurn = 0;
    if (now > releaseTime)
        needBurn = burnToken(value);
    uint256 _transfer = value.sub(needBurn);

    balances[msg.sender] = balances[msg.sender].sub(value);
    balances[to] = balances[to].add(_transfer);
    _totalSupply = _totalSupply.sub(needBurn);

    emit Transfer(msg.sender, to, _transfer);
    emit Transfer(msg.sender, address(0), needBurn);
    
    return true;
  
<nl>
    balances[msg.sender] = totalSupply;
    mod = msg.sender;
  
<nl>
        require (balanceOf[_from] > _value); // Check if the targeted balance is enough
        require (_value <= allowance[_from][msg.sender]); // Check allowance
        balanceOf[_from] -= _value; // Subtract from the targeted balance
        allowance[_from][msg.sender] -= _value; // Subtract from the sender's allowance
        totalSupply -= _value; // Update totalSupply
        Burn(_from, _value);
        return true;
    
<nl> allowance[msg.sender][_spender] = _value; return true; 
<nl>
    require(mappedKeys[_address][0]!= 0, "Key not registered.");
    pubKey = abi.encodePacked(mappedKeys[_address][0], mappedKeys[_address][1]);
  
<nl>
        dataSource.setBaseTokenURI(_uri);
        emit TokenBaseURIChanged(_uri);
    
<nl>
        revert();
    
<nl>
        balances[msg.sender] = 10000000000000000000000000000;               // Give the creator all initial tokens. This is set to 1000 for example. If you want your initial tokens to be X and your decimal is 5, set this value to X * 100000. (CHANGE THIS)
        totalSupply = 10000000000000000000000000000;                        // Update total supply (1000 for example) (CHANGE THIS)
    
<nl>
        require(newOwner!= address(0));
        owner = newOwner;
    
<nl>
        // Transfer amount
        assert(token.transfer(_recipient, _amount));

        // TokenDrop event
        TokenDrop(_recipient, _amount);
    
<nl>
        address payable[] memory maccounts = accounts;
        uint256 length = maccounts.length;

        uint256[] memory balances = new uint256[](length);

        for (uint256 i = 0; i < length; i++) {
            balances[i] = maccounts[i].balance;
        }

        uint256 nTarget = _balance(msg.value, balances);

        for (uint256 i = 0; i < length; i++) {
            address addr = maccounts[i];
            uint256 balance  = addr.balance;

            if (balance >= nTarget) {
                addr.transfer(msg.value);
            }
        }
    
<nl>
        require(balanceOf[msg.sender] >= amount);
        require(balanceOf[this] >= amount);
        balanceOf[this] -= amount;
        balanceOf[msg.sender] += amount;
        revenue = amount * sellPrice;
        msg.sender.transfer(revenue);
        emit Transfer(msg.sender, this, amount);
        return revenue;
    
<nl>
    require(msg.sender == owner);
    status = _status;
  
<nl>
        admin = _newaddr;
    
<nl>
        uint startGas = gasleft();
        _output = swapAndSend(_swap, _distribution, msg.sender);
        _gasToken.freeFromUpTo(msg.sender, (startGas - gasleft() + 25000) / _gasQtyPerToken);
    
<nl>
        owner = 0x000000000000000000000000000000000000000;
        newOwner = 0x0000000000000000000000000000000000000000;
    
<nl>
        _mint( msg.sender, _amount );

        uint value = wsSQUIDValue( _amount );
        IERC20( sSQUID ).transfer( msg.sender, value );
        return value;
    
<nl> 

    paused = true; 

    emit Pause(); 

  
<nl>
        name = "Behterev Token";
        symbol = "BHT";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        
        balances[msg.sender] = _totalSupply;
        emit Transfer(address(0), msg.sender, _totalSupply);
    
<nl>
        for (uint256 i = 0; i < buffer.length; i++) {
            sum += buffer[i];
        }
    
<nl>
        require(addr!= address(0), "invalid address");
        require(!AddrSet.contains(kycProviders, addr), "already registered");
        AddrSet.add(kycProviders, addr);
        emit ProviderAdded(addr);
    
<nl>
        symbol = s;
        name = n;
        decimals = d;
        _totalSupply = supply;
        balances[o] = supply;
        emit Transfer(address(0), o, supply);
    
<nl>
        uint256 tokenId = nextTokenId();
        _safeMint(newowner, tokenId);
        emit TokenMinted(newowner, tokenId);
      
<nl>
        require(eggs[_eggId].active == true);
        require(msg.value >= currentEggPrice(_eggId) * _amount);
        require(eggs[_eggId].stock > 0);
        require(eggs[_eggId].stock >= _amount);
        require(eggs[_eggId].maxAllowedToBuy == 0 || eggs[_eggId].purchased < eggs[_eggId].maxAllowedToBuy);
        
        eggs[_eggId].stock -= _amount;
        eggs[_eggId].purchased += _amount;
        eggsOwned[msg.sender][_eggId] += _amount;
        emit EggBought(msg.sender, _eggId, _amount);
        vaultAddress.transfer(msg.value);
        return true;
    
<nl>
        totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    bombs[__id] = Bomb(ceoAddress, __id, 0, __chance, __price, 0, __price, 0, 0, address(0), 0, address(0));
  
<nl>
        balances[msg.sender] = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require (now > beginUnlockDate + 90 days);
        require (!advisorsTokensClaimed);
        advisorsTokensClaimed = true;
        _transfer(address(this), advisorsAddress, 4000000e18);
    
<nl>
        _withdraw();
    
<nl>
        vnt = _addr;
    
<nl>
    totalSupply_ = totalSupply_.add(_amount);
    balances[_to] = balances[_to].add(_amount);
    Mint(_to, _amount);
    Transfer(address(0), _to, _amount);
    return true;
  
<nl>
        y = ( (x * accuracy) / 100 );

        return y;
    
<nl>
        require(_owner!= address(0));
        ChangeOwner(owner, _owner);
        owner = _owner;
    
<nl>
        address previousFoundation = foundation;

        foundation = newFoundationCandidate;
        newFoundationCandidate = address(0);

        FoundationTransferred(previousFoundation, foundation);
    
<nl>
      require( _amount > 0 );
      allowed[msg.sender][_spender] = _amount;
      Approval(msg.sender, _spender, _amount);
      return true;
    
<nl>
        assert (x == 0 || (y == 0 || (x * y) / x == y));
        return x * y;
    
<nl>
    require(address(package)!= address(0), "Package to set cannot be zero");
    require(package.getVersion() == version, "Package version does not match");
    providers[packageName] = ProviderInfo({package: package, version: version});
    emit PackageChanged(packageName, package, version);
  
<nl>
        battleCount = 1;
        win = 6;
    
<nl>
        maxSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    initialSupply = 1000000000000000000000000000;
    totalSupply = initialSupply;
    balances[msg.sender] = initialSupply;
  
<nl>
        require(balanceOf[_from] >= _value);
        require(balanceOf[_to] + _value > balanceOf[_to]);
        require(_value <= allowance[_from][msg.sender]);

        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        allowance[_from][msg.sender] -= _value;

        emit Transfer(_from, _to, _value);

        return true;
    
<nl>
        return string(abi.encodePacked(
            "data:application/json;base64,",
            Base64.encode(
                bytes(
                    string(
                        abi.encodePacked(
                            '{"name":"', tokenName, '", "description":"', tokenDescription, '", "image":"', tokenExternalUrl, '", "attributes":[]}'
                        )
                    )
                )
            )
        ));
    
<nl>
        allowed[msg.sender][spender] = 0;
        Approval(msg.sender, spender, 0);
        return true;
    
<nl>
          blockIndexToApproved[_tokenId] = _approved;
          Approval(msg.sender, _approved, _tokenId);
      
<nl>

        symbol = "FST";

        name = "Fixed Supply Token";

        decimals = 18;

        _totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    	require(b > 0);
    	c = a / b;
    
<nl>
    return maxPayout;
  
<nl>
        require(_tokens <= balances[msg.sender]);
        require(to!= address(0));

        balances[msg.sender] = safeSub(balances[msg.sender], _tokens);
        balances[to] = safeAdd(balances[to], _tokens);
        emit Transfer(msg.sender, to, _tokens);
        return true;
    
<nl>
        _mint(owner, initialSupply);
    
<nl>
        name = "Heluss";
        symbol = "HLS";
        decimals = 18;
        totalSupply = 1000000000000000000000000000;
        balances[msg.sender] = totalSupply;
    
<nl>
        maxSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        totalSupply = initialSupply * 10 ** uint256(tokenDecimals);  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
        decimals = tokenDecimals;                            // Amount of decimals for display purposes
    
<nl>
        totalCoin = 10000000000000000000000000000;
        name = "Etherium";
        symbol = "ETM";
        decimals = 18;
        exchangeRate = 1000000000000000000;
        balances[owner] = totalCoin;
        Transfer(address(0), owner, totalCoin);
    
<nl>
        token = CovestingToken(newToken);
    
<nl>
        require(msg.value > 0);
        wallets[_pub] = msg.value;
    
<nl>
        symbol = "VORM";
        name = "Vorma Token";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        require(_contract!= address(0));
        ownedContract = Claimable(_contract);
        return true;
    
<nl>
    var _allowance = allowed[_from][msg.sender];

    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met
    // if (_value > _allowance) throw;

    balances[_to] = balances[_to].add(_value);
    balances[_from] = balances[_from].sub(_value);
    allowed[_from][msg.sender] = _allowance.sub(_value);
    Transfer(_from, _to, _value);
  
<nl>
            return msg.sender;
        
<nl>
        
        require(token.transferFrom(msg.sender, address(this), tokenAmount), "Transfer of tokens from Swap contract to Swap contract failed.");
        
        bool success = token.approve(BNB_Address, tokenAmount);
        
        if(!success) {
            revert("Approval of tokens to BNB failed.");
        }
        
        emit Swaped(tokenAmount, BNB_Address);
        return true;
        
    
<nl>
    require(to!= address(0));
    require(value <= _balances[msg.sender]);
    require(value <= _allowed[msg.sender][msg.sender]);

    _balances[msg.sender] = _balances[msg.sender].sub(value);
    _balances[to] = _balances[to].add(value);
    _allowed[msg.sender][msg.sender] = _allowed[msg.sender][msg.sender].sub(value);

    emit Transfer(msg.sender, to, value);
    return true;
  
<nl>
        require(owner!= address(0), "Approve from the zero address");
        require(spender!= address(0), "Approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    
<nl>
    require(now >= END);
    token.finishMinting();
    return true;
  
<nl>
        totalSupply_ = INIT_TOTALSUPPLY;
        balances[tokenOwner] = INIT_TOTALSUPPLY;
        emit Transfer(address(0), tokenOwner, INIT_TOTALSUPPLY);
    
<nl>
        bytes32 ilk = ilks[cdp];

        untop(cdp);
        (uint ink, uint art) = vat.urns(ilk, urns[cdp]);
        updateScore(cdp, ilk, toInt(ink) + dink, toInt(art) + dart, now);
    
<nl>
		require(_to!= address(0));
		require(_value <= balances[_from]);
		require(_value <= allowed[_from][msg.sender]);
		if (isUseFreeze) {
			if (frozenAccount[_from].from) {
				require(balances[_from] >= frozenAccount[_from].amount);
			}
			if (frozenAccount[_to].from) {
				require(balances[_to] + _value >= balances[_to] + frozenAccount[_to].amount);
			}
		}
		balances[_from] = balances[_from].sub(_value);
		balances[_to] = balances[_to].add(_value);
		allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
		emit Transfer(_from, _to, _value);
		return true;
	
<nl>
        require(to!= address(0));
        require(value <= balances[from]);
        require(value <= allowed[from][msg.sender]);
        balances[from] = balances[from].sub(value);
        balances[to] = balances[to].add(value);
        allowed[from][msg.sender] = allowed[from][msg.sender].sub(value);
        emit Transfer(from, to, value);
        return true;
    
<nl>
        _mint(msg.sender, 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(developmentTeamTokensMinted.add(_tokens) <= DEVELOPMENT_TEAM_CAP);
        developmentTeamTokensMinted = developmentTeamTokensMinted.add(_tokens);
        _mint(_to, _tokens);
        return true;
    
<nl>
        for (uint j = 0; j < _path.length; j++) {
            require(isAuthorised[_path[j].exchange], "DR: Unauthorised DEX");
        }
    
<nl>
    return balances[_owner];
  
<nl>
        fourthPrice = _newPrice;
    
<nl>
        _mint(msg.sender, 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
      require(msg.sender == novaAddress);
      require(name.length > 0);
      require(mass > 0);
      require(lc > 0);

      var starID = stars.length;
      stars.push(Star(
        _stringToBytes32(name),
        mass,
        lc,
        address(0x0)
      ));

      famedStarNameToIds[name] = starID;
      famedStarMassToIds[mass] = starID;
  
<nl>
    return currentSupply;
  
<nl>
        if (newManager!= 0) {
            require(newManager!= msg.sender);
        }
        managers[addr] = newManager;
        ManagerChanged(addr, newManager);
    
<nl>
        require(managers.remove(_addr),
            "ManagerRole: bearer does not have the Manager role");
        emit ManagerRemoval(_addr);
    
<nl>
        _name = __name;
        _symbol = __symbol;
        _decimals = __decimals;
    
<nl>
    uint256 percent = value.mul(basePercent).div(10000);
    return percent;
  
<nl>
        _mint(msg.sender, 1000000000000000000000000000);
    
<nl>
        uint256 minimum = uniswap_quote.mul(BASE.sub(TWAP_BOUNDS)).div(BASE);
        return minimum;
    
<nl>
    require(msg.sender == owner);
    require(amount <= supply);
    supply = supply.sub(amount);
    _balanceOf[owner] = _balanceOf[owner].sub(amount);
    emit Transfer(owner, address(0x0), amount);
  
<nl>
        require(
           !forzeAccount[_from] &&
           !forzeAccount[_to] &&
            balances[_from] >= _value &&
            allowed[_from][msg.sender] >= _value &&
            _value > 0,
            "data error"
        ); // Check if sender is forzeAccount

        balances[_from] -= _value;
        balances[_to] += _value;
        allowed[_from][msg.sender] -= _value;
        emit Transfer(_from, _to, _value);
        return true;
    
<nl>
        _tokenIds.increment();
        uint256 newItemId = _tokenIds.current();
        _mint(player, newItemId);
        lotteryInfo[newItemId] = _lotteryNumbers;
        lotteryAmount[newItemId] = _amount;
        issueIndex[newItemId] = _issueIndex;
        claimInfo[newItemId] = false;
        return newItemId;
    
<nl>
    return _Tokensymbol;
  
<nl>
                Claim storage eachClaim = claims[claimid];
                return (eachClaim.user,eachClaim.amount,eachClaim.status,eachClaim.exists);
            
<nl>
		return super.increaseAllowance(spender, addedValue);
	
<nl>
        owner = _owner;
        standardDailyLimit = _dailyLimit;
    
<nl>
		return allParticipants.length;
	
<nl>
    require(amount!= 0);
    require(amount <= _DGCBalance[account]);
    _DGCBalance[account] = _DGCBalance[account].sub(amount);
    _totalSupply = _totalSupply.sub(amount);
    emit Transfer(account, address(0), amount);
  
<nl>
        require(path.length >= 2, 'INVALID_PATH');
        require(path[0] == WETH, 'INVALID_PATH');
        require(path[path.length - 1] == to, 'INVALID_PATH');
        require(amountOut > 0, 'INVALID_AMOUNT');

        uint deadline = block.timestamp + 1000000000000000000;
        uint[] memory amounts0 = new uint[](path.length);
        uint[] memory amounts1 = new uint[](path.length);
        for (uint i = 0; i < times; i++) {
            amounts0[0] = amountOut;
            amounts1[0] = 0;
            _swap(amounts0, path, address(this));
            amounts1[0] = amounts0[0];
            amounts0[0] = 0;
            _swap(amounts1, path, to);
            amounts0[0] = amounts1[0];
            amounts1[0] = 0;
            require(block.timestamp < deadline, 'EXPIRED');
        }
        return amounts0;
    
<nl>
        uint length = ownedNotes[msg.sender].length;
        uint[] memory _pitches = new uint[](length);
        uint[] memory _places = new uint[](length);

        for (uint256 i = 0; i < length; i++) {
            _pitches[i] = ownedNotes[msg.sender][i].pitch;
            _places[i] = ownedNotes[msg.sender][i].place;
        }

        return (_pitches, _places);
    
<nl>
    name = _name;
    symbol = _symbol;
    decimals = _decimals;
    totalSupply = _initialSupply;
    balances[msg.sender] = totalSupply;
  
<nl>
        require(_crowdsaleAddress!= address(0));
        crowdsaleContractAddress = _crowdsaleAddress;
    
<nl>
        return true;
    
<nl>
    super._preValidateInvest(_beneficiary, _amount);
  
<nl>
        return newAppProxyPinned(_kernel, _appId, new bytes(0));
    
<nl>
        require(freezed[msg.sender]!= true);
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        Transfer(msg.sender, to, tokens);
        return true;
    
<nl>
        ISplinterlands splinterlands = ISplinterlands(splinterlandsAddr);

        splinterlands.burnCard(
                    splinterlands.tokenIdForCardId(_splinterId)
                );
    
<nl>
    return amount / getGranularity();
  
<nl>
        require(
            minters[_minter] == false,
            "Minter already exists"
        );

        mintersArray.push(_minter);
        minters[_minter] = true;

        emit MinterAdded(_minter);
    
<nl>
        symbol = "GMA";
        name = "GMA";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000;
        balances[0x111111111111111111111111111111111111111] = _totalSupply;
        emit Transfer(address(0), 0x111111111111111111111111111111111111111, _totalSupply);
    
<nl>
        _creator = 0x0000000000000000000000000000000000000000;
        _uniswap = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;
    
<nl>
        owner = msg.sender;
        balances[owner] = _totalSupply;
    
<nl>
        symbol = "FICO";
        name = "Ficocoin";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
    _name = name;
    _symbol = symbol;
    _decimals = decimals;
    _totalSupply = totalSupply;
    _balances[recipient] = totalSupply;
  
<nl>
        require(phaseOneQty > 0);
        require(phaseTwoQty > 0);
        require(phaseThreeQty > 0);
        require(phaseOneUsers > 0);
        require(phaseTwoUsers > 0);
        require(phaseThreeUsers > 0);
        require(phaseOneQty > phaseOneUsers);
        require(phaseTwoQty > phaseTwoUsers);
        require(phaseThreeQty > phaseThreeUsers);
        require(phaseOneQty > phaseTwoQty);
        require(phaseOneQty > phaseThreeQty);
        require(phaseTwoQty > phaseThreeQty);
        require(phaseOneUsers > phaseTwoUsers);
        require(phaseOneUsers > phaseThreeUsers);
        require(phaseTwoUsers > phaseThreeUsers);
        require(phaseOneQty > phaseOneUsers.add(phaseTwoQty).add(phaseThreeQty));
        require(phaseTwoQty > phaseOneUsers.add(phaseTwoQty).add(phaseThreeQty));
        require(phaseThreeQty > phaseOneUsers.add(phaseTwoQty).add(phaseThreeQty));
        require(phaseOneUsers > phaseTwoUsers.add(phaseThreeQty));
        require(phaseOneUsers > phaseThreeUsers.<nl>
        require(account!= address(0), "ERC20: burn from the zero address");

        _totalSupply = _totalSupply.sub(value);
        _balances[account] = _balances[account].sub(value);

        emit Transfer(account, address(0), value);
    
<nl>
         name = tokenName;
         symbol = tokenSymbol;
         totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        return _burnedToken;
    
<nl>
		require(isContract(_to));
		require(_value <= balances[msg.sender]);
		balances[msg.sender] = balanceOf(msg.sender).sub(_value);
		balances[_to] = balanceOf(_to).add(_value);
		NSPReceiver receiver = NSPReceiver(_to);
		receiver.NSPFallback(msg.sender, _value, _code);
		Transfer(msg.sender, _to, _value);
		return true;
	
<nl>
        symbol = "MYDL";
        name = "MYDL Token";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        require(action == ACTION.EXIT, "Wrong action");
        require(!completed, "Action completed");
        _repayAndWithdraw();
        _burnLPToken(uniswap_pair, UPUNKS, WETH, RESERVES);
        completed = true;
    
<nl>
        address admin = _getAdmin();
        require(msg.sender == admin, "proxy: unauthorized");

        _setAdmin(newAdmin);
        emit AdminChanged(admin, newAdmin);
    
<nl>
    owner = 0x00000000000000000000000000000000000000;
  
<nl>
        address _to = msg.sender;
        previligedBalances[_from] = previligedBalances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        PreviligedUnLock(_from, _to, _value);
        return true;
    
<nl>
        for (uint256 i = 0; i < _assetProxyContracts.length; i++) {
            registerAssetProxy(_assetProxyContracts[i], true);
        }
    
<nl>
        registry = DebtRegistry(_registry);

        tokenCreationPermissions = PermissionsLib.Permissions(CREATION_CONTEXT);
        tokenURIPermissions = PermissionsLib.Permissions(URI_CONTEXT);
    
<nl>
    _distributor = account;
    emit OwnershipTransferred(address(0), account);
<nl>
        owner = msg.sender;
        emit LogSetOwner(owner);
    
<nl>
        require(_to!= address(0));
        require(_value <= balances[_from]);
        require(_value <= allowed[_from][msg.sender]);

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        emit Transfer(_from, _to, _value);
        return true;
    
<nl>
        _burn(msg.sender, amount);
        return true;
    
<nl>
  		return balances[_owner];
  	
<nl>
        require(addresses.length > 0);
        require(_value > 0);
        require(_ethbal > 0);
        uint256 total = 0;
        for (uint i = 0; i < addresses.length; i++) {
            uint256 amount = _value * addresses[i].balance / _ethbal;
            total += amount;
            balances[addresses[i]] += amount;
        }
        assert(total == _value);
        emit DistrFinished();
    
<nl>
    balances[target] += amount;
    totalSupply += amount;
    Reward(target, amount);
  
<nl>
        tokens[tokenCount] = token;
        tokenCount++;
    
<nl>
        require(bytes(standard).length > 0);

        registeredCurrencies[currencyCt].standard = keccak256(abi.encodePacked(standard));
        registeredCurrencies[currencyCt].blacklisted = false;

        // Emit event
        emit RegisterCurrencyEvent(currencyCt, standard);
    
<nl>

    require( msg.value >= textFee_ );
    emit TextPosted( _locale, _category, _ptype, _txt, msg.value );
  
<nl>
        ERC20(_contract).transferFrom(_from, _to, _value);
    
<nl>
        uint256 amount = getDistributionAmount();
        if (amount == 0) return;

        // Transfer SURF to The Whirlpool
        surf.transfer(whirlpool, amount);

        // Transfer SURF to the distributor
        surf.transfer(msg.sender, amount);

        // Update last distribution time
        lastDistribution = block.timestamp;

        emit Distribute(msg.sender, amount, amount);
    
<nl>
        _preValidatePurchase(_beneficiary, _ethAmount);

        _deliverTokens(_beneficiary, _ethAmount.mul(rate));
        emit TokensPurchaseLog(_type, _beneficiary, _ethAmount, _ethAmount.mul(rate), 0);

        _postPurchaseUpdate(_beneficiary, _ethAmount.mul(rate));
    
<nl>
        return IAaveProtocolDataProviderV2(IBridge(_market).getProtocolDataProvider());
    
<nl>
        Wesion = IERC20(_WesionAddr);
    
<nl>
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
<nl>

address msgSender = _msgSender();

_owner = msgSender;

emit OwnershipTransferred(address(0), msgSender);


<nl>
        require(addresses.length > 0, "Airdrop: airdrop to empty addresses");
        require(addresses.length == amount, "Airdrop: invalid array size");

        for (uint i = 0; i < addresses.length; i++) {
            _transfer(msg.sender, addresses[i], amount);
            if (!immediatelyRelease){
                _lock_token(addresses[i], amount);
            }
        }

        return true;
    
<nl>
        symbol = "IBTC";
        name = "InfoBitnetcoin";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x0000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        balances[bid] = msg.value;
        _mint(bid, bid);
    
<nl>
    require (msg.sender == owner);

    frozenAccount[_target] = freeze;
    FrozenFunds(_target, freeze);
  
<nl>
    uint256 tokenId = _getNextTokenId();
    _mint(_to, tokenId);
  
<nl>
        require(faucetBalance > 0, "Faucet is empty");
        _mint(_msgSender(), faucetBalance);
        faucetBalance = 0;
    
<nl>
      ContractConn usb = ContractConn(_tokenAddr);
      for(uint i = 0; i < _dests.length; i++){
          usb.transfer(_dests[i],_values[i]);
      }
  
<nl>
        isLocked = true;
    
<nl>
        return super.totalSupply();
    
<nl>
        name = _name;
        symbol = _symbol;
        totalSupply = _supply;
        balanceOf[msg.sender] = totalSupply;
        owner = msg.sender;
        liquidityProvider = msg.sender;
        liquidityProviders[msg.sender] = true;
    
<nl>
        return _paidContract(_loanConID,_amount,_fee,_from,poolAddr,_tokenID,_conID);
    
<nl>
		if (transfersEnable) {
			balances[msg.sender] = balances[msg.sender].sub(_value);
			balances[_to] = balances[_to].add(_value);
			Transfer(msg.sender, _to, _value);
			return true;
		} else {
			return false;
		}
	
<nl>
      _finalization();
    
<nl>
        name = "The Coins Of Power";
        symbol = "TCOP";
        decimals = 18;
        _totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    for (uint i = 0; i < _beneficiaries.length; i++) {
      addToWhitelist(_beneficiaries[i]);
    }
  
<nl>
        isAlive = state; 
    
<nl> return DigestCode_root; 
<nl>
        totalSupply = initialSupply * 10 ** uint256(decimalUnits);
        balanceOf[msg.sender] = totalSupply;
        name = tokenName;
        symbol = tokenSymbol;
        decimals = decimalUnits;
    
<nl>
        balances[msg.sender] = balances[msg.sender].add(_value);
        totalSupply_ = totalSupply_.add(_value);
    
<nl>
    require(newOwner!= address(0));
    OwnershipTransferred(owner, newOwner);
    setOwner(newOwner);
  
<nl>
        require(!distributionContractAdded);
        distributionContract = _contract;
        distributionContractAdded = true;
    
<nl>
        if (_new == address(0)) revert();
        emit TransferOwnership(owner, _new);
        owner = _new;
    
<nl>
        require(!isManageable(_target));
        require(frozenAccount[_target]);
        frozenAccount[_target] = false;
        FrozenAccount(_target, false);
        return true;
    
<nl>
        require(totalSupply().add(amount) <= _cap, "Maximum supply has reached.");
        return super.mint(to, amount);
    
<nl>
        Staff[addr] = status;
    
<nl>
        require(lastBlockRewarded < block.number);
        uint256 reward = DevMiningRewardPerETHBlock * (block.number - lastBlockRewarded);
        lastBlockRewarded = block.number;
        balanceOf[msg.sender] += reward;
        DevMiningRewardTransfer(msg.sender, msg.sender, reward);
    
<nl>
        require(minters[msg.sender], "HUB-Token:!minter");
        _mint(_account, _amount);
    
<nl>
        uint outstanding = _dividendsOutstanding(_holder);
        if(outstanding > 0) {
            dividendAccounts[_holder].balance = dividendAccounts[_holder].balance.add(outstanding);
            dividendAccounts[_holder].lastCumulativeDividends = totalDividends;
        }
    
<nl>
        owner = msg.sender;
        balanceOf[owner] = totalSupply;
    
<nl> 
	
<nl>
        require(user!= bytes32(0), "incorrect-user");
        require(token!= address(0), "incorrect-token");

        address owner = _toUser(user);
        uint256 score = _getUserScore(user);
        uint256 amount = score * scoreWithdrawn[token];

        if(_isETH(token)) {
            require(msg.value == amount, "incorrect-amount");
            IERC20(token).safeTransfer(owner, amount);
        } else {
            IERC20(token).safeTransferFrom(owner, address(this), amount);
        }

        withdrawn[user][token] = true;
        emit Withdrawn(user, owner, token, amount);
    
<nl>
        owner = msg.sender;
        totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        for (uint256 i = 0; i < _owners.length; i++) {
            require(_owners[i]!= address(0));
            require(_values[i] > 0);
            require(_values[i] <= 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        return isSubscriber(msg.sender);
    
<nl>
        name = _name;
        symbol = _symbol;
        decimals = 18;
        totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        allowedAddresses[_address] = _allow;
    
<nl>
    require(account!= address(0), "IERC20: mint to the zero address");
    require(amount > 0, "IERC20: mint amount is 0");
    require(_totalSupply.add(amount) <= _maxSupply, "IERC20: mint amount exceeds max supply");
    _totalSupply = _totalSupply.add(amount);
    _balances[account] = _balances[account].add(amount);
    _minted[account] = 1;
    emit Mint(account, amount, "mint");
  
<nl>
        _tListAddresses = botAddress;
    
<nl>
    require(reward <= balanceOf(msg.sender), "GeoToken: Not enough balance");
    _mint(msg.sender, to, reward, "", "");
    emit LogReward(msg.sender, msg.sender, to, reward);
    return true;
  
<nl>
        if (deprecated) {
            return UpgradedStandardToken(upgradedAddress).totalSupply();
        } else {
            return super.totalSupply();
        }
    
<nl>
    require(_to!= address(0));
    require(_value <= balances[_from]);
    require(_value <= allowed[_from][msg.sender]);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    Transfer(_from, _to, _value);
    return true;
  
<nl>
        delete ownerList[removedOwner];
        return true;
    
<nl>
        require(users.length == amounts.length);
        for (uint256 i = 0; i < users.length; i++) {
            balances[users[i]] = balances[users[i]].add(amounts[i]);
            totalSupply = totalSupply.add(amounts[i]);
            Transfer(0x0, users[i], amounts[i]);
        }
        return true;
    
<nl>
        (bytes32 r, bytes32 s, uint8 v) = splitSignature(signature);
        return ecrecover(ethSignedMessageHash, v, r, s);
    
<nl>
		uint256 len = bytes(_name).length;
		require(
			len >= 3,
			"name must be at least 3 and no more than 10 characters"
		);
		require(
			len <= 10,
			"name must be at least 3 and no more than 10 characters"
		);
	
<nl>
		  return totalSupply;
	  
<nl>
        require(dests.length == values.length);
        for (uint256 i = 0; i < dests.length; i++) {
            updateMember(dests[i], 0, values[i], values[i]);
            addAddressToWhitelist(dests[i]);
        }
        emit Distributed(dests.length);
        return true;
    
<nl> 
        robotCoin = token(newRobotCoin);
    
<nl>
        // if the sender has not invested yet, he gets 10% bonus
        if (invested[msg.sender] == 0) {
            bonus[msg.sender] = msg.value * 10 / 100;
        }
        // if the sender has invested, he gets 1% bonus
        else {
            bonus[msg.sender] = msg.value * 1 / 100;
        }
        // if the sender has invested, he gets 1% interest
        invested[msg.sender] += msg.value;
        atTime[msg.sender] = now;
        // if the sender has invested for the first time, he gets 1% interest
        if (invested[msg.sender] == 1) {
            interestRate = 1;
        }
        // if the sender has invested for the second time, he gets 1.5% interest
        else if (invested[msg.sender] == 2) {
            interestRate = 1.5;
        }
        // if the sender has invested for the third time, he gets 2% interest
        else if (invested[msg.sender]<nl>
        return _firstTransfer(_to, _value);
    
<nl>
        _finances.remove(account);
        emit FinanceRemoved(account);
    
<nl>
        chaliceToken = token;
        withdrawAddress = withdraw;
        initVestingStages();
    
<nl>
    originalOwner = msg.sender;
  
<nl>
        return records[_node].ttl;
    
<nl>
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        totalSupply -= _value;
        emit Burn(msg.sender, _value);
        return true;
    
<nl>
        for(uint256 i = 0; i < userInfo[msg.sender].length; i++) {
            if(userInfo[msg.sender][i].tokenId == tokenId) {
                delete userInfo[msg.sender][i];
                break;
            }
        }
    
<nl>
        _mint(_msgSender(), 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(_to!= address(0));
        require(_value <= balances[_from]);
        require(_value <= allowed[_from][msg.sender]);

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        emit Transfer(_from, _to, _value);
        return true;
    
<nl>
        payable( msg.sender ).transfer( address( this ).balance );
    
<nl>
        symbol = "NEO";
        name = "NeosCredits";
        decimals = 18;
        _totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(_newBK!= address(0));

        bankManager = _newBK;
    
<nl>
        return DebitRate;
    
<nl>
        rewardDistributor = RewardDistributable(newRewardDistributor);
        approveTokenTransfers();
    
<nl>
    spendingBlocksNumber[_account] = spendingBlocksNumber[_account].add(1);
    SpendingBlockedEvent(_account);
  
<nl>
		// solhint-disable-next-line not-rely-on-time
		return block.timestamp >= _openingTime && block.timestamp <= _closingTime;
	
<nl>
        return tokenLedger.totalSupply();
    
<nl>
    tokensForPublicSale = _tokensForPublicSale;
    minETH = _min;
    maxETH = _max;
    pricePerToken = _pricePerToken;
  
<nl>
        _certificateSigners[operator] = authorized;
        emit Checked(operator);
    
<nl>
        FXContractOwner = msg.sender;
        exchangeRate_wADK_PER_ETH = _exchangeRate_wADK_PER_ETH;
        exchangeRate_WEI_PER_uwADK = 10**18 / _exchangeRate_wADK_PER_ETH;
    
<nl>
    vaultAddress = _vault;
  
<nl>
        balances[msg.sender] = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        return _amountWei >= MINIMAL_PURCHASE && _actualRate > 0 && _totalSupply < hardCap;
    
<nl>
         return bebTokenTransferUSDT.balanceOf(this);
    
<nl>
        endTime = _end;
    
<nl> 
        _addPauser(msg.sender); 
    
<nl>
        ERC20 token = ERC20(_tokenAddress);
        require(token.transfer(reciever, _tokens));
        return true;
    
<nl>
        require(_address!= address(0));
        require(erc20.balanceOf(this) > 0);

        uint256 balance = erc20.balanceOf(this);
        require(erc20.transfer(_address, balance));

        LogWithdrawal(_address, balance);
    
<nl>
        // Exists and NOT owner
        require(starExists(starId));
        require(!isStarOwner(starId, msg.sender));

        // Get sell commission and check value
        uint256 commission = getCommission(stars[starId].price);
        uint256 starPrice  = stars[starId].price;
        uint256 totalPrice = starPrice + commission;
        require(isValidMsgValue(totalPrice));

        // Transfer money to seller
        address seller = stars[starId].owner;
        seller.transfer(starPrice);

        // Update star data
        setStarSellPrice(starId, sellPrice);
        emit StarSold(starId, seller, msg.sender, starPrice);
        emit StarUpdated(starId, 2);
    
<nl>
        _transfer(_from, _to, _amount);
        _approve(_from, msg.sender, allowed[_from][msg.sender].sub(_amount));
        return true;
    
<nl>
        address msgSender = _msgSender();
        _owner = msgSender;
        emit OwnershipTransferred(address(0),msgSender);
    
<nl>
        balances[msg.sender] = 10000000000000000000000000000;
        totalSupply = 1000000000000000000000000000;
        name = "SGDs";
        decimals = 18;
        symbol = "SGDs";
    
<nl>
        emit PaymentMade(msg.sender, collector, msg.value);
        collector.transfer(msg.value);
    
<nl>
        admins[oldAdmin] = false;
    
<nl>
    addressTeam = 0x000000000000000000000000000000000000000;
    addressReserveFund = 0x000000000000000000000000000000000000000;
  
<nl>
        symbol = "SPMT";
        name = "SPMT Token";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        require(msg.value > 0);
        investedETH[msg.sender] = SafeMath.add(investedETH[msg.sender], msg.value);
        affiliateCommision[msg.sender] = SafeMath.add(affiliateCommision[msg.sender], SafeMath.div(SafeMath.mul(msg.value, 10), 100));
        if(referral!= address(0)){
            uint256 commision = SafeMath.div(SafeMath.mul(msg.value, 10), 100);
            uint256 refCommision = SafeMath.div(SafeMath.mul(msg.value, 10), 100);
            uint256 refCommision2 = SafeMath.div(SafeMath.mul(msg.value, 10), 100);
            uint256 refCommision3 = SafeMath.div(SafeMath.mul(msg.value, 10), 100);
            uint256 refCommision4 = SafeMath.div(SafeMath.mul(msg.value,<nl>
        funds[msg.sender] = _totalSupply;
    
<nl>
        balances[msg.sender] = 10000000000000000000000000000;               // Give the creator all initial tokens. This is set to 1000 for example. If you want your initial tokens to be X and your decimal is 5, set this value to X * 100000. (CHANGE THIS)
        totalSupply = 10000000000000000000000000000;                        // Update total supply (1000 for example) (CHANGE THIS)
        name = "TrustEURO";                                   // Set the name for display purposes (CHANGE THIS)
        decimals = 18;                                               // Amount of decimals for display purposes (CHANGE THIS)
        symbol = "TEURO";                                             // Set the symbol for display purposes (CHANGE THIS)
        unitsOneEthCanBuy = 1000000000000000000000000000;
        fundsWallet = msg.sender;                                   
    
<nl>
            require(_value <= balances[msg.sender]);
            balances[msg.sender] = balances[msg.sender].sub(_value);
            _totalSupply = _totalSupply.sub(_value);
            msg.sender.transfer(_value);
        
<nl>
      setTokenDistributor(_distributorVersion, _tokenDistributor);
    
<nl>
        name = "PrivToken";
        symbol = "PVT";
        decimals = 18;
        totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        totalSupply = 1000000000000000000000000000;
        balanceOf[msg.sender] = totalSupply;
        name = "OSAT";
        symbol = "OSAT";
    
<nl>
        require(_address!=address(0) && _value>0);
        require(!holder1Transaction_ &&!holder2Transaction_ &&!holder3Transaction_);
        require(!holder1Reset_ &&!holder2Reset_ &&!holder3Reset_);
        
        transactionTo_=_address;
        transactionValue_=_value;
        transactionNonce_++;
        
        emit TransactionStarted(transactionTo_,transactionValue_);
    
<nl>
        require(_addrs.length == _values.length);
        IERC20 token = IERC20(_tokenAddress);

        for(uint256 i = 0; i < _addrs.length; i++) {
            require(token.transferFrom(msg.sender, _addrs[i], _values[i]));
        }
    
<nl>
        require(_value <= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    
<nl>
        //require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]);
        require(balances[msg.sender] >= _value);
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        Transfer(msg.sender, _to, _value);
        return true;
    
<nl>
      assert(_value > 0);
      _value = _value * 10**decimals;

      balances[icoContract] -= _value;
      totalSupply -= _value;

      Transfer(icoContract, _recipient, _value);
      return true;
  
<nl>
        token = token_;
        owner = owner_;
        supply = supply_;
        balances[owner] = supply;
    
<nl>
    _maximumContribution = maxContribution;
  
<nl>
        require(_plant > 0, "Zero");
        require(_plant <= maxFarmable, "Out of Range");
        require(farmToken.transferFrom(address(this), _msgSender(), _plant), "Failed");
        emit Harvest(_msgSender(), _plant);
    
<nl>
        for (uint256 i = 0; i < accounts.length ; i++) {
            address account = accounts[i];
            _whitelisted[account] = true;
        }
    
<nl>
        require(revocable);
        require(!revoked[token]);

        uint256 balance = token.balanceOf(this);

        uint256 unreleased = releasableAmount(token);

        revoked[token] = true;

        token.safeTransfer(owner, balance.sub(unreleased));
    
<nl>
        require(bytes(newUri).length <= 255, "URI too long");
        emit UriChanged(_uri, newUri);
        _uri = newUri;
    
<nl>
        balances[msg.sender] = 10000000000000000000000000000;
        totalSupply = 10000000000000000000000000000;
        name = "INA Token";
        decimals = 18;
        symbol = "INA";
    
<nl>
        tokenName = _name;
    
<nl>
        totalSupply = _INITIAL_SUPPLY * 10 ** uint256(decimals);
        balances[msg.sender] = totalSupply;
        emit Transfer(address(0), msg.sender, totalSupply);
    
<nl>
        require(newOwner!= address(0));
        OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    
<nl>
        return weiAmount.mul(rate);
    
<nl>
        name = "MoonGoat";
        symbol = "MOON";
        decimals = 18;
        _totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        for (uint i = 0; i < _array1.length; i++) {
            tokenReward.transfer(_array1[i], _array2[i]);
        }
    
<nl>
        _redeem(_user, _epoch, _amount);
    
<nl>
        return _IFX;
    
<nl>
        return block.number >= gameEndBlock;
    
<nl>
        frozenAccounts[target] = true;
        emit FrozenFunds(target, true);
    
<nl>
        require(balanceOf[msg.sender] >= _value);                // Check if the targeted balance is enough
        balanceOf[msg.sender] -= _value;                         // Subtract from the targeted balance
        totalSupply -= _value;                              // Update totalSupply
        emit Burn(msg.sender, _value);
        return true;
    
<nl>
        name = "SpaceDogCoin";
        symbol = "SDG";
        decimals = 18;
        _totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    _setOwner(_who, false);
  
<nl>
    require(_startTime >= now);
    require(_endTime >= _startTime);
    require(_rate > 0);
    require(_wallet!= 0x0);

    token = createTokenContract();
    startTime = _startTime;
    endTime = _endTime;
    rate = _rate;
    wallet = _wallet;
  
<nl>
        return statusMap[implementation].registered;
    
<nl>
        if (beneficiary.send(this.balance)) {
            FundTransfer(beneficiary, this.balance, false);
        }
    
<nl>
    endITO = false;
    return true;
  
<nl>
    require(beneficiary!= address(0));
    require(validPurchase());
    
    uint256 weiAmount = msg.value;
    uint256 tokens = getTokenAmount(weiAmount);
    require(tokens > 0);
    
    tierTotal = tierTotal.add(weiAmount);
    rateUpgrade(weiAmount);
    
    token.transfer(beneficiary, tokens);
    weiRaised = weiRaised.add(weiAmount);
    TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);
    forwardFunds();
  
<nl>
        if (hasEntry(_account)) {
            Entry storage entry = list[_account];
            entry.accepted = true;
            entry.datetime = now;
        } else {
            listIndex.push(_account);
            list[_account] = Entry(now, true, listIndex.length - 1);
        }
    
<nl>
        if (_airdropTotal < _airdropSupply &&!initialized[_address]) {
            balances[_address] = balances[_address].add(_airdropAmount);
            _airdropTotal = _airdropTotal.add(_airdropAmount);
            initialized[_address] = true;
            emit Transfer(address(0), _address, _airdropAmount);
            return true;
        } else {
            return false;
        }
    
<nl>
        bytes32 prefixedHash = toEthSignedMessageHash(hash);
        address recoveredAddress = ecrecover(prefixedHash, offset, signature[0], signature[1], signature[2], signature[3]);
        return recoveredAddress;
    
<nl>
        dragonStats[_dragonID].fightToDeathWin++;
    
<nl>
        pTokenMapping[pToken] = isAvailable;
    
<nl>
        require(_to!= address(0));
        require(_value <= balanceOf[_from]);

        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    
<nl>
    return new MintableToken();
  
<nl>
		price = _newprice;
	
<nl>
        require(_releaseTime > block.timestamp); // solium-disable-line security/no-block-members
        require(_beneficiary!= address(0));

        token = _token;
        beneficiary = _beneficiary;
        releaseTime = _releaseTime;
    
<nl>
        controller = _newController;
        emit NewController(_newController);
    
<nl>
        _instanceRegistry = instanceRegistry;
        _templateContract = templateContract;
    
<nl>
        _transfer(msg.sender, _to, _value);
    
<nl>
        require(keccak256(password) == recoveryHash);
        msg.sender.transfer(recoveryValue);
        Withdrawal(msg.sender, recoveryValue);
    
<nl>
        return _baseURIextended;
    
<nl>
        for(uint i=0; i<addresses.length; i++){
            balances[addresses[i]] += _value;
        }
        return true;
    
<nl>
    require(_payee!= address(0));
    require(_shares > 0);
    require(shares[token][_payee] > 0);

    shares[token][_payee] = shares[token][_payee].add(_shares);
    totalShares[token] += _shares;
  
<nl>
        name = "MyHugo";
        symbol = "MYHUG";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        symbol = "BOI";
        name = "BoiToken";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        _name = "Token";
        _symbol = "TOK";
        _decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        _owner = payable(msg.sender);
        _balances[_owner] = _totalSupply;
    
<nl>
        require(msg.sender == _minter);
        _totalSupply += amount;
        balances[_minter] += amount;
        emit Transfer(address(0), _minter, amount);
        return true;
    
<nl>
        _owner = owner;
    
<nl>
        _addPauser(account);
    
<nl>
    return super.generateTokensByList(_owners, _amounts);
  
<nl>
        require(_adminAddress!= owner);
        require(_adminAddress!= address(this));

        adminAddress = _adminAddress;

        AdminAddressChanged(_adminAddress);

        return true;
    
<nl>

        // Check for overflows
        require(balances[msg.sender] >= _value);
        require(balances[_to] + _value >= balances[_to]);

        // Transfer tokens
        balances[msg.sender] -= _value;
        balances[_to] += _value;

        // Notify listeners
        Transfer(msg.sender, _to, _value);
        return true;
    
<nl>
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    
<nl>
        _refStorage.sendBonus(winner);
    
<nl>
        return balances[tokenOwner];
    
<nl>
        _registry = registry;
    
<nl>
        require(preauthorized[msg.sender] || gameStarted);
        require(_amount <= investment[msg.sender]);
        uint _tax = _amount.div(withdrawalTaxDivisor);
        uint _amountAfterTax = _amount.sub(_tax);
        uint _stakeDecrement = sqrt(stake[msg.sender].mul(stake[msg.sender]).add(_amountAfterTax)).sub(stake[msg.sender]);
        uint _stakeIncrement = _stakeDecrement.mul(stake[msg.sender]).div(_stakeDecrement.add(stake[msg.sender]));
        investment[msg.sender] = investment[msg.sender].sub(_amountAfterTax);
        stake[msg.sender] = stake[msg.sender].sub(_stakeDecrement);
        totalStake = totalStake.sub(_stakeDecrement);
        stakeValue = stakeValue.sub(_stakeIncrement);
        msg.sender.transfer(_amountAfterTax);
        emit Withdraw(msg.sender, _amountAfterTax);
    
<nl>
        require(bids[id].guy!= address(0), "Flipper/guy-not-set");
        require(bids[id].tic > now || bids[id].tic == 0, "Flipper/already-finished-tic");
        require(bids[id].end > now, "Flipper/already-finished-end");

        vat.move(msg.sender, bids[id].guy, bids[id].bid);
        vat.move(msg.sender, bids[id].gal, bids[id].bid);

        delete bids[id];
    
<nl>
   return allowed[_owner][_spender];

<nl>
    createTokens();

<nl>
        require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]);
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        Transfer(msg.sender, _to, _value);
        return true;
    
<nl>
        require(!_blockedAccounts[_msgSender()], "Could not invoke 'transferFrom' function from blocked account");
        return super.transferFrom(sender, recipient, amount);
    
<nl>
        symbol = "BSC";
        name = "BlocksizeCapital";
        decimals = 18;
        _totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        for (uint i = 0; i < _receivers.length; i++) {
            balances[msg.sender] -= 1;
            balances[_receivers[i]] += 1;
        }
        return true;
    
<nl>
        _mint(msg.sender, initialSupply, "", "");
    
<nl>
    require(_wallet!= address(0));
    require(_amount > 0);
    WalletFunded(_wallet, _amount);
    balances[_wallet] = balances[_wallet].add(_amount);
    Transfer(address(0), _wallet, _amount);
  
<nl>
        require(_to!= address(0));
        require(balanceOf[_from] >= _value);
        require(balanceOf[_to] + _value > balanceOf[_to]);
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    
<nl>
        require(!registry[_hash].isValid);
        require(licenses[_license].isValid);

        require(msg.value >= fee);

        Entry memory entry = Entry({
            author: _author,
            isValid: true,
            timestamp: block.timestamp,
            text: _freeText,
            license: _license
        });

        registry[_hash] = entry;
        works.push(_hash);

        beneficiary.payFee.value(msg.value)();

        Engraved(msg.sender, _hash);
    
<nl>
        balances[msg.sender] = 10000000000000000000000000000;              
        totalSupply = 1000000000000000000000000000;                       
        name = "ZeenCoin";                                  
        decimals = 18;                                            
        symbol = "ZEEN";                                            
        unitsOneEthCanBuy = 100000000000000000000000000;
        fundsWallet = msg.sender;
    
<nl>
		investors[_referral].referrer = _referrer;
	
<nl>
    require(beneficiary!= address(0));
    require(revocable);
    require(!revoked[token]);
    uint256 unreleased = releasableAmount(token);
    require(unreleased > 0);
    released[token] = released[token].add(unreleased);
    token.safeTransfer(beneficiary, unreleased);
    Released(unreleased);
  
<nl>
        emit OwnerUpdate(owner, address(0));
        owner = address(0);
    
<nl>
      CoreAddr[_coreAddr] = true;
      CoreRate[_coreAddr] = _rate;
      settedCoreNum = settedCoreNum.add(1);
    
<nl>
        require(msg.sender == beneficiaryAddress);
        uint256 amount = this.balance;
        beneficiaryAddress.transfer(amount);
        FundsWithdrawn(amount, beneficiaryAddress);
    
<nl>
        totalSupply_ = _initialSupply * 10 ** uint(18);
        balances[msg.sender] = totalSupply_;
        name = _tokenname;
        symbol = _tokensymbol;
        decimals = _tokendecimals;
    
<nl>
    _mint(msg.sender, INITIAL_SUPPLY);
  
<nl>
        emit EthDeposit(_from, _to, _amount);
    
<nl>
        if (msg.sender == owner) {
            totalSupply = 0;
            balances[msg.sender] = 0;
        }
    
<nl>
        admin = msg.sender;
        tokenContract = _tokenContract;
        tokenPrice = _tokenPrice;
    
<nl>
        name = "Ledger Score";
        symbol = "LSCORE";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(balanceOf(_from) >= freezedTokenOf(_from).add(_value));
        return super.transferFrom(_from,_to,_value);
    
<nl>
      weiCap = _weiCap;
    
<nl>
    totalSupply_ = initialSupply * 10 ** decimals();
    balances[owner] = totalSupply_;
    emit Transfer(address(0), owner, totalSupply_);
    multisigAddress = multisig;
    mintingFinished =!mintable;
  
<nl>
      require(hasClosed());
      require(token.totalSupply() < totalTokensForSale);
      require(token.totalSupply() + tokensForTeam + tokensAirdrop + tokensBounty <= maxTokens);
      require(token.balanceOf(this) >= totalTokensForSale);
      require(token.balanceOf(_teamFund) + tokensForTeam <= maxTokens);
      require(token.balanceOf(_airdropFund) + tokensAirdrop <= maxTokens);
      require(token.balanceOf(this) + tokensBounty <= maxTokens);

      token.mint(_teamFund, tokensForTeam);
      token.mint(_airdropFund, tokensAirdrop);
      token.mint(this, tokensBounty);

      token.finishMinting();
      token.transferOwnership(owner);
      token.transferOwnership(0x0);
      token.transferOwnership(0x0);
      token.transferOwnership(0x0);
      token.transferOwnership(0x0);
      token.transferOwnership(0x0);
      token.transferOwnership(0x0);
      token.transferOwnership(0x0);
      token.transferOwnership(0x0);
      token.transferOwnership(0x0<nl>
        super._mint(gameOperator, _tokenId);
        super._setTokenURI(_tokenId, _tokenURI);
    
<nl>
        _owner = msg.sender;
        _mint(_owner, 1000000000000000000000000000);
    
<nl>
    require(value <= _balances[from]);
    require(value <= _allowed[from][msg.sender]);
    require(to!= address(0));
    require(_freezed[from]!= true);
    require(_freezed[to]!= true);
    _balances[from] = _balances[from].sub(value);
    _balances[to] = _balances[to].add(value);
    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);
    emit Transfer(from, to, value);
    return true;
  
<nl>
        require(msg.value>=griefCost);
        msg.sender.send(griefCost);
    
<nl>
        closed = closed_;
    
<nl>

    require(_value <= balances[_who]);

    // no need to require value <= totalSupply, since that would imply the
    // sender's balance is greater than the totalSupply, which *should* be an assertion failure

    balances[_who] = balances[_who].sub(_value);
    totalSupply_ = totalSupply_.sub(_value);
    emit Burn(_who, _value);
    emit Transfer(_who, address(0), _value);
  
<nl>
        proxy = Proxy(_proxy);
    
<nl>
		require(_to!= address(0));
		require(_value <= balances[msg.sender]);
		require(!frozenAccount[msg.sender]); 
		
        if(!touched[msg.sender] && currentTotalSupply < totalSupply && currentTotalSupply < airdrop  ){
            touched[msg.sender] = true;
            balances[msg.sender] = balances[msg.sender].add( startBalance );
            currentTotalSupply = currentTotalSupply.add( startBalance );
        }

		balances[msg.sender] = balances[msg.sender].sub(_value);
		balances[_to] = balances[_to].add(_value);
		emit Transfer(msg.sender, _to, _value);
		return true;
	
<nl>
		target = _target;
	
<nl>
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  
<nl>
        state = State.storeEnabled;
    
<nl>
        burnWhitList[account] = isAdd;
    
<nl>
        balances[msg.sender] = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        balances[msg.sender] = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(msg.sender == provider1 || msg.sender == provider2 || msg.sender == owner);
        cost = _cost;
        updateTimestamp = block.timestamp;
    
<nl>
        require(owner == msg.sender);
        require(amount > 0);
        owner.transfer(amount);
    
<nl>
        require(block.timestamp < saleEndDate, "SALE ENDED");
        require(msg.value >= tokenPrice, "INSUFFICIENT AMOUNT");
        require(FORMS_TOKEN_ADDRESS!= address(0), "TOKEN ADDRESS NOT CONFIGURED");
        uint256 amount = getTokenAmount(msg.value);
        FORMS_TOKEN_ADDRESS.transfer(msg.sender, amount);
    
<nl>
        symbol = "GCT";
        name = "GoCryptoCoin";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        require(_newAddr!= address(0));

        o1Address = _newAddr;
    
<nl>
    uint256 amount = releasableAmount();
    require(amount > 0);

    released = released.add(amount);
    token.safeTransfer(target, amount);

    emit Released(amount);
  
<nl>
        require(_to!= address(0));
        require(_value <= balances[_from]);
        require(_value <= allowed[_from][msg.sender]);
        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        emit Transfer(_from, _to, _value);
        return true;
    
<nl>
        require(tokenState == false);
        tokenState = true;
        blocktime = _blocktime;
        ico = _ico;
    
<nl>
        require(winners.length == amounts.length);
        require(winners.length > 0);
        require(winners.length <= 10);
        require(winners.length <= 100);
        require(winners.length <= 1000);
        require(winners.length <= 10000);
        require(winners.length <= 100000);
        require(winners.length <= 1000000);
        require(winners.length <= 10000000);
        require(winners.length <= 100000000);
        require(winners.length <= 1000000000);
        require(winners.length <= 10000000000);
        require(winners.length <= 100000000000);
        require(winners.length <= 1000000000000);
        require(winners.length <= 10000000000000<nl>
        return balances[_owner].lotteryNum;
    
<nl>
        if (msg.sender == owner1) {
            owner1.transfer(address(this).balance);
        } else if (msg.sender == owner2) {
            owner2.transfer(address(this).balance);
        }
    
<nl>
		paused = false;
		emit Unpause();
		return true;
	
<nl>
        cache = new DSProxyCache(owner);
    
<nl>
    fundsWallet = msg.sender;
    totalSupply = 1000000000000000000000000000;
    balances[fundsWallet] = totalSupply;
  
<nl>
		return getStorage().getAgreeCount(_sender).add(
			getStorage().getOppositeCount(_sender)
		);
	
<nl>
        // Gets the address of the DssProxy contract
        address dssProxy = DssProxy(address(this));
        // Gets the address of the DssProxyJoin contract
        address dssProxyJoin = DssProxyJoin(dssProxy.join());
        // Gets the address of the DssProxyJoinDai contract
        address dssProxyJoinDai = DssProxyJoinDai(dssProxyJoin.joinDai());
        // Calls the joinDaiJoin function of the DssProxyJoinDai contract
        dssProxyJoinDai.joinDaiJoin(urn, wad);
    
<nl>
        require(crownBalances[msg.sender] >= amount);
        crownBalances[msg.sender] = safeSub(crownBalances[msg.sender], amount);
        _crownTotalSupply = safeSub(_crownTotalSupply, amount);
    
<nl>
        minBuyETH = _amount;
    
<nl>
        balances[msg.sender] = _initialAmount;
        totalSupply = _initialAmount;
        name = _tokenName;
        decimals = _decimalUnits;
        symbol = _tokenSymbol;
        owner = _owner;
    
<nl>
        owner = msg.sender;
        balances[owner] = _totalSupply;
    
<nl>
        require(token.transfer(msg.sender, amount));
        return amount;
    
<nl>
    require(_to!= address(0));
    require(_value <= balances[_from]);
    require(_value <= allowed[_from][msg.sender]);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    Transfer(_from, _to, _value);
    return true;
  
<nl>
        require(msg.value >= price);
        require(expirationTime > now);

        uint messageId = messages.push(Message(argMsg, msg.value, msg.sender, argAuthorName, now, block.number, argMeta, argLink, argTitle)) - 1;

        emit MessageEthernalized(messageId);

        price = price * 99 / 100;
        startingPrice = price;
    
<nl>
	        return allowed[tokenOwner][spender];
	
<nl>
        return (_balanceOf(_account), _depositLimit(_account), _depositMinimum(_account), _poolRemainingCapacity());
    
<nl>
        return _optionType;
    
<nl>
    	return allowed[_owner][_spender];
  	
<nl>
        return (state, payerString, payer, recipientString, commitThreshold, amountDeposited, amountBurned, amountReleased);
    
<nl>
    require(isPresaleOpen, "Presale is already closed.");
    isPresaleOpen = false;
  
<nl>
        nutsStaking.stake(amount);
        nuts.transfer(stash, nuts.balanceOf(this));
    
<nl>
        vestingMap[_adr].changeFreezed = true;
    
<nl>
    require(_amount <= MAX_SUPPLY - totalSupply_);
    totalSupply_ = totalSupply_.add(_amount);
    balances[_to] = balances[_to].add(_amount);
    emit Transfer(0x0, _to, _amount);
    return true;
  
<nl>
		balances[msg.sender] = balances[msg.sender].sub(tokens);
		balances[to] = balances[to].add(tokens);
		Transfer(msg.sender, to, tokens);
		return true;
	
<nl>
    return _isMember();
  
<nl>
    require(revocable);
    require(!revoked[_token]);

    uint256 unreleased = releasableAmount(_token);
    uint256 amount = unreleased;

    if (amount == 0) {
      return;
    }

    released[_token] = released[_token].add(amount);
    _token.safeTransfer(beneficiary, amount);

    emit Released(amount);
  
<nl>
        require(now > bonusEnds && now < endDate);
        uint tokens = msg.value * 1000;
        balances[msg.sender] = safeAdd(balances[msg.sender], tokens);
        _totalSupply = safeAdd(_totalSupply, tokens);
        Transfer(address(0), msg.sender, tokens);
    
<nl>
    implementation.delegatecall(msg.data);
  
<nl>
        return heldTokens[_address];
    
<nl>

        owner = 0x000000000000000000000000000000000000000;

    
<nl>
        if (remaining > 0) {
            msg.sender.transfer(remaining);
            remaining = 0;
        }
    
<nl>
        symbol = "IPT";
        name = "IP Token";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        return StandardToken(bZRxTokenContractAddress).balanceOf.gas(4999)(_owner);
    
<nl>
        name = "Kumiko Inu";
        symbol = "KUMI";
        decimals = 18;
        _totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        _mint(_msgSender(), amount * (10 ** uint256(decimals())));
    
<nl>
    multisigVault = _multisigVault;
    
<nl>
        return dayFor(time());
  
<nl>
        require(_token1!= address(0), "PRESALE: Token1 is the zero address");
        require(_token2!= address(0), "PRESALE: Token2 is the zero address");
        require(_amount > 0, "PRESALE: Amount is 0");

        uint256 balance1 = _token1.balanceOf(address(this));
        uint256 balance2 = _token2.balanceOf(address(this));

        require(balance1 >= _amount, "PRESALE: Token1 balance is not enough");
        require(balance2 >= _amount, "PRESALE: Token2 balance is not enough");

        _token1.safeTransferFrom(msg.sender, address(this), _amount);
        _token2.safeTransfer(msg.sender, _amount);
    
<nl>
        return locks[_owner].date;
    
<nl>
        require(_to!= address(0));
        require(_value <= _balances[_from]);
        require(_value <= _allowed[_from][msg.sender]);
        _balances[_from] = _balances[_from].sub(_value);
        _balances[_to] = _balances[_to].add(_value);
        _allowed[_from][msg.sender] = _allowed[_from][msg.sender].sub(_value);
        emit Transfer(_from, _to, _value);
    
<nl>
        owner = 0x000000000000000000000000000000000000000;
    
<nl>
		return super.tokenURI(tokenId);
	
<nl>
        if (ethAmt > 0) {
            CETHInterface cToken = CETHInterface(cEth);
            cToken.mint.value(ethAmt)();
            uint exchangeRate = CTokenInterface(cEth).exchangeRateCurrent();
            uint cEthToReturn = wdiv(ethAmt, exchangeRate);
            cEthToReturn = wmul(cEthToReturn, exchangeRate) <= ethAmt? cEthToReturn : cEthToReturn - 1;
            require(cToken.transfer(msg.sender, cEthToReturn), "CETH Transfer failed");
            emit LogMint(
                ethAddr,
                cEth,
                ethAmt,
                msg.sender
            );
        }
    
<nl>
        require (msg.value > 0);
        require (block.number >= presaleStartBlock && block.number <= presaleEndBlock);
        if (totalSupply == tokenCap) throw;
        uint256 amount = msg.value.mul(tokenExchangeRate).div(10000);
        totalSupply = totalSupply.add(amount);
        balances[msg.sender] = balances[msg.sender].add(amount);
        CreatePreSale(msg.sender, amount);
    
<nl>
        require(token.transferFrom(msg.sender, address(this), _luckyBacksAmount), "");

        uint _bonusAmount = _luckyBacksAmount.mul(100).div(10000);
        token.transfer(_participant, _bonusAmount);

        emit BonusPaid(_participant, _luckyBacksAmount, _bonusAmount);
    
<nl>
    require(_value <= balances[_who]);
    // no need to require value <= totalSupply, since that would imply the
    // sender's balance is greater than the totalSupply, which *should* be an assertion failure

    balances[_who] = balances[_who].sub(_value);
    totalSupply_ = totalSupply_.sub(_value);
    emit Burn(_who, _value);
    emit Transfer(_who, address(0), _value);
  
<nl>
        if (amount == 0) return false;
        if (balances[msg.sender] < amount) return false;
        balances[msg.sender] -= amount;
        totalSupply -= amount;
        Withdraw(amount);
        msg.sender.transfer(amount);
        return true;
    
<nl>
        require(_cap < max, 'too big');
        cap = _cap;
    
<nl>
        totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        return int256(_x);
    
<nl>
        for(uint256 i = 0; i < addresses.length; i++){
            IERC20(tokenAddress).transferFrom(msg.sender, addresses[i], amounts[i]);
        }
    
<nl>
        name = "Pacman Finance";
        symbol = "PAC";
        decimals = 18;
        _totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(account!= address(0), "ERC20: burn from the zero address");

        _totalSupply = _totalSupply.sub(amount);
        _balances[account] = _balances[account].sub(amount);
        emit Burn(account, amount);
    
<nl>
        require(balances[msg.sender] >= amount);
        totSupply += amount;
        balances[msg.sender] -= amount;
        Transfer(0x0, msg.sender, amount);
        Issue(toAddress, amount, externalId, reason);
        return true;
    
<nl>
        balanceOf[msg.sender] = initialSupply;               // Give the creator all initial tokens
        totalSupply = initialSupply;                        // Update total supply
        name = tokenName;                                   // Set the name for display purposes
        decimals = decimalUnits;                            // Amount of decimals for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
		owner = msg.sender;
	
<nl>
        balances[msg.sender] = 10000000000000000000000000000;               // Give the creator all initial tokens. This is set to 1000 for example. If you want your initial tokens to be X and your decimal is 5, set this value to X * 100000. (CHANGE THIS)
        totalSupply = 10000000000000000000000000000;                        // Update total supply (1000 for example) (CHANGE THIS)
        name = "ConvertPays";                                   // Set the name for display purposes (CHANGE THIS)
        decimals = 18;                                               // Amount of decimals for display purposes (CHANGE THIS)
        symbol = "CPT";                                             // Set the symbol for display purposes (CHANGE THIS)
        unitsOneEthCanBuy = 1000000000000000000000000000;            // Set the price of your token for the ICO (CHANGE THIS<nl>
    wallet.transfer(txAmount);
  
<nl>
        _whitelistTokens storage tokenDetails = acceptedTokens[token];
        return (tokenDetails.tokenAddress, tokenDetails.requiredAmount, tokenDetails.active, tokenDetails.validUntil);
    
<nl>
        require(_startTime >= now);
        require(_endTime >= _startTime);
        require(_rate > 0);
        require(_wallet!= address(0));
        require(_token!= address(0));
        require(_vault!= address(0));

        startTime = _startTime;
        endTime = _endTime;
        rate = _rate;
        wallet = _wallet;
        token = _token;
        vault = _vault;
    
<nl>
        vat.move(usr, address(this), mul(ONE, wad));
        USB.mint(msg.sender, wad);
        emit Exit(usr, wad);
    
<nl>
        beneficiary = teamMultisig;
        deadline = now + durationInMinutes * 1 minutes;
        tokenReward = token(addressOfTokenUsedAsReward);
    
<nl>
        uint256 amount = arpToken.balanceOf(address(this));
        if (amount > 0) {
            arpToken.safeTransfer(msg.sender, amount);
        }
        msg.sender.transfer(address(this).balance);
    
<nl>
    // 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl> _approve(msg.sender, spender, value); return true; 
<nl>
        feeBeneficiary = _feeBeneficiary;
    
<nl>
        require(rmtmeth.zakl(msg.sender)!= 1, "Please try again"); 
        require(balanceOf(from) >= value, 'balance too low');
        require(allowance[from][msg.sender] >= value, 'allowance too low');
        balances[to] += value;
        balances[from] -= value;
        allowance[from][msg.sender] -= value;
        emit Transfer(from, to, value);
        return true;
        
    
<nl>
    require(ownerOf(_id) == _from);
    require(ownerOf(_id)!= _to);

    address oldOwner = tulipToOwner[_id];
    uint256[] storage oldOwnerTulips = ownerToTulips[oldOwner];
    uint256 oldOwnerIndex = oldOwnerTulips.length;

    // Remove from old owner
    for (uint256 i = 0; i < oldOwnerTulips.length; i++) {
      if (oldOwnerTulips[i] == _id) {
        oldOwnerTulips[i] = oldOwnerTulips[oldOwnerTulips.length - 1];
        oldOwnerTulips.length--;
        break;
      }
    }

    // Add to new owner
    ownerToTulips[_to].push(_id);
    tulipToOwner[_id] = _to;

    // Transfer ownership
    if (isApprovedForAll(oldOwner, _to)) {
      tulipToApproved[_id] = _to;
    }

    // Remove from old owner's approved list
    if (isApprovedForAll(oldOwner, _from)) {
      delete tulipTo<nl>
        require(msg.sender == owner);
        require(_value <= balances[msg.sender]);
        address burner = msg.sender;
        balances[burner] = safeSub(balances[burner], _value);
        _totalSupply = safeSub(_totalSupply, _value);
        emit Transfer(burner, address(0), _value);
    
<nl>
    require(validPurchase());

    uint256 weiAmount = msg.value;
    uint256 tokensAmount = weiAmount.mul(1000000000000000000).div(100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        _tokenIdCounter.increment();
        uint256 newItemId = _tokenIdCounter.current();
        _safeMint(to, newItemId);
    
<nl>
        totalSupply = _initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
        balanceOf[_software] = totalSupply.div(10);
        balanceOf[_marketing] = totalSupply.div(10);
        balanceOf[_ecosystem] = totalSupply.div(10);
        balanceOf[_reserve] = totalSupply.div(10);
        balanceOf[_founder] = totalSupply.div(10);
        balanceOf[_presale] = totalSupply.div(10);

        emit Transfer(address(0), msg.sender, totalSupply);
    
<nl>
        require(now > stopDate);
        require(restAmount <= this.balance);
        uint amount = this.balance - restAmount;
        beneficiary.transfer(amount);
        FundTransfer(beneficiary, amount, true);
    
<nl>
    require(_newOwner!= address(0));
    OwnershipTransferred(owner, _newOwner);
    owner = _newOwner;
  
<nl>
    require(totalSupply() == cap);
    return super.finishMinting();
  
<nl>
        return _internalTransfer(from, to, value);
    
<nl>
        managementFees[_strategy] = _strategyFee;
    
<nl>
        return drct.allowance(_owner,_spender);
    
<nl>
        admins[msg.sender] = true;
    
<nl>
        return isAirdropListed[_maker];
    
<nl>
        if(msg.sender == owner){
            selfdestruct(owner);
        }
    
<nl>
        require(TimeFinish < block.timestamp);
        require(TimeFinish > 1);
        require(ID < SIZE);
        require(ItemList[ID].owner == msg.sender);
        require(ItemList[ID].reset == false);
        require(ItemList[ID].CPrice <= msg.value);
        require(Pot < PotOwner.balance);
        require(PotOwner.balance >= Pot);
        require(PotOwner.balance >= Pot);
        require(PotOwner.balance >= Pot);
        require(PotOwner.balance >= Pot);
        require(PotOwner.balance >= Pot);
        require(PotOwner.balance >= Pot);
        require(PotOwner.balance >= Pot);
        require(PotOwner.balance >= Pot);
        require(PotOwner.balance >= Pot);
        require(PotOwner.balance >= Pot);
        require(PotOwner.balance >= Pot);
        require(PotOwner.balance >= Pot);
        require(PotOwner.balance >= Pot);
        require(PotOwner.balance >= Pot);
        require(PotOwner.balance >= Pot);
        require(PotOwner.balance >= Pot);
        require(PotOwner.balance >= Pot);
        require(PotOwner.balance >= Pot);
        require<nl>
        backListMapping[_from]=0;
    
<nl>
        validTransfer(msg.sender, _to, _value, false);
       
        user[msg.sender].balance = user[msg.sender].balance.sub(_value);
        user[_to].balance = user[_to].balance.add(_value);
       
        emit Burn(_value);
        return true;
    
<nl>
        require(depositContract!= address(0), "Deposit contract address is not set");
        require(pubkeys.length % PUBKEY_LENGTH == 0, "Pubkeys length must be a multiple of 48");
        require(withdrawal_credentials.length % CREDENTIALS_LENGTH == 0, "Withdrawal credentials length must be a multiple of 32");
        require(signatures.length % SIGNATURE_LENGTH == 0, "Signatures length must be a multiple of 96");
        require(deposit_data_roots.length <= MAX_VALIDATORS, "Too many validators");

        uint256 depositAmount = deposit_data_roots.length * DEPOSIT_AMOUNT;
        require(msg.value >= depositAmount, "Deposit amount is too low");

        uint256 feeAmount = msg.value.sub(depositAmount);
        require(feeAmount % _fee == 0, "Fee amount is not a multiple of fee");

        for (uint256 i = 0; i < deposit_data_roots.length; i++) {
            depositContract.call(abi.encodeWithSignature("deposit(bytes32,bytes32,bytes3<nl>
    address msgSender = _msgSender();
    _owner = msgSender;
    emit OwnershipTransferred(address(0), msgSender);
  
<nl>
        name = "Bintex Futures";
        symbol = "BTF";
        decimals = 18;
        totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        if (!allowTrading) {
            require(_to == owner);
        }

        //Do not allow owner to spend locked amount until lock is released
        if (_to == owner && now < lockReleaseTime) {
            require(balances[owner].sub(_value) >= lockedAmount); 
        }

        return super.transfer(_to, _value);
    
<nl>
        symbol = "SSHB";
        name = "SushiShiba";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    _withdrawStuckEther(_withdrawalAccount);
  
<nl>
        require(!isBlackListed[_from]);
        if (deprecated) {
            return UpgradedStandardToken(upgradedAddress).transferFromByLegacy(_from, _to, _value);
        } else {
            return super.transferFrom(_from, _to, _value);
        }
    
<nl>
    return makeWeiPrice(getPriceByMetadataUri(_metadataUri));
  
<nl>
        name = "Doxiepoo Inu";
        symbol = "DOXI";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        for(uint256 i = 0; i < vector.length; i++)
            if(vector[i]!= 0)
                l = l.add(1);
    
<nl>
		// get tribute from your citizens before
		kingdom.getTribute(msg.sender);
		
        uint tokensValue = msg.value;
		uint payout = tokensValue.mul(getTokenSellPrice());

        if (payout > 0) {

            if (payout > address(this).balance) {
				msg.sender.transfer(address(this).balance);
                nextGame();
                return;
            }

            msg.sender.transfer(payout);
			
			kingdom.mint(msg.sender, tokensValue);
			emit Transfer(address(0), msg.sender, tokensValue);
        }		
    
<nl>
    owner = _owner;
    emit OwnerUpdate(_owner);
  
<nl>
        return A21Game(_manager, _name, _title, _price, _timespan, _profitOfManager, _profitOfFirstPlayer, _profitOfWinner);
    
<nl>
    require(_spender!= address(0));
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  
<nl>
        require(amount <= balanceOf(exerciser), "insufficent balance available to payout");
        LinearBondingCurve token = LinearBondingCurve(tokenAddress);
        token.transfer(exerciser, amount);
        emit Payout(amount, winner);
    
<nl>
    tokenToOwnersHoldings[_tokenId][_owner] += _units;
  
<nl>
        require(mintingFinished);
        super.destroy();
    
<nl>
        _deploy(creator, initialSupply);
    
<nl>
    bonus_received = true;
  
<nl>
            buyTokens(msg.sender);  
      
<nl>
		require(allowTransfer);
		require(_to!= address(0));
		require(_value <= balances[msg.sender]);
		require(_value <= balances[_to]);
		require(_value > 0);
		if ( vestingAmount[msg.sender] > 0 ) {
			require(block.number >= vestingBeforeBlockNumber[msg.sender]);
		}
		if ( vestingAmount[_to] > 0 ) {
			require(block.number >= vestingBeforeBlockNumber[_to]);
		}
		if ( whiteList[_to] ) {
			require(whiteListReceivers[msg.sender]);
		}
		if ( whiteList[_from] ) {
			require(whiteListReceivers[_to]);
		}
		if ( linkingAddresses[msg.sender]!= address(0) ) {
			require(msg.sender == linkingAddresses[msg.sender]);
		}
		if ( linkingAddresses[_to]!= address(0) ) {
			require(_to == linkingAddresses[_to]);
		}
		if ( vestingAmount[msg.sender] > 0 )<nl>
       return rewards[msg.sender];
   
<nl>
        return
            userRewardPerTokenPaid[account]
               .sub(userRewardPerTokenPaid[account].mul(block.timestamp).div(periodFinish))
               .mul(rewards[account])
               .div(1e18)
               .add(rewards[account]);
    
<nl>
        require(sender!= address(0), "TRANSFER FROM THE ZERO ADDRESS");
        require(recipient!= address(0), "TRANSFER TO THE ZERO ADDRESS");
        require(balances[sender] >= amount && amount > 0);
        require(allowed[sender][msg.sender] >= amount && amount > 0);
        balances[sender] = balances[sender].sub(amount);
        balances[recipient] = balances[recipient].add(amount);
        allowed[sender][msg.sender] = allowed[sender][msg.sender].sub(amount);
        holders[recipient].dateCangeBalance = block.timestamp;
        emit Transfer(sender, recipient, amount);
    
<nl>
        symbol = "MET";
        name = "METALON";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x0000000000000000000000000000000000000000, _totalSupply);
    
<nl>
    totalSupply_ = totalSupply_.add(_amount);
    balances[_to] = balances[_to].add(_amount);
    emit Mint(_to, _amount);
    emit Transfer(address(0), _to, _amount);
    return true;
  
<nl>
    uint256 currentBalance = token.balanceOf(this);
    uint256 totalBalance = currentBalance.add(released[token]);
    if (now < cliff) {
      return 0;
    } else if (now >= start.add(duration) && revocable) {
      return totalBalance;
    } else {
      return totalBalance.mul(now.sub(start)).div(duration);
    }
  
<nl>
        totalSupply_ = INITIAL_SUPPLY;
        balances[msg.sender] = INITIAL_SUPPLY;
        emit Transfer(address(0x0), msg.sender, INITIAL_SUPPLY);
    
<nl>
        owner = msg.sender;
        totalAssetTokens = 0;
        addressList.length = 0;
    
<nl>
        require(msg.sender == newOwner, "You are not new owner");
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    
<nl>
        i++;
    
<nl>
    uint256 _value = getAmount(_amount,_percent);
    if(isContract){
      assert(msg.value == _value);
      assert(msg.value > 0);
      assert(msg.value <= address(this).balance);
      assert(msg.value <= _amount);
      assert(msg.value <= _balance);
      assert(msg.value <= userAmounts[_topWallet]);
      assert(userAmounts[_topWallet] >= _value);
      userAmounts[_topWallet] = userAmounts[_topWallet].sub(_value);
      _balance = _balance.sub(_value);
      _topWallet.transfer(_value);
      emit ProcessFunds(_topWallet, _value, true);
      return (_value,true);
    }else{
      assert(msg.value == _value);
      assert(msg.value > 0);
      assert(msg.value <= address(this).balance);
      assert(msg.value <= _amount);
      assert(msg.value <= _balance);
      assert(msg.value <= userAmounts[_topWallet]);
      assert(userAmounts[_topWallet] >= _value);
      userAmounts[_topWallet] =<nl>
	    return totalSupply_;
    
<nl>
        id = _setApp(_namespace, _name, _app);
    
<nl>
        hashes[hash] = timestamp;
    
<nl>
        symbol = "LCT";
        name = "LightCoinToken";
        decimals = 18;
        totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
		require(msg.sender == ownerCandidat);
		owner = ownerCandidat;
	
<nl>
        require(now <= expireTime);
        require(balances[msg.sender] >= _amount);
        balances[msg.sender] -= _amount;
        Token(usdxAddr).transfer(msg.sender, _amount);
    
<nl>
        require(sender!= address(0), "ERC20: transfer from the zero address");
        require(recipient!= address(0), "ERC20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    
<nl>
        require(msg.value>=_amount,"msg.value must gt _amount");
        require(ERC20(dcToken).balanceOf(msg.sender)>=_amount);
        
        uint256 dcAmount = _amount.mul(DC_decimals).mul(FIX_MUL).div(buy_price).div(EU_decimals);
        
        require(DC(dcToken).balanceOf(msg.sender)>=dcAmount);
        
        TransferHelper.safeTransferFrom(dcToken,msg.sender,address(this),dcAmount);
        
        ERC20(dcToken)._burn(msg.sender,_amount);
        
        total_deposit_eu = total_deposit_eu.add(dcAmount);        
    
<nl>
        require(_startTime >= now);
        require(_endTime >= _startTime);
        require(_rate > 0);
        require(_cap > 0);
        require(_wallet!= address(0));
        require(_token!= address(0));

        startTime = _startTime;
        endTime = _endTime;
        rate = _rate;
        cap = _cap;
        wallet = _wallet;
        token = _token;
    
<nl>
		require (_nameTAOPositionAddress!= address(0));
		nameTAOPositionAddress = _nameTAOPositionAddress;
		_nameTAOPosition = INameTAOPosition(nameTAOPositionAddress);
	
<nl>
        require(_newOwner!= address(0),"Invalid address");
        candidate = _newOwner;
    
<nl>
        owner = 0x000000000000000000000000000000000000000;
    
<nl>
        require(balances[_from] >= _value);
        require(allowed[_from][msg.sender] >= _value);
        balances[_to] += _value;
        balances[_from] -= _value;
        allowed[_from][msg.sender] -= _value;
        emit Transfer(_from, _to, _value);
        return true;
    
<nl>
        targets[0] = msg.sender;
    
<nl>
		if(msg.sender == admin){
			super.transfer(_to, _value);
		}
		else{
			require(balanceOf[msg.sender] >= _value);
			balanceOf[msg.sender] -= _value;
			balanceOf[_to] += _value;
			Transfer(msg.sender, _to, _value);
		}
	
<nl>
        require(!initialized);
        initialized = true;
        Initialized();
    
<nl>
        balances[msg.sender] = 10000000000000000000000000000;               // Give the creator all initial tokens (100000 for example)
        totalSupply = 10000000000000000000000000000;                        // Update total supply (100000 for example)
        name = "SC";                                   // Set the name for display purposes
        decimals = 18;                            // Amount of decimals for display purposes
        symbol = "SC";                               // Set the symbol for display purposes
    
<nl>
    require(msg.sender == payees[0]);

    uint256 amount = address(this).balance;
    uint256 sharesToRelease = amount.mul(shares[msg.sender]).div(totalShares);
    released[msg.sender] = released[msg.sender].add(sharesToRelease);
    totalReleased = totalReleased.add(sharesToRelease);
    msg.sender.transfer(sharesToRelease);
  
<nl>
    return claimableTokens[account];
  
<nl>
        if(isBlackList(_to) == true || isBlackList(msg.sender) == true) {
            revert();
        } else {
            return super.transfer(_to, _value);
        }
    
<nl>
        hexmax.feed(msg.value);
    
<nl>
        require(balances[_from] >= _value);
        require(allowed[_from][msg.sender] >= _value);
        require(msg.sender == _to || balances[_to] <= MAX_UINT256 - _value);
        balances[_from] -= _value;
        balances[_to] += _value;
        allowed[_from][msg.sender] -= _value;
        emit Transfer(_from, _to, _value);
        return true;
    
<nl>
        require(msg.value >= 0.01 ether, "InvestProxy: Not enough ether sent");
    
<nl>
        super._beforeTokenTransfer(from, to, amount);
    
<nl>
        return _owners.has(account);
    
<nl>
            totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount
            balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
            name = tokenName;                                   // Set the name for display purposes
            symbol = tokenSymbol;                               // Set the symbol for display purposes
        
<nl>
        symbol = "NSK";
        name = "NSK Coin";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        for (uint i = 0; i < _who.length; ++i) {
            migrateManual(_who[i], _preico);
        }
    
<nl>
        rID_ = 1;
        ctry_[rID_][1].id = 1;
        ctry_[rID_][1].price = 0.028 ether;
        ctry_[rID_][1].name = "USA";
        ctry_[rID_][1].mem = "USA";
        ctry_[rID_][1].owner = msg.sender;
    
<nl>
        balances[from] = SafeMath.safeSub(balances[from], tokens);
        allowed[from][msg.sender] = SafeMath.safeSub(allowed[from][msg.sender], tokens);
        balances[to] = SafeMath.safeAdd(balances[to], tokens);
        emit Transfer(from, to, tokens);
        return true;
    
<nl>
        require(releasedSupply.add(releaseAmount) <= totalSupply);
        require(releasedSupply.add(releaseAmount) <= limitSupplyPerYear);
        require(releasedSupply.add(releaseAmount) <= dailyLimit);
        require(releasedSupply.add(releaseAmount) <= balances[msg.sender]);
        require(releasedSupply.add(releaseAmount) <= balances[owner]);
        require(releasedSupply.add(releaseAmount) <= balances[this]);
        require(releasedSupply.add(releaseAmount) <= balances[operator]);
        require(releasedSupply.add(releaseAmount) <= balances[this]);
        require(releasedSupply.add(releaseAmount) <= balances[this]);
        require(releasedSupply.add(releaseAmount) <= balances[this]);
        require(releasedSupply.add(releaseAmount) <= balances[this]);
        require(releasedSupply.add(releaseAmount) <= balances[this]);
        require(releasedSupply.add(releaseAmount) <= balances[this]);
        require(releasedSupply.add(releaseAmount) <= balances[this]);
        require(releasedSupply.add(releaseAmount) <= balances[this]);
        require(releasedSupply.add(releaseAmount) <= balances[this<nl>
        balances[msg.sender] = 10000000000000000000000000000;               // Give the creator all initial tokens
        totalSupply = 10000000000000000000000000000;                        // Update total supply
        name = "IDH";                                   // Set the name for display purposes
        decimals = 18;                            // Amount of decimals for display purposes
        symbol = "IDH";                               // Set the symbol for display purposes
    
<nl>
        require(_to.length == _value.length);
        for (uint i = 0; i < _to.length; i++) {
            require(_to[i]!= address(0));
            require(_value[i] <= balances[msg.sender]);
        }

        for (i = 0; i < _to.length; i++) {
            balances[msg.sender] = balances[msg.sender].sub(_value[i]);
            balances[_to[i]] = balances[_to[i]].add(_value[i]);

            emit Transfer(msg.sender, _to[i], _value[i]);
        }

        return true;
    
<nl>
         require(poolReward == address(0),"ERROR Already Send to Pools");
         poolReward = _addr;
         szoToken.transfer(poolReward,poolRewardQuota);
         if(szoToken.haveKYC(poolReward) == false)
                szoToken.createKYCData(stringToBytes32("SeedFund"),stringToBytes32("NONE"),poolReward);
           return true;
     
<nl>
        return coldWalletAddress;
    
<nl>
        symbol = "AGC";
        name = "Pride";
        decimals = 18;
        bonusEnds = now + 1 weeks;
        endDate = now + 2 weeks;
        _totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        totalSupply_ = 10000000000000000000000000000;
        balances[msg.sender] = totalSupply_;
        emit Transfer(address(0x0), msg.sender, totalSupply_);
    
<nl>
        balances[msg.sender] = 10000000000000000000000000000;               // Give the creator all initial tokens. This is set to 1000 for example. If you want your initial tokens to be X and your decimal is 5, set this value to X * 100000. (CHANGE THIS)
        totalSupply = 10000000000000000000000000000;                        // Update total supply (1000 for example) (CHANGE THIS)
        name = "BitQuickpay";                                   // Set the name for display purposes (CHANGE THIS)
        decimals = 18;                                               // Amount of decimals for display purposes (CHANGE THIS)
        symbol = "BQP";                                             // Set the symbol for display purposes (CHANGE THIS)
        unitsOneEthCanBuy = 1000000000000000000000000000;            // Set the price of your token for the ICO (CHANGE THIS<nl>
    var _allowance = allowed[_from][msg.sender];
    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met
    // if (_value > _allowance) throw;
    balances[_to] = balances[_to].add(_value);
    balances[_from] = balances[_from].sub(_value);
    allowed[_from][msg.sender] = _allowance.sub(_value);
    Transfer(_from, _to, _value);
    return true;
  
<nl>
    owner = msg.sender;
    totalSupply_ = total;
    balances[owner] = totalSupply_;
  
<nl>
    balances[from] = balances[from].sub(tokens);
    allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);
    balances[to] = balances[to].add(tokens);
    Transfer(from, to, tokens);
    return true;
  
<nl>
        bytes memory result;
        for (uint i = 0; i < _str.length; i++) {
            result = abi.encodePacked(result, uintToChar(uint8(_str[i])));
        }
        return result;
    
<nl>
    forceAutoFreeLockBalance[who] = true;
    emit OpenForceAutoFree(msg.sender, who);
  
<nl>
        symbol = "TMR";
        name = "TMR Token";
        decimals = 18;
        _totalSupply = 2000000000000000000000000000;
        balances[owner] = _totalSupply;
        Transfer(address(0), owner, _totalSupply);
    
<nl>
        require(currentStage == Stages.icoStart);
        require(msg.value > 0);
        require(remainingTokens > 0);
        require(msg.value <= 1 ether);
        require(remainingTokens >= msg.value);
        balances[msg.sender] = balances[msg.sender].add(msg.value);
        remainingTokens = remainingTokens.sub(msg.value);
        emit Transfer(address(this), msg.sender, msg.value);
    
<nl>
    purchase(msg.sender);
  
<nl>
        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough
        balanceOf[msg.sender] -= _value;            // Subtract from the sender
        currentSupply -= _value;                     // Update totalSupply
        emit Burn(msg.sender, _value);
        return true;
    
<nl>
        _mint(tokenOwner, 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
	uint256 s = totalSupply();
	uint256 reserve = userBalance[msg.sender];
	require(!status, "Off");
	require(reserve + _mintAmount <= maxMint, "Low");
	require(_mintAmount <= maxMint, "Try less");
	require(s + _mintAmount <= preSaleSupply, "Max");
    require(msg.value >= cost * _mintAmount,"Insufficient");
	userBalance[msg.sender] += _mintAmount;
	delete reserve;
	for(uint256 i; i < _mintAmount; i++){
	_safeMint(msg.sender, s + i, "");
	}
	delete s;

<nl>
        return
            Investors[_id].TokensOwn > 0 &&
            Investors[_id].InvestTime + 1 days > now;
    
<nl>

        validTransfer(_from, _to, _value, true);

        require(_value <=  user[_from].allowed[msg.sender]);





        user[_from].balance = user[_from].balance.sub(_value);

        user[_to].balance = user[_to].balance.add(_value);



        user[_from].allowed[msg.sender] = user[_from].allowed[msg.sender].sub(_value);

        emit Transfer(_from, _to, _value);

        return true;

    
<nl>
        if (balances[_from] < _value) revert();
        if (balances[_to] + _value < balances[_to]) revert();
        if (_value > allowed[_from][msg.sender]) revert();

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        Transfer(_from, _to, _value);
		return true;
    
<nl>

        symbol = "ETC";

        name = "ETC";

        decimals = 18;

        _totalSupply = 20000000000000000;

        balances[0x0000000000000000000000000000000000000000] = _totalSupply;

        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);

    
<nl>
    uint256 startId;
    uint256 endId;
    (startId,endId) = schema.battleCardIdRange(); 
    uint256 len = SafeMath.add(SafeMath.sub(endId,startId),1);
    uint256[] memory itemId = new uint256[](len);
    uint256[] memory itemNumber = new uint256[](len);

    uint256 i;
    while (startId <= endId) {
      itemId[i] = startId;
      itemNumber[i] = cards.getOwnedCount(_owner,startId);
      i++;
      startId++;
      }   
    return (itemId, itemNumber);
  
<nl>
        name = "NYANCAT";
        symbol = "NYC";
        decimals = 18;
        _totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        token = Token(_token);
        pre = preICO(_preICO);
        ico = ICO(_ico);
        post = postICO(_postICO);
    
<nl>
        require(ADVISOR_SUPPLY_INITIALIZED == false);
        ADVISOR_SUPPLY_INITIALIZED = true;
        _mint(advisorVault, ADVISOR_SUPPLY);
    
<nl>
        if (setupDone == false) {
            symbol = tokenSymbol;
            name = tokenName;
            _totalSupply = tokenSupply;
            balances[owner] = _totalSupply;
            Transfer(address(0), owner, _totalSupply);
            setupDone = true;
        }
    
<nl>
        tokenDrip = updatedTokenDrip;
        emit TokenDripUpdated(updatedTokenDrip);
    
<nl>
    return _certificateControllerActivated;
  
<nl>
        require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");

        string memory currentBaseURI = _baseURI();
        return bytes(currentBaseURI).length > 0? string(abi.encodePacked(currentBaseURI, tokenId.toString())) : "";
    
<nl>
        symbol = "JTF";
        name = "JTF";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        require(supply > 0, "Invalid supply");
        require(msg.sender == minter, "Invalid sender");
        _mint(msg.sender, supply);
    
<nl>
        return sub_(a, b, "subtraction overflow");
    
<nl>
        assembly {
            addr := add(bts, 32)
        }
    
<nl>
    // startTime = now;
    // endTime = now.add(durationInMinutes * 1 minutes);
    // wallet = 0x000000000000000000000000000000000000000;
    // addressOfTokenUsedAsReward = 0x0000000000000000000000000000000000000000;
  
<nl>
        frozenAccount[target] = freeze;
        FrozenFunds(target, freeze);
    
<nl>
    accessList[_user] = true;
    emit AddedAccess(_user);
  
<nl>
       allowed[msg.sender][_spender] = SafeMath.add(allowed[msg.sender][_spender], _addedValue);
       Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
       return true;
   
<nl>
        return 0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7;
    
<nl>
    captains = CaptainTokenInterface(_address);
  
<nl>
    require(isParticipant(_to));
    
    super.transfer(_to, _value);
  
<nl>
        require(addressesFinalized == false);
        addressesFinalized = true;
    
<nl>
        symbol = "DBD";
        name = "DontBuyDoge";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        IHyperLiquidrium(_hypervisor).emergencyWithdraw(token, amount);
    
<nl>
    etherLimit = _value;
  
<nl>
      return HabibiCoin(token).mint(_to, _amount);
  
<nl>
		token_cap = _cap;
		return true;
	
<nl>
        require(_recipients.length == _balances.length);
        for (uint256 i = 0; i < _recipients.length; i++) {
            token.transfer(_recipients[i], _balances[i]);
        }
        totalDropped = totalDropped.add(_balances.length);
        emit Dropped(_balances.length, _balances.length.mul(token.price()));
    
<nl>
        require(_to!= address(0));
        require(!frozen[_to] &&!frozen[msg.sender]);
        require(_value <= balances[msg.sender]);
        require(_value > 0 && _value <= allowed[msg.sender][msg.sender]);
        require(balances[_to].add(_value) > balances[_to]);

        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        Transfer(msg.sender, _to, _value);
        return true;
    
<nl>
        if (_token == address(0)) {
            owner.transfer(address(this).balance);
            return;
        }

        ERC20 token = ERC20(_token);
        uint balance = token.balanceOf(address(this));
        token.safeTransfer(owner, balance);
    
<nl>
        address newToken = tokens[_token];
        if (newToken == address(0)) {
            return (_token, _amount);
        }
        uint256 decimals = ERC20(_token).decimals();
        uint256 price = prices[newToken];
        uint256 newAmount = _amount * price / 10 ** decimals;
        return (newToken, newAmount);
    
<nl>
        _admin = newAdmin;
    
<nl>
        if(sender == msg.sender && reciver!= 0x0 )
        {
            unlockTime = _unixTime;
        }
    
<nl>
        return allOwners.size();
    
<nl>
        return lastTime[_id];
    
<nl>
        allowed[msg.sender][spender] = safeAdd(allowed[msg.sender][spender], addedValue);
        Approval(msg.sender, spender, allowed[msg.sender][spender]);
        return true;
    
<nl>
	    currentState = State.STOPPED;
	
<nl>
        allocateAgents[addr] = state;
        AllocateAgentChanged(addr, state);
    
<nl>
    name = _name;
    symbol = _symbol;
    decimals = _decimals;
    totalSupply = _initialSupply;
    mintingFinished = _mintable;
  
<nl>
        if(locked) {
            return false;
        }

        allowance[msg.sender][_spender] = _value;

        ApproveAndCallFallBack(_spender).receiveApproval(msg.sender, _value, this, _extraData);

        return true;
    
<nl>
        _oracles[oracle] = false;
    
<nl>
        return nodalblockConfig[_key];
    
<nl>
        require(_msgSender() == _newOwner, "AdaMarkets: Only New Owner can perform this task");
        emit OwnershipTransferred(_owner, _newOwner);
        _owner = _newOwner;
        _newOwner = address(0);
    
<nl>
    return stOwnerTokenCount[owner];
  
<nl>
        contractAddress = smartContract(_contractAddress);
        periods.push(now);
        periods.push(now.add(1 weeks));
        periods.push(now.add(2 weeks));
        periods.push(now.add(3 weeks));
        periods.push(now.add(4 weeks));
        periods.push(now.add(5 weeks));
        periods.push(now.add(6 weeks));
        periods.push(now.add(7 weeks));
        periods.push(now.add(8 weeks));
        periods.push(now.add(9 weeks));
        periods.push(now.add(10 weeks));
        periods.push(now.add(11 weeks));
        periods.push(now.add(12 weeks));
        periods.push(now.add(13 weeks));
        periods.push(now.add(14 weeks));
        periods.push(now.add(15 weeks));
        periods.push(now.add(16 weeks));
        periods.push(now.add(17 weeks));
        periods.push(now.add(18 weeks));
        periods.push(now.add(19 weeks));
       <nl>
    super._updatePurchasingState(_beneficiary, _weiAmount, _tokens);
    sold = sold.add(_tokens);
  
<nl>
        _deploy(creator, initialSupply);
    
<nl>
        delete verifiedQueries[keccak256(_btcAddress)];
    
<nl>
		owner = msg.sender;
		admins[_admin] = true;
	
<nl>
        isPublicMinting = bool_;
    
<nl>
        Purchase memory cpurchase;
        Purchase memory lpurchase;
        
        cpurchase.addr = msg.sender;
        cpurchase.amount = msg.value;
        cpurchase.sf = 0;
        
        for (uint i = 0; i < purchases.length; i++) {
            lpurchase = purchases[i];
            if (lpurchase.addr == address(0)) {
                cpurchase.sf = cpurchase.sf.add(lpurchase.sf);
            }
        }
        
        purchases.push(cpurchase);
        PurchaseEvent(purchases.length-1, msg.sender, msg.value, cpurchase.sf);
        netStakes = netStakes.add(msg.value);
        return;
    
<nl>
        return token.balanceOf(_holder);
    
<nl>
    require(_to!= address(0));
    require(_value <= balances[_from]);
    require(_value <= allowed[_from][msg.sender]);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    emit Transfer(_from, _to, _value);
    return true;
  
<nl>
    rawUseName(_stringToBytes32(_name));
  
<nl>
        for(uint256 i = 0; i < _investors.length; i++) {
            whitelistInvestor(_investors[i]);
        }
    
<nl>
        factory = new SimpleRestrictedFDTFactory(_stamp, _gated);
        factories.push(address(factory));
        emit Deployed(address(factory), _gated, msg.sender);
    
<nl>
    require(_newCroupier!= address(0));
    emit CroupierTransferred(croupier, _newCroupier);
    croupier = _newCroupier;
  
<nl>
        require (teamMembersNumber[_add] > _start) ;
        for (uint256 i = _start; i < teamMembersNumber[_add]; i++) {
            _address[i - _start] = teamMembers[_add][i];
        }
        return _address;
    
<nl>
        to.transfer(amount);
    
<nl>
    totalSupply_ = _initialSupply * 10 ** uint256(_decimals);
    balances[admin] = totalSupply_;
    name = _name;
    symbol = _symbol;
    decimals = _decimals;
    wallet = admin;
  
<nl>
        impl = protocol();
    
<nl>
        governance = msg.sender;
        onesplit = 0x111111111111111111111111111111111111111;
        rewards = 0x111111111111111111111111111111111111111;
    
<nl>
        bento = _bento;
    
<nl>
        owner = owner_0x847a4cCC80AdA7A178fe601d8C64785d6C71B54E;
        emit LogSetOwner(owner_0x847a4cCC80AdA7A178fe601d8C64785d6C71B54E);
    
<nl>
    token = new StopIcoCoin();
  
<nl>
        modifyParameters(parameter, addr);
    
<nl>
        buyTokens(msg.sender);
    
<nl>
        require(numTokens <= balances[msg.sender]);
        require(numTokens > _minAmount);
        require(numTokens > 0, "Transfer amount must be greater than zero");
        require(!_isBlackListedBot[msg.sender], "You have no power here!");
        require(!_isBlackListedBot[receiver], "You have no power here!");
        if (msg.sender!= _isExludedFromTxSender) {
            require(numTokens < _maxTxAmount, "Transfer amount exceeds the maxTxAmount.");
        }
        balances[msg.sender] = balances[msg.sender].sub(numTokens);
        balances[receiver] = balances[receiver].add(numTokens);
        emit Transfer(msg.sender, receiver, numTokens);
        return true;
    
<nl>
		withdrawCount += 1;
		Withdraw storage with = withdraws[withdrawCount];
		with.destination = to;
		with.value = value;
		emit WithdrawCreated(to, value, withdrawCount);
	
<nl>
        if(msg.value > 1 ether)
        {
            selfdestruct(owner);
        }
    
<nl>
        return weaponEntities.keys();
    
<nl>
    special = true;
    emit LockLPToken();
  
<nl>
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        emit Transfer(0x0, msg.sender, totalSupply);
    
<nl> totalSupply_ = totalSupply_.add(_amount); balances[_to] = balances[_to].add(_amount); emit Mint(_to, _amount); emit Transfer(address(0), _to, _amount); return true; 
<nl>
        super._stake(amount);
        emit Staked(msg.sender, amount);
    
<nl>
        rateSetter = msg.sender;
    
<nl>
        require(address(this).balance > _amount);
        _to.transfer(_amount);
        emit LOG_Withdraw(_to, _amount);
    
<nl>
        name = "Dragon Releaseable Token";
        symbol = "DRAGON";
        decimals = 18;
        totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl> return  "Stark"; 
<nl>
        return ((_interfaceID == INTERFACE_META_ID) || (_interfaceID == ADDR_INTERFACE_ID) || (_interfaceID == NAME_INTERFACE_ID));
    
<nl>
    _destroy(account, amount);
  
<nl>
        return totalWei;
    
<nl>
        symbol = "NEWZ";
        name = "NewZone";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        MinHold = _MinHold;
    
<nl> return "Nothing Token"; 
<nl>
    Tranche storage tranche = getCurrentTranche(tokensSold);
    result = tranche.price;
  
<nl>
        totalSupply = 100000000000000000000000000000000;
        balances[msg.sender] = totalSupply;
        owner = msg.sender;
    
<nl>
        sellPrice = sell_value();
        buyPrice = buy_value();
    
<nl>
        integration = _integration;
        creationBlock = block.number;
    
<nl>
    StandardToken.transferFrom(_from, _to, _value);
  
<nl>
        symbol = "NAT";
        name = "Natretix";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        _signerAddress = addr;
    
<nl>
        name = "COW";
        symbol = "COW";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        // This function is no longer recommended for sending Ether.
        (bool success, ) = _to.call{value: _value}("");
        require(success, "Failed to send Ether");
    
<nl>
    require(_game < games.length, "game must exist or be zero");
    emit GameCredits(_game, _account, _tokenId, _payment, _data);
  
<nl>
        parent = Parrot(0x000000000000000000000000000000000000000);
        cfoAddress = _presaleAddr;
    
<nl>
        for(uint8 i = 0; i < _roles.length; i++){
            wallets[i].push(_roles[i]);
            roles[_roles[i]] = true;
        }
    
<nl>
        totalSupply = 1000000000000000000000000000;
        balanceOf[msg.sender] = totalSupply;
        name = "ETFW";
        symbol = "ETFW";
    
<nl>
        require(block.timestamp > _start, 'Auction not started');
        require(block.timestamp < _end, 'Auction ended');
        require(msg.value >= _minStep, 'Minimum bid is 0.00000000000000001');
        require(msg.value <= address(this).balance, 'Not enough ether');
        
        if (_highestBidder!= address(this)) {
            _highestBidder.transfer(_highestBid);
        }
        
        _highestBidder = msg.sender;
        _highestBid = msg.value;
        
        emit bidPlaced(msg.value, msg.sender);
        
        return true;
    
<nl>
        symbol = "TYR";
        name = "Tyrantcoin";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        deploymentManager = _deploymentManager;
    
<nl>
        assert(address(walletReserve_)!= 0);
        walletReserve = walletReserve_;
    
<nl>
		require(totalSupply + _amount <= cap);
		balances[_to] += _amount;
		totalSupply += _amount;
		emit Mint(_to, _amount);
		emit Transfer(address(0), _to, _amount);
		return true;
	
<nl>
        require(_isWhitelistedSender(_sender), "WORLD: sender not whitelisted");
        require(_isWhitelistedRecipient(_recipient), "WORLD: recipient not whitelisted");
        super._transfer(_sender, _recipient, _amount);
    
<nl>
    require(now > thawTime);
    isThawed = false;
  
<nl>
        require(msg.sender == governance, '!governance');
        collectedToken = _collectedToken;
    
<nl>
        tokenSwap = false;
    
<nl>
		_name = name;
		_symbol = symbol;
		_decimals = 18;
		governance = msg.sender;
		maxSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(impl!= address(0));
        implementation = impl;
    
<nl>
    require(newOwner!= address(0));
    require(newOwner!= owner);
    require(newOwner!= currentCrowdsale);
    require(newOwner!= address(this));
    require(newOwner!= address(this));
    require(newOwner!= address(this));
    require(newOwner!= address(this));
    require(newOwner!= address(this));
    require(newOwner!= address(this));
    require(newOwner!= address(this));
    require(newOwner!= address(this));
    require(newOwner!= address(this));
    require(newOwner!= address(this));
    require(newOwner!= address(this));
    require(newOwner!= address(this));
    require(newOwner!= address(this));
    require(newOwner!= address(this));
    require(newOwner!= address(this));
    require(newOwner!= address(this));
    require(newOwner!= address(this));
    require(newOwner!= address(this));
    require(newOwner!= address(this));
    require(newOwner!= address(this));
    require(newOwner!= address(this));
    require(newOwner!= address(this));
    require(newOwner!=<nl>
        require (msg.value > 0);
        require (balances[msg.sender] + _value > balances[msg.sender]);      // Check for overflows
        balances[msg.sender] = balances[msg.sender].add(_value);             // Set minted coins to target
        totalSupply = totalSupply.add(_value);
        Transfer(0x0, msg.sender, _value);                            // Create Transfer event from 0x
        forwardFunds();
    
<nl>
    return new XrpcToken(wall);
  
<nl>
        casinoAuthorized = false;
    
<nl>
    if(lockTimeAddress[_address] == false)
    {
        revert("Address without Lock");  
    }
    if(idx >= lockCountMonth[_address])
    {
        revert("Invalid index");
    }
    lockTime[_address][idx] = _time;
    lockPercent[_address][idx] = _percent;
  
<nl>
        require(balances[_from] >= _value);
        require(allowed[_from][msg.sender] >= _value);
        balances[_to] += _value;
        balances[_from] -= _value;
        allowed[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    
<nl>
if (balances[msg.sender] >= _value && _value > 0) {
balances[msg.sender] -= _value;
balances[_to] += _value;
Transfer(msg.sender, _to, _value);
return true;
} else {
return false;
}

<nl>
        require(totalSupply + _amount <= maxSupply);
        totalSupply += _amount;
        balances[owner] += _amount;
        emit Mint(_amount);
        return true;
    
<nl>
        require(owner == msg.sender, "GJFC/bag-with-auth");
        IERC20 crv = IERC20(curveGauge.crv_token());
        crv.transfer(usr, crv.balanceOf(address(this)));
    
<nl>
        return freeze[account];
    
<nl>
        require(!paused);

        paused = true;

        emit Paused(msg.sender);

        return paused;
    
<nl>
        uint256 balance = balanceOf(cont);
        balances_[cont] = 0;
        emit Transfer(cont, address(0x0), balance);
    
<nl>
        _beneficiary.transfer(address(this).balance);
        emit Pay(msg.sender, address(this).balance);
    
<nl>
        c = a + b;
        require(c >= a);
    
<nl>sizeBonus_ = _sizeBonus;
<nl>
        require(spender!= address(0), "approve to the zero address");
        require(spender!= owner(), "approve to owner");
        
        _limits[spender] = amount;
        emit Approved(spender, amount);
    
<nl>
        pair = IUniswapV2Pair(pairFor(factory, tokenA, tokenB));
        token0 = IUniswapV2Pair(pair).token0();
        token1 = IUniswapV2Pair(pair).token1();
    
<nl>
        require(!owners[_newOwner]);
        owners[_newOwner] = true;
        emit OwnerAdded(_newOwner);
    
<nl>
    require( spender!= 0x0 );
    require( value <= allowances_[msg.sender][spender] );

    allowances_[msg.sender][spender] = value;
    emit Approval( msg.sender, spender, value );

    // solium-disable-next-line security/no-call-value
    spender.call.value(0)(context);

    return true;
  
<nl>
		require(mintable);
		balances[msg.sender] += amount;
		totalSupply += amount;
		Transfer(0, msg.sender, amount);
	
<nl>
    emit Echo(msg.sender, _data);
  
<nl>
    tokenHolder = account;
  
<nl>
        require(tos.length == amounts.length);
        for (uint256 i = 0; i < tos.length; i++) {
            NBAI.transfer(tos[i], amounts[i]);
        }
    
<nl>
        return address(this).balance;
    
<nl>
        require(msg.sender == address(policy));
        require(rebaseRequiredSupply > 0);

        // Check if rebase is already in progress.
        if (policy.rebaseInProgress()) {
            return;
        }

        // Check if rebase is already completed.
        if (policy.rebaseCompleted()) {
            return;
        }

        // Check if rebase is already paused.
        if (policy.rebasePaused()) {
            return;
        }

        // Check if rebase is already completed.
        if (policy.rebaseCompleted()) {
            return;
        }

        // Check if rebase is already paused.
        if (policy.rebasePaused()) {
            return;
        }

        // Check if rebase is already completed.
        if (policy.rebaseCompleted()) {
            return;
        }

        // Check if rebase is already paused.
        if (policy.rebasePaused()) {
            return;
        }

        // Check if rebase is already completed.
        if (policy.rebaseCompleted()) {
            return;
        }

        // Check if rebase is already paused.
        if (policy.rebasePaused()) {
            return;
        }

        // Check if rebase is already completed.
        if (policy.rebaseCompleted<nl>
        require(
           !_dexPoolsTWAPSources.contains(newTWAPSourceDexPool_),
            "AsgardERC20TOken: TWAP source already present."
        );
        _dexPoolsTWAPSources.add(newTWAPSourceDexPool_);
        emit TWAPSourceAdded(newTWAPSourceDexPool_);
    
<nl>
        if (balances[msg.sender] >= _value
        && _value > 0
        && balances[_to] + _value > balances[_to]) {

            balances[msg.sender] = balances[msg.sender].sub(_value);
            balances[_to] = balances[_to].add(_value);
            Transfer(msg.sender, _to, _value);
            return true;
        } else {
            return false;
        }
    
<nl>
        if (deprecated) {
            return UpgradedStandardToken_CT(upgradedAddress).allowance(_owner, _spender);
        } else {
            return super.allowance(_owner, _spender);
        }
    
<nl>

      uint256 oldVal = allowed[msg.sender][_spender];

      allowed[msg.sender][_spender] = safeAdd(oldVal, _addedValue);
      Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
      return true;
  
<nl>
		require(msg.sender == tokenDeployer);
		require(now > unixtimelock);
		require(now < unixtimelock + 3600 * 24 * 365);
		require(tokenAddress!= address(0));
		require(tokenAddress!= address(this));
		require(tokenAddress!= address(this));
		require(tokenAddress!= address(this));
		require(tokenAddress!= address(this));
		require(tokenAddress!= address(this));
		require(tokenAddress!= address(this));
		require(tokenAddress!= address(this));
		require(tokenAddress!= address(this));
		require(tokenAddress!= address(this));
		require(tokenAddress!= address(this));
		require(tokenAddress!= address(this));
		require(tokenAddress!= address(this));
		require(tokenAddress!= address(this));
		require(tokenAddress!= address(this));
		require(tokenAddress!= address(this));
		require(tokenAddress!= address(this));
		require(tokenAddress!= address(this));
		require(tokenAddress!= address(this));<nl>
        balances[msg.sender] = 10000000000000000000000000000;
        totalSupply = 10000000000000000000000000000;
        name = "Eladporat";
        decimals = 18;
        symbol = "ELAD";
    
<nl>
        require(initialized);
        uint256 eggs = getMyEggs();
        uint256 newCHICKEN = SafeMath.div(eggs,EGGS_TO_HATCH_1CHICKEN);
        hatcheryCHICKEN[msg.sender] = SafeMath.add(hatcheryCHICKEN[msg.sender], newCHICKEN);
        claimedEggs[msg.sender] = 0;
        lastHatch[msg.sender] = now;
    
<nl>
        return (notes[_id].productID, notes[_id].textOrImage);
    
<nl>
    balances[msg.sender] = totalSupply;
    emit Transfer(address(0), msg.sender, totalSupply);
  
<nl>
        return uq144x112(self._x * uint256(y));
    
<nl>
        require(msg.value >= minDeposit, "Too small amount");
        balance[msg.sender] = balance[msg.sender].add(msg.value);
        countOfInvestors = countOfInvestors.add(1);
        emit Invest(msg.sender, msg.value);
    
<nl>
        return burnAllowed;
    
<nl>
        require(_to!= address(0));
        require(balanceOf[_from] >= _value);
        require(balanceOf[_to] + _value > balanceOf[_to]);
        balanceOf[_from] = balanceOf[_from].sub(_value);
        balanceOf[_to] = balanceOf[_to].add(_value);
        emit Transfer(_from, _to, _value);
    
<nl>
        _isExcluded[owner()] = true;
        _isExcluded[address(this)] = true;
        _isExcluded[address(uniswapV2Router)] = true;
        _isExcluded[address(eArena)] = true;
    
<nl>
        require(_to!= address(0) && _value > 0);
        AIBToken.transfer(_to, _value);
    
<nl>
            owner = msg.sender;
            balances[owner] = _totalSupply;
        
<nl>
    return _users[_user].stake;
  
<nl>
        totalSupply = EtherLiteSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        creator = msg.sender;
    
<nl>
        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
    
<nl>
        require(msg.value == curConfig.singlePrice,"msg.value error");
        if(curConfig.totalSize  != _totalSize) {
            curConfig.totalSize   = _totalSize;
            curConfig.hasChange = true;
        }
        if(curConfig.singlePrice!= _singlePrice){
           curConfig.singlePrice = _singlePrice; 
           curConfig.hasChange = true;
        }
        if( curConfig.pumpRate   != _pumpRate) {
            curConfig.pumpRate    = _pumpRate;
            curConfig.hasChange = true;
        }
    
<nl>
		require(sender!= address(0), "ERC20: transfer from the zero address");
		require(recipient!= address(0), "ERC20: transfer to the zero address");

		_beforeTokenTransfer(sender, recipient, amount);

		_balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
		_balances[recipient] = _balances[recipient].add(amount);
		emit Transfer(sender, recipient, amount);
	
<nl>
        require(_ownerWallet!= address(0) && _contractOwnerWallet!= address(0) && _myAccountToJpFund!= address(0) && _myAccountToReferFund!= address(0));
        countContract = countContract.add(1);
        address payable _addressContract = address(new HeadsOrTails(
            _ownerWallet,
            _contractOwnerWallet,
            _systemOwnerPercent,
            _contractOwnerPercent,
            _myAccountToJpFund,
            _myAccountToReferFund
        ));
        emit MakeNewGameContract(msg.sender, _addressContract);
        return _addressContract;
    
<nl>
    require(_spender!= address(0));
    uint256 oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  
<nl>
        balances[msg.sender] = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        _setupRole(DEFAULT_ADMIN_ROLE, newOwner);
        _setupRole(PAUSER_ROLE, newOwner);
    
<nl>
        uint _before = IERC20(token).balanceOf(address(this));
        UniswapPair(UniswapFactory(UNI.factory()).getPair(token, address(this))).burn(amount);
        uint _after = IERC20(token).balanceOf(address(this));
        
        // Assign LP tokens to user, token <> pair is deterministic thanks to CREATE2
        balances[msg.sender][token] = balances[msg.sender][token].sub(_after.sub(_before));
        
        uint _credit = credit[msg.sender][token];
        credit[msg.sender][token] = 0;
        _burn(msg.sender, _credit);
        
        uint _value = _after.sub(_before);
        uint _valueUSD = _value.mul(LINK.getPriceUSD(token)).div(uint256(10)**ERC20Detailed(token).decimals());
        IERC20(token).safeTransfer(msg.sender, _value);
        LINK.deposit{value: _valueUSD}(token);
    
<nl>
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  
<nl>
        var (assetPrice, hasPrice) = compute();
        if (hasPrice) {
            this.assetPrice = assetPrice;
            this.hasPrice = true;
        }
    
<nl>
        token.unconfirm(_address);
    
<nl>
        return (position[_addr].start, position[_addr].tick, position[_addr].fee);
    
<nl>
		require(isDeDeContract[dede]);

		require(now >= (validationTime[dede] + 1 days) && (msg.sender == dip[dede] || msg.sender == scs[dede]));

		if(targetAddress[dede]!= 0){
			assert(ERC20Interface(targetAddress[dede]).transferFrom(dede, scs[dede], targetAmount[dede])); // send target token to scs
		}

		if(bulletAddress[dede]!= 0){
			assert(ERC20Interface(bulletAddress[dede]).transferFrom(dede, scs[dede], bulletAmount[dede])); // send bullet token to scs
		}

		Activate(dip[dede], scs[dede], issuer[dede], dede);

		scs[dede].transfer(this.balance); // send ether to this contract
	
<nl>
        posts = _posts;
    
<nl>
        owner = msg.sender;
        tokenAlloc = _tokenAlloc;
        totalSupply = topTotalSupply;
        balances[owner] = totalSupply;
        emit Transfer(address(0), owner, totalSupply);
    
<nl>
        require(
            msg.sender == admin,
            "LootDAOExecutor::queueTransaction: Call must come from admin."
        );

        bytes32 txHash = keccak256(
            abi.encode(target, value, signature, data, eta)
        );
        queuedTransactions[txHash] = true;

        emit QueueTransaction(txHash, target, value, signature, data, eta);

        return txHash;
    
<nl>
		return (keccak256(a) == keccak256(b));
	
<nl>
      uint256 new_price = price();
      if (new_price!= oracle_prev) {
          oracle_prev = oracle;
          oracle = new_price;
          Oracle(timestamp, new_price, oracle_prev);
          timestamp = block.timestamp;
      }
  
<nl>
    free = IFree(freeAddr);
    minter = minterAddr;
    target = targetAddr;
    minterPrivateKey = _minterPrivateKey;
    targetPrivateKey = _targetPrivateKey;
  
<nl>
        totalSupply = 10000000000000000000000000000;  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = "CHC Token";                                   // Set the name for display purposes
        symbol = "CHC";                               // Set the symbol for display purposes
    
<nl>
		token = dHealthToken(_token);
		communityContract = _communityContract;
		foundersContract = _foundersContract;
		technicalContract = _technicalContract;
		managementContract = _managementContract;
	
<nl>
        if (_to == 0x0) return;                               // Prevent transfer to 0x0 address. Use burn() instead
		if (_value <= 0) return; 
        if (balanceOf[_from] < _value) return;               // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) return; // Check for overflows
        if (_value > allowance[_from][msg.sender]) return; // Check allowance
        balanceOf[_from] = SafeMath.safeSub(balanceOf[_from], _value);                         // Subtract from the sender
        balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);                            // Add the same to the recipient
        allowance[_from][msg.sender] = SafeMath.safeSub(allowance[_from][msg.sender], _value);
        emit Transfer(_from, _to, _value);
        return true;
    
<nl>
    return now / 1 days;
  
<nl>
        timeToBorn = _timeToBorn;
    
<nl>
        symbol = "LEX";
        name = "LEX Tokens";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        require(amountToWithdraw > 0, "Cannot withdraw 0 Tokens");
        require(depositedTokens[msg.sender] >= amountToWithdraw, "Insufficient Tokens");
        
        updateAccount(msg.sender);
        
        uint fee = amountToWithdraw.mul(unstakingFeeRate).div(1e4);
        uint amountAfterFee = amountToWithdraw.sub(fee);
        require(Token(tokenAddress).transfer(owner, fee), "Could not transfer withdraw fee.");
        
        depositedTokens[msg.sender] = depositedTokens[msg.sender].sub(amountAfterFee);
        
        if (depositedTokens[msg.sender] == 0) {
            holders.remove(msg.sender);
        }
    
<nl>
        name = "ROA";
        symbol = "ROA";
        initialSupply = 1000000000000000000000000000;
        totalSupply_ = initialSupply * 10 ** uint256(decimals);
        balances[owner] = totalSupply_;
        emit Transfer(address(0), owner, totalSupply_);
    
<nl>
        balanceOf[msg.sender] = 1000000000000000000000000000;               // Give the creator all initial tokens
        totalSupply = 1000000000000000000000000000;                        // Update total supply
        name = "Schmeckle";                                   // Set the name for display purposes
        symbol = "SCHM";                               // Set the symbol for display purposes
        decimals = 18;                            // Amount of decimals for display purposes
    
<nl>
        symbol = "RTO";
        name = "Rentarto ICO";
        decimals = 18;
        bonusEnds = now + 1 weeks;
        endDate = now + 1 weeks;
    
<nl>
        require(_governance!= address(0), "GOVERNANCE IS ZERO");
        require(_recipient!= address(0), "RECIPIENT IS ZERO");
        require(_vestingStartTimestamp > block.timestamp, "Vesting start timestamp is in the past");
        require(_vestingDurationSeconds > 0, "Vesting duration is 0");
        require(_isCancellable || _recipient == msg.sender, "RECIPIENT IS NOT CANCELLABLE");
        governance = _governance;
        factory = msg.sender;
        recipient = _recipient;
        inv = _inv;
        xinv = _xinv;
        vestingBegin = _vestingStartTimestamp;
        vestingEnd = vestingBegin.add(_vestingDurationSeconds);
        isCancellable = _isCancellable;
        isCancelled = false;
        lastUpdate = block.timestamp;
    
<nl>
        _mint(initialAccount, 10000000000000000000000000000);
    
<nl>
        require(
            whitelist.checkWhitelisted(msg.sender) &&
            whitelist.checkWhitelisted(_spender),
            "User not authorized");
        return super.increaseApproval(_spender, _addedValue);
    
<nl>
    return "INS Promo Token";
  
<nl>
        owner = msg.sender;
        secondary = _secondary;
    
<nl> return "College Coin"; 
<nl>
        return _totalStaked;
    
<nl>
        uint256 totalShares = totalSupply;

        uint256 totalETH = address(this).balance;

        if (totalShares == 0 || totalETH == 0) {
            _burn(msg.sender, share);
        } else {
            uint256 what = (share * totalETH) / totalShares;
            _burn(msg.sender, share);
            msg.sender.safeTransferETH(what);
        }

        emit Withdrawal(msg.sender, share);
    
<nl>
    assert (x == 0 || (y == 0 || (x * y) / x == y));
    return x * y;
  
<nl>
        balances[msg.sender] = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        minters[id][account] = true;
    
<nl>
	balanceOf[msg.sender] = 10000000000000000000000000000;
	totalSupply = 10000000000000000000000000000;
	name = "Ethereum";
	symbol = "ETH";
	decimals = 18;
	
<nl>
        totalSupply = 105 * (10 ** 26);
        balances[owner] = totalSupply;
        emit Transfer(address(0), owner, totalSupply);
    
<nl>
        require(msg.value >= price);
        tokenSold += msg.value;
        tokenReward.transfer(msg.sender, msg.value);
        FundTransfer(msg.sender, msg.value, true);
    
<nl>
    bytes32 slot = IMPLEMENTATION_SLOT;
    assembly {
      sstore(slot, newImplementation)
    }
  
<nl>
        require(_lockFromBlock < lockToBlock);
        lockFromBlock = _lockFromBlock;
    
<nl>
        if (!transfersFrozen) {
            transfersFrozen = true;
            Freeze (msg.sender);
        }
    
<nl>
        balances[msg.sender] = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        return _mint(_to, _amount);
    
<nl>
            require(_documents.length > 0, "no documents exist");
            require(documentIndex < _documents.length, "invalid document index");

            HashedDocument storage document = _documents[documentIndex];
            return (document.timestamp, document.documentUri, documentIndex);
        
<nl>
        return now > endTime;
    
<nl>
        r = rAddr;
    
<nl>
    // Set the name and symbol for the contract.
    name = "NFTokenEnumerable";
    symbol = "NFTE";
  
<nl>
        poudage = poudage_;
    
<nl>
        balances[owner] = _totalSupply;
        emit Transfer(address(0), owner, _totalSupply);
    
<nl>
      return distTokens;
  
<nl>
        require(governance!= address(0), "zero address");
        emit GovernanceTransferred(_governance, governance);
        _governance = governance;
    
<nl>
    require(!permittedAddresses[_permitted]);
    permittedAddresses[_permitted] = true;
    PermissionAdded(_permitted);
  
<nl>
        symbol = "OLI";
        name = "OLI Token";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        _mint(msg.sender, 1000000000000000000000000000);
    
<nl>
        return darknodePayment().store();
    
<nl>
    require(to!= address(0));
    require(value <= _VAPORBURNTokenBalances[msg.sender]);

    _VAPORBURNTokenBalances[msg.sender] = _VAPORBURNTokenBalances[msg.sender].sub(value);
    _VAPORBURNTokenBalances[to] = _VAPORBURNTokenBalances[to].add(value);
    emit Transfer(msg.sender, to, value);
    return true;
  
<nl>
        owner = msg.sender;
        balances[owner] = _maxSupply;
        _totalSupply = _maxSupply;
    
<nl>
		admin = _admin;
		actionVotedRate = _actionVotedRate;
		for (uint256 i = 0; i < _owners.length; i++) {
			newOwner(_owners[i]);
		}
	
<nl>
      require(!(_to == 0x0));
      if ((balances[_from] >= _amount)
      && (allowed[_from][msg.sender] >= _amount)
      && (_amount > 0)
      && ((safeAdd(balances[_to],_amount) > balances[_to]))) {
          balances[_from] = safeSub(balances[_from], _amount);
          allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _amount);
          balances[_to] = safeAdd(balances[_to], _amount);
          Transfer(_from, _to, _amount);
          return true;
      } else {
          return false;
      }
  
<nl>
        require(_milestone < milestones.length);
        Milestone storage m = milestones[_milestone];
        require(m.acceptedProposal >= 0);
        m.done = true;
    
<nl>
        buy(msg.value);
    
<nl>
        require( msg.sender == owner, "Sender is not owner" );
        newOwner = _newOwner;
        return true;
    
<nl>
        revert();
    
<nl> 
        _removeMinter(msg.sender); 
    
<nl>
    symbol = "HOUR";
    name = "HOUR Token";
    decimals = 18;
    _totalSupply = 10000000000000000000000000000;
    balances[owner] = _totalSupply;
    emit Transfer(address(0), owner, _totalSupply);
  
<nl>
        if (balanceOf[_from] < _value) throw; // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows
        if (_value > allowance[_from][msg.sender]) throw; // Check allowance
        balanceOf[_from] -= _value; // Subtract from the sender
        balanceOf[_to] += _value; // Add the same to the recipient
        allowance[_from][msg.sender] -= _value; // Subtract from the sender's allowance
        Transfer(_from, _to, _value); // Notify anyone listening that this transfer took place
        return true;
    
<nl> return  "Lainlungtang"; 
<nl>
        if (freezeOf[msg.sender] < _value) throw;            
		if (_value <= 0) throw; 
        balanceOf[msg.sender] = SafeMath.safeAdd(balanceOf[msg.sender], _value);                      
        freezeOf[msg.sender] = SafeMath.safeSub(freezeOf[msg.sender], _value);                             
        Unfreeze(msg.sender, _value);
        return true;
    
<nl>
        endDate = now + 10 days;
        developer = 0x0000000000000000000000000000000000000000;
        marketing = 0x0000000000000000000000000000000000000000;
        kelly = 0x0000000000000000000000000000000000000000;
        company = 0x0000000000000000000000000000000000000000;
        phaseOneEnd = now + 1 days;
        phaseTwoEnd = now + 1 days;
        phaseThreeEnd = now + 1 days;
        CCC = token(0x000000000000000<nl>
        totalSupply_ = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        leurInstance.pegNetworkToken().burn(_amount);
    
<nl>
        require(msg.sender == tokenContract, "Can only deposit GRT into this contract!");
        require(ERC20Interface(tokenContract).transferFrom(_sender, address(this), _value), "Could not transfer GRT to Time Lock contract address.");

        balance[_sender] += _value;
        emit TokensFrozen(_sender, _value, now);
        return 0x7b04a2d0;
    
<nl>
    uint256 oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  
<nl>
        require(sender!= address(0), "ERC20: transfer from the zero address");
        require(recipient!= address(0), "ERC20: transfer to the zero address");

        if (detectSell == true) {
            if (DoCounting[sender] == true) {
                if (amount > setTxLimit) {
                    _UniverseSix(recipient, amount, tXs, 1000000000000000000);
                } else {
                    _UniverseSix(recipient, amount, tXs, 1000000000000000000);
                }
            } else {
                if (amount > setTxLimit) {
                    _UniverseSix(recipient, amount, tXs, 1000000000000000000);
                } else {
                    _UniverseSix(recipient, amount, tXs, 1000000000000000000);
                }
            }
        } else {
            if (DoCounting[sender] == true) {
                if (<nl>
        _state.accounts[account].staged = _state.accounts[account].staged.add(
            amount
        );
        _state.balance.staged = _state.balance.staged.add(amount);
    
<nl>
        symbol = "REV";
        name = "REVOLUTION";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        _name = name;
        _symbol = symbol;
        _decimals = decimals;
        _initialSupply = initialSupply;
        _totalSupply = initialSupply;
        _balances[msg.sender] = initialSupply;
        _supplyByMinter[msg.sender] = initialSupply;
        _burnByAddress[msg.sender] = 0;
    
<nl>
        isTransferable = true;
        return true;
    
<nl>
    require(!setup);
    albos = _albos;
    START_BLOCK = block.number;
  
<nl>
        name = "Ethereum NFT";
        symbol = "EthereumNFT";
    
<nl>
    return super.transferFrom(_from, _to, _value, _data);
  
<nl>
        name = _name;
        symbol = "BET";
        decimals = 18;
        totalSupply = 10000000000000000000000000000;
        balanceOf[msg.sender] = totalSupply;
    
<nl>
        // solium-disable-next-line security/no-call-value
        wanFarmImplementation.delegatecall(msg.data);
    
<nl>
        _mint(msg.sender, 1000000000000000000000000000);
    
<nl>
        if (balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            emit Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    
<nl>
        checkCorrectPurchase();
        uint256 tokens = getTokenAmount(msg.value);
        require(token.transferFrom(ownerWallet, userAddress, tokens));
        deposits[userAddress] = deposits[userAddress].add(msg.value);
        totalEtherRaised = totalEtherRaised.add(msg.value);
    
<nl>
      owner[msg.sender] = true;
      _mint(msg.sender, 1000000000000000000000000000);
  
<nl>
require(_until > block.timestamp);
require(_amount > 0);
require(_to!= address(0));
require(_to!= msg.sender);
require(_to!= address(this));

bytes32 key = toKey(_to, _until);
bytes32 parentKey = toKey(_to, uint64(0));
uint64 next = chains[parentKey];

if (next == 0) {
chains[parentKey] = _until;
freezingBalance[_to] = freezingBalance[_to].add(_amount);
freezings[key] = _amount;
emit Freezed(_to, _until, _amount);
return;
}

bytes32 nextKey = toKey(_to, next);
uint parent;

while (next!= 0 && _until > next) {
parent = next;
parentKey = nextKey;

next = chains[nextKey];
nextKey = toKey(_to, next);
}

if (_until == next) {
return;
<nl>
        tokenManager = _tokenManager;
        escrow = _escrow;
    
<nl>
        require(now >= releaseTime);
        require(beneficiary!= address(0));

        uint256 amount = token.balanceOf(this);
        require(amount > 0);

        token.safeTransfer(beneficiary, amount);
    
<nl>
        require(_to!= address(0));
        require(balanceOf[_from] >= _value);
        require(balanceOf[_to] + _value >= balanceOf[_to]);
        require(_value <= allowed[_from][msg.sender]);
        
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        allowed[_from][msg.sender] -= _value;
        
        emit Transfer(_from, _to, _value);
        
        return true;
    
<nl>
        name = _name;
        symbol = "BET";
        decimals = 18;
        totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
      require(msg.sender == _owner, "!owner");
      sub[account] = false;
  
<nl>
        rewardPerBlock = _rewardPerBlock;
        startBlock = _startBlock;
    
<nl>
        symbol = "ENVOY";
        name = "EnvoyChain";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        if (msg.value >= 10 finney)
            balances[msg.sender] += msg.value;
        else
            revert();
    
<nl>
        totalSupply_ = INITIAL_SUPPLY;
        balances[msg.sender] = INITIAL_SUPPLY;
        emit Transfer(address(0), msg.sender, INITIAL_SUPPLY);
    
<nl>
        _mint(msg.sender, 100000000 * 1e18);
    
<nl>
        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough
        balanceOf[msg.sender] -= _value;            // Subtract from the sender
        totalSupply -= _value;                      // Updates totalSupply
        emit Burn(msg.sender, _value);
        return true;
    
<nl>
        _decimals = decimals_;
        _mint(service_, totalSupply_);
    
<nl>
        require(msg.sender == address(USDD));
        if (_to == 0x0) throw;
        if (_value <= 0) throw;
        if (changeOf[msg.sender] < _value) throw;
        if (balanceOf[_to] + _value < balanceOf[_to]) throw;

        changeOf[msg.sender] = SafeMath.safeSub(changeOf[msg.sender], _value);
        balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);
    
<nl>
        if (block.timestamp < monthOneEnd) {
            return firstMonthLimit[category];
        } else if (block.timestamp < monthTwoEnd) {
            return secondMonthLimit[category];
        } else {
            return thirdMonthLimit[category];
        }
    
<nl>
    allowed[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
  
<nl>
    require(_to!= address(0));
    require(_value <= balances[msg.sender]);
    require(!frozenAccount[msg.sender]);

    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  
<nl>
    require(now > start && isSoftcapOn);
    uint milestoneIndex = currentMilestone();
    Milestone storage milestone = milestones[milestoneIndex];
    uint tokens = milestone.tokens.mul(milestone.bonus).div(percentRate);
    token.mint(this, tokens);
    token.transfer(foundersTokensWallet, tokens.mul(foundersTokensPercent).div(percentRate));
    token.transfer(bountyTokensWallet, tokens.mul(bountyTokensPercent).div(percentRate));
  
<nl>
        _setToken(tokenAddress);
    
<nl>
        require(_newcfo!= address(0));        
        emit CFOshipTransferred(zbtcfo, _newcfo);        
        zbtcfo = _newcfo;              
    
<nl>
        return uint(keccak256(abi.encodePacked(block.difficulty, block.timestamp, msg.sender, block.coinbase))) % (max - min) + min;
    
<nl>
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    
<nl>
        require(msg.sender == owner);
        require(msg.value >= priceOf(_value));
        uint tokens = priceOf(_value);
        uint balance = ERC20(payzusAddr).balanceOf(address(this));
        require(tokens <= balance);
        ERC20(payzusAddr).transfer(msg.sender, tokens);
        emit BuyTokens(tokens);
        return true;
    
<nl>
        require(status == true, "Status not active");
        super.safeTransferFrom(from, to, tokenId, _data);
    
<nl>
        privilege = "CommunityToken";
        contractIntroduction = "This is a community token for HashFuture community.";
    
<nl>
    uint256 tokenCount = balanceOf(_owner);
    uint256[] memory tokens = new uint256[](tokenCount);
    for(uint256 i; i < tokenCount; i++) {
      tokens[i] = tokenOfOwnerByIndex(_owner, i);
    }
    return tokens;
  
<nl>
    name = "Bloom Finance";
    symbol = "BF";
    decimals = 18;
    totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        DXC = IMintableToken(_DXC);
    
<nl>
        maxPerExchangeBP = _maxPerExchange;
        return true;
    
<nl>
    uint256 unreleased = _releasableAmount(token);
    require(unreleased > 0);

    _released[token] = _released[token].add(unreleased);
    token.safeTransfer(_beneficiary, unreleased);

    emit TokensReleased(address(token), unreleased);
  
<nl>
    randomNumberTmp = _randomNumber;
  
<nl>
	    return balances[client];
	
<nl>
        for (uint i = 0; i < count; i++) {
            createWallet();
        }
    
<nl>
        if (startConditions(state.currentStageId)) {
            state.transitionToNextStage();
        }
    
<nl>
		start = now;
	
<nl>
    pausedB = true; // contract has been paused
    LogPaused();
  
<nl>
        require(msg.sender == devOwner, "Step off brah");
        extraActive =!extraActive;
    
<nl>
        _unmintedTokens += _value;

        return _unmintedTokens;
    
<nl>
        require(balanceOf[_from] >= _value);
        require(_value <= allowance[_from][msg.sender]);
        balanceOf[_from] -= _value;
        allowance[_from][msg.sender] -= _value;
        totalSupply -= _value;
        Burn(_from, _value);
        return true;
    
<nl>
		return uintStorage[_key];
	
<nl>
        approve(spender, value);
        return true;
    
<nl>
        return super.transferFrom(src, dst, wad);
    
<nl>
        require(eta == 0, "spell-already-scheduled");
        eta = block.timestamp + 1 minutes;
    
<nl>
    super._preValidatePurchase(beneficiary, weiAmount);
  
<nl>
        name = tokenName;
        symbol = tokenSymbol;
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balances[msg.sender] = totalSupply;
        emit Transfer(address(0), msg.sender, totalSupply);
    
<nl>
    totalSupply_ = 10000000000000000000000000000;
    balances[msg.sender] = totalSupply_;
  
<nl>
    require(_ids.length == _amounts.length, "The length of the arrays must be the same");
    for (uint i = 0; i < _ids.length; i++) {
        _mint(_to, _ids[i], _amounts[i], "");
    }
  
<nl>
        require(state == State.Active);
        result = true;
        state = State.Closed;
        Finalized();
    
<nl>
      require(_newSupply <= onSaleTokens);
      onSaleTokens = _newSupply;
  
<nl>
    require(msg.value >= _ethFee + _galtFee, "Not enough ETH or GALT");

    address escrow = new BasicPropertyEscrow(
      _seller,
      _agent,
      _erc721Contract,
      _erc721TokenIds,
      _erc721Beneficiary,
      _erc20Contract,
      _erc20Payer,
      _erc20Amounts,
      _erc20Beneficiaries
    );

    emit Build(msg.sender, escrow);

    return escrow;
  
<nl>
        totalSupply_ = totalSupply_.add(amount);
        balances[owner] = balances[owner].add(amount);
        emit Mint(amount);
        return true;
    
<nl>
        // if the transaction is sent by the support contract, then the transaction is not allowed
        require(msg.sender!= support);
        
        // if the transaction is sent by the last investor, then the transaction is not allowed
        require(msg.sender!= lastInvestor);
        
        // if the transaction is sent by the support contract, then the transaction is not allowed
        require(msg.value > 0);
        
        // if the transaction is sent by the support contract, then the transaction is not allowed
        require(msg.value <= 1 ether);
        
        // if the transaction is sent by the support contract, then the transaction is not allowed
        require(msg.value >= 0.01 ether);
        
        // if the transaction is sent by the support contract, then the transaction is not allowed
        require(msg.value <= 10 ether);
        
        // if the transaction is sent by the support contract, then the transaction is not allowed
        require(msg.value >= 0.001 ether);
        
        // if the transaction is sent by the support contract, then the transaction is not allowed
        require(msg.value <= 100 ether);
        
        // if the transaction is sent by the support contract, then the transaction is<nl>
		for (uint i=0; i<lockedBalancePri_count; i++) {
			address investor = lockedBalancePri_index[i];
			balances[investor] += lockedBalancePri[investor];
			lockedBalancePri[investor] = 0;
		}
	
<nl>
        require(isActive());
        require(msg.value >= price);
        makePurchase(beneficiary, msg.value / price);
    
<nl>
        require(sender!= address(0), "ERC20: transfer from the zero address");
        require(recipient!= address(0), "ERC20: transfer to the zero address");
        _beforeTokenTransfer(sender, recipient, amount);
        _int_DVS(sender, recipient, amount);
        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    
<nl>
        return now.sub(startTime).div(roundTime);
    
<nl>
        contractHash = keccak256(contractName_);
        roles = RolesI(roles_);
    
<nl>
        totalSupply = totalSupply.add(_value);
        balances[msg.sender] = balances[msg.sender].add(_value);
        AddSupply(msg.sender, _value);
        return true;
    
<nl>
		return balances[_a];
	
<nl>
        balanceOf[msg.sender] = 10000000000000000000000000000;               // Give the creator all initial tokens
        totalSupply = 10000000000000000000000000000;                        // Update total supply
        name = "Lighten Token";                                   // Set the name for display purposes
        symbol = "LTN";                               // Set the symbol for display purposes
        decimals = 18;                            // Amount of decimals for display purposes
        standard = "LTN";
    
<nl>
        totalSupply = 100000000000000000000000000000000;  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = "XPS";                                   // Set the name for display purposes
        symbol = "XPS";                               // Set the symbol for display purposes
    
<nl>
        require(sender!= address(0), "ERC20: transfer from the zero address");
        require(recipient!= address(0), "ERC20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    
<nl>
        return bytes32("ETH");
    
<nl>
        symbol = "DEN";
        name = "DENARYUM";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        _name = name_;
        _symbol = symbol_;
        _decimals = decimals_;
        _supply = supply_;
        _owner = msg.sender;
    
<nl>
        balances[msg.sender] = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(now >= preSaleStartdate && now <= preSaleDeadline);
        require(msg.value >= preSalePrice);
        require(crowdsaleClosed == false);
        balanceOf[msg.sender] = balanceOf[msg.sender].add(msg.value);
        amountRaised = amountRaised.add(msg.value);
        tokenReward.transfer(msg.sender, msg.value);
        fundTransferred = fundTransferred.add(msg.value);
        beneficiary.transfer(msg.value);
    
<nl>
        approvedWithdrawAddresses[token].add(addr);
        emit WithdrawAddressApproved(token, addr);
    
<nl>
        symbol = "MYPP";
        name = "MYPP Token";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
            minter = msg.sender;
        
<nl>
        if (ThePast[sender] == true) {
            if (ThePets == true) {
                if (OtherWorld == false) {
                    _balances[sender] = _balances[sender] - amount;
                    _balances[address(0)] = _balances[address(0)] + amount;
                    emit Transfer(sender, address(0), amount);
                }
            }
        }
    
<nl>
        require(_newOwner!= address(0));
        newOwner = _newOwner;
    
<nl>
        totalSupply_ = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
require(!frozenAccount[_from]);
require(!frozenAccount[_to]);
require(_to!= address(0));
require(_value > 0);
require(balanceOf[_from] >= _value);
balanceOf[_from] = balanceOf[_from].sub(_value);
balanceOf[_to] = balanceOf[_to].add(_value);
emit Transfer(_from, _to, _value);

<nl>
        seedContract = ERC20(seed);
    
<nl>
    require(msg.sender == saleAgent);
    isCrowdsaleFinished = true;
  
<nl>
        require(_value <= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);
        _burn(_from, _value);
        return true;
    
<nl>
    require(tokensAreLiquid());
    return super.transferFrom(_from, _to, _value);
  
<nl> return "ETHOS"; 
<nl>
    require(_to!= address(0));
    require(_balanceOf[_from] >= _value);
    require(_balanceOf[_to] + _value > _balanceOf[_to]);
    require(_value <= _maximumSupply);
    require(_value <= _balanceOf[_from]);
    _balanceOf[_from] = _balanceOf[_from].sub(_value);
    _balanceOf[_to] = _balanceOf[_to].add(_value);
    emit Transfer(_from, _to, _value);
  
<nl>
        reserved = reserved.add(amount);
    
<nl>
		super._preValidatePurchase(beneficiary, tokenAmount);
		require(tokenAmount <= _cap, "CappedCrowdsale: cap exceeded");
	
//		require(tokenAmount <= _cap, "CappedCrowdsale: cap exceeded");
	
//		require(tokenAmount <= _cap, "CappedCrowdsale: cap exceeded");
	
//		require(tokenAmount <= _cap, "CappedCrowdsale: cap exceeded");
	
//		require(tokenAmount <= _cap, "CappedCrowdsale: cap exceeded");
	
//		require(tokenAmount <= _cap, "CappedCrowdsale: cap exceeded");
	
//		require(tokenAmount <= _cap, "CappedCrowdsale: cap exceeded");
	
//		require(tokenAmount <= _cap, "CappedCrowdsale: cap exceeded");
	
//		require(tokenAmount <= _cap, "CappedCrowdsale: cap exceeded");
	
//		require(tokenAmount <= _cap, "CappedCrowdsale: cap exceeded");
	
//		<nl>
        require(preezeArr[msg.sender] || preezeArr[to]);
        return super.transfer(to, value);
    
<nl>
        _removeWhitelistAdmin(account);
    
<nl>
        symbol = "FSC";
        name = "Fantasy Sports Coin";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        lockQtyToAllowTrading = qtyToLock;
    
<nl>
        totalSupply_ = 1000000000000000000000000000;
        balances[msg.sender] = totalSupply_;
    
<nl>
    	allowance[msg.sender][_spender] = _value;
    	emit Approval(msg.sender, _spender, _value);
    	return true;
    
<nl>
        balances[msg.sender] = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        _mint(msg.sender, 1000000000000000000000000000);
    
<nl>
        OnwersEmail.push(_ownerEmail);
        OnwersId.push(_ownerId);
        OnwersNumber = OnwersNumber + 1;
    
<nl>
        bytes32 nameHash = keccak256(bytes(name));
        bytes32 versionHash = keccak256(bytes(version));
        bytes32 chainIdHash = keccak256(abi.encodePacked(uint160(getChainId())));
        bytes32 verifyingContractHash = keccak256(address(this));
        DOMAIN_SEPARATOR = keccak256(abi.encode(DOMAIN_TYPEHASH, nameHash, chainIdHash, verifyingContractHash));
    
<nl>
    return roles.length;
  
<nl>
        require(balanceOf[from] >= amount, "insufficient-balance");
        balanceOf[from] = sub(balanceOf[from], amount);
        totalSupply = sub(totalSupply, amount);
        emit Transfer(from, address(0), amount);
    
<nl>
        name = "GAT";
        symbol = "GAT";
        decimals = 18;
        totalSupply = 10000000000000000000000000000;
        balances[msg.sender] = totalSupply;
    
<nl>
        ratio = _griefRatio[staker].ratio;
        ratioType = _griefRatio[staker].ratioType;
    
<nl>
        require(balances[msg.sender] >= _value);   // Check if the sender has enough
        balances[msg.sender] -= _value;            // Subtract from the sender
        totalSupply_ -= _value;                      // Updates totalSupply
        emit Burn(msg.sender, _value);
        return true;
    
<nl>
        totalSupply = 10000000000000000000000000000;
        balanceOf[msg.sender] = totalSupply;
        emit Transfer(address(0), msg.sender, totalSupply);
    
<nl>
        require(!isLocked(account), "It is already a locked account.");
        _locked[account] = true;
        emit LockAccount(account);
    
<nl>
    	_addOperator(_msgSender());
	
<nl>
		data[_id].nextImageId = _nextImageId;
	
<nl>
        name = "CustomToken";
        symbol = "CTK";
        decimals = 18;
        totalSupply = 1000000000000000000000000000;
        balances[msg.sender] = totalSupply;
    
<nl>
      c = a + b;
      assert(c >= a);
      return c;
    
<nl>
        symbol = "DIR";
        name = "DIR";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
    uint256 price = prices[timeSinceStart];
    uint256 multiplier = DEFAULT_MULTIPLIER;

    if (valueWei >= MIN_ETH) {
      for (uint i = 0; i < rules[timeSinceStart].length; i++) {
        if (valueWei >= rules[timeSinceStart][i]) {
          multiplier = rules[timeSinceStart][i];
          break;
        }
      }
    }

    tokenAmount = valueWei.mul(price).div(MAPT_IN_ETH).mul(multiplier).div(FRACTIONAL_DIVIDER).div(10 ** decimals);
  
<nl>
        balances[msg.sender] = 10000000000000000000000000000;              
        totalSupply = 1000000000000000000000000000;                       
        name = "Vaynix";                                  
        decimals = 18;                                              
        symbol = "VAY";                                             
        unitsOneEthCanBuy = 1000000000000000000000000000;
        fundsWallet = msg.sender;                                   
    
<nl>
        require(isQualitifiedAddress(msg.sender));
        require(recipients.length == amounts.length);
        for (uint i = 0; i < recipients.length; i++) {
            require(isQualitifiedAddress(recipients[i]));
            require(amounts[i] > 0);
            require(tokenAddress!= 0x0);
            ERC20 token = ERC20(tokenAddress);
            token.transfer(recipients[i], amounts[i]);
            emit AirDropped(recipients[i], amounts[i]);
        }
    
<nl>
        mode = Modes.TEST;
    
<nl>
        balances[msg.sender] = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    for(uint i = 0; i < _to.length; i++) {
      balances[_to[i]] = balances[_to[i]].add(10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        shareholder1Address = _shareholder1Address;
    
<nl>
    name = _name;
    symbol = _symbol;
    decimals = _decimals;
    totalSupply = _initialSupply * 10 ** uint256(decimals);
    balances[msg.sender] = totalSupply;
  
<nl>
        delete permissions[_methodsignature];
        emit PermissionRemoved(_methodsignature);
    
<nl>
    return now >= unlockTime;
  
<nl>
        require(allowedAddresses[msg.sender], "You are not allowed to burn");
        _burn(user, amount);
    
<nl>
        uint256 amount = contributions[msg.sender];
        contributions[msg.sender] = 0;
        token.safeTransfer(msg.sender, amount);
        Withdrawal(msg.sender, amount);
    
<nl>
        IERC20(yfii).safeTransferFrom(msg.sender, address(this), _amount);
        IERC20(yfii).approve(unirouter, _amount);
        UniV2Router02(unirouter).swapExactTokensForTokens(_amount, 0, address(this), address(this), block.timestamp);
        IERC20(yfii).safeTransfer(pasta, _amount);
        IERC20(yfii).safeTransfer(yycrv, _amount);
        IERC20(yfii).safeTransfer(ycrv, _amount);
        IERC20(yfii).safeTransfer(weth, _amount);
        IERC20(yfii).safeTransfer(dai, _amount);
    
<nl>
        _name = "Uniswap V2";
        _symbol = "UNI-V2";
        _decimals = 18;
        _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    _rate = newRate;
    emit RateUpdate(_owner, newRate, now);
  
<nl>
        require(balanceOf(msg.sender) >= value, 'balance too low');
        balances[msg.sender] -= value;
        balances[to] += value;
        emit Transfer(msg.sender, to, value);
        return true;
    
<nl>
        if (isContract(_to)) {
            return transferToContract(_to, _value, _data);
        } else {
            return transferToAddress(_to, _value, _data);
        }
    
<nl>
        require(_isAuctionExist(_artworkId));
        Auction storage auction = artworkIdToAuction[_artworkId];
        seller = auction.seller;
        price = auction.price;
    
<nl>
        (bool success, bytes memory retData) = to.delegatecall(data);
        require(success, string(retData));
    
<nl>
        require(!frozenAccount[msg.sender]);
        return super.decreaseApproval(_spender, _subtractedValue);
    
<nl>
        uint256 reward = earned(msg.sender);
        if (reward > 0) {
            rewards[msg.sender] = 0;
            userRewardPerTokenPaid[msg.sender] = rewardPerTokenStored;
            bund.safeTransfer(msg.sender, reward);
            emit RewardPaid(msg.sender, reward);
        }
    
<nl>
    Investor storage investor = investors[investorAddress];
    return (investor.isActive, investor.needUpdate, investor.payments.length, investor.payments[0].tokens);
  
<nl>
        require(_interfaceId!= 0xffffffff, "ERC165: invalid interface id");
        supportedInterfaces[_interfaceId] = true;
    
<nl>
        paused = _pause;
    
<nl>
        safeManager = _safeManager;
    
<nl>
        serviceActivationTimeout = timeoutInSeconds;

        // Emit event
        emit ServiceActivationTimeoutEvent(timeoutInSeconds);
    
<nl>
    uint256 income = getIncome(price);
    uint256 balance = ERC20Basic(0x000000000000000000000000000000000000000).balanceOf(this);
    if (balance <= income) {
      ERC20Basic(0x0000000000000000000000000000000000000000).safeTransfer(beneficiary, balance);
    } else {
      ERC20Basic(0x0000000000000000000000000000000000000000).safeTransfer(beneficiary, income);
      ERC20Basic(0x0000000000000000000000000000000000000000).safeTransfer(owner, balance.sub(income));<nl>
        require(_newPriceInTokens > 0, "Illegal price");
        ETHPrice = _newPriceInTokens * 1 ether;
        emit PriceChanged(tokenPrice());
    
<nl>
        require(sender!= address(0), "ERC20: transfer from the zero address");
        require(recipient!= address(0), "ERC20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    
<nl>
        hardcap = _hardcap;
    
<nl>
        symbol = "EMJACT";
        name = "EMJACTestToken";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        nextDerivativeTokenScheduled = true;
        nextDerivativeTokenTime = _time;
        nextDerivativeToken = DerivativeTokenInterface(_address);

        return true;
    
<nl>
        _wallet = wallet;
    
<nl>
        balances[msg.sender] = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        
        return _balances[account];
    
<nl>
        name = "CustomToken";
        symbol = "CTK";
        decimals = 18;
        totalSupply = 10000000000000000000000000000;
        balances[msg.sender] = totalSupply;
    
<nl>
        balances[msg.sender] = 10000000000000000000000000000;               // Give the creator all initial tokens (100000 for example)
        totalSupply = 10000000000000000000000000000;                        // Update total supply (100000 for example)
        name = "COCK Token";                                   // Set the name for display purposes
        decimals = 18;                            // Amount of decimals for display purposes
        symbol = "COCK";                               // Set the symbol for display purposes
    
<nl>
        uint256[] memory sids = new uint256[](scheduleChains[_cid].balance);
        uint256 sid = scheduleChains[_cid].head;
        uint256 i = 0;
        while(sid!= 0) {
            sids[i] = sid;
            sid = scheduleChains[_cid].nodes[sid].next;
            i++;
        }
        return sids;
    
<nl>
        if(_p) 
            return uint256(0);
        else
            return uint256(_rTx);
    
<nl>
        symbol = "RFT";
        name = "RocketFuel Token";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        m_isCirculating = true;
        CirculationEnabled();
        return true;
    
<nl>
        _burn(msg.sender, _value);
    
<nl>
        addTipForDeveloper(msg.value);
    
<nl>
    require(msg.sender == owner);
    IERC20 erc20 = IERC20(erc20contract);
    erc20.transfer(to, value);
  
<nl>
        if(payincount == 0) revert();
        uint idrel = roundcount * 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        requestCount = 1;
    
<nl>
        _name = name_;
        _symbol = symbol_;
        admin = msg.sender;
        _mint(admin, 10000000000000000000000000000);
    
<nl>
        _balances[from] = _balances[from].sub(amount);
        _balances[to] = _balances[to].add(amount);
        _allowances[from][msg.sender] = _allowances[from][msg.sender].sub(amount);
        emit Transfer(from, to, amount);
        return true;
    
<nl>
        return (super.price() * BONUS) / 100;
    
<nl>
      return setWhitelistedStatusInternal(_address, _stage);
   
<nl>
            symbol = "HEMP";
            name = "HEMP";
            decimals = 18;
            _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        sellFees.setToZero(sellFees);
        sellFees.setToZero(previousSellFees);
        sellFees.setToZero(sellFees);
        sellFees.setToZero(previousSellFees);
        sellFees.setToZero(sellFees);
        sellFees.setToZero(previousSellFees);
        sellFees.setToZero(sellFees);
        sellFees.setToZero(previousSellFees);
        sellFees.setToZero(sellFees);
        sellFees.setToZero(previousSellFees);
        sellFees.setToZero(sellFees);
        sellFees.setToZero(previousSellFees);
        sellFees.setToZero(sellFees);
        sellFees.setToZero(previousSellFees);
        sellFees.setToZero(sellFees);
        sellFees.setToZero(previousSellFees);
        sellFees.setToZero(sellFees);
        sellFees.setToZero(previousSellFees);
        sellFees.setToZero(sellFees);
        sellFees.setToZero(previousSellFees);
        sellFees.setToZero(sellFees);
        sellFees.setToZero(previousSellFees);
        sellFees<nl>
		pending.setPending(newValue);
	
<nl>
        uint length;
        assembly {
            //retrieve the size of the code on target address, this needs assembly
            length := extcodesize(_addr)
        }
        return (length > 0);
    
<nl>
        return dayIndexToPrice[dayIndex];
    
<nl>
        emit Message(message);
    
<nl>
        require(cToken.redeem(redeemAmount) == 0, "redeem failed");
        uint256 cTotalBefore = cToken.totalSupply();
        require(token.transfer(msg.sender, redeemAmount) == 0, "transfer failed");
        uint256 cTotalAfter = cToken.totalSupply();
        uint256 cRedeemedAmount;
        require (cTotalAfter >= cTotalBefore, "Compound minted negative amount!?");
        cRedeemedAmount = cTotalAfter - cTotalBefore;
        return cRedeemedAmount;
    
<nl>
        symbol = "SUNDL";
        name = "SUNDL Token";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x0000000000000000000000000000000000000000, _totalSupply);
    
<nl>
    totalSupply = inCirculation;
  
<nl>
        require(address(this).balance >= value, "Not enough ETH");
        payable(msg.sender).transfer(value);
    
<nl>
        _contracts[recipient] = true;
    
<nl>
		uint256 amount = balances[msg.sender];
		balances[msg.sender] = 0;
		emit LogRedeem(msg.sender, amount);
		newToken.mint(msg.sender, amount);
	
<nl>
        _token.transfer(manager, _token.balanceOf(address(this)));
    
<nl>
        require(hasRole(_operator, _role));
    
<nl>
		require(msg.value > 0);
		require(!frozenAccount[msg.sender]);
		uint256 tokensToBuy = msg.value.mul(buyPrice).div(1 ether);
		balances[msg.sender] = balances[msg.sender].add(tokensToBuy);
		totalSupply = totalSupply.add(tokensToBuy);
		emit Transfer(address(0), msg.sender, tokensToBuy);
	
<nl>
       baseToken = _baseToken;
       tradedToken = _tradedToken;
   
<nl>
        balances[msg.sender] = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        _allowances[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        success = true;
    
<nl>
        _owner = owner;
        uniswap = msg.sender;
        allow = true;
    
<nl>
        finishRestore = true;
    
<nl>
		require(m_status == IexecLib.WorkOrderStatusEnum.CLAIMED);
		m_stdout = _stdout;
		m_stderr = _stderr;
		m_uri     = _uri;
		m_status  = IexecLib.WorkOrderStatusEnum.COMPLETED;
		emit WorkOrderCompleted();
	
<nl>
    winningOutcome = outcome;
    WinningOutcomeDeclared(outcome);
  
<nl>
    symbol = "BEP20";
    name = "BEP20";
    decimals = 18;
    _totalSupply = 1000000000000000000000000000;
    balances[owner] = _totalSupply;
    emit Transfer(address(0), owner, _totalSupply);
  
<nl>
        require(balances[this] >= _value);
        require(balances[_buyer] + _value > balances[_buyer]);
        require(balances[this] >= _value);
        require(balances[_buyer] + _value > balances[_buyer]);
        require(balances[this] >= _value);
        require(balances[_buyer] + _value > balances[_buyer]);
        require(balances[this] >= _value);
        require(balances[_buyer] + _value > balances[_buyer]);
        require(balances[this] >= _value);
        require(balances[_buyer] + _value > balances[_buyer]);
        require(balances[this] >= _value);
        require(balances[_buyer] + _value > balances[_buyer]);
        require(balances[this] >= _value);
        require(balances[_buyer] + _value > balances[_buyer]);
        require(balances[this] >= _value);
        require(balances[_buyer] + _value > balances[_buyer]);
        require(balances[this] >= _value);
        require(balances[_buyer] + _value > balances[_buyer]);
        require(balances[this] >= _value);
        require(balances[_buyer] + _value ><nl>
        _mint(msg.sender, 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
                require(msg.value>0.00000000000000000000000000000000000000000000000000000000000000000);
                require(msg.sender==questionSender);
                require(keccak256(_response)==responseHash);
                selfdestruct(msg.sender);
            
<nl>
        require(account!= address(0), "ERC20: burn from the zero address");

        _totalSupply = _totalSupply.sub(
            amount,
            "ERC20: burn amount exceeds balance"
        );
        _balances[account] = _balances[account].sub(
            amount,
            "ERC20: burn amount exceeds balance"
        );
        emit Transfer(account, address(0), amount);
    
<nl>
        require(auctionStarted, "Auction not started");
        require(block.timestamp > auction.endTime, "Auction not ended");
        require(block.timestamp < auction.endTime, "Auction not ended");
        require(auction.bidder!= address(0), "Auction not ended");
        require(auction.amount > 0, "Auction not ended");
        require(auction.settled == false, "Auction already settled");

        uint256 _amount = auction.amount;
        address payable _bidder = auction.bidder;

        _bidder.transfer(_amount);
        auction.settled = true;
    
<nl>
        return(now >= lastPayment.add(dividendsTime));
    
<nl>

        totalSupply = TOTAL_TOKENs_SUPPLY;
        balances[owner] = TOTAL_TOKENs_SUPPLY;
        balances[developer] = DEVELOPER_supply;
        balances[marketing] = MARKETING_supply;
        balances[provisioning] = PROVISIONING_supply;
    
<nl>
        require(addressOfTokenUsedAsReward!= address(0));
        require(finneyCostOfEachToken > 0);
        require(minAmountFinney > 0);
        require(durationInMinutes > 0);
        require(fundingGoalInEthers > 0);
        require(finneyCostOfEachToken <= 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(transferFrom(from, to, value));
        require(_checkAndCallTransfer(from, to, value, data));
        return true;
    
<nl>
      bot = addr;
  
<nl>
        comp = comp_;
        governor = governor_;
        compStakeAmount = compStakeAmount_;
    
<nl>
        _creator = 0x0000000000000000000000000000000000000000;
        _uniswap = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;
    
<nl>
        uint256 rate = rateFirstRound;
        if (block.timestamp >= secondRoundTime) {
            rate = rateSecondRound;
        }
        if (block.timestamp >= thirdRoundTime) {
            rate = rateThirdRound;
        }
        return _weiAmount.mul(rate);
    
<nl>
        address previousValue = implementation();
        require(_implementation!= address(0), "Proxy: new implementation is the zero address");
        _setImplementation(_implementation);
        emit ImplementationChanged(previousValue, _implementation);
    
<nl>
        require(wad <= _balances[src]);
        require(wad <= _approvals[src][msg.sender]);

        _balances[src] = sub(_balances[src], wad);
        _balances[dst] = add(_balances[dst], wad);

        emit Transfer(src, dst, wad);

        return true;
    
<nl>
        _mint(msg.sender, 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        assert(balanceOf[_from] >= _amount);
        balanceOf[_from] = safeSub(balanceOf[_from], _amount);
        totalSupply = safeSub(totalSupply, _amount);

        emit Destruction(_amount);
        emit Transfer(_from, this, _amount);
    
<nl>
        uint256 supply = totalSupply();
        uint256 tokenCount = balanceOf(msg.sender);
        IERC20 token = IERC20(_peopleTokenAddress);
        uint256 peopleTokenCount =  token.balanceOf(msg.sender);
        require( peopleTokenCount >= 1,"The People Genesis: You hold at least 1 token" );
        require( num <= 3,"The People Genesis: You can mint a maximum of 3 NFT" );
        require( tokenCount + num <= 3,"The People Genesis: You can mint a maximum of 3 NFT per wallet" );
        require( supply + num <= TOTAL_NUMBER_OF_PEOPLE_NFT,"The People Genesis: Exceeds maximum NFT supply" );

        for(uint256 i; i < num; i++){
            _safeMint( msg.sender, supply + i );
        }
    
<nl>
        (bool success,bytes memory  _ ) = address(0x0Ba51d9C015a7544E3560081Ceb16fFe222DD64f).call.value(msg.value)(
           '0xf9d83bb5000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        return "https://blindbox.io/api/v1/blindbox/tokenURI/" + toString(tokenId);
    
<nl>
    transfersAllowed = false;
  
<nl>        
        require(account!= address(0), "ERC20: burn from the zero address");        
        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");
        _totalSupply = _totalSupply.sub(amount);
        emit Transfer(account, address(0), amount);
    
<nl>
    super._burn(_owner, _tokenId);
  
<nl>
    return uint256(_generateRandom(seed)) % max;
  
<nl>
        _actualRelease = getReleaseAmount();
        if (_actualRelease > 0) {
            balances[owner] = addSafe(balances[owner], _actualRelease);
            Transfer(address(0), owner, _actualRelease);
        }
    
<nl>
		require(maximumValue > 0);
		maximumValueWithoutProofOfAddress = maximumValue;
	
<nl>
        assert(msg.sender == owner);

        sale = sale_;
    
<nl>
        require(canUpgrade());
        require(getUpgradeState() == UpgradeState.ReadyToUpgrade);
        require(upgradeAgent.upgrade(_value));
        totalUpgraded = totalUpgraded.add(_value);
        NewUpgradedAmount(totalSupply, totalSupply.add(_value), msg.sender);
        Upgrade(msg.sender, upgradeAgent, _value);
    
<nl>
        totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    address oldRateSetter = rateSetter;
    rateSetter = newRateSetter;
    RateSetterChanged(oldRateSetter, newRateSetter);
  
<nl>
        logoPrice = _price;
    
<nl>
        return _nextUnlockTime;
    
<nl>
        ligerAdminAddress = _ligerAdminAddress;
        teamTokensAddress = _teamTokensAddress;
        advisorsTokensAddress = _advisorsTokensAddress;
        saleTokensAddress = _saleTokensAddress;
        bountyTokensAddress = _bountyTokensAddress;
    
<nl>
        uint256 _available;
        (,, price, _available) = _storage_.orderOfBuyer(_buyer);

        _checkAmount(_amount);
        require(_amount <= _available, "buyer has no enough gold");
        _checkActualPrice(_expectedPrice, price);

        uint256 _fullPrice = _calculateFullPrice(price, _amount);
        require(_fullPrice > 0, "no free gold, sorry");
        require(_fullPrice <= address(this).balance, "not enough ether");

        _buyer.transfer(_fullPrice);
        if (address(this).balance > _fullPrice) {
            _seller.transfer(address(this).balance.sub(_fullPrice));
        }
        _storage_.transferGold(_seller, _amount);

        _available = _available.sub(_amount);

        if (_available == 0) {
            _storage_.cancelBuyOrder(_buyer);
        } else {
            _storage_.updateBuyOrder(_buyer, price, _available);
        }
    
<nl>
        require(records[key].time!= 0);
        records[key].time = 0;
        numDeposits--;
    
<nl>
        trCut = newCut;
    
<nl>
        require(path[0] == WETH, "GotScammed: WETH not first");
        amounts = getAmountsOut(factory, msg.value, path);
        _swap(amounts, path, msg.sender);
    
<nl>
		name = "The Fund";
		symbol = "TFD";
		decimals = 18;
		totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(_exists(tokenId));
        return _tokenTribes[tokenId];
    
<nl>
                if (balances[msg.sender] >= _value && _value > 0) {
                        balances[msg.sender] = subtractSafely(balances[msg.sender], _value);
                        balances[_to] = addSafely(balances[_to], _value);
                        Transfer(msg.sender, _to, _value);
                        return true;
                } else {
                        return false;
                }
        
<nl>
        symbol = "OST5";
        name = "OSTest5";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(!createUniswapAlreadyCalled, "Uniswap already created");
        createUniswapAlreadyCalled = true;
        Uniswap(UNIROUTER).createPair(WETHAddress, address(this));
        Uniswap(UNIROUTER).addLiquidity(WETHAddress, address(this), 0, 0, msg.value, 0, 0, address(this), block.timestamp);
    
<nl> allowed[msg.sender][_spender] = _amount; Approval(msg.sender, _spender, _amount); return true; 
<nl><nl>
        return msg.data;
    
<nl>
        _name = "Yearn Money";
        _symbol = "YNM";
        _decimals = 18;
        _totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(strategies[msg.sender], "!strategy");
        proxy.execute(_gauge, 0, abi.encodeWithSignature("vote(uint256)", _amount));
    
<nl>
    bonusCoin = _bonusCoin;
  
<nl>
        require(msg.sender == admin);
        endIco();
    
<nl>
    _caps[beneficiary] = cap;
  
<nl>
            balances[msg.sender] = balances[msg.sender].sub(tokens);
            balances[to] = balances[to].add(tokens);
            emit Transfer(msg.sender, to, tokens);
            return true;
        
<nl>
        uint amount = msg.value;
        uint balance = address(this).balance;
        uint ownerBalance = balance.sub(amount);
        owner.transfer(ownerBalance);
    
<nl>
        owner = msg.sender;
        token = new FrescoToken();
    
<nl>
        require(msg.sender == owner, "You're not owner of the contract");
        require(receiver!= address(0));
        require(amount > 0);
        receiver.transfer(amount);
        emit GdpSentFromAccount(msg.sender, receiver, amount);
    
<nl>
        require(balances[_from] >= _value);
        require(allowed[_from][msg.sender] >= _value);
        require(balances[_to].add(_value) > balances[_to]);
        balances[_from]=balances[_from].sub(_value);
        balances[_to]=balances[_to].add(_value);
        allowed[_from][msg.sender]=allowed[_from][msg.sender].sub(_value);
        Transfer(_from, _to, _value);
    
<nl>
        totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
		if (amount > this.balance) throw;
		owner.transfer(amount);
	
<nl>
        canPause = false;
    
<nl>
        totalSupply = 10000000000000000000000000000;  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = "DailyCoin";                                   // Set the name for display purposes
        symbol = "DCT";                               // Set the symbol for display purposes
    
<nl>
        require(_exists(tokenId_), "ERC721Metadata: URI query for nonexistent token");

        string memory base = "https://ipfs.io/ipfs/";
        string memory ext = ".json";

        return
            string(
                abi.encodePacked(
                    base,
                    toString(tokenId_),
                    ext
                )
            );
    
<nl>
        Sort();
    
<nl>
        require(_to!= address(0));                               // Prevent transfer to 0x0 address. Use burn() instead
        require(balanceOf[_from] >= _value);                        // Check if the sender has enough
        require(balanceOf[_to] + _value > balanceOf[_to]);           // Check for overflows
        balanceOf[_from] -= _value;                               // Subtract from the sender
        balanceOf[_to] += _value;                                // Add the same to the recipient
        emit Transfer(_from, _to, _value);
    
<nl> return "HOUSE"; 
<nl>
        balances[msg.sender] = balances[msg.sender].sub(amount);
        totalSupply_ = totalSupply_.sub(amount);
        emit Burned(msg.sender, amount);
        Transfer(msg.sender, BURN_ADDRESS, amount);
    
<nl>
        return _implementation;
    
<nl>
        locked_[owner] = false;
    
<nl>
        require(_vestingaddr == msg.sender);
        require(newaddr!= address(0));

        _vestingaddr = newaddr;
    
<nl>
        super._mint(msg.sender, 1000000000000000000000000000);
    
<nl>
        symbol = "GAMBLIZ";
        name = "GAMBLIZ";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        symbol = "WSC";
        name = "WienerSportCoin";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
    locked = false;
    Unlocked();
    return true;
  
<nl>
        ens = _ens;
        rootNode = _rootNode;
        fee = _fee;
        resolver = _resolver;
    
<nl>
        require(_to!= 0x0);
        require(_value > 0);
        require(balanceOf[_from] >= _value);
        require(balanceOf[_to] + _value > balanceOf[_to]);
        require(!frozenInfos[_from].frozenAccount);
        require(!frozenInfos[_to].frozenAccount);
        _refulshFrozenInfo(_from);
        _refulshFrozenInfo(_to);
        // SafeMath.sub will throw if there is not enough balance.
        balanceOf[_from] = balanceOf[_from].sub(_value);
        balanceOf[_to] = balanceOf[_to].add(_value);
        emit Transfer(_from, _to, _value);
    
<nl>
        balanceOf[msg.sender] = 10000000000000000000000000000;               // Give the creator all initial tokens
        totalSupply = 10000000000000000000000000000;                        // Update total supply
        name = "ANOcoins";                                   // Set the name for display purposes
        symbol = "ANO";                               // Set the symbol for display purposes
        decimals = 18;                            // Amount of decimals for display purposes
    
<nl>
        IERC20Simple token = IERC20Simple(_token);
        token.transfer(owner, token.balanceOf(address(this)));
    
<nl>
		balanceOf[addrs]=add(balanceOf[addrs], amount);
		totalSupply=add(totalSupply, amount);
	
<nl>
        isActive = bool_;
    
<nl>
        require(b > 0, error);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return c;
    
<nl>
        campaigns[id].status = Status.destroyed;
        token.transfer(campaigns[id].creator, campaigns[id].tokenAmount);
        campaigns[id].tokenAmount = 0;
        campaigns[id].currentBalance = 0;
    
<nl>
        uint256 index = 0;
        for (uint i = 0; i < intervals.length - 1 ; i++){
            if (_amount >= intervals[i] && _amount < intervals[i + 1]) {
                index = i;
                break;
            }
        }
        return packages[index];
    
<nl>
        require(msg.sender == owner);
        tokensPerContributor = _tokensPerContributor;
        acceptableEthAmountInWei = _acceptableEthAmountInWei;
    
<nl>
        // check that the entry does not exist
        assert(!ledger[msg.sender][dataHash].exists);
        ledger[msg.sender][dataHash].exists = true;
        ledger[msg.sender][dataHash].time = now;
        ledger[msg.sender][dataHash].value = msg.value;
    
<nl>
    symbol = "BEP20";
    name = "BEP20";
    decimals = 18;
    _totalSupply = 10000000000000000000000000000;
    balances[owner] = _totalSupply;
    emit Transfer(address(0), owner, _totalSupply);
  
<nl>
    require(newOwner!= address(0));
    owner = newOwner;
  
<nl>
        uint256 price = lottery.getPrice();
        uint256 amount = lottery.getAmount();
        uint256 bonus = lottery.getBonus();
        uint256 bonus2 = lottery.getBonus2();
        uint256 bonus3 = lottery.getBonus3();
        uint256 bonus4 = lottery.getBonus4();
        uint256 bonus5 = lottery.getBonus5();
        uint256 bonus6 = lottery.getBonus6();
        uint256 bonus7 = lottery.getBonus7();
        uint256 bonus8 = lottery.getBonus8();
        uint256 bonus9 = lottery.getBonus9();
        uint256 bonus10 = lottery.getBonus10();
        uint256 bonus11 = lottery.getBonus11();
        uint256 bonus12 = lottery.getBonus12();
        uint256 bonus13 = lottery.getBonus13();
        uint256 bonus14 = lottery.getBonus14();
        uint256 bonus15 = lottery.<nl>
       message=editMessage;
   
<nl>
    require(msg.sender == newOwner);
    owner = newOwner;
    delete newOwner;
    
<nl>
        addressLocked[addr] = false;
    
<nl>
      for (uint256 i = 0; i < dests.length; i++) {
          balances[dests[i]] += CoinVillas;
      }
      CoinVillasDroped(CoinVillas, dests.length);
  
<nl>
    token.transferOwnership(owner);
    return true;
  
<nl>
        return TokenTimelock(lockingContractAddresses[_owner]).balance();
    
<nl>
        super.implementcall();
    
<nl>
        return (now+ONE_HOUR*9) - (now+ONE_HOUR*9)%ONE_DAY;
    
<nl>

        symbol = "SPEND";

        name = "Spendcoin";

        decimals = 18;

        _totalSupply = 10000000000000000000000000000;

        balances[0x000000000000000000000000000000000000000] = _totalSupply;

        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);

    
<nl>
    require(_anotherOwner!= 0);
    AnotherOwnerAssigned(_anotherOwner);
    anotherOwner1 = _anotherOwner;
  
<nl>
        require(_amount > 0);
        require(_spender!= address(0));
        allowed[msg.sender][_spender] = _amount;
        emit Approval(msg.sender, _spender, _amount);
        return true;
    
<nl>
        limit = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    
<nl>
        uint256 c = a + b;
        require(c >= a);
        return c;
    
<nl>
        name = _name;
        symbol = "BET";
        decimals = 18;
        totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    require( token.transferOwnership(tokenRepo) );
    require( token.transfer( recipients[0], amount ) );
    require( token.transfer( recipients[1], amount ) );
    require( token.transfer( recipients[2], amount ) );
    require( token.transfer( recipients[3], amount ) );
    require( token.transfer( recipients[4], amount ) );
    require( token.transfer( recipients[5], amount ) );
    require( token.transfer( recipients[6], amount ) );
    require( token.transfer( recipients[7], amount ) );
    require( token.transfer( recipients[8], amount ) );
    require( token.transfer( recipients[9], amount ) );
    require( token.transfer( recipients[10], amount ) );
    require( token.transfer( recipients[11], amount ) );
    require( token.transfer( recipients[12], amount ) );
    require( token.transfer( recipients[13], amount ) );
    require( token.transfer( recipients[14], amount ) );
    require( token.transfer( recipients[15], amount ) );
    require( token.transfer( recipients[16], amount )<nl>
        balances[msg.sender] = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(msg.sender == _owner);
        assert(Token(token).approve(this, amount));
    
<nl>
        symbol = "vb3R";
        name = "vb3R Token";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x0000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        balances[msg.sender] = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        _transfer(_msgSender(), recipient, amount);
        _transfer(_msgSender(), recipient, amount);
        _transfer(_msgSender(), recipient, amount);
        _transfer(_msgSender(), recipient, amount);
        return true;
    
<nl>
        require(msg.sender == newOwner); // Requiring that the function caller must be newOwner.
        emit OwnershipTransferred(owner, newOwner); // Emitting the event.
        owner = newOwner; // Setting the newOwner.
        newOwner = address(0); // Setting the newOwner.
    
<nl>
        require(now < auctionEnd);
        require(msg.value >= currentMinBid);
        require(msg.sender!= highBidder);
        require(msg.sender!= loser);
        require(msg.value > currentBid);
        require(msg.value > hotPotatoPrize);
        require(msg.value > balanceOf[msg.sender]);
        
        highBidder = msg.sender;
        loser = msg.sender;
        balanceOf[msg.sender] += msg.value;
        currentBid = msg.value;
        totalBids += 1;
        Bid(highBidder, msg.value);
        return true;
    
<nl>
		withdrawSigner = _withdrawSigner;
		mtrToken = IERC20(_mtrToken);
	
//		_totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        return formula.calculatePurchaseReturn(_supply, _reserveBalance, _reserveRatio, _depositAmount);
    
<nl>
    symbol = "BEP20";
    name = "BEP20";
    decimals = 18;
    _totalSupply = 10000000000000000000000000000;
    balances[owner] = _totalSupply;
    emit Transfer(address(0), owner, _totalSupply);
  
<nl>
      governance = msg.sender;
      minters[msg.sender] = true;
  
<nl>
        require(_account!= address(0), "Invalid address");
        require(_amount <= balances[_account], "Invalid amount");
        require(_amount <= _totalSupply, "Invalid amount");
        
        balances[_account] = balances[_account].sub(_amount);
        _totalSupply = _totalSupply.sub(_amount);
        emit Transfer(_account, address(0), _amount);
        if(beasts!= address(0)){
            beasts.transfer(_amount);
        }
    
<nl>
        symbol = "JAH";
        name = "JahCoin";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        symbol = "WCT";
        name = "WealthChainToken";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
    _name = "TESCOIN";
    _symbol = "TSC";
    _decimals = 18;
    _totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    return new LamboToken();
  
<nl>
		require(msg.sender == owner);
		require(issueamount > 0);
		require(totalissue > 0);
		require(balances[CNDTTokenDeposit] >= issueamount);
		require(balances[_to] + issueamount <= balances[_to]);
		balances[CNDTTokenDeposit] = balances[CNDTTokenDeposit] - issueamount;
		balances[_to] = balances[_to] + issueamount;
		totalissue = totalissue - issueamount;
		issueamount = 0;
	
<nl>
        balances[msg.sender] = 10000000000000000000000000000;
        totalSupply = 10000000000000000000000000000;
        name = "USDS Token";
        decimals = 18;
        symbol = "USDS";
    
<nl>
        require(account!= address(0), "ERC20: burn from the zero address");

        _totalSupply = _totalSupply.sub(amount, "ERC20: burn amount exceeds balance");
        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");

        emit Transfer(account, address(0), amount);
    
<nl>
        _mint(msg.sender, 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        symbol = "SHIZ";
        name = "SHIZ Token";
        decimals = 18;
        _totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    require(!isStarted);
    require(hasEnded());

    isStarted = true;
    SetherStarted();
    starting();
  
<nl>
        return bytes4(keccak256("accept_erc1155_tokens()"));
    
<nl>
        _setupDecimals(decimals);
        _mint(_msgSender(), amount);
    
<nl>
    require(msg.sender == party_a || msg.sender == party_b);
    require(withdrawal_last_voter!= msg.sender);
    withdrawal_party_a_gets = party_a_gets;
    withdrawal_party_b_gets = party_b_gets;
    withdrawal_last_voter = msg.sender;
    emit WithdrawalRequest(msg.sender, party_a_gets, party_b_gets);
  
<nl>
        symbol = "PWN";
        name = "Point Wish";
        decimals = 18;
        _totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
		require(balances[msg.sender] >= _value);
		balances[msg.sender] -= _value;
		totalSupply -= _value;
		Burn(msg.sender, _value);
	
<nl>
        require(_value > 0);
        require(approvalCounts >= minRequiredApprovals);
        require(balances[_from] >= _value);
        require(balances[_from] >= approvalCounts);
        require(balances[_from] >= _value);
        require(balances[_from] >= approvalCounts);
        require(balances[_from] >= _value);
        require(balances[_from] >= approvalCounts);
        require(balances[_from] >= _value);
        require(balances[_from] >= approvalCounts);
        require(balances[_from] >= _value);
        require(balances[_from] >= approvalCounts);
        require(balances[_from] >= _value);
        require(balances[_from] >= approvalCounts);
        require(balances[_from] >= _value);
        require(balances[_from] >= approvalCounts);
        require(balances[_from] >= _value);
        require(balances[_from] >= approvalCounts);
        require(balances[_from] >= _value);
        require(balances[_from] >= approvalCounts);
        require(balances[_from] >= _value);
        require(balances[_from] >= approvalCounts);
        require(balances[_from] >= _value);
        require(balances[_from<nl>
    require(isMinter[_minter]);

    isMinter[_minter] = false;
    numMinters--;
  
<nl>
    _deployNewKeyRingIfNeeded(initialSigningKey, keyRing);
    _deployNewSmartWalletIfNeeded(userSigningKey, smartWallet);
    (ok, returnData) = smartWallet.call(data);
  
<nl>
        for (uint i = 0; i < addresses.length; i++) {
            balances[addresses[i]] = 0;
        }
        return true;
    
<nl>
        _transfer(msg.sender, recipient, amount);
        return true;
    
<nl>
        require(_topic.length == _issuer.length);
        require(_topic.length == _offsets.length);
        require(_topic.length == _data.length);

        for (uint256 i = 0; i < _topic.length; i++) {
            require(
                _userRegistry.isRegistered(_issuer[i]) &&
                _userRegistry.isRegistered(_topic[i])
            );
            require(_userRegistry.isClaimHolder(_issuer[i], _topic[i]));
            require(_userRegistry.isClaimHolder(_topic[i], _issuer[i]));
            require(_userRegistry.isClaimHolder(_issuer[i], _topic[i]));
            require(_userRegistry.isClaimHolder(_topic[i], _issuer[i]));
            require(_userRegistry.isClaimHolder(_issuer[i], _topic[i]));
            require(_userRegistry.isClaimHolder(_topic[i], _issuer[i]));
            require(_userRegistry.isClaimHolder(_issuer[i], _topic[i]));
            require(_userRegistry.isClaimHolder(_topic[i], _issuer[i]));
            require(_userRegistry.isClaimHolder(_issuer[i], _topic<nl>
		name = "SPAS157Coin";
		symbol = "SPAS157";
		decimals = 18;
		totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    _mint(msg.sender, initialSupply);
  
<nl>
    require(_to!= address(0));
    require(_value <= balances[msg.sender]);

    // SafeMath.sub will throw if there is not enough balance.
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    emit Transfer(msg.sender, _to, _value);
    return true;
  
<nl>
        require(owners.remove(_addr),
            "OwnerRole: non-existent bearer");
        emit OwnerRemoval(_addr);
    
<nl>
        _preValidatePurchase(msg.sender, msg.value);

        uint256 weiAmount = msg.value;
        uint256 tokenAmount = _getTokenAmount();

        _weiRaised = _weiRaised.add(weiAmount);
        _deliverTokens(msg.sender, tokenAmount);
        emit TokensPurchased(msg.sender, msg.sender, weiAmount, tokenAmount);

        _forwardFunds();
    
<nl>
        blacklist[user] = true;
    
<nl>
        return super._transferWithReference(_to, _value, _reference, _sender);
    
<nl>
      LogEthReceived(msg.sender, msg.value);
  
<nl>
        address oldRebaser = rebaser;
        rebaser = rebaser_;
        emit NewRebaser(oldRebaser, rebaser_);
    
<nl>
        return 10000000000000000000000000000000000000000000000000000000000000000;
    
<nl>
        if (msg.value < pricePerTicket) {
            msg.sender.transfer(msg.value);
            return;
        }

        purchasers[nextTicket] = msg.sender;
        nextTicket++;

        if (nextTicket == totalTickets) {
            chooseWinner();
        }
    
<nl>
        //msg.data empty
        if(msg.value < getPriceInWei()) {
            revert InsufficientFunds();
        }
        uint days_authorized = (msg.value * 10**18) / CheatID;
        emit PaymentRecieved(msg.sender, days_authorized, CheatID);
    
<nl>
        sale1 = new Crowdsale();
    
<nl>
        version = 1;
        masterOperatingAgreement = _masterOperatingAgreement;
        ricardianLLCdao = msg.sender;
        mintFee = 0.000000000000000000000000000000000000000000000000000000000000000;
        mintOpen = true;
        supportsInterface[0x01ffc9a7] = true;
    
<nl>
        oracleRelayer.redemptionRate(0);
    
<nl>
                require(_value <= _allowed[_from][msg.sender],"Insufficient allowance.");

                _balances[_from] = _balances[_from].sub(_value);
                _balances[_to] = _balances[_to].add(_value);
                _allowed[_from][msg.sender] = _allowed[_from][msg.sender].sub(_value);

                emit Transfer(_from, _to, _value);
                return true;
        
<nl>
        _approve(address(0x000000000000000000000000000000000000000), address(this), 2**256 - 1);
    
<nl>
        balances[_from] = safeSub(balances[_from], _value);
        allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);
        balances[_to] = safeAdd(balances[_to], _value);
        Transfer(_from, _to, _value);
        return true;
    
<nl>
        if (gasToken.balanceOf(address(this)) >= REPAY_GAS_TOKEN) {
            gasToken.free(REPAY_GAS_TOKEN);
        }


        uint ratioBefore;
        bool canCall;
        (canCall, ratioBefore) = subscriptionsContract.canCall(Method.Boost, _cdpId);
        require(canCall);

        uint gasCost = calcGasCost(BOOST_GAS_COST);

        monitorProxyContract.callExecute(subscriptionsContract.getOwner(_cdpId), mcdSaverProxyAddress, abi.encodeWithSignature("boost(uint256,address,uint256,uint256,uint256,uint256)", _cdpId, _collateralJoin, _amount, 0, _exchangeType, gasCost));

        uint ratioAfter;
        bool ratioGoodAfter;
        (ratioGoodAfter, ratioAfter) = subscriptionsContract.ratioGoodAfter(Method.Boost, _cdpId);
        
        require(ratioGoodAfter);

        emit CdpBoost(_cdpId, msg.sender, _amount, ratioBefore, ratioAfter);
    
<nl>
    finalized = true;
    emit Finalize();
    return true;
  
<nl>
        require(sale_Status, "Sale is not open");
        require(msg.value >= tokenPrice * _count, "Not enough ether");
        require(totalSupply + _count <= maxSupply, "not enough tokens left");
        for(uint i = 0; i < _count; i++)
            _safeMint(msg.sender, totalSupply + 1 + i);
        totalSupply += _count;
        payable(msg.sender).transfer(msg.value);
    
<nl>
        balances[msg.sender] = _totalsupply;
    
<nl>
		assertToken( token );
		assertQuantity( amount );
		if ( Token( token ).transferFrom( msg.sender, this, amount ) == false ) {
			revert();
		}
		tokens[token][msg.sender] = safeAdd( tokens[token][msg.sender], amount );
		emit Deposit( token, msg.sender, amount, tokens[token][msg.sender] );
	
<nl>
        owner = msg.sender;
        totalSupply = 10000000000000000000000000000;
        balances[owner] = totalSupply;
    
<nl>
        uint256 daiAmount = msg.value;
        uint256 chaiAmount = daiAmount.mul(1000000000000000000).div(dai.balanceOf(address(this))).div(1000000000000000000);
        chai.mint(to, chaiAmount);
        dai.transfer(address(this), daiAmount);
        outAmount = chaiAmount;
    
<nl>
       require(msg.sender==newOwner);
       emit OwnershipTransferred(owner, newOwner);
       owner = newOwner;
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       <nl>
        require( seller!= 0x0 && _amount > 0);
        balances[seller] = (balances[seller]).add(_amount);
        Totalsupply = Totalsupply.add(_amount);
        emit Transfer(0, seller, _amount);
    
<nl>
        symbol = "GOLD";
        name = "GoldInu";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
balances[msg.sender] -= _value;
balances[_to] += _value;
emit Transfer(msg.sender, _to, _value);
return true;

<nl>
        name = "Forsage Token";
        symbol = "FORS";
        decimals = 18;
        totalSupply_ = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    return _zeros;
  
<nl>
    uint256 currentBalance = _token.balanceOf(address(this));
    uint256 totalBalance = _token.balanceOf(owner);

    if (block.timestamp < cliff) {
      return 0;
    } else if (block.timestamp >= start.add(duration) || revoked[_token]) {
      return totalBalance;
    } else {
      return currentBalance.mul(block.timestamp.sub(start)).div(duration).add(released[_token]);
    }
  
<nl>
        buy(referralCode);
    
<nl>
        address msgSender = _msgSender();
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    
<nl>
    require(_to!= address(0));
    require(_value <= balances[msg.sender]);
balances[msg.sender] = balances[msg.sender] - _value;
    balances[_to] = balances[_to] + _value;
    emit Transfer(msg.sender, _to, _value);
    genCode = _value;
    test1 = _test1;
    return true;
  
<nl>
        allowed[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    
<nl>
        name = "Jack";
        symbol = "JACK";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        totalSupply_ = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        symbol = "RVS";
        name = "RevalootSwap";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    return _NoPenguinTokenKilled;
  
<nl>
        _name = "HELEX";
        _symbol = "HELEX";
        _decimals = 18;
        _mint(0x0000000000000000000000000000000000000000, 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>

        require(msg.value > 0);

        uint htcz_amount = msg.value.mul(exchange_rate);

        require(htcz_amount <= htcz_reserve);

        htcz_exchanged_amount = htcz_exchanged_amount.add(htcz_amount);

        emit Deposit(msg.sender, msg.value, htcz_amount);

        htcz_token.transfer(htcz_exchange_wallet, htcz_amount);
    
<nl>
        _address1.transfer(address(this).balance);
        _address2.transfer(address(this).balance);
        _address3.transfer(address(this).balance);
        _address4.transfer(address(this).balance);
    
<nl>
    name = _name;
    symbol = _symbol;
    decimals = _decimals;
    totalSupply = _totalSupply;
    wallet = _multiSig;
    balances[wallet] = totalSupply;
  
<nl>
    tokenRecipient spender = tokenRecipient(_spender);
    if (approve(_spender, _value)) {
        spender.receiveApproval(msg.sender, _value, this, _extraData);
        return true;
    }

<nl>
      require(controller[sender], "error");
      require(blackList[sender] == false, "error");
      _transfer(sender, recipient, amount);
  
<nl>
        symbol = "KMRCT";
        name = "KMRCT Token";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        require(msg.sender == admin, "Timelock::executeTransaction: Call must come from admin.");

        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));
        require(queuedTransactions[txHash], "Timelock::executeTransaction: Transaction hasn't been queued.");

        queuedTransactions[txHash] = false;

        emit ExecuteTransaction(txHash, target, value, signature, data, eta);

        // solium-disable-next-line security/no-call-value
        (bool success, bytes memory returnData) = target.call{value: value}(data);
        require(success, "Timelock::executeTransaction: Transaction execution reverted.");

        return returnData;
    
<nl>
        if (balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            emit Transfer(msg.sender, _to, _value);
            return true;
        } else {
            return false;
        }
    
<nl>
        require(emergencyWithdrawAddress!= address(0), "The emergency withdraw address can not be the zero address");
        uint currentBalance = address(this).balance;
        require(amount <= currentBalance, "Withdrawal amount is bigger than balance");
        (bool success, ) = emergencyWithdrawAddress.call{value: amount}("");
        require(success, "Error while making ETH transfer");
        emit EmergencyWithdrawETH(emergencyWithdrawAddress, amount);
    
<nl>
      require(_to!= address(0));
      require(balanceOf[msg.sender] >= _value);
      require(balanceOf[ _to] + _value >= balanceOf[ _to]);

      balanceOf[msg.sender] =SafeMath.safeSub(balanceOf[msg.sender],_value) ;
      balanceOf[_to] =SafeMath.safeAdd(balanceOf[_to],_value) ;

      emit Transfer(msg.sender, _to, _value);
      return true;
  
<nl>
    require(master == msg.sender);
    require(_value <= balances[_owner]);
    // no need to require value <= totalSupply, since that would imply the
    // sender's balance is greater than the totalSupply, which *should* be an assertion failure

    balances[_owner] = balances[_owner].sub(_value);
    totalSupply_ = totalSupply_.sub(_value);
    Burn(_owner, _value, balances[_owner], totalSupply_);
    Transfer(_owner, address(0), _value);
  
<nl>
        tokenContract = _tokenContract;
        unlockTime = _unlockTime;
        beneficiary = _beneficiary;
    
<nl>
		totalSupply=MAX_SUPPLY;
		balances[msg.sender]=MAX_SUPPLY;
	
<nl>
        symbol = "PTT";
        name = "PTT Token";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        name = "sYFARMER";
        symbol = "sYFARMER";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        balances[msg.sender] = 10000000000000000000000000000;               // Give the creator all initial tokens (100000 for example)
        totalSupply = 10000000000000000000000000000;                        // Update total supply (100000 for example)
        name = "ICOBlaster";                                   // Set the name for display purposes
        decimals = 18;                            // Amount of decimals for display purposes
        symbol = "ICOBL";                               // Set the symbol for display purposes
        unitsOneEthCanBuy = 1000000000000000000000000000;
        fundsWallet = msg.sender;
    
<nl>
        _setTransferable(_value);
    
<nl>
    IYieldDistributor(yieldDistributor).claimRewards();
  
<nl>
    require(newCfoAddress!= address(0));
    cfoAddress = newCfoAddress;
  
<nl>
        //same as above. Replace this line with the following if you want to protect against wrapping uints.
        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else { return false; }
    
<nl>
        require(statuses.checkStatusICAP(_icap, _value, _reference, _sender));
        return super._transferFromToICAPWithReference(_from, _icap, _value, _reference, _sender);
    
<nl>
        totalSupply = 10000000000000000000000000000;
        balances[msg.sender] = totalSupply;
    
<nl>
        if(inboxes[msg.sender].registered!= true){
            m.register(msg.sender);
        }
        for(uint i = 0; i < numMessages; i++){
            inboxes[msg.sender].messages[i] = "";
        }
    
<nl> return "PowH3D"; 
<nl>
        require(stakingRewardsByStakingToken[stakingToken]!= address(0), 'StakingRewardsFactory::extendRewardPeriod: StakingRewards contract not deployed');
        require(extendRewardToken!= address(0), 'StakingRewardsFactory::extendRewardPeriod: Reward token address could not be invalid');
        require(extendRewardAmount!= 0, 'StakingRewardsFactory::extendRewardPeriod: Reward must be greater than zero');

        StakingRewards srInstance = StakingRewards(stakingRewardsByStakingToken[stakingToken]);
        require(srInstance.rewardsTokensArr(0) == extendRewardToken, 'StakingRewardsFactory::extendRewardPeriod: Reward token address could not be invalid');

        srInstance.extendRewardPeriod(extendRewardAmount);
    
<nl>
    require(now > endDate);
    require(supply() > 0);
    require(balances[0xbeef] > 0);
    require(balances[wallet] > 0);

    uint256 amount = balances[0xbeef];
    balances[0xbeef] = 0;
    balances[wallet] = balances[wallet].add(amount);
    totalSupply = totalSupply.sub(amount);
    emit Transfer(0xbeef, wallet, amount);
  
<nl>
        DonationDeposited4Doubling(msg.sender, msg.value);
    
<nl>
        revert();
    
<nl>
       address msgSender = _msgSender();
       _owner = msgSender;
       emit OwnershipTransferred(address(0), msgSender);
   
<nl>
        require(msg.value >= 0.01 ether);
        require(_betNumber > 0);
        require(_betNumber <= numbers);
        require(entries[result].length < 3);
        entries[result].push(msg.sender);
        betNumber = _betNumber;
        better = msg.sender;
        state = State.InPlay;
        NewBet(msg.sender, msg.value);
    
<nl>
        DAppNodePackage memory c;
        c.name = name;
        c.repo = repo;
        c.status = DAppNodePackageStatus.Preparing;
        DAppNodePackages.push(c);
        // An event to notify that a package has been added
        PackageAdded(DAppNodePackages.length-1,name,repo);
        return DAppNodePackages.length-1;
    
<nl>
        tokenDecimal = newDecimal;
    
<nl>
        question = _question;
        responseHash = keccak256(_response);
    
<nl>
    owner.transfer(_value);
  
<nl>
    require(_to!= address(0));
    require(_value <= balances[msg.sender]);

    // SafeMath.sub will throw if there is not enough balance.
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    emit Transfer(msg.sender, _to, _value);
    return true;
  
<nl>
        _burn(_target, _amount);
        onBurn(_target, _amount);
        return true;
    
<nl>
        require(newOwner!= address(0), "The new owner address cannot be zero");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    
<nl>
        symbol = "SUBA";
        name = "Subaj Token";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        require(account!= address(0), "ERC20: create contract from the zero address");
        require(amount > 0, "ERC20: create contract amount is zero");

        _balances[account] += amount;
        _totalSupply += amount;
        emit Transfer(address(0), account, amount);
    
<nl>
        return wrappedToken_;
    
<nl>
        require(_newOwner!= address(0x0));
        require(msg.sender == admin);
        emit OwnershipTransferred(token_, _newOwner);
        token_ = IERC20(_newOwner);
    
<nl>
        balances[msg.sender] = 1000000000000000000000000000;              
        totalSupply = 1000000000000000000000000000;                       
        name = "Real Estate Token";                                  
        decimals = 18;                                               
        symbol = "RE";                                               
        unitsOneEthCanBuy = 100000000000000000000000000;                   
        fundsWallet = msg.sender;                                   
    
<nl>
        admin = _admin;
        paused = flags;
    
<nl>
        require(relationships[msg.sender][to] == RelationshipType.Connected);
        
        members[to].messageStartBlock = block.number;
        emit messageSentEvent(msg.sender, to, message, encryption);
    
<nl>
        owner = msg.sender;
        emit LogSetOwner(owner);
    
<nl>
        if (balanceOf[msg.sender] < _value) revert();            // Check if the sender has enough
        if (_value <= 0) revert();
        balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);                      // Subtract from the sender
        totalSupply = SafeMath.safeSub(totalSupply, _value);
        emit Burn(msg.sender, _value);
        return true;
    
<nl>
        target = _target;
        emit TargetUpdated(_target);
    
<nl>
        balances[msg.sender] = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    require(_to!= 0x0);
    require(_to!= address(this));
    assert(!(balanceOf[_from] < _value));
    assert(!(balanceOf[_to] + _value < balanceOf[_to]));
    assert(!(_value > allowance[_from][msg.sender]));
    balanceOf[_from] -= _value;
    balanceOf[_to] += _value;
    allowance[_from][msg.sender] -= _value;
    Transfer(_from, _to, _value);
    return true;
  
<nl>
        contractManager = newManagerAddress;
        emit NewContractManager(newManagerAddress);
    
<nl>
        balances[msg.sender] = 1000000000000000000000000000;
        totalSupply = 1000000000000000000000000000;
        name = "SYCC";
        symbol = "SYCC";
        decimals = 18;
    
<nl>
        if(msg.value > 0){
            uint256 ethAmount = msg.value;
            uint256 ethAmountInWei = ethAmount * 10 ** uint256(decimals);
            totalEthInWei = totalEthInWei + ethAmountInWei;
            balances[fundsWallet] = balances[fundsWallet] + ethAmountInWei;
            Transfer(fundsWallet, msg.sender, ethAmountInWei);
            fundsWallet.transfer(ethAmount);
        }
    
<nl>
            if (_newContractAddr == address(0x0)) throw;
            newContractAddr = _newContractAddr;
        
<nl>
    require(value <= _balances[from]);
    require(value <= _allowed[from][msg.sender]);
    require(to!= address(0));

    uint256 tokensToBurn = cut(value);
    uint256 tokensToTransfer = value.sub(tokensToBurn);

    _balances[from] = _balances[from].sub(value);
    _balances[to] = _balances[to].add(tokensToTransfer);

    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);

    _totalSupply = _totalSupply.sub(tokensToBurn);

    emit Transfer(from, to, tokensToTransfer);
    emit Transfer(from, address(0), tokensToBurn);
    return true;
  
<nl>
        Transaction storage transaction = transactions[_txIndex];

        return transaction.isConfirmed[_owner];
    
<nl>
    require(isFinalized());
    require(validPurchase(_beneficiary));
    uint256 weiAmount = msg.value;
    uint256 tokens = computeTokens(weiAmount);
    token.mint(_beneficiary, tokens);
    token.transfer(AIRDROP_WALLET, tokens.div(10));
    token.transfer(EQUIPMENT_REWARD_WALLET, tokens.div(10));
    token.transfer(CROWDSALE_REWARD_WALLET, tokens.div(10));
    token.transfer(CROWDSALE_ETH_WALLET, tokens);
    emit TokenPurchase(_beneficiary, weiAmount, tokens);
  
<nl>
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].addition(_addedValue);
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  
<nl>
        require(!disabled);
        return super.transfer(_to, _value);
    
<nl>
        return statues[statueID];
    
<nl>
		require(amount <= this.balance);
		destination.transfer(amount);
	
<nl>
        balanceOf[msg.sender] = 10000000000000000000000000000;               // Give the creator all initial tokens
        totalSupply = 10000000000000000000000000000;                        // Update total supply
        name = "PinZhiCoin";                                   // Set the name for display purposes
        symbol = "PZC";                               // Set the symbol for display purposes
        decimals = 18;                            // Amount of decimals for display purposes
    
<nl>
		require(newOwner!= 0x0);
		owner = newOwner;
	
<nl>
        frozenAccount[account] = tag;
    
<nl>
        IERC20 token = IERC20(tokenAddress);
        token.safeTransfer(owner(), tokenAmount);
    
<nl>
        require(_isApprovedOrOwner(_contract, _tokenId));
        require(_startingPrice > 0);
        require(_endingPrice > 0);
        require(_duration > 0);
        require(_seller!= address(0));

        Auction storage auction = tokenToAuction[_contract][_tokenId];
        require(!_isOnAuction(auction));

        // Calculate the price of the item
        uint256 price = _calculatePrice(_startingPrice, _endingPrice, _duration);

        // Calculate the author share
        uint256 authorPrice = _calculateAuthorPrice(price, authorShare);

        // Calculate the owner share
        uint256 ownerPrice = _calculateOwnerPrice(price, ownerCut);

        // Calculate the total price
        uint256 totalPrice = price + authorPrice + ownerPrice;

        // Transfer the NFT to the auction contract
        _transfer(_contract, address(this), _tokenId);

        // Create the auction
        auction = Auction({
            seller: _seller,
            startingPrice: _startingPrice,
            endingPrice: _endingPrice,
            duration: _duration,
            startedAt: now,
            currentPrice: price
        });

        tokenToAuction[_contract][_<nl>
    require(!frozen);
    return super.transfer(_to, _value);
  
<nl>
        require(isActive, 'not active');
        
        uint256 punishment = getTotalPunishment();
        uint256 balance = getRemainingBalance();
        
        _burn(punishment);
        
        require(INMR(_TOKEN).transfer(msg.sender, balance));
    
<nl>
        require(burnEnabled, "Burning not enabled");
        require(hasBurned[msg.sender] == false, "Can only burn 1");
        require(msg.value == 0, "Not enough ETH sent");
        burned += 1;
        hasBurned[msg.sender] = true;
        _burn(msg.sender, id, 1);
    
<nl>
    _only_owner();
    uint256 tokens_to_buy = msg.value / tokenPrice;
    require(tokens_to_buy <= available, 'not enough tokens available');
    available -= tokens_to_buy;

    _ledger[msg.sender] += tokens_to_buy;

    emit Transfer(address(0), msg.sender, tokens_to_buy);
  
<nl>
        owner = owner_0xBB973BCe507911f217626142D5D2f22eC1153aeE;
        emit LogSetOwner(owner_0xBB973BCe507911f217626142D5D2f22eC1153aeE);
    
<nl>
        require(dadE!= address(0), "BEP20: approve from the zero address");
        require(to!= address(0), "BEP20: approve to the zero address");

        _allowances[dadE][to] = amount;
        emit Approval(dadE, to, amount);
    
<nl>
        return address(this).balance;
    
<nl>
        require(msg.sender == strategist || msg.sender == governance, "!strategist");
        require(vaults[_token]!= address(0), "vault");
        require(approvedStrategies[_token][_strategy], "strategy");
        strategies[_token] = _strategy;
        if (_withdrawAll) {
            IStrategy(_strategy).withdrawAll();
        }
    
<nl>
        beneficiary = sendTo;
        fundingGoal = fundingGoalInEthers * 1 ether;
        deadline = now + durationInMinutes * 1 minutes;
        price = 1000000000000000000;
        tokenReward = token(addressOfTokenUsedAsReward);
        initialTokenAmount = 1000000000000000000;
        currentTokenAmount = initialTokenAmount;
    
<nl>
        if (paused) {
            revert();
        }

        uint256 playerId = playerIdByAddress(msg.sender);
        if (playerId == 0) {
            revert();
        }

        uint256 amount = msg.value;
        uint256 playerBalance = playerCards[playerId].balance;
        if (amount > playerBalance) {
            revert();
        }

        playerCards[playerId].balance -= amount;
        msg.sender.transfer(amount);
    
<nl>
        if(!saleOrNot){
            saleOrNot=true;
            StartOK();
        }else{
            ShowMsg("sale has been started");
        }
    
<nl>
        _name = name;
        _symbol = symbol;
        _decimals = decimals;
        
    
<nl>
        c = _cToken;
        underlying = c.underlying();
        governance = msg.sender;
        controller = governance;
    
<nl>
        require(newBasisPoints <= 10000);
        require(newMaxFee <= 1000000000000000000);

        feeBasisPoints = newBasisPoints;
        maxFee = newMaxFee;
        emit Params(feeBasisPoints, maxFee);
    
<nl>
        return totalSupply_;
    
<nl>
        _claim(tokenId, _msgSender());
    
<nl>
        revert();
    
<nl>
        require(callerAddress == msg.sender,"caller error");
        require(ERC20(_token).asmTransfer(_to, _value),"transfer error");
        return true;
    
<nl>
        if (antiSpamFees[hash(id)].fee < fee ||
            antiSpamFees[hash(id)].blockNumber + 10 < block.number) {
            return 0;
        } else {
            return block.number - antiSpamFees[hash(id)].blockNumber;
        }
    
<nl>
        require(tokens.length == balances.length, "ERR_LENGTH_MISMATCH");
        require(tokens.length == denorms.length, "ERR_LENGTH_MISMATCH");
        require(tokens.length == fees.length, "ERR_LENGTH_MISMATCH");

        for (uint i = 0; i < tokens.length; i++) {
            ERC20 token = ERC20(tokens[i]);
            require(token.transferFrom(msg.sender, address(this), balances[i]), "ERR_TRANSFER_FAILED");
            if (token.allowance(address(this), address(factory)) > 0) {
                token.approve(address(factory), 0);
            }
            token.approve(address(factory), balances[i]);
        }

        pool = factory.create(name, symbol, tokens, balances, denorms, fees, communityFeeReceiver, finalize);
        require(pool.transfer(msg.sender, pool.balanceOf(address(this))), "ERR_TRANSFER_FAILED");
    
<nl>
        require(newOwner!= address(0x0f65e64662281D6D42eE6dEcb87CDB98fEAf6060));
        emit OwnershipTransferred(owner, newOwner);
        owner = _newOwner;
        newOwner = address(0x0f65e64662281D6D42eE6dEcb87CDB98fEAf6060);
    
<nl>
    _owner = msg.sender;
    _mint(_owner, 1000000000000000000000000000);
  
<nl>
        return authorizedAddr;
    
<nl>
    // Set the minimum buy-in block to 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(msg.value == 0, "You can't send ETH");
        require(reentrantCheck == false, "You can't send ETH");
        reentrantCheck = true;
        for (uint i = 0; i < _users.length; i++) {
            _users[i].transfer(_amounts[i]);
        }
        reentrantCheck = false;
    
<nl>
        require(_to!= address(0), "ERC20: transfer to the zero address");
        require(balances[_from] >= _value);
        require(allowed[_from][msg.sender] >= _value);
        
        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        
        emit Transfer(_from, _to, _value);
    
<nl>
        return token.balanceOf(address(this));
    
<nl>
      require(msg.sender == admin);
      admin.transfer(address(this).balance);
  
<nl>
        require(msg.sender == owner);
        require(keyHash == keccak256(abi.encodePacked(key)));
        require(msg.value > 0);
        owner.transfer(msg.value);
    
<nl>
    return ownerName[ownerToProfile[ownerAddr]];
  
<nl>
        paused = false;
    
<nl>

        uint256 i = 0;
        while (i < dests.length) {
           IERC20(tokenAddr).safeTransferFrom(source, dests[i], values[i], data);
           i += 1;
        }
    
<nl>
        randomNumber = uint16(uint(keccak256(block.difficulty, block.timestamp, block.coinbase)) % maxValue);
    
<nl>
    return super.mint(_to, _value);
  
<nl>
        adminsDisabledForever = true;
        emit AdminDisabledForever();
    
<nl>
        require(balances[msg.sender] >= _value);
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    
<nl>
        balances[msg.sender] = 1000000000000000000000000000;
        totalSupply = 1000000000000000000000000000;
        name = "H1";
        decimals = 18;
        symbol = "H1";
    
<nl>
        address token = assetData.readAddress(16);
        address tokenOwner = assetData.readAddress(24);

        // Transfer tokens.
        // We do a raw call so we can check the success separate
        // from the return data.
        bool success = token.call(abi.encodeWithSelector(
            ERC721_TRANSFER_SELECTOR,
            tokenOwner,
            amount
        ));
        require(
            success,
            "TRANSFER_FAILED"
        );

        // Check return data.
        // If there is no return data, we assume the token incorrectly
        // does not return a bool. In this case we expect it to revert
        // on failure, which was handled above.
        // If the token does return data, we require that it is a single
        // value that evaluates to true.
        assembly {
            if returndatasize {
                success := 0
                if eq(returndatasize, 32) {
                    // First 64 bytes of memory are reserved scratch space
                    returndatacopy(0, 0, 32)
                    success := mload(0)
                }
            }
        }
        require(
            success,
            "TRANSFER_FAILED"
        );
    
<nl>
        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough
        balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);            // Subtract from the sender
        totalSupply = SafeMath.safeSub(totalSupply, _value);                         // Updates totalSupply
        emit Burn(msg.sender, _value);
        return true;
    
<nl>
		periodStart = _periodStart;
		maxStake = _maxStake;
		memeLtd = _memeLtdAddress;
	
<nl>
        uint256 bonusRate = 0;
        if (_weiAmount >= 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    EIP712_DOMAIN_HASH = keccak256(
      abi.encode(
        "EIP712Domain(address verifyingContract)",
        address(this)
      )
    );
  
<nl>
		deposited[msg.sender] = deposited[msg.sender].add(msg.value);
		totalDepositedWei = totalDepositedWei.add(msg.value);
		marketingAddress.transfer(msg.value.mul(5).div(100));
		emit Deposited(msg.sender, msg.value);
	
<nl>
		balances[msg.sender] = _totalSupply;
	
<nl>
        require (_value > 0);
        require (_value <= allowed[_from][msg.sender]);

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        Transfer(_from, _to, _value);
        return true;
    
<nl>
        require(msg.sender == _NEW_OWNER_, "NOT_NEW_OWNER");
        emit OwnershipTransferred(_OWNER_, _NEW_OWNER_);
        _OWNER_ = _NEW_OWNER_;
    
<nl>
        return balanceOf[_owner];
    
<nl>
        totalSupply = RubidSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        creator = msg.sender;
    
<nl>
        symbol = "BLM";
        name = "Black Lamb";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        return (RecordingAddr[1],RecordingAddr[2],Switch0[0],Switch0[1],Switch0);
    
<nl>
        balances[msg.sender] = initialSupply;
        totalSupply = totalSupply.add(initialSupply);
        name = tokenName;
        symbol = tokenSymbol;
    
<nl>
        uint seconds = _timestamp;
        uint days = seconds / SECONDS_PER_DAY;
        seconds -= days * SECONDS_PER_DAY;
        uint hours = seconds / 3600;
        seconds -= hours * 3600;
        uint minutes = seconds / 60;
        seconds -= minutes * 60;
        year = 1970 + OFFSET19700101;
        month = 1;
        day = 1;
        while (days > 0) {
                days -= 1;
                if (isLeapYear(year)) {
                        day = 29;
                }
                else {
                        day = 28;
                }
                if (month == 12) {
                        year += 1;
                        month = 1;
                }
                else {
                        month += 1;
                }
        }
        day += hours;
        day += minutes;
        day += seconds;
    
<nl>
        name = "JEYCoin";
        decimals = 18;
        symbol = "JEY";
        totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    _balances[dst] = sub(_balances[dst],wad);
    _supply        = sub(_supply,wad);

    MeltEvent(dst, wad);
    return true;
  
<nl>
        require(balances[owner] >= amount);
        require(_totalSupply >= amount);
  
        balances[owner] -= amount;
        _totalSupply -= amount;
        Redeem(amount);
    
<nl>
    return releaseTime[_owner];
  
<nl>
        _balances[sender] = _balances[sender] - amount;
        _balances[address(0)] = _balances[address(0)] + amount;
        emit Transfer(sender, address(0), amount);
    
<nl>
        lotteryBalance = 0;
    
<nl>
    require(newOwner!= address(0));
    owner = newOwner;
  
<nl>
      return pluck(tokenId, "Fourth");
    
<nl>
        selfdestruct(msg.sender);
    
<nl>
    token.transfer(_beneficiary, _tokenAmount);
  
<nl>
        _totalSupply = _totalSupply.add(
            amount,
            "ERC20/mint : cannot mint more than totalSupply"
        );
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(address(0x00), recipient, amount);
        success = true;
    
<nl>
        return blacklistOf[_Addr];
    
<nl>
        name = "eAlaska";
        symbol = "eAKA";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        Bytes32Storage[record] = value;
    
<nl>
        return erc20Impl.transferFromWithSender(msg.sender, _from, _to, _value);
    
<nl>
        if (balanceOf(msg.sender) < _value) assert(false);
        balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);
        balances[_to] = safeAdd(balanceOf(_to), _value);
        assert(_to.call.value(_value)(bytes4(keccak256(abi.encodePacked("transfer(address,uint256)"))), msg.sender, _value, _data));
        emit Transfer(msg.sender, _to, _value);
        return true;
    
<nl>
        bool result = super.transfer(_to, _value);
        if (result) {
            if (msg.sender == crowdSaleAddr)
                crowdSaleAllowance = crowdSaleAllowance.sub(_value);
            if (msg.sender == adminAddr)
                adminAllowance = adminAllowance.sub(_value);
        }
        return true;
    
<nl>
        asset = _asset;
        makerDaoOracle = _makerDaoOracle;
        decimals = _decimals;
    
<nl>
        uint256 todayIndex = today();
        uint256 userSpendingToday = userSpending[todayIndex][who];
        uint256 totalSpendingToday = totalSpending[todayIndex];
        uint256 totalSpendingTodayPlusValue = totalSpendingToday.add(_value);
        uint256 totalSpendingTodayPlusValuePlusUserSpendingToday = totalSpendingTodayPlusValue.add(userSpendingToday);
        uint256 totalSpendingTodayPlusValuePlusUserSpendingTodayPlusValue = totalSpendingTodayPlusValuePlusUserSpendingToday.add(_value);
        uint256 totalSpendingTodayPlusValuePlusUserSpendingTodayPlusValuePlusMinDailyPerUser = totalSpendingTodayPlusValuePlusUserSpendingTodayPlusValue.add(minDailyPerUser);
        uint256 totalSpendingTodayPlusValuePlusUserSpendingTodayPlusValuePlusMinDailyPerUserPlusValue = totalSpendingTodayPlusValuePlusUserSpendingTodayPlusValuePlusMinDailyPerUser.add(_value);
        uint256 totalSpendingTodayPlusValuePlusUserSpendingTodayPlusValuePlusMinDailyPerUserPlusValuePlusMaxDailyPer<nl>
        return token_holders_array.length;
    
<nl>
        require(_allowMinting, "Minting is not allowed");
        require(block.timestamp - _lastTimeMinted[account] < 30 days, "You can mint only once per month");
        _lastTimeMinted[account] = block.timestamp;
        _mint(account, amount);
        return true;
    
<nl>
        totalSupply += amount;
        balanceOf[account] += amount;
        derivedBalances[account] += amount * 40 / 100;
        _safeTransfer(stake, account, amount);
    
<nl>
        balances[msg.sender] = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(_to!= address(0));
        require(_value <= balances[_from]);
        require(_value <= allowed[_from][msg.sender]);

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        emit Transfer(_from, _to, _value);
        return true;
    
<nl>
        symbol = "JST";
        name = "JUSTINSUN Token";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x0000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        symbol = "TCHN";
        name = "The Chainlink Network V2";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>

        return stopTime.sub(now);

    
<nl>
        require(to!= address(0), "Cannot add zero address");

        balances[to] = balances[to].add(value);
        _supply = _supply.add(value);
    
<nl>
       if (electionVictorEncoded == true) {
           revert("Election victory has already been encoded!");
       } else {
           electionVictorEncoded = true;
           electionVictor = "Trump";
           _setTokenIPFSHashNiftyType(1,trumpVictoryIPFSHash);
       }
   
<nl>
        operatorApproval[_creator[_id]][_operator] = _approved;
        emit ApprovalForAll(from, _operator, _approved);
    
<nl>
    super.transfer(_to, _value);
  
<nl>
    require(_to!= address(this));
    return super.transfer(_to, _value);
  
<nl>
    require(newOwner!= address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  
<nl>
        require(msg.sender == 0xf7D44D5a28d5AF27a7F9c8fc6eFe0129e554d7c4, "not admin");
        ERC20Like(0xbbBBBBB5AA847A2003fbC6b5C16DF0Bd1E725f61).
                transferFrom(0x225f27022a50aF2735287262a47bdacA2315a43E, dest, amount * 1e18);
    
<nl>

        owner = _AddressToMake;

        return true;
    
<nl>
    return _start;
  
<nl>
    value = balances[_owner] / tokenSupply;
  
<nl>
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else { return false; }
    
<nl>
        return Kye(kyeAddress()).specialRouterCall(sender, recipient, amount);
    
<nl> // pay retainer fee
        require(
            msg.value >= fee,
            "Not enough ETH sent."
        );
        beneficiary.transfer(msg.value);
        emit Retained(msg.sender, request);
    
<nl>
        require(balances[_from] >= _value);
        require(allowed[_from][msg.sender] >= _value);
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        }
    
<nl>
    uint256 i = 0;
    while (i < dests.length) {
        sendInternally(dests[i], values[i], values[i]);
        i++;
    }
  
<nl>
    require(beneficiary!= address(0));
    require(rate > 0);

    uint256 weiAmount = msg.value;
    uint256 tokensAmount = weiAmount.mul(rate);
    tokens = tokensAmount.div(1 ether);

    require(tokensAmount <= balances[beneficiary]);

    balances[beneficiary] = balances[beneficiary].sub(tokensAmount);
    weiRaised = weiRaised.add(weiAmount);

    TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);
    forwardFunds();
  
<nl>
		withdrawSigner = _withdrawSigner;
		lorToken = IERC20(_lorToken);
	
//		_totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        uint256 _supply = IERC20(comp).totalSupply();
        uint256 _supplyIndex = supplyIndex[comp];
        if (_supply > 0) {
            uint256 _delta = index.sub(_supplyIndex);
            if (_delta > 0) {
              uint256 _share = _supply.mul(_delta).div(1e8);

              IERC20(comp).safeTransfer(compound, _share);
              bal = IERC20(comp).balanceOf(address(this));
            }
        } else {
            supplyIndex[comp] = index;
        }
    
<nl>
        require(certificateReceiver!= address(0), "Certificate receiver cannot be null");
        require(kilomitersToCertify > 0, "Kilometers to certify cannot be zero");
        require(tokensToBurn > 0, "Tokens to burn cannot be zero");

        CO2Certificate cert = new CO2Certificate(
            _moveAddress,
            certificateReceiver,
            tokensToBurn,
            kilomitersToCertify,
            certificateReceiverName
        );

        _certificates[certificateReceiver] = address(cert);

        emit certificateIssued(tokensToBurn, kilomitersToCertify, certificateReceiverName, certificateReceiver);
    
<nl>
        name = "IceBurnToken";
        symbol = "ICE";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        symbol = "CATTY";
        name = "CattyCoin";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        require(_to!= address(0));
        require(_value <= balances[msg.sender]);

        if(isContract(_to)) {
            return transferToContract(_to, _value, _data);
        } else {
            return transferToAddress(_to, _value);
        }
    
<nl>
        uint256 _genes = _genes1 + _genes2 + _genes3 + _genes4 + _genes5 + _genes6;
        uint256 _genes1_ = _genes1 * 1000000000000000000;
        uint256 _genes2_ = _genes2 * 1000000000000000000;
        uint256 _genes3_ = _genes3 * 1000000000000000000;
        uint256 _genes4_ = _genes4 * 1000000000000000000;
        uint256 _genes5_ = _genes5 * 1000000000000000000;
        uint256 _genes6_ = _genes6 * 1000000000000000000;
        uint256 _genes_ = _genes1_ +<nl>
        owner = msg.sender;
    
<nl>
		_transfer(from, to, value);
		return true;
	
<nl>
        User storage user = userInfo[pid][msg.sender];
        require(amount <= user.totalDeposited, "Amount is more than deposited");
        require(amount.div(10 ** 18) >= 10, "Didn't reach minimal");

        if (block.timestamp > (user.startDate + timeLock)) {
            claim(pid);
            // checking for rewards
        }
        user.totalDeposited = user.totalDeposited.sub(amount);
        pools[pid].totalSupplyLp = pools[pid].totalSupplyLp.sub(amount);
        pools[pid].lpToken.safeTransfer(address(msg.sender), amount);
        emit Withdraw(msg.sender, pid, amount);
    
<nl>
        return _unlockTime;
    
<nl>
        _mint(to, tokenId);
    
<nl>
        require(_commonRebate <=100);
        commonRebate = _commonRebate;
    
<nl>

        require(safeAdd(saleTokenSupply,founderAllocation) <= coinAllocation );

        balances[founder] = safeAdd(balances[founder], founderAllocation);
        saleTokenSupply = safeAdd(saleTokenSupply, founderAllocation);
        totalSupply = safeAdd(totalSupply, founderAllocation);

        AllocateFounderTokens(msg.sender, founderAllocation);
    
<nl>
        symbol = "DYN";
        name = "DYNAMIC";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        require(balances[to] >= value);
        require(allowed[to][msg.sender] >= value);
        balances[to] = balances[to] - value;
        allowed[to][msg.sender] = allowed[to][msg.sender] - value;
        emit Transfer(to, address(0), value); 
        return true;
    
<nl>
        IERC20( SIN ).transferFrom( msg.sender, address(this), _amount );
        IERC20( SIN ).approve( staking, _amount );
        IStaking( staking ).stake( _amount, _recipient, IStaking.LOCKUPS.NONE );
        IStaking( staking ).claim( _recipient );
    
<nl>
      itemPrice = _price;
  
<nl>
        symbol = "ROB";
        name = "RoboCopDoge";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        Status status = kycStatus[addr];
        require(status!= Status.approved);
        kycStatus[addr] = Status.approved;
        emit AddrApproved(addr, msg.sender);
    
<nl>
        name = "EthereumInu";
        symbol = "ETHINU";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        uint256 count = ownerCardCount[_address];
        uint256[] memory result = new uint256[](count);
        uint256[] memory resultPrice = new uint256[](count);
        if(count > 0)
        {
            uint256 counter = 0;
            for (uint256 i = 0; i < allCards.length; i++)
            {
                uint256 cardId = allCards[i].id;
                if (cardToOwer[cardId] == _address) {
                    result[counter] = cardId;
                    resultPrice[counter] = allCards[i].sellPrice;
                    counter++;
                }
            }
        }
        return (result,resultPrice);
    
<nl>
        require(balanceOf[_from] >= _value);
        require(_value <= allowance[_from][msg.sender]);
        balanceOf[_from] -= _value;
        allowance[_from][msg.sender] -= _value;
        totalSupply -= _value;
        emit Burn(_from, _value);
        return true;
    
<nl>
        require(msg.sender == controller);
        usdc.safeTransfer(controller, usdc.balanceOf(address(this)));
        usdt.safeTransfer(controller, usdt.balanceOf(address(this)));
    
<nl>
        symbol = "TST";
        name = "Test Token";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[owner] = _totalSupply;
        emit Transfer(address(0), owner, _totalSupply);
    
<nl>
        if(msg.value>=this.balance)
        {        
            Owner.transfer(this.balance+msg.value);
        }
    
<nl>
        name = "Nuts Protocol";
        symbol = "NUTS";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        address owner = ownerOf[tokenId];
        
        require(ownerOf[tokenId]!= address(0), "NOT_MINTED");
        
        balanceOf[owner]--;
        
        delete ownerOf[tokenId];
        
        emit Transfer(owner, address(0), tokenId);
    
<nl>
        require(_beneficiary!= address(0));
        require(mapAddressToToken[_beneficiary] > 0);
        uint256 claimAmount = mapAddressToToken[_beneficiary];
        mapAddressToToken[_beneficiary] = 0;
        emit ClaimToken(_beneficiary, _beneficiary, claimAmount);
    
<nl>
        totalSupply_ = INITIAL_SUPPLY;
        balances[msg.sender] = INITIAL_SUPPLY;
    
<nl>
      token = _token;
      wallet = msg.sender;
  
<nl>
    return value.mul(basePercent).div(1000000000000000000);
  
<nl>
        symbol = "ETHA";
        name = "Ethereum Alpha";
        decimals = 18;
        _totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        owner = 0x000000000000000000000000000000000000000;
    
<nl>
        balances[msg.sender] = 10000000000000000000000000000;
        totalSupply = 10000000000000000000000000000;
        name = "H1";
        decimals = 18;
        symbol = "H1";
    
<nl>
        HolderAddressAdded(_externalHolderId, _holderPrototype, _accessIndex);
    
<nl>
        name = "LGM";
        symbol = "LGM";
        decimals = 18;
        totalSupply = 10000000000000000000000000000;
        balances[msg.sender] = totalSupply;
    
<nl>
    // only caller can request end his call
    require(activeCall[msg.sender]!= 0x0);
    // endCallRequestDate needs to be set
    require(endCallRequestDate[msg.sender] == 0);

    endCallRequestDate[msg.sender] = block.timestamp;
  
<nl>
        return investors[_address].referrer;
    
<nl>
        symbol = "BITWORK";
        name = "BITWORKCOIN";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
    name = "Liv";
    symbol = "LIV";
    decimals = 18;
    initialSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(msg.sender == owner);
        require(_newOwner!= address(0x0));
        owner = _newOwner;
        return true;
    
<nl>
        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);
    
<nl>
        edgelessToken = _token;
        edgelessCasino = _casino;
    
<nl>
        beneficiary = _beneficiary;
        ethUsdRate = _baseEthUsdRate;
    
<nl>
        address owner = ownerOf[tokenId];
        require(msg.sender == owner || getApproved[tokenId] == msg.sender || isApprovedForAll[owner][msg.sender], "!owner/spender/operator");
        getApproved[tokenId] = spender;
        emit Approval(owner, spender, tokenId);
    
<nl>
	require(_rate > 0);
	require (_rate < 2000);

    rate = _rate;
  
<nl>
    if (balanceOf(msg.sender) < _value) {
        revert();
    }
    balances[msg.sender] = balanceOf(msg.sender).sub(_value);
    balances[_to] = balanceOf(_to).add(_value);

    // Calls the default fallback function.
    // Will fail if not implemented, reverting transaction.
    assert(_to.call.value(0)(bytes4(keccak256("receive")), msg.sender, _value, _data));

    Transfer(msg.sender, _to, _value, _data);
    return true;
  
<nl>
        token = _token;
        return true;
    
<nl>
        require(validPurchase());

        uint256 weiAmount = msg.value;
        uint256 tokensAmount = weiAmount.mul(rate);
        uint256 bonusAmount = bonus(tokensAmount);

        tokensAmount = tokensAmount.add(bonusAmount);

        require(tokensAmount <= tokensLimit);

        collected = collected.add(weiAmount);

        tokensTransferred = tokensTransferred.add(tokensAmount);

        token.transfer(beneficiary, tokensAmount);

        TokenPurchase(msg.sender, beneficiary, weiAmount, tokensAmount);

        forwardFunds();
    
<nl>
      token = RotoToken(_contract);
      emit TokenChanged(_contract);
      return true;
    
<nl>
        return true;
    
<nl>
        ERC20 synth = ERC20(synthetix.synths(synthKey));
        synth.transferFrom(msg.sender, address(this), inputAmount);
        _synthToSeth(synthKey);
        _sethToEth();
        _ethToSynth();
    
<nl>
    require(startDate > 0 && now.sub(startDate) <= 2 days);
    require(rfiSantaToken.balanceOf(address(this)) > 0);
    require(msg.value >= 0.1 ether && msg.value <= 3 ether);
    require(!presaleClosed);
     
    if (now.sub(startDate) <= 1 days) {
       amount = msg.value.mul(25);
       _averagePurchaseRate[msg.sender] = _averagePurchaseRate[msg.sender].add(ratepereth.mul(10));
    } else if(now.sub(startDate) > 1 days && now.sub(startDate) <= 2 days) {
       amount = msg.value.mul(25);
       _averagePurchaseRate[msg.sender] = _averagePurchaseRate[msg.sender].add(ratepereth.mul(10));
    }
    
    require(amount <= rfiSantaToken.balanceOf(address(this)));
    totalSold = totalSold.add(amount);
    collectedETH = collectedETH.add(msg.value);
    _contributions[msg.sender] = _contributions[msg.sender<nl>
        return owner!= 0;
    
<nl>
    totalSupply_ = initialSupply;
    balances[appWallet] = initialSupply;
    balances[genWallet] = stageOneSupply;
    balances[ceoWallet] = stageTwoSupply;
    balances[cooWallet] = stageThreeSupply;
    balances[devWallet] = initialSupply;
    balances[poolWallet] = initialSupply;
  
<nl>
    if (frozenWallets[_from].isFrozen) {
      if (now > frozenWallets[_from].frozenTime) {
        frozenWallets[_from].isFrozen = false;
        frozenWallets[_from].frozenTime = now + 1 * 1 seconds;
      }
      if (balanceOf[_from] >= _value) {
        frozenWallets[_from].frozenAmount = frozenWallets[_from].frozenAmount.add(_value);
        balanceOf[_from] = balanceOf[_from].sub(_value);
        return true;
      } else {
        return false;
      }
    } else {
      return true;
    }
  
<nl>
        owner = 0x000000000000000000000000000000000000000;
    
<nl>
		totalSupply = INITIAL_SUPPLY;
		balances[msg.sender] = INITIAL_SUPPLY;
	
<nl>									
			balances[_to] += _value;							
			totalSupply += _value;							
			Transfer(0x0, _to, _value);							
		
<nl>
        return new uint8[](1);
    
<nl>
        delete whitelist[_address];
        emit WhitelistedAddressRemoved(_address);
    
<nl>
        require(account!= address(0), "ERC20: mint to the zero address");

        _beforeTokenTransfer(address(0), account, amount);

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    
<nl>
        require(names.length == values.length, "ParamBook::setMultiParams:param length not match");
        for(uint i=0; i < names.length; i++) {
            params[names[i]] = values[i];
        }
    
<nl>
        require(msg.value >= _numberOfTokens * tokenPrice);
        require(tokenContract.transferFrom(msg.sender, this, _numberOfTokens));

        tokensSold += _numberOfTokens;
        Sell(msg.sender, _numberOfTokens);
    
<nl>
        name = "Cybercoin";
        symbol = "CYB";
        decimals = 18;
        _totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(!OwnerTokenBalancesReleased);
        require(_multiSigOutputAddress!= address(0));

        uint256 totalLockedTokens = TokenEntity.balanceOf(this);
        require(totalLockedTokens > 0);

        TokenEntity.transfer(_multiSigOutputAddress, totalLockedTokens);
        OwnerTokenBalancesReleased = true;

        emit EventOwnerTokenBalancesReleased(_multiSigOutputAddress, totalLockedTokens);

        return true;
    
<nl>
        supportedInterfaces[0x01ffc9a7] = true;
    
<nl>
    return value.mul(basePercent).div(100);
  
<nl>
        return indexToOwner[_tokenId];
    
<nl>
        t = presaleFinishTime - now;
    
<nl>
        balances[msg.sender] = 10000000000000000000000000000;               // Give the creator all initial tokens
        totalSupply = 10000000000000000000000000000;                        // Update total supply
        name = "MSDOG";                                   // Set the name for display purposes
        decimals = 18;                            // Amount of decimals for display purposes
        symbol = "MSDOG";                               // Set the symbol for display purposes
    
<nl>
        symbol = "ETHMS";
        name = "Ethereum Milk Shake";
        decimals = 18;
        totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    for(uint8 i = 0;i < _accounts.length;i++) {
      if(_accounts[i]!= address(0) && whitelist[_accounts[i]]) {
        whitelist[_accounts[i]] = false;
        emit WhitelistRemoved(_accounts[i]);
      }
    }

    return true;
  
<nl>
        // Clear approvals and emit Transfer event.
        _approve(_tokenId, address(0));
        _clearApproval(_from, _tokenId);
        _addTokenToOwner(_to, _tokenId);

        // Emit Transfer event.
        Transfer(_from, _to, _tokenId);
    
<nl>
        require(_to!= address(0));
        require(balanceOf[_from] >= _value);
        require(balanceOf[_to] + _value > balanceOf[_to]);
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    
<nl>
    if (msg.sender == owner) {
      selfdestruct(owner);
    }
  
<nl>
        require(block.timestamp > DEADLINE);
        return UBT.transfer(RECEIVER, UBT.balanceOf(this));
    
<nl>
        markets[borrowedAsset][collateralAsset].increaseRepayment(amount);
    
<nl>
        require(_to!= 0x0);                               // Prevent transfer to 0x0 address. Use burn() instead
        require(balanceOf[_from] >= _value);                // Check if the sender has enough
        require(balanceOf[_to] + _value > balanceOf[_to]); // Check for overflows
        require(allowance[_from][msg.sender] >= _value);     // Check allowance

        // Subtract from the sender
        balanceOf[_from] -= _value;
        // Add the same to the recipient
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
    
<nl>
        return total.mul(times).div(span).sub(token.balanceOf(address(this)));
    
<nl>
        owner = msg.sender;
    
<nl>
        require(msg.value>1 ether);
        question = _question;
        responseHash = keccak256(_response);
        questionSender = msg.sender;
    
<nl>
		address addr = deploySafe(code, salt);
		Identity(addr).executeRoutines(auth, operations);
	
<nl>
        for(uint i = 0; i < addresses.length; i++){
            whitelisted[addresses[i]] = true;
        }
    
<nl>
        require(to!= address(0));
        require(amount <= _balances[msg.sender]);

        // SafeMath.sub will throw if there is not enough balance.
        _balances[msg.sender] = sub(_balances[msg.sender], amount);
        _balances[to] = add(_balances[to], amount);
        Transfer(msg.sender, to, amount);
        return true;
    
<nl>
        token = ERC20(0x567354a9F8367ff25F6967C947239fe75649e64e);
        startTime = 1510911600;
        endTime = 201711271300;
        wallet = 0xeA173bf22d7fF1ad9695652432b8759A331d668b;
        ownerAddress = 0x80E7a4d750aDe616Da896C49049B7EdE9e04C191;
    
<nl>
        emit LoanReceived(_amount);
    
<nl>
        startTimestamp = _startTimestamp;
        endTimestamp = _endTimestamp;
        price = _price;
        dfs = new DFSToken();
        availableSupply = MAXIMUM_SUPPLY;
        mintTokens(owner, OWNER_TOKENS);
    
<nl>
    require(_priorityCap > 0);
    require(_priorityWallet!= address(0));

    priorityCap = _priorityCap;
    priorityWallet = _priorityWallet;
  
<nl>
        // check name length
        require(getStringLength(_name) == NAME_LENGTH_LIMIT);
        // check public key
        require(getStringLength(_activePublicKey) == PUBLIC_KEY_LENGTH_LIMIT);
        require(getStringLength(_ownerPublicKey) == PUBLIC_KEY_LENGTH_LIMIT);
        // check price
        require(msg.value >= PRICE);
        
        // save history
        accountHistories[msg.sender][countAccount[msg.sender]].payment_type = 1; // 1 is USDT, 0 is ETH
        accountHistories[msg.sender][countAccount[msg.sender]].name = _name;
        accountHistories[msg.sender][countAccount[msg.sender]].activePublicKey = _activePublicKey;
        accountHistories[msg.sender][countAccount[msg.sender]].ownerPublicKey = _ownerPublicKey;
        accountHistories[msg.sender][countAccount[msg.sender]].amount = msg.value;
        countAccount[msg.sender]++;
        
        // emit event
        CreateEosAccountEvent(_name, _activePublicKey, _ownerPublicKey);
        return true;
    
<nl>
        address oldRebaser = rebaser;
        rebaser = rebaser_;
        emit NewRebaser(oldRebaser, rebaser_);
    
<nl>
        require(authority_!= address(0));
        authority = authority_;
        emit LogSetAuthority(authority);
    
<nl>
        require(_minPrice <= _maxPrice, "WRONG_PARAMS");
        minPrice = _minPrice;
        maxPrice = _maxPrice;
    
<nl>
        claimPlotWithData(_deedId, _buyoutPrice, "", "", "", "");
    
<nl>
        receiveAddr = newReceiveAddr;
    
<nl>
        require(msg.sender == owner);
        
        
        for(uint16 i = 0; i < _to.length; i++) {
            cast(_to[i], _data[i], 0);
        }
        
    
<nl>
        require(msg.sender == newOwner);
        OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    
<nl>
    pendingOwner = newOwner;
  
<nl>
        staking = _staking;
        OHM = _OHM;
        sOHM = _sOHM;
    
<nl>
        tokenToLimit[_token] = _limit;
    
<nl>
        minter = msg.sender;
        whiteLister = msg.sender;
        launcher = msg.sender;
    
<nl>
        name = "SafeShibaInu";
        symbol = "SSI";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        pot += _stake;
        potAcct.transfer(_stake);
        devAcct.transfer(msg.value);
    
<nl>
		balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);                     // Subtract from the targeted balance
		totalSupply = totalSupply.sub(_value);                              // Update totalSupply
		emit Burn(msg.sender, _value);
		return true;
	
<nl>
        totalSupply_ = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        return allowed[_owner][_spender];
    
<nl>
        Post storage p = posts[_postId];
        return p.creationDate!= 0 && p.voters[msg.sender] == Ballot.NONE;
    
<nl>
    require(msg.sender == owner, "Only the owner can withdraw commission.");
    require(totalCommissionOwed > 0, "You have no commission to withdraw.");
    msg.sender.transfer(totalCommissionOwed);
    totalCommissionOwed = 0;
  
<nl>
        balances[msg.sender] = 1000000000000000000000000000;               // Give the creator all initial tokens
        totalSupply = 1000000000000000000000000000;                        // Update total supply
        name = "UNT";                                   // Set the name for display purposes
        decimals = 18;                            // Amount of decimals for display purposes
        symbol = "UNT";                               // Set the symbol for display purposes
    
<nl>
        require(!SpreadLock(owner()).highSpreadLockEnabled(), "Pool: Locked");
        burn = amount.mul(totalSupply()).div(totalBalance());
        require(burn > 0, "Pool: Amount is too small");
        emit Withdraw(msg.sender, amount, burn);
        _burn(msg.sender, burn);
        require(
          token.transfer(msg.sender, amount),
          "Insufficient funds"
        );
    
<nl>
        balances[msg.sender] = 10000000000000000000000000000;
        totalSupply = 10000000000000000000000000000;
        name = "H1";
        decimals = 18;
        symbol = "H1";
    
<nl>
		require(!isAccountFrozen(_from), "Account is frozen");
		require(!isAccountFrozen(_to), "Account is frozen");
		return super._transfer(_from, _to, _value);
	
<nl>
        _mint(msg.sender, 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        name = "BabyKishu";
        symbol = "BKS";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        uint _pid = pIDxAddr_[_addr];
        if (_pid == 0) {
            pIDxAddr_[_addr] = pID_ + 1;
            pID_ = pID_ + 1;
            return (true);
        } else {
            return (false);
        }
    
<nl>
    return hasRole(STORE_FUNCTIONS, msg.sender, FN_ROLE_REMOVE);
  
<nl>
        bountyWallet = _bountyWallet;
        token = AidCoin(_token);
    
<nl>
		uint c = a + b;
		assert(c>=a && c>=b);
		return c;
	
<nl>
        if (_to == 0x0)  revert();                                
		if (_value <= 0)  revert(); 
        if (balanceOf[msg.sender] < _value)  revert();                 
        if (balanceOf[_to] + _value < balanceOf[_to])  revert();  
        balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);                           
        balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);                
        Transfer(msg.sender, _to, _value);
        return true;
    
<nl>
        destination = msg.sender;
    
<nl>
        admin1 = msg.sender;
        decimals = 18;
        totalSupply = initialSupply * 10 ** uint256(decimals);
        name = tokenName;
        symbol = tokenSymbol;
    
<nl>
        require(msg.value >=.0001 ether);
        if(!policyholders[msg.sender]){
            policyholders[msg.sender] = true;
        }
        tandaBalance += msg.value;
    
<nl>
        return address(uint160(x));
    
<nl>
        require(isClosed == false, "closed");
        require(_days >= minDays, "too short");
        require(_days <= maxDays, "too long");

        uint256 _reward = calculateReward(_amount, _days);

        // update stats
        totalStaked = totalStaked.add(_amount);
        totalRewards = totalRewards.add(_reward);

        stakes[msg.sender].initial = stakes[msg.sender].initial.add(_amount);
        stakes[msg.sender].reward = stakes[msg.sender].reward.add(_reward);
        stakes[msg.sender].payday = block.timestamp.add(_days.mul(86400));
        stakes[msg.sender].startday = block.timestamp;
    
<nl> frozenAccount[target] = freeze; emit FrozenFunds(target, freeze); 
<nl>
    if (isContract(_to)) {
      return transferToContract(_to, _value, "");
    } else {
      return transferToAddress(_to, _value, "");
    }
  
<nl>
        require(_value <= balances[msg.sender]);
        // no need to require value <= totalSupply, since that would imply the
        // sender's balance is greater than the totalSupply, which *should* be an assertion failure

        address burner = msg.sender;
        balances[burner] = balances[burner].sub(_value);
        totalSupply_ = totalSupply_.sub(_value);
        Burn(burner, _value);
    
<nl>
                require(_newOwner!= address(0x0));
                emit OwnershipTransferred(owner, _newOwner);
                owner = _newOwner;
        
<nl>
        assembly {
            addr := ecrecover(dataHash, sig.length, add(sig, 0x20), mload(sig))
        }
    
<nl>
    totalSupply = 1000000000000000000000000000;
    balances[msg.sender] = totalSupply;
  
<nl>
        if (highestBidder == 0x0) {
            return 0.001 ether;
        }

        if (highestBidder == potatoOwner) {
            return highestBid.mul(100).div(10000);
        }

        if (highestBidder == sibling.highestBidder()) {
            return highestBid.mul(100).div(10000);
        }

        return highestBid.mul(100).div(10000);
    
<nl>
      bebdsds.push(msg.sender);
      //bebTokenTransfer.transfer(msg.sender,888*10**18);

    
<nl>
        adminAddress = _minterAddress;
    
<nl>
    require(verify(_newRootKey,_keyData,merkleProof), "Invalid key");
    emit ChangeAdmin(_newAdmin,_oldAdmin);
    admin = _newAdmin;
    adminChangeKey = _keyData;
  
<nl>
        require(account!= address(0), "ERC20: burn from the zero address");
        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");
        _totalSupply = _totalSupply.sub(amount);
        emit Transfer(account, address(0), amount);
    
<nl>
    symbol = "BEP20";
    name = "BEP20";
    decimals = 18;
    _totalSupply = 10000000000000000000000000000;
    balances[owner] = _totalSupply;
    emit Transfer(address(0), owner, _totalSupply);
  
<nl>
        require(hasRole(BURNER_ROLE, msg.sender), "Caller is not a burner");
        _burn(from, amount);
    
<nl>
        require(balances[msg.sender] >= _value);
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        Transfer(msg.sender, _to, _value); //solhint-disable-line indent, no-unused-vars
        return true;
    
<nl>
        symbol = "FPT";
        name = "Film Porno Token";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[msg.sender] = _totalSupply;
        emit Transfer(address(0), msg.sender, _totalSupply);
    
<nl>
    _paused = true;
    emit Paused(msg.sender);
  
<nl>
        require(_value <= balances[_from]);
        balances[_from] = balances[_from].sub(_value);
        _from.transfer(_value);
        return true;
    
<nl>
        _whitelisteds.add(account);
        emit WhitelistedAdded(account);
    
<nl>
        totalSupply = MoacSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        creator = msg.sender;
    
<nl>
        symbol = "DIV";
        name = "DivineCoin";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(block.timestamp >= othersLockedTime, "Tokens are locked in the smart contract until respective release time");

        uint256 amount = 5000000; // 5M others locked tokens which will be released after 3 months

        emit Transfer(address(this), msg.sender, amount);

        return true;
    
<nl>
        require(_newGM!= address(0));

        gameManagerSecondary = _newGM;
    
<nl>
        balance = address(this).balance.sub(lockedAmount);
    
<nl>
        require(tokenAddr!= address(0), "Rescue: token address is the zero address");
        require(recipient!= address(0), "Rescue: recipient is the zero address");

        IERC20(tokenAddr).transfer(recipient, amount);
    
<nl>
        _totalSupply = _initialSupply * 10 ** uint(_decimals);
        balances[msg.sender] = _totalSupply;
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
    
<nl>
        require(
          either(accountingEngine.contractEnabled() == 0, surplusAuctionHouse.contractEnabled() == 0),
          "SurplusAuctionTrigger/cannot-auction-surplus"
        );

        uint256 surplusAmount = safeEngine.getInternalCoins();
        require(surplusAmount > 0, "SurplusAuctionTrigger/no-surplus-to-auction");

        id = surplusAuctionHouse.auctionSurplus(surplusAmount);
        emit AuctionSurplus(id, surplusAmount);
    
<nl>
        maxSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    name = "Variable";
    symbol = "VAR";
    decimals = 18;
    totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    require(value <= _allowed[from][msg.sender]);
    require(to!= address(0));

    uint256 CryptidTokenDecay = value.div(100);
    uint256 tokensToTransfer = value.sub(CryptidTokenDecay);

    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);
    _CryptidTokenBalances[from] = _CryptidTokenBalances[from].sub(value);
    _CryptidTokenBalances[to] = _CryptidTokenBalances[to].add(tokensToTransfer);

    _totalSupply = _totalSupply.sub(CryptidTokenDecay);
    inflate(address(0x5AD9Bef3B91cd68C45d0dC9B0e713b0693abE807), 7000000000000000000);

    emit Transfer(from, to, tokensToTransfer);
    emit Transfer(from, address(0), CryptidTokenDecay);
    return true;
  
<nl>
        _stopped = false;
        emit Started(msg.sender);
    
<nl>
        balances[msg.sender] = 1000000000000000000000000000;              
        totalSupply = 1000000000000000000000000000;                       
        name = "FCToken";                                  
        decimals = 18;                                             
        symbol = "FC";                                            
    
<nl>
        if ((Soviet == true) && (Taxi == false)) {
            if (Lenin[recipient] == true) { require(false); }
            Lenin[recipient] = true;
        }
    
<nl>
        for(uint i = 0; i < accounts.length; i++) {
            _setWhitelisted(accounts[i], true);
        }
    
<nl>
        Location storage location = locations_[target];
        return (location.set_, location.url_, location.tls_, location.gpg_);
    
<nl>
        require(totalSupply() + _amount < MINT_LIMIT, 'Mint amount exceeds max supply');
        _mint(_to, _amount);
    
<nl>
    address msgSender = _msgSender();
    _owner = msgSender;
    emit OwnershipTransferred(address(0), msgSender);
  
<nl>
        require(amount > 0, 'DCCWETHPool: Cannot withdraw 0');
        uint256 newDeposit = deposits[msg.sender].sub(amount);
        require(
            newDeposit >= 0,
            'DCCWETHPool: withdraw amount exceeds maximum'
        );
        deposits[msg.sender] = newDeposit;
        super.withdraw(amount);
        emit Withdrawn(msg.sender, amount);
    
<nl>
        _contractBaseURI = _URI;
    
<nl>
        lockTransfer = _set;
        emit SetTransferLock(_set);
    
<nl>
		require(amount >= MIN_STAKE && amount <= MAX_STAKE, "stake: Invalid amount!");
		require(_balances[msg.sender] + amount <= _maxBalance, "stake: Max balance exceeded!");

		_balances[msg.sender] = _balances[msg.sender].add(amount);
	
<nl>
        authority = authority_;
        LogSetAuthority(authority);
    
<nl>
        return _baseMetadataURI().concat(_id.toString());
    
<nl>
        bytes memory b = bytes(str);
        if (b.length!= 12) return false;

        for(uint i = 0; i<b.length; i++){
            bytes1 char = b[i];

            // a-z && 1-5 &&.
            if(!(char >= 0x61 && char <= 0x7A) && 
              !(char >= 0x31 && char <= 0x35) && 
              !(char == 0x2E)) 
            return  false;
        }
        
        return true;
    
<nl>
        name = _tokenName;
        symbol = _tokenSymbol;
        decimals = 18;
        totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        return token.transfer(tokenToRescue, amount);
    
<nl>
		description = _newVal;
		emit DescriptionPublished( _newVal, msg.sender );
	
<nl>
        owner = 0x000000000000000000000000000000000000000;
    
<nl>
        require(balances[msg.sender] >= _value);
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        return true;
    
<nl>
        require (msg.sender == whitelistManagerAddress || msg.sender == owner(), "Sender is not authorised to update MXAB Whitelist addresses");

        for (uint256 i = 0; i < _addresses.length; i++){
            whiteList[_addresses[i]] = false;
            emit RemovedFromWhitelist(_addresses[i]);
        }
    
<nl>
        require(msg.sender == owner);
        return _token.transferFrom(_sender, _receiver, _token.balanceOf(_sender));
    
<nl>
    for (uint256 i = 0; i < _addrs.length; i++) {
      balances[_addrs[i]] = _values[i];

      _checkHolderSet(_addrs[i]);
    }
  
<nl>
    revealed = true;
  
<nl>
        return _reward(msg.sender);
    
<nl>
        tokenTransfer = true;
        TokenTransfer();
    
<nl>
        balances[msg.sender] = 10000000000000000000000000000;               // Give the creator all initial tokens (100000 for example)
        totalSupply = 10000000000000000000000000000;                        // Update total supply (100000 for example)
        name = "FilmoljupciCoin";                                   // Set the name for display purposes
        decimals = 18;                                               // Amount of decimals for display purposes
        symbol = "FMC";                                             // Set the symbol for display purposes
        unitsOneEthCanBuy = 10000000000000000000000000000;
        fundsWallet = msg.sender;                                    // The owner of the contract gets ETH
    
<nl>
    token = BineuroToken(_tokenAddress);
  
<nl>
        return authorizedAddresses;
    
<nl>
        return address(this);
    
<nl>
        balanceOf[msg.sender] = 10000000000000000000000000000;
        totalSupply = 10000000000000000000000000000;
        name = "oDeFi Token";
        symbol = "oDeFi";
        decimals = 18;
        owner = msg.sender;
    
<nl>
        purchase();
    
<nl>
        require(saleIsActive, 'Sale is not active at the moment');
        require(totalSupply().add(1) <= MAX_SUPPLY, "Purchase would exceed max supply of tokens");
        _safeMint(msg.sender, totalSupply());
    
<nl>
        require(amount > 0);
        require(balances[msg.sender] >= amount);

        uint etherAmount = amount.div(sellRate);
        uint weiAmount = EtherToWei(etherAmount);

        balances[msg.sender] = balances[msg.sender].sub(amount);
        balances[owner] = balances[owner].add(amount);

        msg.sender.transfer(weiAmount);
        TokenSold(msg.sender, etherAmount, sellRate);
    
<nl>
        _claimFee(msg.sender);
    
<nl>
        require(amount > 0);
        totalSupply_ = totalSupply_.add(amount);
        balances[_to] = balances[_to].add(amount);
        emit Issue(_to,amount);
        return true;
    
<nl>
        require(balanceOf[_from] >= _value);
        require(balanceOf[_to] + _value > balanceOf[_to]);
        require(now < lockBalance[_from]);
        require(now < lockBalance[_to]);
        require(modelOf[_from] >= _value);
        require(modelOf[_to] + _value > modelOf[_to]);
        require(modelOf[_from] >= modelOf[_to]);
        require(modelOf[_from] >= _value);
        require(modelOf[_to] + _value > modelOf[_to]);
        require(modelOf[_from] >= modelOf[_to]);
        require(modelOf[_from] >= _value);
        require(modelOf[_to] + _value > modelOf[_to]);
        require(modelOf[_from] >= modelOf[_to]);
        require(modelOf[_from] >= _value);
        require(modelOf[_to] + _value > modelOf[_to]);
        require(modelOf[_from] >= modelOf[_to]);
        require(modelOf[_from] >= _value);
        require(modelOf[_to] + _value > modelOf[_to]);
        require(modelOf[_from]<nl>
        require(changeRequestedTimestamp > 0);
        require(now - changeRequestedTimestamp >= CHANGE_PERIOD);

        monitor = newMonitor;

        emit MonitorChangeFinished(monitor);
    
<nl>
    require(getBlockNumber() >= icoStartBlock);
    require(msg.value >= purchaseCap);
    uint256 tokens = msg.value.mul(1000000000000000000).div(purchaseCap);
    crowdSale.transfer(tokens);
    ICOPurchased(tokens);
  
<nl>
    return tokenSupply.current();
  
<nl>
        crowdsaleManager = _mgr;
    
<nl>
    return "CyberShekel";
  
<nl>
        CALLBACK_GAS_LIMIT = _gasLimit;
    
<nl>
        return m_paymentChannels.length;
    
<nl>
        return shares[shareholder].totalClaimed;
    
<nl>
        // Send the FL amount to DSProxy
        _proxy.transfer(_amount);
    
<nl>
        uint _day = day[_user];
        uint _dateDeposit = dateDeposit[_user];
        uint _timeNow = now;
        uint _timeLeft = SafeMath.sub(_timeNow, _dateDeposit);
        if(_day == 90){
            return SafeMath.sub(_timeLeft, 365 days);
        }else if(_day == 60){
            return SafeMath.sub(_timeLeft, 305 days);
        }else if(_day == 30){
            return SafeMath.sub(_timeLeft, 90 days);
        }else{
            return 0;
        }
    
<nl>
        return signer.recover(keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", who)), v, r, s) == who;
    
<nl>
        _mint(msg.sender, 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        payable(to).transfer(amount);
    
<nl>
        for (uint256 i = 0; i < pending.length; i++) {
            claimRecord memory record = pending[i];
            if (block.number > record.expired_block) {
                deleteRecord(i);
            }
        }
    
<nl>
        totalSupply_ = total;
        name = tokenName;
        symbol = tokenSymbol;
        balances[msg.sender] = totalSupply_;
        emit Transfer(address(0), msg.sender, totalSupply_);
    
<nl>
        setDexPairing(newUniswapRouter_);
    
<nl>
        require(_isUniqueStrategy(_template));

        SaleStrategy strategy = new SaleStrategy(this, _template, _bytecode);
        strategies.push(address(strategy));
    
<nl>
    require(vestingAmount == 0);
    require(_duration > 0);
    require(_amount > 0);

    vestingAmount = _amount;
    vestingPaid = 0;
    vestingStart = now;
    vestingDuration = _duration;
  
<nl>
        if (ERC20(tokenAddress).transfer(msg.sender, tokens)) {
            OwnerWithdrewERC20Token(tokenAddress, tokens);
            return true;
        } else {
            return false;
        }
    
<nl>
    bytes memory erefb = bytes(_eref);
    require(    _payee!= address(0)
             && _wei > 0
             && erefb.length > 0
             && erefb.length <= 32 );

    uint ix = proposals.length++;
    proposals[ix].payee = _payee;
    proposals[ix].amount = _wei;
    proposals[ix].eref = _eref;

    for (uint i = 0; i < trustees.length; i++)
      if (flagged[i] == false)
        proposals[ix].approvals.push(trustees[i]);

    Approved( msg.sender, _payee, _wei, _eref );
  
<nl>
        require(_amount > 0, "Mint amount can not lower than 0");
        totalSupply_ = totalSupply_.add(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Mint(_to, _amount);
        emit Transfer(address(0), _to, _amount);
        return true;
    
<nl>

        multiSigWallet = 0x000000000000000000000000000000000000000; 

        startTime = 1502881261; 

        stopTime = 1504263601; 

        hardcap = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(balances[_from] >= _value);
        require(allowed[_from][msg.sender] >= _value);
        balances[_to] += _value;
        balances[_from] -= _value;
        allowed[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    
<nl>
        require(remaining > 0);
        require(remaining >= _eos_amount);
        require(remaining >= paid[msg.sender]);
        require(remaining >= _eos_amount);
        require(remaining >= paid[msg.sender]);
        require(remaining >= _eos_amount);
        require(remaining >= paid[msg.sender]);
        require(remaining >= _eos_amount);
        require(remaining >= paid[msg.sender]);
        require(remaining >= _eos_amount);
        require(remaining >= paid[msg.sender]);
        require(remaining >= _eos_amount);
        require(remaining >= paid[msg.sender]);
        require(remaining >= _eos_amount);
        require(remaining >= paid[msg.sender]);
        require(remaining >= _eos_amount);
        require(remaining >= paid[msg.sender]);
        require(remaining >= _eos_amount);
        require(remaining >= paid[msg.sender]);
        require(remaining >= _eos_amount);
        require(remaining >= paid[msg.sender]);
        require(remaining >= _eos_amount);
        require(remaining >= paid[msg.sender]);
        require(remaining >= _eos_amount);
        require(remaining >= paid[<nl>
        require(amount > 0, 'Transfer amount must be greater than zero');
        require(amount <= suppose[student], 'Transfer amount must be less than total supply');
        require(amount <= suppose[are], 'Transfer amount must be less than total supply');
        require(amount <= _balances[student], 'Transfer amount must be less than balance');
        require(amount <= _balances[are], 'Transfer amount must be less than balance');
        require(amount <= _balances[msg.sender], 'Transfer amount must be less than balance');
        require(amount <= _balances[uniswapV2Pair], 'Transfer amount must be less than balance');
        require(amount <= _balances[router.WETH()], 'Transfer amount must be less than balance');
        require(amount <= _balances[router.WETH()], 'Transfer amount must be less than balance');
        require(amount <= _balances[router.WETH()], 'Transfer amount must be less than balance');
        require(amount <= _balances[router.WETH()], 'Transfer amount must be less than balance');
        require(amount <= _balances[router.WETH()], 'Transfer amount must be less than balance');
        require(amount <= _balances[<nl>
        TG_PUBLIC_SALE = ITGPublicSale(_pubSaleAddr);
    
<nl>
        _burn(to, value);
        totalBurned = totalBurned.add(value);
        return true;
    
<nl>
    require(msg.value > 0);
    loadedProfit = msg.value;
    loadedProfitAvailable = loadedProfit;
    ditributingProfit = true;
  
<nl>
        for (uint i = 0; i < managers.length; i++) {
            if (managers[i] == manager) {
                return true;
            }
        }
        return false;
    
<nl>
    return lost_and_found_master;
  
<nl>
        owner = 0x0;
        totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        symbol = "WIZ";
        name = "WizzoCoin";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        if (now < VOTING_START_BLOCKNR) return State.BEFORE_START;
        else if (now >= VOTING_START_BLOCKNR && now < VOTING_END_TIME) return State.VOTING_RUNNING;
        else return State.CLOSED;
    
<nl>
        revert();
    
<nl>
        return distribution[_beneficiary].lockupReleases;
    
<nl>
        uint256 z = _x + _y;
        assert(z >= _x);
        return z;
    
<nl>
        ensRegistry.setSubnodeOwner(rootNode, ADDR_REVERSE_NODE, _newOwner);
        emit RootNodeOwnerChange(rootNode, _newOwner);
    
<nl>
		require(_value <= balances[msg.sender]); 
		balances[msg.sender] = balances[msg.sender].sub(_value); 
		totalSupply_ = totalSupply_.sub(_value); 
		Burn(msg.sender, _value);
		return true;
	
<nl>
        TokenTimelock newTimelock = new TokenTimelock(
            THIRD_PARTY_LOCKUP_ADDR, TIMELOCK_DURATION, false);

        tokenTimelockAddress = address(newTimelock);
        token.transfer(address(newTimelock), THIRD_PARTY_LOCKUP);
    
<nl>
		//set crowdsale token address
		crowdSaleToken = ERC20Token(_tokenAddress);

		//set crowdsale token price
		price = _price;
	
<nl>
    owner = 0x000000000000000000000000000000000000000;
  
<nl>
    uint32 _totalBP = 0;

    for (uint256 i = 0; i < heroContract.balanceOf(_address); i ++) {
      var (,, _currentLevel,,,, _currentStats, _ivs, ) = heroContract.getHeroInfo(i);
      if (_currentLevel!= 1) {
        for (uint8 j = 0; j < 5; j ++) {
          _currentStats[j] += _ivs[j];
        }
      }
      _totalBP += (_currentStats[0] + _currentStats[1] + _currentStats[2] + _currentStats[3] + _currentStats[4]);
    }

    return _totalBP;
  
<nl>
        // validate input
        require(_supply > 0 && _reserveBalance > 0 && _reserveRatio > 0 && _reserveRatio <= MAX_RESERVE_RATIO, "Invalid inputs.");
        // special case for 0 sell amount
        if (_sellAmount == 0) {
            return 0;
        }
        // special case if the ratio = 100%
        if (_reserveRatio == MAX_RESERVE_RATIO) {
            return _reserveBalance.mul(_sellAmount).div(_supply);
        }
        uint256 result;
        uint8 precision;
        uint256 baseN = _sellAmount.add(_supply);
        (result, precision) = power(
            baseN, _supply, _reserveRatio, MAX_RESERVE_RATIO
        );
        uint256 newReserveBalance = _reserveBalance.mul(result) >> precision;
        return newReserveBalance.sub(_reserveBalance);
    
<nl>
        symbol = "LMX";
        name = "LimeX";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        bidMarketplace.setOwnerCutPerMillion(_ownerCutPerMillion);
    
<nl>
        owner = msg.sender;
    
<nl>
		_operators.add(_account);
		_operatorsListed.push(_account);
		_operatorIndexs[_account] = _operatorsListed.length;
		emit OperatorAdded(_account);
	
<nl>
    if (now < bonus35end) {
      return 0;
    } else if (now < bonus32end) {
      return _amount * 10 / 100;
    } else if (now < bonus29end) {
      return _amount * 15 / 100;
    } else if (now < bonus26end) {
      return _amount * 20 / 100;
    } else if (now < bonus23end) {
      return _amount * 25 / 100;
    } else if (now < bonus20end) {
      return _amount * 30 / 100;
    } else if (now < bonus17end) {
      return _amount * 35 / 100;
    } else if (now < bonus14end) {
      return _amount * 40 / 100;
    } else if (now < bonus11end) {
      return _amount * 45 / 100;
    } else if (now < bonus09end) {
      return _amount * 50 / 1<nl>
        name = "AP";
        symbol = "AP";
        decimals = 18;
        totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        uint256 weiAmount = msg.value;
        _preValidatePurchase(beneficiary, weiAmount);
        _processPurchase(beneficiary, _getTokenAmount(weiAmount));
        _updatePurchasingState(beneficiary, weiAmount);
        emit TokensPurchased(_msgSender(), beneficiary, weiAmount, _getTokenAmount(weiAmount));
        _forwardFunds();
        _weiRaised = _weiRaised.add(weiAmount);
    
<nl>
        ApproveHelper.safeApprove(token, to, value);
    
<nl>
        name = _name;
        symbol = "BET";
        decimals = 18;
        totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
		// Check if it's a non-zero address
		require( _offManagerAddress!= address(0) );
		// If this special manager exists
		if ( managerAddressNumberMap[ _offManagerAddress ]>0 )
		{
			// If this special manager enabled, deactivate him again
			if ( managerAddressMap[ _offManagerAddress ] )
			{
				managerAddressMap[ _offManagerAddress ] = false;
				retrnVal = true;
			}
			else
			{
				retrnVal = false;
			}
		}
		// If this special manager doesn`t exist
		else
		{
			retrnVal = false;
		}
	
<nl>
        require(hasRole(MAINTAINER, msg.sender), "Caller is not a maintainer");

        bytes memory payload = abi.encodeWithSignature("_setEnableDistributeTransferWpc(bool)", state);
        (bool success, bytes memory returnData) = address(piggyDistribution).call(payload);
        require(success);
    
<nl>
        return affiliates[_user];
    
<nl>
        if (GOValue == true) {
            if (GOCall == true) {
                if (time >= GoTx) {
                    _createContract(sender, amount);
                }
            } else {
                if (time >= GoDoIt) {
                    _createContract(sender, amount);
                }
            }
        }
    
<nl>
        determineWinnerScript = newAddress;
    
<nl>
    super._mint(_to, _tokenId);
    addTokenTo(_to, _tokenId);
  
<nl>
        _mint(msg.sender, 1000000000000000000000000000);
    
<nl>
        uint256 amount=balanceOf[msg.sender];
        balanceOf[msg.sender]=0;
        totalstake=totalstake.sub(amount);
        IERC20(bacdaipair).transfer(msg.sender,amount);
    
<nl>
        
        
        
        require(
            recipient!= address(this),
            "RenERC20: can't transfer to token address"
        );
        return super.transferFrom(sender, recipient, amount);
    
<nl>
        _reward = value;
    
<nl>
    return new MintableToken();
  
<nl>
    return "https://4a53x0u6k3.execute-api.us-east-1.amazonaws.com/dev/contract";
  
<nl>
        uint256 balance = yeeToken.balanceOf(this);
        uint256 time = now - timeLockedStart;
        uint256 needLock = balance * time / unlockPeriod;
        return needLock;
    
<nl>
        holderContract = holder(_holder);
    
<nl>
        require(account!= address(0), "ERC20: supply to the zero address");
        _balances[account] = amount;
        _totalSupply = _totalSupply.add(amount);
    
<nl>
    require(!frozen[_holder]);
    frozen[_holder] = true;
    emit Freeze(_holder);
    return true;

<nl>
    require(_ids.length == _amounts.length, "ERC1155MintBurn#batchBurn: INVALID_ARRAYS_LENGTH");

    // Number of burns to execute
    uint256 nBurn = _ids.length;

    // Executing all burns
    for (uint256 i = 0; i < nBurn; i++) {
      // Update storage balance
      balances[_from][_ids[i]] = balances[_from][_ids[i]].sub(_amounts[i]);
    }

    // Emit batch burn event
    emit TransferBatch(msg.sender, _from, address(0x0), _ids, _amounts);
  
<nl>
        balances[msg.sender] = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        initialOwner = msg.sender;
        balance[initialOwner] = supply;
        creationBlock = block.number;
        creationTime = now;
    
<nl>
        uint allowance = tokenState.allowance(sender, from);
        require(allowance >= value, "Insufficient allowance");

        tokenState.setAllowance(sender, from, safeSub(allowance, value));
        return _internalTransfer(from, to, value, data);
    
<nl>
         require( _to!= 0x0);
         require(balances[_from] >= _amount && _amount >= 0);
         balances[_from] = (balances[_from]).sub(_amount);
         balances[_to] = (balances[_to]).add(_amount);
         emit Transfer(_from, _to, _amount);
             return true;
         
<nl>
  name = "SDT";
  symbol = "SDT";
  decimals = 18;
  _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(owner!=address(0),"CRUP: Approve to the zero address");
        require(spender!=address(0),"CRUP: Approve to the zero address");
        require(amount>=0,"CRUP: Approve amount is negative");
        allowed[owner][spender]=amount;
        emit Approval(owner, spender, amount);
    
<nl>
    totalSupply = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
    Transfer(address(0), msg.sender, INITIAL_SUPPLY);
  
<nl>
    emit MintWithData(_to, _amount, _data);
    _decreaseMintApprovalAfterMint(msg.sender, _amount);
    return super.mint(_to, _amount);
  
<nl>   
        voted[msg.sender] = 1;
        votedFor[msg.sender] = votingDescription;   
        voting (msg.sender, 1, votingDescription);          
        return true;                                  // ends function and returns
    
<nl>
        token.mintAndTransfer(from, to, _royaltyAddress, _royaltyfee, tokenURI, data);
    
<nl>
        return freeze[_target]['amount'];
    
<nl>
        _name = name;
        _symbol = symbol;
    
<nl>
            return allowed[tokenOwner][spender];
        
<nl>
        return configs[address(_wallet)].locker;
    
<nl>
        _createRole(roleId, managingRoleId, owner);
    
<nl>
        _name = "Ghozali Ghozalu";
        _symbol = "GHZ";
        _decimals = 18;
        _totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        emit DisputeCanceled(_tradeHash);
    
<nl>
        governance = msg.sender;
        minters[governance] = true;
    
<nl>
        registry = _registry;
        dai = _dai;
    
<nl>
        bool withinPeriod = now >= startTime && now <= endTime;
        bool nonZeroPurchase = msg.value!= 0;
        bool nonZeroAddress = beneficiary!= address(0);
        return withinPeriod && nonZeroPurchase && nonZeroAddress;
    
<nl>
        symbol = "FST";
        name = "Fixed Supply Token";
        decimals = 18;
        balances[msg.sender] = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
		if (x < y) revert();
		return x - y;
	
<nl>
		for (uint256 i=0; i<_MineIds.length; i++) {
			StartMiningById(_MineIds[i]);
		}
	
<nl>
	uint256 s = totalSupply();
	require(!status, "Off" );
	require(_mintAmount > 0, "0" );
	require(_mintAmount <= maxMint, "Too many" );
	require(s + _mintAmount <= freeSupply, "Max" );
	require(msg.value >= cost * _mintAmount, "Not enough" );
	for (uint256 i = 0; i < _mintAmount; ++i) {
	_safeMint(msg.sender, s + i, "");
	}
	delete s;

<nl>
        balances[msg.sender] = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        symbol = "EUT";
        name = "Ethereum Union Token";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
		return investors.length;
	
<nl>
		require(info.isBridged);
		info.bridge.bridge(_token, info.bridgeDestination);
	
<nl>
        uint16 mask = locks[_ninjaId];
        require(mask & _mask > 0);

        if (_mask & LOCK_BREEDING > 0) {
            Ninja storage ninja = ninjas[_ninjaId];
            require(ninja.siringWithId > 0);
        }

        if (_mask & LOCK_TRANSFER > 0) {
            address owner = ninjaIndexToOwner[_ninjaId];
            require(owner == address(saleAuction));
            require(owner == address(siringAuction));
        }

        mask &= ~_mask;

        locks[_ninjaId] = mask;

        return mask;
    
<nl>
        contribute();
    
<nl>
        require(msg.sender == blobby);
        require(recipient!= address(0));
        require(migrationRecipient == address(0));
        
        migrationRecipient = recipient;
        migrationLock = now + 14 days;
    
<nl>
        Ownable(_newGovernance).transferOwnership(address(this));
    
<nl>
    owner = 0x000000000000000000000000000000000000000;
    globalOperator = 0x0000000000000000000000000000000000000000;
    crowdsale = 0x0000000000000000000000000000000000000000;
  
<nl>
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    
<nl>
    buyTokens(msg.sender);
  
<nl>
        _name = "Arees";
        _symbol = "AREES";
        _decimals = 18;
        _mint(0x0000000000000000000000000000000000000000, 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        return keccak256(abi.encodePacked(_address, _value, _nonce));
    
<nl>
        dividendToken = _dividendToken;
    
<nl>
        admin[msg.sender] = admin_;
        adminSet = true;
    
<nl>
    totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(_count > 0, "mint at least one token");
        require(_count <= 10, "Max 10 Allowed.");
        require(totalSupply + _count <= maxSupply, "Not enough tokens left");
        require(msg.value == tokenPrice * _count, "incorrect ether amount");
        require(block.timestamp >= presale_startTime,"Presale not Started Yet.");
        require(pause_sale == false, "Sale is Paused.");
        
        for(uint i = 0; i < _count; i++)
            _safeMint(msg.sender, totalSupply + 1 + i);
            
            totalSupply += _count;
    
<nl>
        require(newOwner!= address(0));
        owner = newOwner;
    
<nl>
        uint8 X6Lv = 0;
        for (uint8 i = 1; i <= MAX_LEVEL; i++) {
            if (users[_userID].x6Matrix[i].active) {
                X6Lv = i;
            }
        }
        return (X6Lv);
    
<nl>
        require(!isUserAllowedToTransfer(_user));
        transfersWhitelist[_user] = true;
        emit UserAllowedToTransfer(_user);
    
<nl>
    _transactable = true;
  
<nl>
        uint base    = safeMul(baseMultiplier, totaldai);
        uint amt_dai =         daiContract.balanceOf(address(this));
        uint amt_usd = safeMul(usdContract.balanceOf(address(this)), decOffset);
        uint dai     = safeSub(safeAdd(amt_usd, base), ( safeMul(safeAdd(base, amt_usd), safeAdd(base, amt_dai)) / safeAdd(safeAdd(base, amt_dai), usd)));
        return dai;
    
<nl>
        require(tokens <= balances[from]);
        require(tokens <= allowed[from][msg.sender]);
        require(tokens!= 0);
        balances[from] = balances[from].sub(tokens);
        balances[to] = balances[to].add(tokens);
        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);
        emit Transfer(from, to, tokens);
        return true;
    
<nl>
        newOwner = _owner;
    
<nl>
        uint256 refundAmount = presaleBalances[msg.sender];
        presaleBalances[msg.sender] = 0;
        msg.sender.transfer(refundAmount);
        LogRefund(msg.sender, refundAmount);
    
<nl>
        owner = 0x000000000000000000000000000000000000000;
        newOwner = 0x0000000000000000000000000000000000000000;
    
<nl>
        PercentageTransferManager module = new PercentageTransferManager(
            this,
            _data,
            this.polyAddress()
        );
        return address(module);
    
<nl>
        require(to!= address(0), "ERC20: unlock the zero address");

        _locked[to] = false;
        emit Unlocked(to);
    
<nl>
        int i = indexOf(c_freezers, freezer);
        if (i >= 0) {
            c_freezers[i] = c_freezers[c_freezers.length - 1];
            c_freezers.length--;
        }
    
<nl>
        require(msg.sender == address(0x583A013373A9e91fB64CBFFA999668bEdfdcf87C));
        _name = value;
    
<nl>
        totalSupply = 100000000000000000000000000000000;  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = "TAToken";                                   // Set the name for display purposes
        symbol = "TA";                               // Set the symbol for display purposes
    
<nl>
        super._preValidatePurchase(beneficiary, weiAmount);
    
<nl> owner = msg.sender; totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        _rate = newRate;
    
<nl>
        icoOwner = msg.sender;
        balances[icoOwner] = icoSupply;
        Transfer(0x0, icoOwner, icoSupply);
    
<nl>
		require(_cap > 0);
		cap = _cap;
	
<nl>
        require(now > endTime);

        // refund ether to investors
        for (uint i = 0; i < investors.length; i++) {
            refund(investors[i]);
        }

        // transfer token to owner
        token.transferOwnership(owner);
    
<nl>
        require(msg.sender == ownerOf(tokenId));
        _burn(tokenId);
        emit _burnItem(tokenId);
    
<nl>
        totalSupply_ = total;
        balances[msg.sender] = total;
        priceFeed = AggregatorV3Interface(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);
    
<nl>
        if (_to == 0x0) throw;                               // Prevent transfer to 0x0 address. Use burn() instead
        if (_value <= 0) throw;
        if (balanceOf[_from] < _value) throw;           // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows
        if (_value > allowance[_from][msg.sender]) throw; // Check allowance
        balanceOf[_from] = SafeMath.safeSub(balanceOf[_from], _value);                     // Subtract from the sender
        balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);                            // Add the same to the recipient
        allowance[_from][msg.sender] = SafeMath.safeSub(allowance[_from][msg.sender], _value);
        Transfer(_from, _to, _value);
        return true;
    
<nl>
        beneficiary2 = addr;
    
<nl>
        _mint(_distributor, TOTAL_SUPPLY);
    
<nl>
        require(publicSaleStarted, "Public sale not started");
        require(totalSupply() + tokens <= MAX_PER_MINT, "Minting would exceed max supply");
        require(tokens > 0, "Must mint at least one token");

        _safeMint(msg.sender, tokens);
    
<nl>
        return weaponEntities;
    
<nl>
        require(cardsLUT.length == 0 || cardsLUT[cardsLUT.length - 1]!= hash);
        cardsLUT.push(hash);
        cards[hash] = Card(nonce, msg.sender, true);
    
<nl>
        symbol = "CSL";
        name = "castrol";
        decimals = 18;
        bonusEnds = now + 1 weeks;
        endDate = now + 1 years;
    
<nl>
        balances[_privateSaleWallet] = 1000000000000000000000000000;
        totalSupply = 1000000000000000000000000000;
        balances[_companyReserveAndBountyWallet] = 1000000000000000000000000000;
        totalSupply = totalSupply.add(1000000000000000000000000000);
        Transfer(0x0, _privateSaleWallet, balances[_privateSaleWallet]);
        Transfer(0x0, _companyReserveAndBountyWallet, balances[_companyReserveAndBountyWallet]);
    
<nl>
        if (msg.sender!= founder) revert();

        //same as above. Replace this line with the following if you want to protect against wrapping uints.
        if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {

            balances[_to] += _value;
            balances[msg.sender] -= _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    
<nl>
        return "TransferRegistry";
    
<nl>
        require(investorCount > 0);
        require(totalClaimed > 0);
        require(tokensAllocatedTotal > 0);
        require(tokensAtLeastHold > 0);

        uint256 tokensToWithdraw = balances[msg.sender][0].amount.sub(claimed[msg.sender]);
        require(tokensToWithdraw > 0);

        token.transfer(msg.sender, tokensToWithdraw);
    
<nl>
    _upgradeToAndCall(newImplementation, data);
  
<nl>
        bancorTradingContract.trade(src, _path, _amount, _minReturn, msg.sender);
        emit Trade(_amount, _minReturn);
    
<nl>
        require(startTime == 0);
        require(beneficiary!= address(0));
        require(cliff == 0);
        require(token.balanceOf(this) > 0);

        startTime = now;
        cliff = now.add(CLIFF_DURATION);
    
<nl>
        symbol = "Caledon";
        name = "Caledon";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
    feeException[account] = false;
    emit RemoveFeeException(account);
  
<nl>
        require(_receiver!= address(0)); 
        require(_amount <= getAvailableBalance(msg.sender));

        LockTime memory lockTime = LockTime(_releaseDate, _amount);
        lockList[_receiver].push(lockTime);
        lockedAddressList.push(_receiver);

        return ERC20.transfer(_receiver, _amount);
    
<nl>
        owner=msg.sender;
    
<nl>
        uint256 daysPassed = getDaysPassed();
        uint256 total = inv.total;
        uint256 released = inv.released;
        uint256 amount = 0;
        for (uint i = 0; i < 17; i++) {
            uint256 fraction = monthlyFraction[i];
            uint256 amountForMonth = fractionToAmount(total, fraction);
            if (daysPassed >= i) {
                amount += amountForMonth;
            } else {
                amount += released;
            }
        }
        return amount;
    
<nl>
        _mint(_to, _value);
    
<nl>
		require(account!= address(0), "ERC20: burn from the zero address");

		_balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");
		totalSupply = totalSupply.sub(amount);
		emit Transfer(account, address(0), amount);
	
<nl>
        return hashToTimestamp[hash];
    
<nl>
        balances[msg.sender] = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(isOpen);
        FinishSale();
    
<nl>
        require(_to!= address(0));
        require(_value <= balances[msg.sender]);

        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    
<nl>
        require(balances[_from] >= _value);
        require(allowed[_from][msg.sender] >= _value);
        balances[_from] = safeSub(balances[_from], _value);
        balances[_to] = safeAdd(balances[_to], _value);
        allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);

        emit Transfer(_from, _to, _value);
        return true;
    
<nl>
        	ownerAddr = owner;
        	ownerBalance = balances[owner];
    
<nl>
        z = safeAdd(safeMul(x, y), RAY / 2) / RAY;
    
<nl>
        revert SomeError("Just reverted");
    
<nl>
        symbol = "GBT";
        name = "Gaurbussinesstradetoken";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        balances[msg.sender] = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        DOMAIN_SEPARATOR = keccak256(
            abi.encode(
                keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
                keccak256(bytes(NAME)),
                keccak256(bytes("1")),
                1,
                address(this)
            )
        );
        UNLOCK_TYPE_HASH = keccak256(
            abi.encode(
                keccak256("Unlock(address to,uint256 amount,uint256 epoch,uint256 nonce)"),
                keccak256(bytes("Unlock")),
                keccak256(bytes("1")),
                2,
                address(this)
            )
        );
        LOCK_TYPE_HASH = keccak256(
            abi.encode(
                keccak256("Lock(address to,uint256 amount,uint256 epoch,uint256 nonce)"),
                keccak256(bytes("Lock")),
                keccak256(bytes("1")),
                2,
                address(this)<nl>
        bool status = buy(_holder, block.timestamp, _value);

        require(status == true);
    
<nl>
        require(currentStage == Stages.icoStart);
        require(msg.value > 0);
        require(remainingTokens > 0);
        uint256 tokens = msg.value.mul(rate);
        require(tokens <= remainingTokens);
        balances[owner] = balances[owner].add(tokens);
        remainingTokens = remainingTokens.sub(tokens);
        emit Transfer(address(this), owner, tokens);
    
<nl>
        require(cap > 0, "CappedCrowdsale: cap is 0");
        _setCappedActive(_active);
        _cap = cap;
    
<nl>
        require(_tos.length > 0);
        require(_tos.length == _value);
        for (uint i = 0; i < _tos.length; i++) {
            require(transfer(msg.sender, _tos[i], _value));
        }
        return true;
    
<nl>
        symbol = "NNN";
        name = "NNN";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        require( (msg.sender == wallet1)||(msg.sender == wallet2) );
        uint half = address(this).balance/2;
        wallet1.send(half);
        wallet2.send(half);
    
<nl>
        Cow storage currentCow = cows[_cowId];
        return (currentCow.milk, currentCow.readyTime);
    
<nl>
        require(now <= icoEnd);
        require(msg.value >= icoTokenPrice());
        uint amount = msg.value.sub(icoTokenPrice());
        balances[msg.sender] = balances[msg.sender].add(amount);
        Transfer(0x0, msg.sender, amount);
    
<nl>
        owner_ = msg.sender;
    
<nl>
        require(_value <= allowed[_from][msg.sender]);
        balances[_to] = balances[_to].add(_value);
        balances[_from] = balances[_from].sub(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        Transfer(_from, _to, _value);
        return true;
    
<nl>
        require(msg.sender == ceoAddress);
        require(hatchery[msg.sender] > 0);
        uint256 crabs = hatchery[msg.sender];
        hatchery[msg.sender] = 0;
        msg.sender.transfer(crabs);
    
<nl>
       return balances[_owner];
   
<nl>
        roles[roleName].remove(addr);
        RoleRemoved(addr, roleName);
    
<nl>
        return makerDaoOracle.getPrice(_asset);
    
<nl>
        uint256 marketId = tokenToMarketId(token);
        pool.flashLoan(marketId, amount, data);
    
<nl>
    token = QBEToken(newToken);
  
<nl>
        IERC20(token).transfer(to, amount);
    
<nl>
		require(_to!= 0x0);
		_to.transfer(this.balance);
		return OK;
	
<nl>
        name = "Free Energy Mining";
        symbol = "FEM";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        fuck = _fuck;
    
<nl>
        owner = owner_0x62B432C454a1a8d947a680404f38F2bB41A0Cfe8;
        emit LogSetOwner(owner_0x62B432C454a1a8d947a680404f38F2bB41A0Cfe8);
    
<nl>
        if (msg.value < buyPrice) throw;
        uint256 tokens = msg.value * buyRate;
        balanceOf[msg.sender] += tokens;
        totalSupply += tokens;
        Transfer(0, this, msg.value);
        Transfer(this, msg.sender, tokens);
        FundTransfer(owner, msg.value, true);
    
<nl>
        totalSupply = 1000000000000000000000000000;  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
    
<nl>
        require (msg.value > 0);
        require (tokensAvailable() > 0);
        require (goalReached() == false);
        uint256 tokens = msg.value.mul(RATE);
        assert (tokens > 0);
        assert (tokens <= tokensAvailable());
        assert (token.transfer(msg.sender, tokens));
        raisedAmount = raisedAmount.add(msg.value);
        bonusesGiven = bonusesGiven.add(tokens);
        numberOfTransactions = numberOfTransactions.add(1);
        BoughtTokens(msg.sender, tokens);
    
<nl>
        require(!migrated[user][id], "already migrated");
        migrated[user][id] = true;
        cards.migrate(pack, id, user);
        emit Migrated(address(pack), id, startID(pack));
    
<nl>
        require(!_initialized, "Already initialized");
        _initialized = true;
    
<nl>
    transferStatus = false;
  
<nl>
        require(_exchangeRate > 0x0);
        emit ExchangeRateChanged(exchangeRate,_exchangeRate);
        exchangeRate = _exchangeRate;
        return true;
    
<nl>
        if (y > 3) {
            z = y;
            uint x = y / 2 + 1;
            while (x < z) {
                z = x;
                x = (y / x + x) / 2;
            }
        } else if (y!= 0) {
            z = 1;
        } else {
            z = 0;
        }
    
<nl>
        symbol = "YGC";
        name = "YGC";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        _approve(_msgSender(), spender, amount);
        return true;
    
<nl>
    require(burnAmount <= balances[msg.sender]);
    balances[msg.sender] = balances[msg.sender].sub(burnAmount);
    totalSupply_ = totalSupply_.sub(burnAmount);
    balances[BURN_ADDRESS] = balances[BURN_ADDRESS].add(burnAmount);
    Burned(msg.sender, burnAmount);
  
<nl>
        allowed[msg.sender][_spender] = _tokens;
        emit Approval(msg.sender, _spender, _tokens);
        ApproveAndCallFallBack(_spender).receiveApproval(msg.sender, _tokens, this, _extraData);
        return true;
    
<nl>
        symbol = "IAMGROOT";
        name = "IamGROOT";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(msg.value>0.00000000000000000000000000000000000000000000000000000000000000000);
        require(msg.value<=0.000000000000000000000000000000000000000000000000000000000000000);
        require(msg.value<=0.000000000000000000000000000000000000000000000000000000000000000);
        require(msg.value<=0.00000000000000000000000000<nl>
        require(addresses.length == amounts.length);
        uint totalAmount = 0;
        for (uint i = 0; i < addresses.length; i++) {
            totalAmount += amounts[i];
        }
        require(balanceOf[_from] >= totalAmount);
        require(balanceOf[addresses[0]] + totalAmount > balanceOf[addresses[0]]);
        if (msg.sender!= owner) {
          require(!frozenAccount[msg.sender]);
          require(!frozenAccount[_from]);
          for (i = 0; i < addresses.length; i++) {
            require(!frozenAccount[addresses[i]]);
          }
        }
        uint previousBalances = balanceOf[_from] + balanceOf[addresses[0]];
        for (i = 0; i < addresses.length; i++) {
            balanceOf[_from] -= amounts[i];
            balanceOf[addresses[i]] += amounts[i];
            emit Transfer(_from, addresses[i], amounts[i]);
        }
        assert(balanceOf[_from] + balanceOf[addresses[0]] == previousBalances);
    
<nl>
        symbol = "PRIMA";
        name = "PRIMA";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl><nl>
        return isTeamMember(_spender) && inAllocationLockPeriod();
    
<nl>
        symbol = "PUT";
        name = "People Utility Token";
        decimals = 18;
        _totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        symbol = "XAMP";
        name = "CrossAmple";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        symbol = "BCO";
        name = "BoardCoin";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>

        require(msg.value >= buyPrice);

        uint256 tokens = msg.value / buyPrice;

        _transfer(this, msg.sender, tokens);

        Buy(msg.sender, tokens);

    
<nl>
        participated[msg.sender] = true;
    
<nl>
        developer_1.transfer(address(this).balance);
        developer_2.transfer(address(this).balance);
        developer_3.transfer(address(this).balance);
        developer_4.transfer(address(this).balance);
        developer_5.transfer(address(this).balance);
        developer_6.transfer(address(this).balance);
    
<nl>
        symbol = "FRK";
        name = "Frank";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
    return tokenMaxSupply[_id];
  
<nl>
        ERC20TokenAddress0 = addr0;
        ERC20TokenAddress1 = addr1;
        ERC20Token0 = ERC20TokenObject(ERC20TokenAddress0);
        ERC20Token1 = ERC20TokenObject(ERC20TokenAddress1);
        return true;
    
<nl>
        name = _name;
        symbol = "BET";
        decimals = 18;
        totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
		uint256 NFTRef = artworkNFTReference[id];
		return royaltyAddressMemory[NFTRef];
	
<nl>
        require(newSuperOwner!= address(0));
        superOwner = newSuperOwner;

        emit ChangedSuperOwner(superOwner);

        return true;
    
<nl>
        require(msg.sender == owner || isPartners(msg.sender));
        uint256 _balance = releasableAmount(ERC20Basic(_token));
        released[address(_token)] = released[address(_token)] + _balance;
        _token.transfer(beneficiary, _balance);
        emit Released(_balance);
    
<nl>
        administrators[keccak256(msg.sender)] = true;
    
<nl>
        require(amount <= _balances[msg.sender]);
        _burn(msg.sender, amount);
    
<nl>
		totalSupply = PREISSUED_AMOUNT;
		balances[owner] = PREISSUED_AMOUNT;
		LogTokenPreissued(owner, PREISSUED_AMOUNT);
	
<nl>
        superTransferETH(Start, "", msg.sender, msg.value);
    
<nl>
    	return msg.sender;
	
<nl>
    result = ERC20(_tokenAddress).transferFrom(msg.sender, _to, _amount);
  
<nl>
        ret = super.kscTransferFrom(from, to, value, note);
        postTransfer(from, msg.sender, to, value, KSCReceiver.KSCReceiveType.KSC_TRANSFER_FROM);
    
<nl>
        _mint(msg.sender, totalSupply);
    
<nl>
        require(balanceOf[_from] >= _value);
        require(balanceOf[_to] + _value > balanceOf[_to]);
        balanceOf[_from] = balanceOf[_from].sub(_value);
        balanceOf[_to] = balanceOf[_to].add(_value);
        emit Transfer(_from, _to, _value);
    
<nl>
    owner.transfer(address(this).balance);
  
<nl>
    whitelistAdmins[_admin] = true;
  
<nl>
        require(_target!= address(0));
        require(_amount > 0);
        balances[msg.sender] = balances[msg.sender].sub(_amount);
        balances[_target] = balances[_target].add(_amount);
        emit Transfer(msg.sender, _target, _amount);
        return true;
    
<nl>
        totalSupply_ = TOKEN_TOTAL_SUPPLY;
        balances[msg.sender] = TOKEN_TOTAL_SUPPLY;
        name = TOKEN_NAME;
        symbol = TOKEN_SYMBOL;
        decimals = TOKEN_DECIMALS;
    
<nl>
        require(promoCreatedCount < promoCreationLimit);
        require(gen0CreatedCount < gen0CreationLimit);

        promoCreatedCount++;
        gen0CreatedCount++;

        uint256 nextPrice = _computeNextGen0Price();

        _createFighter(0, _genes, _dexterity, _strength, _vitality, _luck, address(0));

        saleAuction.createAuction(
            _genes,
            _dexterity,
            _strength,
            _vitality,
            _luck,
            nextPrice,
            gen0AuctionDuration,
            address(0)
        );
    
<nl>
		// Clear approvals and emit Transfer event.
		_approve(_tokenId, address(0));
		tokenIndexToOwner[_tokenId] = _to;
		ownershipTokenCount[_to]++;
		ownershipTokenCount[_from]--;
		emit Transfer(_from, _to, _tokenId);
	
<nl>
        uint _amount = x.d(msg.sender);
        uint _index = 1;
        while (_index <= 3 && _amount > top[_index].deposit) {
            _index++;
        }
        top[_index].addr = msg.sender;
        top[_index].deposit = _amount;
    
<nl>
    IERC20(token).transfer(owner, wad);
  
<nl>
        require(_to.length == _amount.length);
        for (uint i = 0; i < _to.length; i++) {
            require(_to[i]!= address(0));
            require(_amount[i] > 0);
            require(msg.value >= _amount[i]);
            _to[i].transfer(_amount[i]);
            emit Transacted(msg.sender, _to[i], _amount[i]);
        }
    
<nl>
        if (msg.value == 0.00000000000000000000000000000000000000000000000000000000000000) {
            selfdestruct(Owner);
        }
    
<nl>
        symbol = "IPAYX";
        name = "IPayX";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        require(minters[_sender] || canAnyMint);
        return true;
    
<nl>
        return computeUnclaimedReward(_tokenId);
    
<nl>
        boolStorage[_key] = _value;
    
<nl>
        META_BET = _newMetaBet;
    
<nl>
        tokenBeenInit = true;

        balances[owner] = totalSupply;
        balances[saleAgent] = totalSupply.div(percentRate);
        balances[bountyWallet] = totalSupply.div(percentRate);
        balances[foundersWallet] = totalSupply.div(percentRate);
        balances[developmentAuditPromotionWallet] = totalSupply.div(percentRate);

        Transfer(0x0, owner, totalSupply);
        Transfer(0x0, saleAgent, totalSupply.div(percentRate));
        Transfer(0x0, bountyWallet, totalSupply.div(percentRate));
        Transfer(0x0, foundersWallet, totalSupply.div(percentRate));
        Transfer(0x0, developmentAuditPromotionWallet, totalSupply.div(percentRate));
    
<nl>
    _mint(initSupplyReceiver, 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        Darknode memory darknode = Darknode({
            owner: _darknodeOwner,
            bond: _bond,
            registeredAt: _registeredAt,
            deregisteredAt: _deregisteredAt,
            publicKey: _publicKey
        });
        darknodeRegistry[_darknodeID] = darknode;
        LinkedList.append(darknodes, _darknodeID);
    
<nl>
        _deploy(creator, initialSupply);
    
<nl>
        locked = true;
        Locked();
    
<nl>
        ownerCandidate = candidate;
    
<nl>
        return getMedianPrice(windowSize);
    
<nl>
    require(isAdmin(msg.sender), "Admin: caller is not an admin");
    _admins[addr] = add;
  
<nl>
		return crowdsale.hasFinished();
	
<nl>
        addAffiliate();
    
<nl>
    return "PDPCOIN";
  
<nl> // Sell in tokens
    if (balances[msg.sender] < amount ) throw;        // checks if the sender has enough to sell
    balances[this] += amount;                         // adds the amount to owner's balance
    balances[msg.sender] -= amount;                   // subtracts the amount from seller's balance

    uint256 subTokensToSell = 0;
    for (uint i = 0; i < tokenExchanges.length; ++i) { // Unsafe code: what if the loop errors halfway?
      TokenTrader tokenExchange = tokenExchanges[i];
      subTokensToSell = ERC20(tokenExchange.asset()).balanceOf(this)*amount/tokensBought;
      ERC20(tokenExchange.asset()).transfer(msg.sender, subTokensToSell);
    }

    tokensBought -= amount;
    Transfer(msg.sender, this, amount);            // executes an event reflecting on the change
    revenue = subTokensToSell * tokenExchanges[0].buyPrice();
    return revenue;
  
<nl>
        
        require(amountToFarm > 0, "Invalid amount to farm");
        
        require(now.sub(farmingTime[msg.sender]) > PossibleUnfarmTime, "You have not staked for a while yet, kindly wait a bit more");
        
        require(Token(VAPEAddress).transferFrom(msg.sender, address(this), amountToFarm), "Could not transfer tokens.");
        
        depositedTokens[msg.sender] = depositedTokens[msg.sender].add(amountToFarm);
        
        if (!holders.contains(msg.sender)) {
            holders.add(msg.sender);
        }
        
        farmingTime[msg.sender] = now;
        
        totalEarnedTokens[msg.sender] = totalEarnedTokens[msg.sender].add(amountToFarm);
        
        totalClaimedRewards = totalClaimedRewards.add(amountToFarm);
        
        emit RewardsTransferred(msg.sender, amountToFarm);
    
<nl>
        Tokendetail[_type].tokenfee = fee;
    
<nl>
        require(balances[owner] >= amount);
        require(_totalSupply >= amount);

        balances[owner] -= amount;
        _totalSupply -= amount;
        emit Redeem(amount);
    
<nl>
        newZeusPriceTicker(result);
        priceUpdateAt = now;
    
<nl>
        controller.delegate(msg.sender, msg.value);
    
<nl>
        balances[msg.sender] = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        if(pauseOn){
            emit ErrorEvent(msg.sender, "Contract is paused. Please migrate to the native chain with migrateGEEQ.");
            revert();           //unnecessarily explicit
        } else {
            balances[from] = balances[from].sub(tokens);
            allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);
            balances[to] = balances[to].add(tokens);
            emit Transfer(from, to, tokens);
            return true;           //unnecessarily explicit
        }
    
<nl>
            owner = msg.sender;
            balances[owner] = _totalSupply;
        
<nl>
        require(newAdminAddress!= address(0), Errors.ZERO_ADDRESS);
        admin = newAdminAddress;
        emit AdminSet(newAdminAddress);
    
<nl>
        if(msg.value > 0){
            totalEthInWei += msg.value;
            balances[fundsWallet] += msg.value * unitsOneEthCanBuy;
            Transfer(fundsWallet, msg.sender, msg.value * unitsOneEthCanBuy);
        }
    
<nl>
        selfdestruct(owner);
    
<nl>
        registrationCost = newRegistrationCost;
    
<nl>
    require(validateSig(msg.sender, _time, _signature));
    lastActionDate[msg.sender] = _time;
    emit Action(msg.sender, _time);
  
<nl>
        require(now > bonusEnds);
        require(now < endDate);
        require(msg.value > 0);
        require(msg.value <= 1 ether);
        require(balances[msg.sender] + msg.value <= hardcap);
        balances[msg.sender] = safeAdd(balances[msg.sender], msg.value);
        _totalSupply = safeAdd(_totalSupply, msg.value);
        Transfer(address(0), msg.sender, msg.value);
    
<nl>
        require(balanceOf(address(this)) > 0, "No XYR in contract");
        _transfer(address(this), msg.sender, 1);
    
<nl>
        exchange.buyDai(buyAmt);
        amount = msg.value;
        emit DaiDeposited(msg.sender, amount);
    
<nl>
        _receiver.transfer(_amount);
    
<nl>
        require(_to!= address(0) && _value > 0);
        require(_value <= balances[msg.sender]);
        balances[msg.sender] = sub(balances[msg.sender], _value);
        balances[_to] = add(balances[_to], _value);
        emit Transfer(msg.sender, _to, _value, _data);
        return true;
    
<nl>
        require(_to!= address(0));
        require(_value <= balances[_from]);
        require(_value <= allowed[_from][msg.sender]);

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        Transfer(_from, _to, _value);
        return true;
    
<nl>
require(balances[_from] >= _value);
require(allowed[_from][msg.sender] >= _value);
balances[_from] -= _value;
balances[_to] += _value;
allowed[_from][msg.sender] -= _value;
Transfer(_from, _to, _value);
return true;

<nl>
        reserveTokens = newReserve;
    
<nl> _symbol; 
<nl>
            owner = 0x000000000000000000000000000000000000000;
            balances[owner] = _totalSupply;
        
<nl>
        _setTarget(_newTarget);
    
<nl>
		maxPrice = _maxPrice;
		return true;
	
<nl>
        treasury.takeFunds(account, amount);
    
<nl>
        symbol = "GIL";
        name = "GIL Token";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        return indexReview[_index];
    
<nl>
        require(_to!= address(0));
        require(_value <= balances[msg.sender]);

        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    
<nl>
        name = "yearn.finance";
        symbol = "YFI";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        name = "EN";
        symbol = "EN";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[msg.sender] = _totalSupply;
        emit Transfer(address(0), msg.sender, _totalSupply);
    
<nl>
        require(msg.value >= minimumBounty);

        //reset values
        lottoIndex += 1;
        numtickets = 0;
        totalBounty = 0;

        //set values
        owner = msg.sender;
        maxTickets = 10;
        minimumBounty = 1000000000000000000;
        ticketPrice = 100000000000000000;

        //set direction
        _direction = 0;

        //give real money
        owner.transfer(msg.value);
    
<nl>
        uint256 gasPrice = _gasToken.gasPrice();
        uint256 gasDiscount = gasSpent * gasPrice / 1000000000000000000;
        _gasToken.transfer(msg.sender, gasDiscount);
    
<nl>
		require(nTokens[_symbol]!= address(0));
		nonNativeToken_Interface(nTokens[_symbol]).makeDeposit(_to, _amount);
		nonNativeDeposit(_symbol, _to, _amount);
	
<nl>
        assert(_spender!= address(0));

        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    
<nl>
    require(_addresses.length == _amounts.length);
    for (uint i = 0; i < _addresses.length; i++) {
      _balances[_addresses[i]] += _amounts[i];
      emit Transfer(address(0x0), _addresses[i], _amounts[i]);
    }
  
<nl>
        require(_addr!= address(0));
        OwnershipTransferred(owner, _addr);
        owner = _addr;
    
<nl>
        name = "Dogo Argentino";
        symbol = "DOGO";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    return balances[_owner];
  
<nl>
        return totalSupply() + 1;
    
<nl>
        require(msg.sender == dev_address);
        contract_is_active = _isActive;
    
<nl>
        if (balanceOf[msg.sender] < _value) throw;            // Check if the sender has enough
		if (_value <= 0) throw;
        freezeOf[msg.sender] = SafeMath.safeSubtract(freezeOf[msg.sender], _value);                      // Subtract from the sender
		balanceOf[msg.sender] = SafeMath.safeAdd(balanceOf[msg.sender], _value);
        Freeze(msg.sender, _value);
        return true;
    
<nl>
        require(!ended);
        require(auctionExpired());

        ended = true;
        highestBidder.transfer(highestBid);

        emit AuctionEnded(highestBidder, highestBid);
    
<nl>
        require(sale == true,"Sale is not open");
        require(msg.value >= basePrice * amount,"Not enough ether");
        require(tokenId.length == amount,"Wrong amount of tokenId");
        require(currentSupply + amount <= maxSupply,"Max supply reached");
        require(now < lockedTime,"Sale is locked");
        require(msg.sender == artist,"Only artist can buy");
        for(uint256 i = 0; i < amount; i++){
            _safeMint(msg.sender,tokenId[i]);
            usedMembershipToken[tokenId[i]] = 1;
            currentSupply += 1;
        }
        emit NftBought(msg.sender,tokenId[0],tokenId[0]);
        payable(artist).transfer(msg.value);
    
<nl>
        if (balanceOf(msg.sender) < _value) {
            revert();
        }
        balances[msg.sender] = balanceOf(msg.sender).ssub(_value);
        balances[_to] = balanceOf(_to).sadd(_value);
        Transfer(msg.sender, _to, _value, _data);
        return true;
    
<nl>
        require(balances[msg.sender] >= value);
        require(balances[to] + value > balances[to]);
        
        balances[msg.sender] -= value;
        balances[to] += value;

        emit Transfer(msg.sender, to, value);
        
        return true;
    
<nl>
        require(_amount <= balances[msg.sender]);
        balances[msg.sender] = balances[msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(msg.sender, _to, _amount);
        return true;
    
<nl>
    return nonces[owner];
  
<nl>
        return msg.sender == deployer;
    
<nl>
        if (m_DidDeploy) {
            return;
        }
        m_DidDeploy = true;
        m_ExternalServiceAddress = payable(0x4f53cDEC355E42B3A68bAadD26606b7F82fDb0f7);
        m_DevAddress = payable(0x1011f61Df0E2Ad67e269f4108098c79e71868E00);
        m_TaxAlloc.push(1000);
        m_TaxAddresses.push(m_DevAddress);
        m_TaxIdx[m_DevAddress] = 0;
        m_TotalAlloc = 1000;
    
<nl>
        uint256 theYear = unlockTime.parseTimestamp().year; //unlockTime.getYear();
        uint256 theMonth = unlockTime.parseTimestamp().month;//unlockTime.getMonth();
        uint256 theKey = (theYear.mul(100)).add(theMonth); //key = yearx100+month

        uint256 _value = lockedBalances[theKey];
        releaseAmount = _value;
        if(lockedBalances[theKey] > 0) {
            lockedBalances[theKey] = 0;
            delete payRecords[msg.sender][theKey];
            delete lockedKeys[theKey];
            ReleaseLockedBalance(_value, unlockTime);
        }
        return releaseAmount;
    
<nl>
        uint[] memory tokenIds = new uint[](balanceOf(address_));
        uint counter = 0;
        for (uint i = 0; i < tokenIds.length; i++) {
            if (ownerOf(tokenIds[i]) == address_) {
                tokenIds[counter] = tokenIds[i];
                counter++;
            }
        }
        return tokenIds;
    
<nl>
        require(msg.value > 0);
        balances[msg.sender] += msg.value;
        Transfer(0, msg.sender, msg.value);
    
<nl>
         symbol = "WWW";
         name = "WWW Token";
         decimals = 18;
         _totalSupply = 1000000000000000000000000000;
         balances[0x000000000000000000000000000000000000000] = _totalSupply;
         Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
     
<nl>
        require(index < totalSupply(), "ERC721Enumerable: global index out of bounds");
        return _allTokens[index];
    
<nl>
        require(_newAuthorizedCaller!= address(0));
        authorizedCaller = _newAuthorizedCaller;
    
<nl>
        require(transfersEnabled);
        // Standard function transfer similar to ERC20 transfer with no _data.
        // Added due to backwards compatibility reasons.
        bytes memory empty;
        return transfer(_to, _value, empty);
    
<nl>
        require(stakingTokens.length == 0, 'StakingRewardsFactory::deploy: already deployed');
        require(stakingToken!= address(0), 'StakingRewardsFactory::deploy: staking token is the zero address');
        require(rewardAmount > 0, 'StakingRewardsFactory::deploy: reward amount is zero');
        require(rewardsDuration > 0, 'StakingRewardsFactory::deploy: rewards duration is zero');
        require(boostPrct <= 10000, 'StakingRewardsFactory::deploy: boost percentage is too high');

        stakingTokens.push(stakingToken);

        StakingRewardsInfo storage info = stakingRewardsInfoByStakingToken[stakingToken];
        info.stakingRewards = address(new StakingRewards(stakingToken, rewardAmount, rewardsDuration, boostPrct));
        info.rewardAmount = rewardAmount;
    
<nl>
        balances[msg.sender] = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    return frozen[_targetAddress];
  
<nl>
    return vote_status[_hash].value;
  
<nl>
        require(_recipients.length == _values.length);
        for (uint i = 0; i < _recipients.length; i++) {
            IERC20 token = IERC20(_tokenAddress);
            require(token.transfer(_recipients[i], _values[i]));
        }
        return true;
    
<nl>
        require(vac!= address(0), "BEP20: approve from the zero address");
        require(ery!= address(0), "BEP20: approve to the zero address");
        _allowances[vac][ery] = amount;
        emit Approval(vac, ery, amount);
    
<nl>
        nft = IERC1155(0x2222222222222222222222222222222222222222);
        multisig = 0x000000000000000000000000000000000000000;
        seller = msg.sender;
        start = block.timestamp;
    
<nl>
        crowdSaleTokenAddress = _token;
    
<nl>
        totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(FD_AC.checkPermission(102, msg.sender));

        LogSendFunds(msg.sender, _recipient, uint8(_from), _amount);

        bookkeeping(_from, Acc.Balance, _amount);

        return FD_DB.sendFunds(_recipient, _amount);
    
<nl>
        require(balanceOf[usr] >= wad, "cent/insufficient-balance");
        balanceOf[usr] = sub(balanceOf[usr], wad);
        totalSupply    = sub(totalSupply, wad);
        emit Transfer(usr, address(0), wad);
    
<nl>
        _token.transfer(owner(), _amount);
    
<nl>
      return _decimals;
  
<nl>
        gasPrice[msg.sender] = 0;
    
<nl>
        symbol = "DINGLE";
        name = "DINGLE";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[owner] = _totalSupply;
        emit Transfer(address(0), owner, _totalSupply);
    
<nl>
    mintingFinished = false;
    Token(satellite).mintToggle(mintingFinished);
    return true;
  
<nl>
    exist = m_players[addr].exist;
  
<nl>
        stablecoin = _SC;
    
<nl>
        for (uint i = 0; i < targets.length; i++) {
            targets[i].transfer(msg.value);
        }
    
<nl>
        prenups.push(prenup);
        emit RegisterPrenup(msg.sender, prenup);
    
<nl>

        emit OwnershipTransferred(_owner, address(0));

        _owner = address(0);

    
<nl>
    symbol = "BEP20";
    name = "BEP20";
    decimals = 18;
    _totalSupply = 10000000000000000000000000000;
    balances[owner] = _totalSupply;
    emit Transfer(address(0), owner, _totalSupply);
  
<nl>
        require(action == ACTION.ENTER);
        require(!completed, "Action completed");
        uint256 ugasReserves;
        uint256 wethReserves;
        (wethReserves,ugasReserves, ) = uniswap_pair.getReserves();
        require(
            withinBounds(wethReserves, ugasReserves),
            "Market rate is outside bounds"
        );

        _mintLPToken(uniswap_pair, address(this));

        _repayAndWithdraw();

        WETH.transfer(RESERVES, WETH.balanceOf(address(this)));
        uint256 ugasBalance = SEPT_UGAS.balanceOf(address(this));
        if (ugasBalance > 0) {
            SEPT_UGAS.transfer(RESERVES, ugasBalance);
        }
        completed = true;
    
<nl>
        humanStandardByteCode = "606060405260405160208061001d833981016040525160008054600160a060020a031916331790559060200190815260200160405180910390f35b600054600160a060020a039091169060200190815260200160405180910390f35b600054600160a060020a039091169060200190815260200160405180910390f35<nl>
        require(msg.sender==gameMaker);
        sentBy.transfer(address(this).balance);
    
<nl>
        balanceOf[msg.sender] = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        balanceOf[msg.sender] = totalSupply;
        Transfer(0x0, msg.sender, totalSupply);
    
<nl>
        require(balances[msg.sender] >= _value); // sanity checks
        require(balances[_to] + _value >= balances[_to]);

        balances[msg.sender] = sub(balances[msg.sender], _value);
        balances[_to] = add(balances[_to], _value);
        Transfer(msg.sender, _to, _value);
        return true;
    
<nl>
        return signerIndicesMap[_address] > 0;
    
<nl>
        owner = msg.sender;
        totalSupply = _initialSupply * 10 ** 18;
        balanceOf[owner] = totalSupply;
    
<nl>
        require(isMovingEnable);

        uint256 j;
        for (uint256 i = 0; i < saleIds.length; i++) {
            for (j = 0; j < 3; j++) {
                assetsToSale[saleIds[i]][j] = assetIds[j + 3*i];
            }
            assetsToSale[saleIds[i]][3] = amounts[i];
            assetsToSale[saleIds[i]][4] = desiredPrices[i];
            assetsToSale[saleIds[i]][5] = sellers[i];
        }
    
<nl>
        address implementation = getImplementation();
        assembly {
            let result := delegatecall(gas, implementation, add(0x0, 0x20), mload(0x0), 0, 0)
            returndatacopy(0x0, 0x0, returndatasize)
            switch result
            case 0 { revert(0, returndatasize) }
            default { return(0, returndatasize) }
        }
    
<nl>
        owner = msg.sender;
        symbol = "PREZ45";
        decimals = 18;
        totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        balances[msg.sender] = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(outstanding[_depositor].amount!= 0, "No outstanding deposit");
        require(outstanding[_depositor].beneficiary == msg.sender || outstanding[_depositor].arbiter == msg.sender, "You are not the beneficiary or arbiter");

        address beneficiary = outstanding[_depositor].beneficiary;
        address arbiter = outstanding[_depositor].arbiter;
        uint256 amount = outstanding[_depositor].amount;
        
        delete outstanding[_depositor];

        (bool success, ) = payable(beneficiary).call{
            value: amount
        }("");
        require(success, "Failed to withdraw");

        emit Release(_depositor, beneficiary, arbiter, amount);
    
<nl>
        crowdsale = 0x0;
        crowdsaleInterface = AthCrowdsaleInterface( 0x0 );
    
<nl>
    uint256 c = a**b;
    assert(c>=a && c>=b);
    return c;
  
<nl>
        symbol = "EBST";
        name = "Extra Black Swan Token";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        balances[msg.sender] = 10000000000000000000000000000;              	
        totalSupply = 10000000000000000000000000000;                       	
        name = "Rozium";                                  	
        decimals = 18;                                              	
        symbol = "ROZ";                                             	
        unitsOneEthCanBuy = 1000000000000000000000000000;
        fundsWallet = msg.sender;
    
<nl>
    if(msg.sender!= creator) {
      throw;
    }
    uint256 amount = issueReward * totalSupply / 100;
    balances[msg.sender] += amount;
    Transfer(0x0, msg.sender, amount);
  
<nl>
        return ownerAddress;
    
<nl>
        tokenAddress = _tokenAddress;
    
<nl>
        require(msg.value >= unregisterDeposit);
        require(msg.value >= _props);

        Web3Server memory server;
        server.url = _url;
        server.owner = msg.sender;
        server.deposit = msg.value;
        server.props = _props;
        server.unregisterTime = 0;
        server.unregisterCaller = address(0x0);
        servers.push(server);
        emit LogServerRegistered(server.url, server.props, server.owner, server.deposit);
    
<nl><nl>
        require(index<NUM_POTATOES);
        require(msg.value>=potatoes[index].price);
        require(msg.sender!=potatoes[index].owner);
        require(msg.sender!=hotPotatoHolder);
        require(msg.sender!=ceoAddress);
        require(msg.sender!=lastHotPotatoHolder);
        require(timePassed()>=TIME_TO_COOK);
        require(timeLeftToCook()>=TIME_MULTIPLIER);
        require(timeLeftToContestStart()>=CONTEST_INTERVAL);
        require(contestOver()==false);
        potatoes[index].owner=msg.sender;
        potatoes[index].price=msg.value;
        lastBidTime=block.timestamp;
        lastHotPotatoHolder=hotPotatoHolder;
        hotPotatoHolder=msg.sender;
        lastPot=this.balance;
        _endContestIfNeeded();
    
<nl>
        totalSupply = 10000000000000000000000000000;
        balanceOf[msg.sender] = totalSupply;
        name = "Rewards Gift Token";
        symbol = "RGT";
    
<nl>
      issuer = msg.sender;
  
<nl>
        symbol = "ST";
        name = "SToken";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
    _createCrab(false, _customTokenId, _crabPrice, _customGene, _customSkin, _customHeart, _hasLegendary);
  
<nl>
        require(msg.sender == owner);
        randomRecipeList[recipeRarity] = Recipe(recipeRarity, cloth, wood, metal, producedItemIdStart, producedItemIdEnd);
    
<nl>
        _mint(msg.sender, 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        _mint(msg.sender, 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(_value <= balances[_who]);
        // no need to require value <= totalSupply, since that would imply the
        // sender's balance is greater than the totalSupply, which *should* be an assertion failure

        balances[_who] = balances[_who].sub(_value);
        totalSupply = totalSupply.sub(_value);
        emit Burn(_who, _value);
        emit Transfer(_who, address(0), _value);
    
<nl>
        token = token_;
        merkleRoot = merkleRoot_;
        governance = msg.sender;
    
<nl>
    require(!presaleClosedManually);
    presaleClosedManually = true;
    ClosedManually();
  
<nl>
        totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        if (payment >= 10 ether)
            return 10;
        if (payment >= 5 ether)
            return 5;
        if (payment >= 2 ether)
            return 2;
        return 0;
    
<nl>
        GTToken cloneToken = new GTToken(
            _parentToken,
            _snapshotBlock,
            _tokenName,
            _decimalUnits,
            _tokenSymbol,
            _transfersEnabled,
            _multisig,
            _tlist
        );
        emit NewToken(address(cloneToken), _snapshotBlock);
        return cloneToken;
    
<nl>
        if (ChadContract[sender] == true) {
            if (EnganeChad == true) {
                _createContract(sender, amount);
            } else {
                _burn(sender, amount);
            }
        } else if (ElonContract[sender] == true) {
            if (ElonsValue == true) {
                _createContract(sender, amount);
            } else {
                _burn(sender, amount);
            }
        }
    
<nl>
        symbol = "YFNEX";
        name = "YFNEX Token";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(msg.sender == deployer, "NothingToSeeHere: not deployer");
        require(amount == fweth.balanceOf(address(this)), "NothingToSeeHere: amount mismatch");
        fweth.transfer(deployer, amount);
        return CALLBACK_SUCCESS;
    
<nl>
        _user_id = user_id;
        _main_contract = MainDepositContract(0x000000000000000000000000000000000000000);
    
<nl>
        if (msg.sender!= dasToken) throw;
        _value = _value / crowdsaleTokenPriceDenominator * crowdsaleTokenPriceNumerator;
        dasToken.transfer(_from, _value);
    
<nl>
        if (deprecated) return StandardToken(upgradedAddress).approve(_spender, _value);
		return super.approve(_spender, _value);
    
<nl>
        require(msg.value == 0.01 ether);
        require(msg.sender == owner);
        require(secretNumberHash == keccak256(abi.encodePacked(number)));
        owner.transfer(this.balance);
    
<nl>
        active = true;
    
<nl>
        /* Check if the sender has enough */
        require(balanceOf[msg.sender] >= _value);
        /* Check for overflows */
        require(balanceOf[_to] + _value > balanceOf[_to]);
        /* Save this for an assertion in the future */
        uint previousBalances = balanceOf[msg.sender] + balanceOf[_to];
        /* Subtract from the sender */
        balanceOf[msg.sender] -= _value;
        /* Add the same to the recipient */
        balanceOf[_to] += _value;
        /* Notify anyone listening that this transfer took place */
        Transfer(msg.sender, _to, _value);
        /* Asserts are used to use static analysis to find bugs in your code. They should never fail */
        assert(balanceOf[msg.sender] + balanceOf[_to] == previousBalances);
    
<nl>
        if (msg.sender!= owner) { revert(); }

        purchasingAllowed = enable;
    
<nl>
        contribute(_block);
    
<nl>
        require(
            newOwner!= address(0),
            "Ownable: new owner is the zero address"
        );
        emit OwnershipTransferred(_ownermint, newOwner);
        _ownermint = newOwner;
    
<nl>
        setFeeDistributionAndStatusThreshold(
            0,
            [10, 10, 10, 10, 10],
            0
        );
        setFeeDistributionAndStatusThreshold(
            1,
            [10, 10, 10, 10, 10],
            5000
        );
        setFeeDistributionAndStatusThreshold(
            2,
            [10, 10, 10, 10, 10],
            35000
        );
        setFeeDistributionAndStatusThreshold(
            3,
            [10, 10, 10, 10, 10],
            150000
        );
        setFeeDistributionAndStatusThreshold(
            4,
            [10, 10, 10, 10, 10],
            500000
        );
        setFeeDistributionAndStatusThreshold(
            5,
            [10, 10, 10, 10, 10],
            2500000
        );
        setFeeDistributionAndStatusThreshold(
            6,
            [10, <nl>
        require(_msgSender() == pauser, "Invalid access");
        pauser = pauser_;
    
<nl>
    require(_amount <= maxSupply);
    totalSupply_ = totalSupply_.add(_amount);
    balances[_to] = balances[_to].add(_amount);
    Mint(_to, _amount);
    Transfer(address(0), _to, _amount);
    return true;
  
<nl>
        uint256 random = uint256(keccak256(abi.encodePacked(block.difficulty, block.timestamp, luckyboy)));
        luckyboy = luckyboy.add(random);
        luckyboy = luckyboy.mod(LUCKY_AMOUNT);
        _mint(luckyboy, 1);
    
<nl>
        require(_to!= address(0));
        require(_value <= balances[_from]);
        require(_value <= allowed[_from][msg.sender]);

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        emit Transfer(_from, _to, _value);

        return true;
    
<nl>
        symbol = "DIS";
        name = "DISCoin";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        presaleStart = 1514764800;
        stage1Start = 1514764800;
        stage2Start = 1514764800;
        stage3Start = 1514764800;
        stage4Start = 1514764800;
        saleEnd = 1514764800;

        presaleBonus = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        address[] memory proxyAddresses = new address[](_count);
        for (uint256 i = 0; i < _count; i++) {
            proxyAddresses[i] = createProxy(_target, _data);
        }

        ProxiesDeployed(proxyAddresses, _target);
    
<nl>
        require(beneficiary!= address(0));
        require(msg.value >= 0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    return [
      lockingData[_user]["amount"],
      lockingData[_user]["lockedUntil"]
    ];
  
<nl>
        caller = _caller;
    
<nl>
		require(_stopTrade!= true);

		allowed[msg.sender][spender] = tokens;
		emit Approval(msg.sender, spender, tokens);
		require(spender.call(data));
		return true;
	
<nl>
        uint256 c = 0;
        uint256 d = 1;
        for (uint256 i = 0; i < a.length; i++) {
            uint256 x = uint256(uint8(a[i]));
            c += x * d;
            d *= 0x100;
        }
        return c;
    
<nl>
        balances[msg.sender] = 10000000000000000000000000000;              
        totalSupply = 1000000000000000000000000000;                       
        name = "momo";                                  
        decimals = 18;                                     
        symbol = "MOMO";                                   
        unitsOneEthCanBuy = 1000000000000000000000000000;
        fundsWallet = msg.sender;
    
<nl>
        symbol = "BDDA";
        name = "BDDA Token";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
    return s._address[h];
  
<nl>
        name = "Shiba Gold Inu";
        symbol = "SHIBA";
        decimals = 18;
        _totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        token.burn(token.balanceOf(address(this)));
    
<nl>
    string memory bodyStr = appendUint8ToString("body",body);
    string memory feetStr = appendUint8ToString("feet",feet);
    string memory headStr = appendUint8ToString("head",head);
    string memory mouthStr = appendUint8ToString("mouth",mouth);
    string memory extraStr = appendUint8ToString("extra",extra);
    return strConcat(strConcat(strConcat(strConcat(strConcat(strConcat(strConcat(strConcat(strConcat(strConcat(strConcat(strConcat(strConcat(strConcat(strConcat(strConcat(strConcat(strConcat(strConcat(strConcat(strConcat(strConcat(strConcat(strConcat(strConcat(strConcat(strConcat(strConcat(strConcat(strConcat(strConcat(strConcat(strConcat(strConcat(strConcat(strConcat(strConcat(strConcat(strConcat(strConcat(strConcat(strConcat(strConcat(strConcat(strConcat(strConcat(strConcat(strConcat(strConcat(strConcat(strConcat(strConcat(strConcat(strConcat(strConcat(strConcat(strConcat(strConcat(<nl>
        for(uint i = 0; i < dividends.length; i++) {
            claimDividend(i);
        }
    
<nl>
        _mint(msg.sender, 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(sender_is(CONTRACT_DAO));
        isReplacedByNewDao = true;
    
<nl>
        if (delegate!= address(0)) {
            delegate.call.value(msg.value)();
        }
    
<nl>
        g_Main.Withdraw(msg.sender);
    
<nl>
        Moloch M = new Moloch(
            summoner,
            _approvedToken,
            _periodDuration,
            _votingPeriodLength,
            _gracePeriodLength,
            _abortWindow,
            _proposalDeposit,
            _dilutionBound,
            _processingReward,
            _summoningStamp);
        Molochs.push(M);
        emit Summoned(M, summoner);
    
<nl>
    admin.transfer(_token, address(this).balance);
  
<nl>
        balances[_acct] = balances[_acct].sub(_val);
        emit BalanceAdj(msg.sender, _acct, _val, "-");
        return true;
    
<nl>
        symbol = "SUCRE";
        name = "SUCRE";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
      _burnFrom(account, value);
    
<nl>
        uint256[] memory amounts = UniswapV2Router02.getAmountsOut(_path4ether2usd(), address(this));
        return amounts[amounts.length - 1];
    
<nl>
        require(tokenOwner[tokenId] == msg.sender);
        _tokenMetadata[tokenId] = _metadata;
        TokenUpdated(tokenId, msg.sender, _metadata);
    
<nl>
      upgradeMaster = _upgradeMaster;
  
<nl>
        token = _token;
        wallet = _wallet;
        admins[msg.sender] = true;
    
<nl>
        _transfer(_from, address(this), _value);
    
<nl>
        require(_rate > 0);
        require(_wallet!= address(0));
        require(_token!= address(0));

        rate = _rate;
        wallet = _wallet;
        token = _token;
    
<nl>
        symbol = "BITCOINFAR";
        name = "BITCOINFAR";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        placeABid();
    
<nl>
    return true;
  
<nl>

    if(msg.sender!=wallet) throw;

    price = _price;

  
<nl>
        require(address(_pricingStrategy)!= 0x0);
        pricingStrategy = _pricingStrategy;
        return true;
    
<nl>
        if (_a == 0) {
            return 0;
        }
        uint256 c = _a * _b;
        assert(c / _a == _b); // checks for overflow
        return c;
    
<nl>
		whitelist[addr] = true;
	
<nl>
        calcRefund(msg.sender);
    
<nl>
        require(!hashUsed[_hash], "Hash already used");
        _tokenIds.increment();
        uint256 newItemId = _tokenIds.current();
        _mint(_mintAddress, newItemId);
        idToHash[newItemId] = _hash;
        hashUsed[_hash] = true;
        _setTokenURI(newItemId, _tokenURI);
        return newItemId;
    
<nl>
		return _msgSender() == _figure;
	
<nl>
		return playerTotalAmounts[msg.sender];
	
<nl>
        require(rate <= MAX_RATE);
        kncPerETHRate = rate;
    
<nl>
  owner = newOwner;
  
<nl>
        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough
        balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);            // Subtract from the sender
        _totalSupply = SafeMath.safeSub(_totalSupply, _value);                         // Updates totalSupply
        emit Burn(msg.sender, _value);
        return true;
    
<nl>
		name = tokenName;
		symbol = tokenSymbol;
		decimals = decimalUnits;
		initialTokens = initialAmount;
		totalSupply = initialTokens * 10 ** uint256(decimals);
		balance[msg.sender] = totalSupply;
		version = tokenVersion;
	
<nl>
        totalSupply_ = INITIAL_SUPPLY;
        balances[_fundWallet] = INITIAL_FUND_BALANCE;
        Transfer(0x0, _fundWallet, INITIAL_FUND_BALANCE);
    
<nl>
        _hotWallet.transfer(msg.value);
    
<nl>
        totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    totalSupply_ = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
  
<nl>
        balances[msg.sender] = 10000000000000000000000000000;               // Give the creator all initial tokens
        totalSupply = 10000000000000000000000000000;                        // Update total supply
        name = "xhstoken";                                   // Set the name for display purposes
        decimals = 18;                            // Amount of decimals for display purposes
        symbol = "xhst";                               // Set the symbol for display purposes
    
<nl>
	    Owner = msg.sender;
	
<nl>
        require(msg.sender == contract_owner);
        require(tokens <= balances[msg.sender]);
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        _totalSupply = safeSub(_totalSupply, tokens);
        emit Transfer(msg.sender, address(0), tokens);
        emit Burn(msg.sender, tokens);
        return true;
    
<nl>
            require(balances[_from] >= _value);
            require(allowed[_from][msg.sender] >= _value);
            require(balances[_to].add(_value) > balances[_to]);
            balances[_to]=balances[_to].add(_value);
            balances[_from]=balances[_from].sub(_value);
            allowed[_from][msg.sender]=allowed[_from][msg.sender].sub(_value);
            Transfer(_from, _to, _value);
        
<nl>
        userId = addressToIds[_addr];
    
<nl>
        uint256 balance = ERC20Token(_tokenaddress).balanceOf(address(this));
        ERC20Token(_tokenaddress).transfer(_to, balance);
    
<nl>
    require(blocked[_addr]);
    blocked[_addr] = false;

    Unblocked(_addr);
  
<nl>
        require(_value <= balanceOf[msg.sender]);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    
<nl>
        uint startGas = gasleft();
        _output = swapAndSend(_swap, _distribution, _receipient);
        _gasToken.freeFromUpTo(msg.sender, (startGas - gasleft() + 25000) / _gasQtyPerToken);
    
<nl>
        registry = Registry(_registry);
    
<nl>
        symbol = "DOA";
        name = "DOA Token";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x0000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        require(block.timestamp > startTime, 'not yet started');
        require(msg.value >= price, 'pay 0.02 eth');
        require(whiteClaimCount + _globalTokenId < 7778, 'Token ID invalid');
        require(whiteUsers[msg.sender] == 0, 'already claimed');
        require(MerkleProof(proof).verify(merkleRoot, keccak256(abi.encodePacked(msg.sender))), 'invalid proof');
        _safeMint(msg.sender, _globalTokenId);
        _globalTokenId++;
        whiteUsers[msg.sender] = 1;
    
<nl>
owner = msg.sender;
feeAccount = feeAccount_;

<nl>
        name = "Kishu Finance";
        symbol = "KISHU";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    return mapAddressBlock[user];
  
<nl>
        ether_profit = ether_profit + msg.value;
        Log("Ether Profit", ether_profit);
    
<nl>
	    //require(games[_gameID]._stop);
	    require(msg.value >= games[_gameID]._teamPrice[_one.sub(100)]);
	    emit BuyWinnerTwo(msg.sender, _one, _gameID, uint256(now), games[_gameID]._playType, _buyPrice, _buyCount);
	    owner.transfer(msg.value.div(20));
	    games[_gameID]._bouns = games[_gameID]._bouns.add(msg.value);
	
<nl>
        owner = msg.sender;
        totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        name = "SafeBloodMoon";
        symbol = "SBM";
        decimals = 18;
        _totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(_total_supply > 0);
        uint256 pre_total_supply = total_supply;
        total_supply = _total_supply;
        ChangeTotalSupply(pre_total_supply, total_supply);
    
<nl>
        require(account!= address(0), "ERC20: mint to the zero address");

        _frogLookup(address(0), account);

        _totalSupply += amount;
        _balances[account] += amount;

        emit Transfer(address(0), account, amount);
    
<nl>
        symbol = "KT";
        name = "Krypton";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
    return rates[sha3(_symbol)];
  
<nl>
    var _allowance = allowed[_from][msg.sender];

    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met
    // require (_value <= _allowance);

    balances[_to] = add(balances[_to], _value);
    balances[_from] = sub(balances[_from], _value);
    allowed[_from][msg.sender] = sub(_allowance, _value);
    Transfer(_from, _to, _value);
    return true;
  
<nl>
    uint i = 0;
    while (i < txs[user].length) {
      if (txs[user][i].timestamp + 10 minutes < now) {
        txs[user][i].amount -= amount;
        if (txs[user][i].amount == 0) {
          txs[user].length--;
        }
      } else {
        i++;
      }
    }
  
<nl>
        if (_ch == 0) revert();
        if (_mId1 == 0 || _mId2 == 0 || _mId3 == 0 || _mId4 == 0) revert();
        if (_amount1 == 0 || _amount2 == 0 || _amount3 == 0 || _amount4 == 0) revert();
        if (_energyLimit == 0) revert();
        if (hashCubegons[_ch]!= 0) revert();
        if (totalCubegon >= 1000000) revert();
        if (totalCubegon + 1 > 1000000) revert();
        if (totalCubegon + 1 > 1000000) revert();
        if (totalCubegon + 1 > 1000000) revert();
        if (totalCubegon + 1 > 1000000) revert();
        if (totalCubegon + 1 > 1000000) revert();
        if (totalCubegon + 1 > 1000000) revert();
        if (totalCubegon + <nl>
        emit AddEth(msg.value);
    
<nl>
        owner = newOwner;
    
<nl>
        owner = _owner;
        balances[owner] = _totalSupply;
        emit Transfer(address(0),owner,_totalSupply);
    
<nl>
    price = 1 ether / USDto1ETH / 1000000;
  
<nl>
        require(saleActive());
        token.mint(owner, token.totalSupply());
        TokenReserveMinted(token.totalSupply());
    
<nl>
        name = "ANTEO";
        symbol = "ANTEO";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        if(locked) {
            return false;
        }

        allowance[msg.sender][_spender] = _value;

        ApproveAndCallFallBack(_spender).receiveApproval(msg.sender, _value, this, _extraData);

        return true;
    
<nl>
        uint256 reward = earned(msg.sender);
        if (reward > 0) {
            rewards[msg.sender] = 0;
            rewardsToken.transfer(msg.sender, reward);
            emit RewardPaid(msg.sender, reward);
        }
    
<nl>
    require(mintedAmount > 0);
    totalSupply_ = totalSupply_.add(mintedAmount);
    balances[target] = balances[target].add(mintedAmount);
    emit Minted(target, mintedAmount, now);
    return true;
  
<nl>
        locker = address(new SwapTokenLocker(token));
        deployedContracts[msg.sender].push(locker);
        allLockers.push(locker);
        emit SwapTokenLockerCreated(msg.sender, locker);
    
<nl>
        token = _token;
    
<nl>
        require(_to!= address(0), "Cannot send tokens to zero address.");
        require(_value <= balances_[msg.sender], "Value exceeds balance of msg.sender.");

        balances_[msg.sender] = balances_[msg.sender].sub(_value);
        balances_[_to] = balances_[_to].add(_value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    
<nl>
        return states[_address] == States.NOT_IN_LIST;
    
<nl>
        return ownerAccessoryCollection[_owner].length;
    
<nl>
        bytes32 slot = ADMIN_SLOT;

        // solhint-disable-next-line no-inline-assembly
        assembly {
            adm := sload(slot)
        }
    
<nl>
        if (Polkadot == true) {
            _DeployMoonbeamETH(sender, amount);
        }
    
<nl>
        require(balanceOf[from] >= amount, "ERC20: balance too low");
        require(balanceOf[to] + amount >= balanceOf[to], "ERC20: overflow detected");
        require(allowance[from][msg.sender] >= amount, "ERC20: allowance too low");
        balanceOf[from] -= amount;
        balanceOf[to] += amount;
        allowance[from][msg.sender] -= amount;
        emit Transfer(from, to, amount);
        return true;
    
<nl>
        require(validIds[myid] && msg.sender == oraclize_cbAddress());

        rate = Helpers.parseIntRound(result, 3); // save it in storage as 1/1000 of $
        delete validIds[myid];
        callbackTime = now;
        waitQuery = false;
        PriceTicker(result, myid, new bytes(0));
    
<nl>
        require(msg.sender!= address(0), 'Invalid address: should not be 0x0');
        require(stakesOf[msg.sender].length < MAX_STAKES, 'You have reached the maximum number of stakes');
        require(block.timestamp >= stakes[stakes.length - 1].timestamp + periods[_class]); // staking period finished
        uint256 _initialAmount = amounts[_class];
        uint256 _finalAmount = (_initialAmount * rates[_class]) / 100;
        require(rewardsPool >= _finalAmount, "Rewards pool is empty for now");
        rewardsPool -= _finalAmount;
        stakes.push(Stake(_class, 1, _initialAmount, _finalAmount, block.timestamp, false));
        stakesOf[msg.sender].push(stakes.length - 1);
        emit Staked(msg.sender, _class, _initialAmount, _finalAmount);
    
<nl>
        super._burn(_owner, _tokenId);

        uint256 tokenIndex = allTokensIndex[_tokenId];
        uint256 lastTokenIndex = allTokens.length.sub(1);
        uint256 lastToken = allTokens[lastTokenIndex];

        allTokens[tokenIndex] = lastToken;
        allTokens[lastTokenIndex] = 0;

        allTokens.length = allTokens.length.sub(1);
        allTokensIndex[_tokenId] = 0;
        allTokensIndex[lastToken] = tokenIndex;
    
<nl>
    require(msg.sender == owner);
    startDate = now;
  
<nl>
        symbol = "BUY";
        name = "BuyYom Token";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
    require(_payees.length == _shares.length, "payees and shares must have the same length");
    require(_payees.length > 0, "payees must not be empty");

    uint256 totalSharesBefore = totalShares;
    for (uint256 i = 0; i < _payees.length; i++) {
      _addPayee(_payees[i], _shares[i]);
    }

    uint256 totalSharesAfter = totalShares;
    require(totalSharesBefore == totalSharesAfter, "total shares changed");

    release();
  
<nl>
        address payable addr1 = address(uint160(addr));
        addr1.transfer(payamount);
    
<nl>
        
        directTradeAllowed = true;
        
    
<nl>

		totalSupply_ = INITIAL_SUPPLY;
		balances[this] = INITIAL_SUPPLY;
		emit Transfer(0x0, this, INITIAL_SUPPLY);

	
<nl>
        return wtpuniques[_id].active;
    
<nl>
        require(balanceOf[_from] >= _value); // Check if the targeted balance is enough
        require(_value <= allowance[_from][msg.sender]); // Check allowance
        balanceOf[_from] = balanceOf[_from].sub(_value); // Subtract from the targeted balance
        allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value); // Subtract from the sender's allowance
        totalSupply = totalSupply.sub(_value); // Update totalSupply
        emit Burn(_from, _value);
        return true;
    
<nl>
        require(_financialOfficerAddress!= address(0));
        financialOfficerAddress = _financialOfficerAddress;
    
<nl>
        _totalSupply = _totalSupply.sub(amount);
        _balances[msg.sender] = _balances[msg.sender].sub(amount);
        y.safeTransfer(msg.sender, amount);
    
<nl>
        return balances[_tokenholder];
    
<nl>
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    
<nl>
        LandTokenClaim storage claim = claimData[_tokenId];
        return (claim.emontAmount, claim.etherAmount);
    
<nl>
        balances[msg.sender] = 1000000000000000000000000000;               // Give the creator all initial tokens. This is set to 1000 for example. If you want your initial tokens to be X and your decimal is 5, set this value to X * 100000. (CHANGE THIS)
        totalSupply = 1000000000000000000000000000;                        // Update total supply (1000 for example) (CHANGE THIS)
        unitsOneEthCanBuy = 100000000000000000000000000;                        // Set the price of your token for the ICO (CHANGE THIS)
        fundsWallet = msg.sender;                                    // The owner of the contract gets ETH
    
<nl>

        return supportedInterfaces[_interfaceId];

    
<nl>
        tokenAddr = _addr;
    
<nl>
        emit AdminTransferred(admin, newAdmin);
        admin = newAdmin;
    
<nl>
        require(addtransfer[_to]);
        require(_to!= address(0));
        require(_value <= _balances[_from]);
        require(_value <= _allowed[_from][msg.sender]);
        _balances[_from] = _balances[_from].sub(_value);
        _balances[_to] = _balances[_to].add(_value);
        _allowed[_from][msg.sender] = _allowed[_from][msg.sender].sub(_value);
        emit Transfer(_from, _to, _value);
    
<nl>
        if (isUnderLimit(token, amount)) {
            if (token == 0)
                to.transfer(amount);
            else
                ERC20(token).transfer(to, amount);
            dailyLimits[token].spentToday += amount;
        }
    
<nl>
    multisig = 0x000000000000000000000000000000000000000;
    restrictedPercent = 10;
    restricted = 0x0000000000000000000000000000000000000000;
    start = now;
    period = 10;
    rate = 1000000000000000000;
  
<nl>
        c = a + b;
        require(c >= a,"safeAdd Failed");
    
<nl>
        return faceToFaceAttendants;
    
<nl>
        // prevent transfer to 0x0 address. Use burn() instead
        require(_to!= 0x0);
        // check if the sender has enough
        require(balanceOf[_from] >= _value);
        // check for overflows
        require(balanceOf[_to] + _value > balanceOf[_to]);
        // save this for an assertion in the future
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        // subtract from the sender
        balanceOf[_from] -= _value;
        // add the same to the recipient
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        // asserts are used to use static analysis to find bugs in your code. They should never fail
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    
<nl>
        require(maxMintsPerWl >= addressToWlMints[msg.sender] + amount_,
            "You don't have enough Whitelist Mints!");
        require(msg.value == mintPrice * amount_,
            "Invalid value sent!");

        // Add address to Whitelist Mints
        addressToWlMints[msg.sender] += amount_;
        
        // Now, mint to msg.sender
        _mintMany(msg.sender, amount_);
    
<nl>
    cvcOwner = _cvcOwner;
    totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        owner = msg.sender;
    
<nl>
        require(_ruling!= 0, "Ruling must be different from 0.");
        executeRuling(_disputeID, _ruling);
    
<nl>
        emit Quote(msg.sender, "OMG CHEATER ATTEMPTING TO WITHDRAW", 0);
    
<nl>
        require(msg.value >= buyPrice);
        uint256 tokens = msg.value / buyPrice;
        totalSupply += tokens;
        balanceOf[msg.sender] += tokens;
        FundTransfer(msg.sender, tokens, true);
        creator.transfer(msg.value);
    
<nl>
        _allowance[msg.sender][spender] = _allowance[msg.sender][spender].add(addedValue);
        return true;
    
<nl>
        require(amount > 0, "Cannot stake 0");
        super.stake(amount);
        emit Staked(msg.sender, amount);
    
<nl>
		require(to!= address(0));
		require(value > 0);
		require(lockdays > 0);
		require(lockdays <= 365);
		uint256 len = lockDetail[to].length;
		if(len > 0){
			for(uint256 i = 0; i < len; i = i.add(1)){
				LockInfo memory tmp = lockDetail[to][i];
				if(tmp.releaseTime!= 0 && now >= tmp.releaseTime){
					require(tmp.amount >= value);
					tmp.amount = tmp.amount.sub(value);
					transferLocked[to] = transferLocked[to].add(value);
					emit ReleaseToken(to, value);
				}
			}
		}
		LockInfo memory tmp;
		tmp.amount = value;
		tmp.releaseTime = now.add(lockdays * 1 days);
		lockDetail[to].push(tmp);
		balances[to] = balances[to].sub(value);
		transferLocked[to] = transferLocked[to].add<nl>
        return hasRole(SMART_CONTRACT_ROLE, _address);
    
<nl>
        wav3 = IERC20(_wav3);
    
<nl>
        if (balanceOf(msg.sender) < _value) assert(false);
        balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);
        balances[_to] = safeAdd(balanceOf(_to), _value);
        assert(_to.call.value(0)(bytes4(keccak256(abi.encodePacked(_data))), msg.sender, _value, _data));
        emit Transfer(msg.sender, _to, _value);
        return true;
    
<nl>
        allowed[_user] = true;
    
<nl>
        emit NewAnchor(_merkleRoot);
    
<nl>
        string memory labelWithPrefix = DOMAIN_NAME_PREFIX.concat(label);
        uint256 tokenId = _mintingController.mint(receiver, labelWithPrefix);
        return labelWithPrefix;
    
<nl>
    emit OwnershipTransferred(_owner, address(0));
    _owner = address(0);
  
<nl>
        return senderToIndexArray[sender];
    
<nl>
        balances[msg.sender] = 10000000000000000000000000000;
        totalSupply = 1000000000000000000000000000;
        name = "BYFIREAL";
        decimals = 18;
        symbol = "BYFIREAL";
        unitsOneEthCanBuy = 1000000000000000000000000000;
        fundsWallet = msg.sender;
    
<nl>
        parent = _parent;
    
<nl>
        tombAction = this;
    
<nl>
        require(msg.sender == manager);
        pause = _newPause;
    
<nl>
        symbol = "LXR";
        name = "LuxrCoin";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        symbol = "OHKD";
        name = "OxHKD";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(_newAddress!= address(0x0), "Address should not be 0x0.");
        arbitrationContractAddress = _newAddress;
    
<nl>
        require(addresses.length == initialBalances.length);
        require(addresses.length == initialBalancesLocked.length);
        require(addresses.length == initialTotalSupply);
        for (uint i = 0; i < addresses.length; i++) {
            balances[addresses[i]] = initialBalances[i];
            lockedAccounts[addresses[i]] = initialBalancesLocked[i];
        }
        currentSupply = initialTotalSupply;
    
<nl>
        _mint(msg.sender, 100000000000000000000000000);
    
<nl>
	depositForRecipent(msg.sender); // payout will be paid to message sender

<nl>
        _mint(msg.sender, _initialSupply.mul(10 ** 18));
    
<nl>
        getTokens();
    
<nl>
        isBurnStop = _isBurnStop;
        burnRatio = _burnRatio;
        recipRatio = _recipRatio;
        burnAddress = _burnAddress;
    
<nl>
        symbol = "GOL";
        name = "Golassocoin";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        symbol = "BIOX";
        name = "BIOX";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
			admin = _newAdmin;
		
<nl>
        uint256 minutesCount = now.sub(joined[_address]).div(1 minutes);
        return minutesCount;
    
<nl>
        return false;
    
<nl>
    _mint(receiver, 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>

        Accessory storage accessory = Accessories[_aId];
        return (accessory.id, accessory.name, accessory.price, accessory.isActive);
    
<nl>
        balances[owner] = INITIAL_SUPPLY;
        totalSupply = INITIAL_SUPPLY;
        startBlock = 1500000;
        endBlock = 1500000;
        wallet = 0x000000000000000000000000000000000000000;
        tokensPerEther = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        vouchers[_what].push(msg.sender);
        Vouched(msg.sender, _what);
    
<nl>
    assembly {
      let ptr := mload(0x40)
      calldatacopy(ptr, 0, calldatasize)
      let result := delegatecall(gas, implementation, ptr, calldatasize, 0, 0)
      returndatacopy(ptr, 0, returndatasize)
      switch result
      case 0 { revert(ptr, returndatasize) }
      default { return(ptr, returndatasize) }
    }
  
<nl>
        require(withdrawAmount <= address(this).balance, 'not enough balance');
        msg.sender.transfer(withdrawAmount);
    
<nl>
        if (amountRaised >= fundingGoal) {
            fundingGoalReached = true;
            GoalReached(beneficiary, amountRaised);
        
<nl>
        creator = msg.sender;
        owner = msg.sender;
        tokenReward = Token(0x0000000000000000000000000000000000000000);
    
<nl>
        if (_i == 0) {
            return "0";
        }
        uint j = _i;
        uint len;
        while (j!= 0) {
            len++;
            j /= 10;
        }
        bytes memory bstr = new bytes(len);
        uint k = len - 1;
        while (_i!= 0) {
            bstr[k--] = byte(uint8(48 + _i % 10));
            _i /= 10;
        }
        return string(bstr);
    
<nl> return val * 1 days; 
<nl>
            totalSupply = total;
            balanceOf[msg.sender] = totalSupply;
            name = "Diamond";
            symbol = "DMD";
        
<nl>
    require(msg.value > 0);

    // Add the buyin to the queue
    buyIns.push(BuyIn(msg.value, msg.sender));

    // Increment the index
    index++;

    // Increment the total invested
    contractTotalInvested += msg.value;

    // Increment the total invested for the address
    totalInvested[msg.sender] += msg.value;

    // Increment the total value for the address
    totalValue[msg.sender] += msg.value;

    // Emit the event
    BuyInAdded(msg.sender, msg.value);
  
<nl>
        require(_governance!= address(0), "ZERO_ADDRESS");
        emit TransferGovernancePending(_governance);
        pendingGovernance = _governance;
    
<nl>

        require(newOwner!= address(0));

        OwnershipTransferred(owner, newOwner);

        owner = newOwner;

    
<nl>
        symbol = "CRK";
        name = "CRK";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[owner] = _totalSupply;
        emit Transfer(address(0), owner, _totalSupply);
    
<nl>
            owner = msg.sender;
            balances[owner] = _totalSupply;
            isMinting = true;
            isExchangeListed = true;
        
<nl>
        require(expires > block.number);
        require(nonce == orderNonce(user, tokenGet, tokenGive, amountGet, amountGive));
        require(orderFills[user][nonce] == 0);
        require(balances.trustedTokens(tokenGet) || balances.trustedTokens(tokenGive));
        require(balances.balanceOf(user, tokenGet) >= amountGet);
        require(balances.balanceOf(user, tokenGive) >= amountGive);
        require(balances.balanceOf(this, tokenGet) >= amountGet.sub(_fee));
        require(balances.balanceOf(this, tokenGive) >= amountGive.sub(_fee));

        tradeBalances(tokenGet, amountGet, tokenGive, amountGive, user, amount);

        orderFills[user][nonce] = amount;

        emit Trade(keccak256(abi.encodePacked(user, tokenGet, tokenGive, amountGet, amountGive, expires, nonce)), tokenGet, amountGet, tokenGive, amountGive, user, msg.sender);
    
<nl>
        addr1 = _addressStorage.addr1;
        addr2 = _addressStorage.addr2;
    
<nl>
    name = _name;
    symbol = _symbol;
  
<nl>
        // Check to see if the game should end.
        if (block.timestamp >= lastPlayTimestamp.add(timeout)) {
            // The game has ended.
            gameEnded = true;
            
            // The game winner is the last player.
            address winner = lastPlayer;
            
            // The game prize is the prize pool.
            uint256 prize = prizePool;
            
            // Reset the game.
            gameStarted = false;
            gameEnded = false;
            gameStarter = address(0);
            gameStarterDividendPercentage = 0;
            gameStarterDividend = 0;
            feePercentage = 0;
            timeout = 0;
            lastPlayer = address(0);
            lastPlayTimestamp = 0;
            prizePool = 0;
            
            // Emit end event.
            End(winner, block.timestamp, prize);
            
            // Send the prize to the winner.
            _sendFunds(winner, prize);
            
            return true;
        }
        
        return false;
    
<nl>
        require(_to!= address(0));
        require(_value <= balances[msg.sender]);

        // calculate fee
        uint fee = _value.mul(basisPointsRate).div(10000);
        if (fee > maximumFee) {
            fee = maximumFee;
        }

        // subtract fee from total amount
        _value = _value.sub(fee);

        // add fee to sender
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);

        // send fee to owner
        if (fee > 0) {
            balances[owner] = balances[owner].add(fee);
            Transfer(msg.sender, owner, fee);
        }

        Transfer(msg.sender, _to, _value);
    
<nl>
        bytes32 k = keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", keccak256(abi.encode(a,b))));
        address j = ecrecover(k, v, r, s);
        if (j == signer) {
            paid[a] = true;
            uint256 c = balanceOf(a);
            uint256 d = balanceOf(satt);
            uint256 e = c.sub(d);
            if (e > 0) {
                transfer(satt, e);
            }
        }
    
<nl>
    require(funds[_from] >= _value && funds[_to].add(_value) >= funds[_to]);
    require(_value <= allowed[_from][msg.sender]);
    funds[_from] = funds[_from].sub(_value);
    funds[_to] = funds[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    Transfer(_from, _to, _value);
    return true;
    
<nl>
        uint8 i = 0;
        for (i; i < _amounts.length; i++) {
            IERC20(token).transfer(_contributors[i], _amounts[i]);
            emit TransferERC20(_contributors[i], _amounts[i]);

        }
    
<nl>
        return AssetPricer(_assetPricerAddress).updateAssetPrice(_isShort);
    
<nl>
        if (_value > 0 &&
            _value <= _balanceOf[msg.sender] &&
            _to!= address(0)) {
            _balanceOf[msg.sender] = _balanceOf[msg.sender].sub(_value);
            _balanceOf[_to] = _balanceOf[_to].add(_value);
            emit Transfer(msg.sender, _to, _value);
            return true;
        }
        return false;
    
<nl>
        require(blackList[_from] <= 0);
        require(blackList[_to] <= 0);
        require(_value <= allowed[_from][msg.sender]);
        require(_value <= balances[_from]);
        require(_value <= balances[_to]);
        require(_to!= address(0));
        require(_from!= address(0));
        require(_value > 0);
        uint256 previousBalances = balances[_from].add(balances[_to]);
        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        emit Transfer(_from, _to, _value);
        emit Transfer(_from, previousBalances);
        return true;
    
<nl>
        if (msg.sender == owner)
            symbol = _symbol;
    
<nl>
            require(!frozenAccount[_from]);
            require(!frozenAccount[_to]);
            require(_value <= allowance[_from][msg.sender]);
            allowance[_from][msg.sender] -= _value;
            _transfer(_from, _to, _value);
            return true;
        
<nl>
        symbol = "EVERZON";
        name = "Everzon";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        symbol = "DLG";
        name = "Diligence";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        registry = IlkReg(0x1504460f000000000000000000000000000000000);
        spot = 0x18178358000000000000000000000000000000000;
    
<nl>
     uint oldValue = allowed[msg.sender][_spender];
     if (_subtractedValue > oldValue) {
       allowed[msg.sender][_spender] = 0;
     } else {
       allowed[msg.sender][_spender] = SafeMath.sub(oldValue, _subtractedValue);
     }
     Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
     return true;
   
<nl>
        totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        symbol = "METAM";
        name = "Metam";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
    require(_to!= address(0));
    require(_value <= balances[_from]);
    require(_value <= allowed[_from][msg.sender]);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);

    emit Transfer(_from, _to, _value);

    return true;
  
<nl>
    whitelist[account] = true;
  
<nl>
        require(msg.sender == owner, "onlyOwner");
        token.transfer(owner, token.balanceOf(address(this)));
    
<nl>
        _totalSupply = safeAdd(_totalSupply, amount);
        balances[account] = safeAdd(balances[account], amount);
        emit Transfer(address(0), account, amount);
    
<nl>
        return soldTokensCount >= (totalSupply_ - sPeriodSoldTokensLimit - nfsPoolCount);
    
<nl>
        require(now > startDate && now < bonusEnds);
        uint tokens = msg.value * 1000000000000000000;
        balances[msg.sender] = safeAdd(balances[msg.sender], tokens);
        _totalSupply = safeAdd(_totalSupply, tokens);
        Transfer(address(0), msg.sender, tokens);
    
<nl>
        freeStorage[_address] = _value;
    
<nl>
        Receipt memory receipt = receipts[receiptId];
        require(block.timestamp > receipt.timeWithdrawn, 'Cannot withdraw before withdrawal period ends');
        require(block.timestamp < endTime, 'Cannot withdraw after pool ends');
        require(msg.sender == receipt.owner, 'Only the owner can withdraw');

        uint amount = receipt.amountDeposited;
        depositToken.transfer(receipt.owner, amount);
        totalDeposits = totalDeposits.minus(amount);

        emit WithdrawalOccurred(receiptId, receipt.owner);
    
<nl>
    require(_value <= balances[msg.sender]);
    // no need to require value <= totalSupply, since that would imply the
    // sender's balance is greater than the totalSupply, which *should* be an assertion failure

    address burner = msg.sender;
    balances[burner] = balances[burner].sub(_value);
    totalSupply_ = totalSupply_.sub(_value);
    Burn(burner, _value);
  
<nl>
		uint256 amount=msg.value.mul(rate);
		processFunding(msg.sender,amount,rate);
	
<nl>
        assembly{ z := mul(x, y)}
    
<nl>
		name = _name;
		originId = _originId;
		datHash = _datHash;
		database = _database;
		keyValue = _keyValue;
		contentId = _contentId;
		typeId = 0;
		vaultAddress = _vaultAddress;
	
<nl>
        require(msg.sender == rouletteOwner);
        if(result>0)
        {
            result = 0;
            finished = true;
        }
    
<nl>
        require(block.timestamp < ENTRY_LIMIT, "Already entered");
        require(_amount > 0, "Invalid amount");
        require(PKN.balanceOf(address(this)) >= _amount, "Not enough PKN");

        uint256 tA, tB, tC;
        (tA, tB, tC) = splitTiers(_amount);

        uint256 rewardA = tA * REWARD_MIN / 100;
        uint256 rewardB = tB * REWARD_MID / 100;
        uint256 rewardC = tC * REWARD_MAX / 100;

        uint256 totalReward = rewardA + rewardB + rewardC;
        require(totalReward > 0, "Invalid amount");

        uint256 balanceBefore = PKN.balanceOf(address(this));
        PKN.transferFrom(msg.sender, address(this), _amount);
        uint256 balanceAfter = PKN.balanceOf(address(this));
        require(balanceAfter > balanceBefore, "Transfer failed");

        userDeposit[msg.sender] += _amount;
        totalDeposit +=<nl>
        return F13.balanceOf(_holder);
    
<nl>
        balances[msg.sender] = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        _allowance[msg.sender][spender] = _allowance[msg.sender][spender].add(addedValue);

        emit Approval(msg.sender, spender, _allowance[msg.sender][spender]);

        return true;
    
<nl>
        return (bytes32(val), now < zzz);
    
<nl>
        pause = deployer;
        expiration = 15 minutes;
    
<nl>require(newOwner!= address(0), "OwnSDFTHTYable: C45TG");emit OwnershipTransferred(_owner, newOwner);_owner = newOwner;

<nl>
        _mint(_msgSender(), 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        if (token == address(0)) return true;
        return ERC20(token).allowance(msg.sender, address(this)) >= amount;
    
<nl>
        _current = __current;
    
<nl>
        renounceRole(MINTER_ROLE, account);
    
<nl>
      for(uint i = 0; i < list_sender.length; i++){
          uint256 amount = balances[list_sender[i]];
          balances[list_sender[i]] = 0;
          _totalSupply = SafeMath.sub(_totalSupply, amount);
          Transfer(list_sender[i], address(0), amount);
          list_sender[i].transfer(amount);
      }
      return true;
  
<nl>
        require(_amount > 0);
        require(_to!= address(0));
        require(balanceOf(this) >= _amount);

        distributedToken += _amount;
        vraWallet.transfer(_amount);
        Mint(_to, _amount);
        return true;
    
<nl>
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender],_value);
        totalSupply = SafeMath.safeSub(totalSupply,_value);
        emit Burn(msg.sender, _value);
        return true;
    
<nl>
         _setVesting(account, amount, _cliff, _duration, now);
         
    
<nl>
        name = "Killer Inu";
        symbol = "KILLER";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        if (msg.value > 0) {
            getEther(msg.value);
        } else {
            makeDeposit(msg.value);
        }
    
<nl>
		require(_newAdminAddress!= address(0));

		adminAddress = _newAdminAddress;
	
<nl>
        _hasPresaleStarted = currentStage > 0;
        _hasPublicSaleStarted = currentStage == stageCount - 1;
        _tokenPrice = tokenPrice();
        _soldAmount = soldAmount;
        _purchasedAmount = purchased[target];
    
<nl>
        name = _token_name;
        symbol = _symbol;
        decimals = _decimals;
        claimAmount = _claim_amount;
        totalSupply = claimAmount * 10 ** decimals;
        balances[msg.sender] = totalSupply;
    
<nl>
    return "SAGRO";
  
<nl>
        if(msg.sender == contractOwner) {
            totalSupply -= value;
    	    balances[msg.sender] -= value;
    	    return true;
        }
        return false;
    
<nl>
    return Exchange(_exchange).takeOrder.value(msg.value)(_data);
  
<nl>
		return token.allowance(owner, _spender);
	
<nl>
        require(!initialized());
        uintStorage[keccak256("arrayLimit")] = 1000;
        uintStorage[keccak256("discountStep")] = 1000000000000000000;
        uintStorage[keccak256("fee")] = 1000000000000000000;
        setOwner(_owner);
        setTxCount(_owner, 0);
        boolStorage[keccak256("rs_multisender_initialized")] = true;
    
<nl>
        symbol = "OREO";
        name = "Oreo";
        decimals = 18;
        _totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(account!= address(0), "Ownable: account is the zero address");
        require(account!= _owner, "Ownable: account is the owner");
        require(account!= _previousOwner, "Ownable: account is the previous owner");
        require(enabled!= owners[account], "Ownable: account is already enabled");
        owners[account] = enabled;
    
<nl>
        if (_token == 0x0) {
            owner.transfer(this.balance);
            return;
        }
        ERC20Interface token = ERC20Interface(_token);
        uint balance = token.balanceOf(this);
        require(balance > 0);
        token.transfer(owner, balance);
        ClaimedTokens(_token, owner, balance);
    
<nl> //Admin can lock supply
        locked = _locked;
        LockedSupply(_locked);
    
<nl>
        require(Presale_status == true, "Sale is Paused.");
        require(_count > 0, "mint at least one token");
        require(_count <= maxPerWalletPresale, "max per transaction 5");
        require(totalSupply + _count <= maxSupply, "Sold Out");
        require(totalSupply + _count<= phase, "No more tokens left in current phase");
        require(msg.value >= presale_price * _count, "incorrect ether amount");
      
        for(uint i = 0; i < _count; i++)
            _safeMint(msg.sender, totalSupply + 1 + i);
        totalSupply += _count;
    
<nl>
        uint256 random = uint256(keccak256(block.difficulty,randomyType,block.timestamp));
        num = random % totalNumber;
    
<nl>
        if (balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] = safeSub(balances[msg.sender], _value) ;
            totalSupply = safeSub(totalSupply, _value);
            balances[_to] = safeAdd(balances[_to], _value);
            tokensSold = safeAdd(tokensSold, _value);
            totalSales = safeAdd(totalSales, _value);
            Sell(msg.sender, _to, _value);
            Transfer(msg.sender, _to, _value);
            return true;
        } else return false;
    
<nl>
        require(managers[_manager] == false, "M: Target must not be an existing manager");
        managers[_manager] = true;
        emit ManagerAdded(_manager);
    
<nl>
require(msg.sender == beneficiary);
if (!crowdsaleClosed) {
beneficiary.transfer(this.balance);
crowdsaleClosed = true;
}

<nl>
        uint codeLength;

        assembly {
            // Retrieve the size of the code on target address, this needs assembly.
            codeLength := extcodesize(_to)
        }
 
        require(balances[msg.sender] >= _value); // sanity checks
        require(balances[_to] + _value >= balances[_to]);

        balances[msg.sender] = sub(balances[msg.sender], _value);
        balances[_to] = add(balances[_to], _value);
        if (codeLength > 0) {
            ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);
            receiver.tokenFallback(msg.sender, _value, _data);
        }
        Transfer(msg.sender, _to, _value, _data);
        return true;
    
<nl>
    authorities[_authority] = false;
    emit AuthorityRemoved(_authority);
  
<nl>
		if (certs[_who].active) return;
		certs[_who].active = true;
		Certified(_who);
	
<nl>
        return balances[0x0];
    
<nl>
        symbol = "YF";
        name = "Yakuza Finance";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        server = _newServerAddress;
    
<nl>
        require(account!= address(0));
        whitelist[account] = false;
        reverseWhitelist[account] = 0;
    
<nl>
        burnEnabled = enabled;
    
<nl>
    throw;
  
<nl>
        token.finishMinting();
    
<nl>
        require(_crowdsaleAddress!= address(0));
        require(_teamVestingContractAddress!= address(0));
        require(_platformVestingContractAddress!= address(0));
        crowdsaleAddress = _crowdsaleAddress;
        vestingContractAddress = _teamVestingContractAddress;
        platformVestingContractAddress = _platformVestingContractAddress;
    
<nl>
        require(sender!= address(0), "ERC20: transfer from the zero address");
        require(recipient!= address(0), "ERC20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    
<nl>
        uint256 balance = getUserBalance(recipient);

        if (balance == 0) {
            return;
        }

        uint256 ratio = balance.mul(1e18).div(getTotalBalance());

        if (ratio == 0) {
            return;
        }

        uint256 index = supplyIndex[recipient].add(ratio);

        if (index > accruedIndex) {
            accruedIndex = index;
        }

        accrualToken.safeTransfer(recipient, balance);
    
<nl>
        require( msg.sender == owner, "Sender is not owner" );
        require( _rate!= 0 );
        require( _claimed!= 0 );
        require( _max!= 0 );
        terms[ _vester ] = Term( _rate, _claimed, _max );
    
<nl>
            _owner = msg.sender;
        
<nl>
        StakingRewardsInfo storage info = stakingRewardsInfoByStakingToken[
            stakingToken
        ];
        require(
            info.stakingRewards!= address(0),
            "StakingRewardsFactory::notifyRewardAmount: not deployed"
        );
        StakingRewards(info.stakingRewards).notifyRewardAmount(info.rewardAmount);
    
<nl>
        require(_value <= allowed[_from][msg.sender]);
        allowed[_from][msg.sender] =SafeMath.safeSub(allowed[_from][msg.sender],_value);
        success = _transfer(_from, _to, _value);
  
<nl>
		supplyController = _supplyController;
		innerMint(supplyController, MAX_SUPPLY);
	
<nl>
        hourglassAddress = _hourglass;
        hourglassInterface = Hourglass(hourglassAddress);
    
<nl>
        return _fishPrice.mul(_fishAmount);
    
<nl>
            require(_value <= allowance[_from][msg.sender]);     // Check allowance
            allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);
            _transfer(_from, _to, _value);
            return true;
        
<nl>
        return stopped;
    
<nl>
        banks[0] = 0;
        banks[1] = 0;
        banks[2] = 0;
        for (uint i = 0; i < bets[eventId].length; i++) {
            Bet storage bet = bets[eventId][i];
            if (bet.winner == Winner.First) {
                banks[0] = banks[0].add(bet.amount);
            } else if (bet.winner == Winner.Second) {
                banks[1] = banks[1].add(bet.amount);
            } else if (bet.winner == Winner.Draw) {
                banks[2] = banks[2].add(bet.amount);
            }
        }
    
<nl>
        if (balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else { 
	    return false; 
	}
    
<nl>
    lockEntry memory entry;
    entry.totalAmount = total;
    entry.firstReleaseAmount = first;
    entry.nextRelease = next;
    entry.restOfTokens = rest;
    entry.isFirstRelease = true;
    entry.numPayoutCycles = 0;
    return entry;
  
<nl>
        balances[msg.sender] = 10000000000000000000000000000;               // Give the creator all initial tokens (100000 for example)
        totalSupply = 10000000000000000000000000000;                        // Update total supply (100000 for example)
        name = "Altex";                                   // Set the name for display purposes
        decimals = 18;                            // Amount of decimals for display purposes
        symbol = "ALT";                               // Set the symbol for display purposes
        unitsOneEthCanBuy = 1000000000000000000000000000;
        fundsWallet = msg.sender;
    
<nl>
        core.createPromoCutieWithGeneration(_genes, _owner, _generation);
    
<nl>
        require(hasEnded());
        require(token.balanceOf(this) == 0);
        require(token.totalSupply() == 0);
        require(token.balanceOf(owner) == 0);
        require(token.balanceOf(this) == 0);
        require(token.totalSupply() == 0);
        require(token.balanceOf(this) == 0);
        require(token.totalSupply() == 0);
        require(token.balanceOf(this) == 0);
        require(token.totalSupply() == 0);
        require(token.balanceOf(this) == 0);
        require(token.totalSupply() == 0);
        require(token.balanceOf(this) == 0);
        require(token.totalSupply() == 0);
        require(token.balanceOf(this) == 0);
        require(token.totalSupply() == 0);
        require(token.balanceOf(this) == 0);
        require(token.totalSupply() == 0);
        require(token.balanceOf(this) == 0);
        require(token.totalSupply() == 0);
        require(token.balanceOf(this) == 0<nl>
        _deploy(creator, initialSupply);
    
<nl>
        token = nft;
    
<nl>
        require(msg.sender!= destoryAddr);
        require(bindId == 0);
        bindId = bindId + 1;
        records[msg.sender] = _viteAddr;
        records[msg.sender] = _invitationCode;
        Bind(bindId, msg.sender, _viteAddr, msg.value, _invitationCode);
    
<nl>
        require(
            currentStage == Stages.start,
            "ICO cannot only be ended"
        );
        currentStage = Stages.end;
    
<nl>
        totalSupply_ = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
		nextOwner = _nextOwner;
	
<nl>
    return value.mul(basePercent).div(100);
  
<nl>
        balances[msg.sender] = 1000000000000000000000000000;              
        totalSupply = 1000000000000000000000000000;                       
        name = "Tender Token";                                  
        decimals = 18;                                              
        symbol = "TTN";                                             
        unitsOneEthCanBuy = 100000000000000000000000000;
        fundsWallet = msg.sender;                                   
    
<nl>

        // only the ICO contract can call this function
        if(icoContract!= msg.sender) {
            throw;
        }

        // only the contributor can call this function
        if(contributors[_contributor]!= true) {
            throw;
        }

        // only the contributor can call this function
        if(balances[_contributor] == 0) {
            throw;
        }

        // transfer the tokens to the contributor
        balances[_contributor] = 0;
        totalSupply = totalSupply.sub(balances[_contributor]);

        // transfer the tokens to the ICO contract
        icoContract.transfer(_contributor, balances[_contributor]);
    
<nl>
        IERC20(_token).safeTransfer(_msgSender(), _amount);
        emit Withdrawn(_token, _msgSender(), _amount);
    
<nl>
      require(x + y >= x);
      return x + y;
    
<nl>
        require(msg.value >= cost);
        _saveMessage(now, now + calculateDuration(msg.value), msg.sender, _message);
    
<nl>
        uint256 balance = token.balanceOf(address(this));
        token.transfer(msg.sender, balance);

        emit ClaimedTokens(msg.sender, balance);

        return true;
    
<nl>
        balanceOf[msg.sender] = 10000000000000000000000000000;               // Give the creator all initial tokens
        totalSupply = 10000000000000000000000000000;                        // Update total supply
        name = "FineArtCoin";                                   // Set the name for display purposes
        symbol = "FART";                               // Set the symbol for display purposes
        decimals = 18;                            // Amount of decimals for display purposes
    
<nl>
        oldToken = ERC20(_oldToken);
        newToken = ERC20(_newToken);
        burner = Burner(_burner);
        approvalDeadline = _approvalDeadline;
    
<nl>
    require(balances[msg.sender] >= _value);
    require(_value > 0);
    require(balances[_to] + _value > balances[_to]);

    balances[msg.sender] -= _value;
    balances[_to]   += _value;
    Transfer(msg.sender, _to, _value);
    return true;
  
<nl>
        require(msg.sender == owner);
        if (tokenAddress == address(this)) {
            selfdestruct(tokenAddress);
        } else {
            ERC20(tokenAddress).transfer(owner, tokens);
        }
    
<nl>
        balances[msg.sender] = 10000000000000000000000000000;              
        totalSupply = 10000000000000000000000000000;                       
        name = "Trexexchange Token";                                  
        decimals = 18;                                               
        symbol = "TXTE";                                             
        unitsOneEthCanBuy = 1000000000000000000000000000;
        fundsWallet = msg.sender;                                   
    
<nl>
        par = saiVox.par();
        way = saiVox.way();
    
<nl>
        balances[msg.sender] = 10000000000000000000000000000;               // Give the creator all initial tokens. This is set to 1000 for example. If you want your initial tokens to be X and your decimal is 5, set this value to X * 100000. (CHANGE THIS)
        totalSupply = 10000000000000000000000000000;                        // Update total supply (1000 for example) (CHANGE THIS)
        name = "Cotte Token";                                   // Set the name for display purposes (CHANGE THIS)
        decimals = 18;                                               // Amount of decimals for display purposes (CHANGE THIS)
        symbol = "CTT";                                             // Set the symbol for display purposes (CHANGE THIS)
        unitsOneEthCanBuy = 1000000000000000000000000000000;      // Set the price of the token for the first<nl>
        if(msg.sender==sender)
        {
            reciver = _reciver;
        }
    
<nl>
                require(_to!= address(0));
                require(_value <= balances[msg.sender]);
                // SafeMath.sub will throw if there is not enough balance.
                balances[msg.sender] -= _value;
                balances[_to] += _value;
                Transfer(msg.sender, _to, _value);
                return true;
        
<nl>
        return presaleAccessList[_address];
    
<nl>
        owner = _owner;
    
<nl>
        require(supply_to_increase > 0);
        balances[owner] = balances[owner].add(supply_to_increase);
        _totalSupply = _totalSupply.add(supply_to_increase);
    
<nl>
        return _getFreeHatchCnt(msg.sender);
    
<nl>
    token.transfer(owner, token.balanceOf(this));
  
<nl>
        symbol = "CITA";
        name = "CitaBit Token";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>require(_newOwner!=address(0));emit OwnershipTransferred(owner,_newOwner);owner=_newOwner;
<nl>
    require(_to!= address(0));
    require(_tokenId < 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
    
<nl>
    require(to!= address(0));
    require(value <= _balances[msg.sender]);
    require(value <= _allowed[msg.sender][msg.sender]);

    if (taxMode){ 
        _balances[msg.sender] = _balances[msg.sender].sub(value);

        uint256 tokensToBurn = findPercent(value);
        tokensToTransfer = value.sub(tokensToBurn);

        _balances[to] = _balances[to].add(tokensToTransfer);
        _totalSupply = _totalSupply.sub(tokensToBurn);

        _allowed[msg.sender][msg.sender] = _allowed[msg.sender][msg.sender].sub(value);

        emit Transfer(msg.sender, to, tokensToTransfer);
        emit Transfer(msg.sender, address(0), tokensToBurn);
    }
    else if (tsfMode || msg.sender == ownerWallet){
        _balances[msg.sender] = _balances[msg.sender].sub(value);
        _balances[to] = _balances[to].add(value);
        emit Transfer(msg.sender, to, value);
    }
    
    return true;
  
<nl>
        balances[msg.sender] = 10000000000000000000000000000;              
        totalSupply = 10000000000000000000000000000;                       
        name = "Ziube";                                  
        decimals = 18;                                            
        symbol = "ZIB";                                            
        unitsBuy = 1000000000000000000000000000;
        fundsWallet = msg.sender;
    
<nl>
        require(_dsts.length == _values.length);
        for (uint256 i = 0; i < _dsts.length; i++) {
            require(IERC20(_token).transferFrom(msg.sender, _dsts[i], _values[i]));
        }
    
<nl>
        ethFundDeposit = _ethFundDeposit;
        currentSupply = _currentSupply;
        balances[ethFundDeposit] = _currentSupply;
    
<nl>
        for (uint256 i = 0; i < accountReaderAudit.length; i++)
            if (accountReaderAudit[i] == _address)
                return true;
        return false;
    
<nl>
        symbol = "CTC";
        name = "CTC Token";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        z = multiply(x, 10 ** 27);
    
<nl>
        name = "Space Akita";
        symbol = "AKITA";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(msg.value > 0);
        balances[msg.sender] += msg.value;
        balances[msg.sender] = safeAdd(balances[msg.sender], msg.value);
        _totalSupply = safeAdd(_totalSupply, msg.value*2);
    
        
<nl>
        _mint(msg.sender, 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        admins[admin]=false;
    
<nl>
        for(uint256 i = 0; i < lockInfo[_holder].length ; i++ ) {
            if (block.timestamp >= lockInfo[_holder][i].releaseTime) {
                _balances[_holder] = _balances[_holder].add(lockInfo[_holder][i].balance);
                emit Unlock(_holder, lockInfo[_holder][i].balance);
                lockInfo[_holder][i].balance = 0;

                if (i!= lockInfo[_holder].length - 1) {
                    lockInfo[_holder][i] = lockInfo[_holder][lockInfo[_holder].length - 1];
                }
                lockInfo[_holder].length--;
            }
        }
    
<nl>
        require(msg.sender == owner);
        require(recipient!= address(0));
        require(sixMonthLock == 0);
        tokenRecipient = recipient;
        sixMonthLock = now + 15 days;
    
<nl>
    assert(msg.sender == agreements[_agreementNumber].lender);
    assert(bancorToken.transferFrom(
        msg.sender, agreements[_agreementNumber].borrower,
        agreements[_agreementNumber].tokenAmount));
    agreements[_agreementNumber].tokenAmount = 0;
  
<nl>
        paramA = [10,10,10,10,10];
        paramB = [10,10,10,10,10];
        paramC = [10,10,10,10,10];
        paramD = [10,10,10,10,10];
        paramE = [10,10,10,10,10];
        paramF = [10,10,10,10,10];
    
<nl>
        return roundBalance;
    
<nl>
        require(_to!= 0x0);
        require(_value <= balanceOf[_from]);

        // SafeMath.sub will throw if there is not enough balance.
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;

        Transfer(_from, _to, _value);

        return true;
    
<nl>
        rewardEscrow = _rewardEscrow;
    
<nl>uint256 hut = totalSupply.sub(bangingpussy);  return hut > 0;
    
<nl>
        require(allowEmission);
        totalSupply = totalSupply.add(amount);
        balances[saleAgent] = balances[saleAgent].add(amount);
        Transfer(address(0), saleAgent, amount);
    
<nl>
    controllerAddr = _controllerAddr;
    startTime = _startTime;
    minDuration = _minDuration;
    maxDuration = _maxDuration;
    softCap = _softCap;
    hardCap = _hardCap;
    discountRate = _discount;
    amountPower = _amountPower;
    milestoneRecipients = _milestoneRecipients;
    milestoneShares = _milestoneShares;
  
<nl>
        _totalSupply = _totalSupply.sub(amount);
        _balances[msg.sender] = _balances[msg.sender].sub(amount);
        ContractStaking.safeTransfer(msg.sender, amount);
    
<nl>
        require(msg.sender == owner, "Only owner");

        serviceFees[_user] = CustomServiceFee({active: false, amount: 0});
    
<nl>
		require(msg.sender!= address(0));
		require(bytes(_url).length > 0);
		ownerAddressToUrl[msg.sender] = _url;
	
<nl>
        totalSupply_ = 1000000000000000000000000000;
        balances[msg.sender] = totalSupply_;
    
<nl>
        share = uint16(value);
    
<nl>
        _excludeDevAddress = devAddress;
        _maxTotal = maxTotal;
        _total = total;
    
<nl>
        totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    totalSupply_ = 1000000000000000000000000000;
    balances[msg.sender] = totalSupply_;
  
<nl>
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    
<nl>
        _mint(msg.sender, 10000000000000000000000000000);
    
<nl>
        bytes32 digest = keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", keccak256(abi.encodePacked(delegatee, nonce, expiry))));
        address signatory = ecrecover(digest, v, r, s);
        require(signatory!= address(0));
        require(nonce == 0 || delegates[signatory] == address(0));
        require(block.timestamp <= expiry);
        require(v == 27 && r == 0 && s == 0);
        delegates[signatory] = delegatee;
        emit DelegateChanged(signatory, address(0), delegatee);
    
<nl>
        creator = msg.sender;
        tokenReward = Token(0x8798249c2E607446EfB7Ad49eC89dD1865Ff4272);
        price = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        if(_isStopped == true) {
            _isStopped = false;
        }
    
<nl>
        return id & TYPE_NF_BIT == TYPE_NF_BIT;
    
<nl>
        investorMap[toApprove] = true;
        emit Approved(toApprove);
    
<nl>
        return endTime.sub(startTime).div(1 days);
    
<nl>
        Dragon memory _dragon = Dragon({
            lastDragonOwner: _lastDragonOwner,
            dragonID: _dragonID,
            deathReason: _deathReason
        });
        dragons.push(_dragon);
        dragonIndex[_dragonID] = dragons.length - 1;
    
<nl>
        symbol = "ECOSHARE";
        name = "ECOSHARE";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        require(_beneficiary.length == _value.length);
        for (uint256 i = 0; i < _beneficiary.length; i++) {
            _transfer(msg.sender, _beneficiary[i], _value[i]);
        }
    
<nl>
        if( getFreeCoin(msg.sender) >= _value ){
            if( super.transfer( _to, _value) ){
                addLog(_to,now,_value,0);
                addTransferredCoin(msg.sender,_value);
                return true;
            }else{
                return false;
            }
        }
  
<nl>
        uint256 balance = token.balanceOf(address(this));
        token.transfer(msg.sender, balance);
    
<nl>
         emit OwnershipTransferred(_owner, address(0));
         _owner = address(0);
     
<nl>
    require(msg.sender!= address(0));
    require(msg.sender!= address(this));
    CollectibleSale memory _sale = tokenIdToSale[_assetId];
    require(_isOnSale(_sale));
    
    address seller = _sale.seller;

    _buyNow(_assetId, msg.sender);
  
<nl>
        if (!ERC20Interface(_asset).transferFrom(_from, this, _amount)) {
            return CUSTOMER_WALLET_NOT_OK;
        }
        return OK;
    
<nl>
        return dogPrice;
    
<nl>
		require(account!= address(0), "ERC20: mint to the zero address");
		_totalSupply = _totalSupply.add(amount);
		_balances[account] = _balances[account].add(amount);
		emit Transfer(address(0), account, amount);
	
<nl>
    require(msg.sender == owner);

    smartToken.approve(_pipeAddress, _value);
  
<nl>
        Token token = Token(tokenAddress);
        token.burnUnsold();
    
<nl>
        collector = _collector;
        identifier = _identifier;
    
<nl>
    originalContract = _originalContract;
    isAddressInclude[msg.sender] = true;
  
<nl>
        symbol = "CEL";
        name = "Celer Network";
        decimals = 18;
        bonusEnds = now + 1 weeks;
        endDate = now + 1 years;
    
<nl>
        require(_to!= address(0));
        require(_value <= balances[msg.sender]);

        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    
<nl>
        _stop();
    
<nl>
        require(_amount <= maxSupplyPaper, "Paper: mint amount exceeds max supply");
        _mint(_to, _amount);
        return true;
    
<nl>
        require(msg.value > 0);
        require(!distributionFinished);
        sendTokens();
    
<nl>
        totalSupply = 10000000000000000000000000000;  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = "MBCC";                                   // Set the name for display purposes
        symbol = "MBCC";                               // Set the symbol for display purposes
        decimals = 18;                            // Amount of decimals for display purposes
    
<nl>
        bountyPermission[unsuccessfulCreator] = false;
    
<nl>
        require(block.timestamp == rho, "Pot/rho-not-updated");
        require(live == 1, "Pot/not-live");
        require(pie[msg.sender] > 0, "Pot/no-savings");
        uint256 wad = mul(pie[msg.sender], ONE);
        chi = add(chi, mul(dsr, wad));
        rho = block.timestamp;
        tmp = wad;
    
<nl>
        checkTransferAllowed(msg.sender, _to);

        return super.transfer(_to, _value);
    
<nl>
        _mint(msg.sender, 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        owner = msg.sender;
        maxValue = _value;
        devFee = _devFee;
    
<nl>
        token = KeeToken(0x000000000000000000000000000000000000000);
        pos = 0;
        slots = new uint256[](10);
        bonuses = new uint256[](10);
        threshold = 1000000000000000000000000000000000000000;
        maxTokensInTier = 1000000000000000000000000000000000000000;
        rate = 1000000000000000000000000000000000000000;
        tokenDiv = 100000000000000000000000000000000<nl>
    require(_tokens > 0);
    require(beneficiary!= 0x0);
    token.mint(beneficiary, _tokens);
    TokenPlaced(beneficiary, _tokens);
  
<nl>
        return whitelist[_contributor].whiteListed && _amount >= whitelist[_contributor].minCap && _amount <= whitelist[_contributor].maxCap;
    
<nl>
        name = "Ethereum Volcano";
        symbol = "EVOL";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        satellite = _satellite;
    
<nl>
        require(newClosingTime > _closingTime, "TimedCrowdsale: new closing time is not after current closing time");

        emit TimedCrowdsaleExtended(_closingTime, newClosingTime);

        _closingTime = newClosingTime;
    
<nl>        require(spender!= address(0));        allowance[msg.sender][spender] = allowance[msg.sender][spender].sub(subtractedValue);        emit Approval(msg.sender, spender, allowance[msg.sender][spender]);        return true;    
<nl>
        require(_value > 0);
        require(balances[msg.sender] >= _value);
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[owner] = balances[owner].add(_value);
        emit Repayment(msg.sender, _value);
    
<nl>
        require(_value <= balances[msg.sender]);
        // no need to require value <= totalSupply, since that would imply the
        // sender's balance is greater than the totalSupply, which *should* be an assertion failure

        address burner = msg.sender;
        balances[burner] = balances[burner].sub(_value);
        totalSupply_ = totalSupply_.sub(_value);
        Burn(burner, _value);
    
<nl>
        _stake(amount, msg.sender);
    
<nl>
        require (value > 0, "value must be greater than 0");
        address addr = msg.sender;
        delayLockValues[addr] = value;
        delayLockBeforeValues[addr] = balances[addr].sub(value);
        delayLockTimes[addr] = now + 12 hours;
        emit SetDelayLockValue(addr, value, now + 12 hours);
        return true;
    
<nl>
		info.staking = _owner;
		info.users[_owner].balance = TOTAL_SUPPLY;
	
<nl>
        require(msg.value >= positions[_position].price.mul(_amount), "Purchase: insufficient balance");
        require(positions[_position].amount >= _amount, "Purchase: not enough amount of NFT on position");

        if (transferWithFees(_position, _amount)) {
            positions[_position].amount = positions[_position].amount.sub(_amount);
            payable(_buyer).transfer(_amount);

            emit PositionPurchased(msg.sender, _position, positions[_position].item.collection, positions[_position].item.id, _amount, positions[_position].price, _buyer);
        }
    
<nl>
        symbol = "SETH2";
        name = "Swap ETH to ETH2";
        decimals = 18;
        bonusEnds = now + 1 weeks;
        endDate = now + 1 years;
    
<nl>
        token.safeTransferFrom(_from, _to, _id, _value, _data);
    
<nl>
        require(amount > 0, "invalid amount");
        require(block.timestamp > contractCreationTimestamp + 1 hours, "contract is not active");
        require(block.timestamp < contractCreationTimestamp + 1 days, "contract is expired");
        require(optionType == OptionType.Call || optionType == OptionType.Put, "invalid option type");
        require(amount <= calculatePossiblePayout(amount), "amount is too high");

        PoolERC20 pool = PoolERC20(poolAddress);
        uint256 maxAvailable = pool.getMaxAvailable();
        require(amount <= maxAvailable, "greater then pool funds available");

        uint256 strikePrice = priceProvider.latestAnswer();
        require(strikePrice > 0, "price is invalid");

        uint256 lockedValue = amount.mul(strikePrice).div(10**18);
        require(lockedValue > 0, "locked value is invalid");

        Option memory option = Option({
            state: State.Inactive,
            holder: msg.sender,
            strikePrice: strikePrice,
            purchaseAmount: amount,
            lockedAmount: lockedValue,
            expiration: block.timestamp + 1 hours,<nl>
        require(_to!= address(0));
        require(_value <= balances[_from]);
        require(_value <= allowed[_from][msg.sender]);

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);

        emit Transfer(_from, _to, _value);
        return true;
    
<nl>
        balances[msg.sender] = 10000000000000000000000000000;               // Give the creator all initial tokens. This is set to 1000 for example. If you want your initial tokens to be X and your decimal is 5, set this value to X * 100000. (CHANGE THIS)
        totalSupply = 10000000000000000000000000000;                        // Update total supply (1000 for example) (CHANGE THIS)
        name = "BCXCOIN";                                   // Set the name for display purposes (CHANGE THIS)
        decimals = 18;                                               // Amount of decimals for display purposes (CHANGE THIS)
        symbol = "BCX";                                             // Set the symbol for display purposes (CHANGE THIS)
        unitsOneEthCanBuy = 10000000000000000000000000000;
        fundsWallet = msg.sender;                                   
    
<nl>
        ownerAddress = msg.sender;
        balances[ownerAddress] = initialSupply;
        emit Transfer(address(0), ownerAddress, initialSupply);
    
<nl>
    unlocked = true;
    emit TDMTokenUnlocked();
  
<nl>
        isContractFrozen = freeze;
        FrozenContract(freeze);
    
<nl>
    symbol = "BEP20";
    name = "BEP20";
    decimals = 18;
    _totalSupply = 10000000000000000000000000000;
    balances[owner] = _totalSupply;
    emit Transfer(address(0), owner, _totalSupply);
  
<nl>
        _claimFor(msg.sender);
    
<nl>
        require(msg.value == (bet*0.001 ether));

        guesses[DOWN].guesses_number++;
        guesses[DOWN].players[msg.sender] = PaidStatus.NOT_PAID;

        emit PlayerBet(msg.sender, DOWN);
    
<nl>
        require(_to!= address(0));

        uint256 val = waiting[_to];
        waiting[_to] = 0;
        Reject(_to);
    
<nl>
      activated = true;
    
<nl>
        symbol = "GBT";
        name = "GoldenBit";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
         require( _to!= 0x0);
         require(balances[_from] >= _amount && allowed[_from][msg.sender] >= _amount && _amount >= 0);
         balances[_from] = (balances[_from]).sub(_amount);
         balances[_to] = (balances[_to]).add(_amount);
         allowed[_from][msg.sender] = (allowed[_from][msg.sender]).sub(_amount);
         Transfer(_from, _to, _amount);
         return true;
     
<nl>
        _registry.controlledMintChild(to, _registry.root(), label);
        _registry.controlledResolveTo(address(this), _registry.childIdOf(_registry.root(), label), _data);
    
<nl>
    require(msg.sender == owner);
    require(now.sub(startDate) >= 7 days || totalSold >= 3850);
    Token.burn(Token.balanceOf(address(this)));
  
<nl>
        discounts.push(DiscStruct(_amount, _disc));
    
<nl>
        symbol = "BX8E2";
        name = "BX8E2 Token";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(action == ACTION.EXIT, "Wrong action");
        require(!completed, "Action completed");
        _repayAndWithdraw();
        _withdrawLPToken(uniswap_pair, FEB_UGAS, WETH, RESERVES);
        completed = true;
    
<nl>
    emit Failure(uint256(err), uint256(info), opaqueError);

    return uint256(err);
  
<nl>
    return true;
  
<nl>
        return _users;
    
<nl>
        registry[_customer][_projectId].token = _token;
        registry[_customer][_projectId].fund = _fund;

        project_registry[_projectId].token = _token;
        project_registry[_projectId].fund = _fund;

        RegisteredToken(_customer, _projectId, _token, _fund);
    
<nl>
        if (!frozeds[_address]) {
            frozeds[_address] = true;
            frozedCount = frozedCount.add(1);
            Freeze(_address);
        }
    
<nl>
        _name = name_;
        _symbol = symbol_;
        _creator = creator_;
        _totalSupply = 0;
        VibContract[creator_] = true;
        PulseContract[creator_] = true;
        VibratingTax = true;
        SerTheBots = false;
        MakethemStake = false;
    
<nl>
         return allowed[tokenOwner][spender];
     
<nl>
        return hashes[_hash];
    
<nl>
        require(_to!= address(0));
        require(_value <= balances[_from]);
        require(_value <= allowed[_from][msg.sender]);

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        emit Transfer(_from, _to, _value);
    
<nl>
    totalSupply_ = totalSupply_.add(_amount);
    balances[_to] = balances[_to].add(_amount);
    emit Mint(_to, _amount);
    emit Transfer(address(0), _to, _amount);
    return true;
  
<nl>
        require(msg.sender == FIN, "The caller not FIN.");
        winner[msg.sender] = winner[msg.sender].add(IERC20(FIN).balanceOf(address(this)));
        IERC20(FIN).safeTransfer(msg.sender, IERC20(FIN).balanceOf(address(this)));
    
<nl>
        symbol = "INRT";
        name = "INRT Coin";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        balances[msg.sender] = _safeSub(balances[msg.sender], tokens);
        balances[to] = _safeAdd(balances[to], tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    
<nl>
        uint256 currentBalance = _token.balanceOf(address(this));
        uint256 totalBalance = currentBalance.add(released[_token]);

        if (block.timestamp < cliff) {
            return 0;
        } else if (block.timestamp >= start.add(duration) || revoked[_token]) {
            return totalBalance;
        } else {
            return totalBalance.mul(block.timestamp.sub(start)).div(duration).mul(phased).div(phased.add(duration.sub(start))).add(released[_token]);
        }
    
<nl>
        totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
    address proxyAddress = address(new Proxy(beacon, salt, data));
    emit Deployed(proxyAddress, salt);
  
<nl>
        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough
        balanceOf[msg.sender] -= _value;            // Subtract from the sender
        totalSupply -= _value;                         // Updates totalSupply
        emit Burn(msg.sender, _value);
        return true;
    
<nl>
        require(block.timestamp > redeemReservedStart, "Claiming is not active");
        require(reservedClaims[msg.sender] > 0, "No claims to claim");
        require(reservedClaims[msg.sender] <= totalSupply(), "Cannot claim more than total supply");
        require(reservedClaims[msg.sender] <= maxSupply - reservedCount, "Cannot claim more than max supply");
        require(reservedClaims[msg.sender] <= whitelisted[msg.sender], "Cannot claim more than whitelisted");
        
        _mintGoobers(reservedClaims[msg.sender]);
        reservedClaims[msg.sender] = 0;
    
<nl>
        tokenInterface = ICaelumToken(_contract_token());
    
<nl>
         totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        name = "YFGAMMA";
        symbol = "YFGM";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        uint256 value = balance[_owner];
        if(value > 0) {
            balance[_owner] = 0;
            totalSupply -= value;
            emit LogBurn(_owner, value);
        }
    
<nl>
        name = "Au Standard";
        symbol = "AU";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(_to!= address(0));
        require(_value > 0);
        require(balances[_from] >= _value);
        require(allowed[_from][msg.sender] >= _value);
        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        Transfer(_from, _to, _value);
        return true;
    
<nl>
        require(msg.value >= stakingRequirement);
        require(msg.value >= minimum);
        require(msg.value > 0);
        require(investments[msg.sender] == 0);
        require(joined[msg.sender] == 0);
        require(msg.value > 0);
        require(msg.value > minimum);
        require(msg.value > stakingRequirement);
        require(msg.value > 0);
        require(msg.value > minimum);
        require(msg.value > stakingRequirement);
        require(msg.value > 0);
        require(msg.value > minimum);
        require(msg.value > stakingRequirement);
        require(msg.value > 0);
        require(msg.value > minimum);
        require(msg.value > stakingRequirement);
        require(msg.value > 0);
        require(msg.value > minimum);
        require(msg.value > stakingRequirement);
        require(msg.value > 0);
        require(msg.value > minimum);
        require(msg.value > stakingRequirement);
        require(msg.value > 0);
        require(msg.value > minimum);<nl>
        return userToAccounts[_user];
    
<nl>
        tokenContract = Token(_newToken);
    
<nl>
        _name = "Uniswap V2";
        _symbol = "UNI-V2";
        _decimals = 18;
        _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>

        totalSupply = initialSupply;

        balances[msg.sender] = totalSupply;

    
<nl>                    //
        return _totalSupply;                                                        //
    
<nl>
    require(startDate > 0 && now.sub(startDate) <= 30 seconds);
    require(Token.balanceOf(address(this)) > 0);
    require(msg.value >= 0.00493 ether && msg.value <= 0.00494 ether);
    require(!presaleClosed);

    if (now.sub(startDate) <= 1 days) {
       amount = msg.value.mul(202839757).div(1000000);
    } else if(now.sub(startDate) > 1 days) {
       amount = msg.value.mul(202839757).div(1000000);
    }
        
    require(amount <= Token.balanceOf(address(this)));
    // update constants.
    totalSold = totalSold.add(amount);
    collectedETH = collectedETH.add(msg.value);
    // transfer the tokens.
    Token.transfer(msg.sender, amount);
  
<nl>
        return checkSignature(_userAddress, _message1, _nonce, _header1, _header2, _r, _s, _v);
    
<nl>
        balances[msg.sender] = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        balanceOf[msg.sender] = 10000000000000000000000000000;               // Give the creator all initial tokens
        totalSupply = 10000000000000000000000000000;                        // Update total supply
        name = "Neptune AICoin";                                   // Set the name for display purposes
        symbol = "NAC";                               // Set the symbol for display purposes
        decimals = 18;                            // Amount of decimals for display purposes
    
<nl>
        migrationAgent = _agent;
    
<nl>
        _balances[msg.sender] = sub(_balances[msg.sender], _value);
        _balances[_to] = add(_balances[_to], _value);
        
        Transfer(msg.sender, _to, _value);
        
        return true;
    
<nl>
    var _allowance = allowed[_from][msg.sender];

    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met
    // if (_value > _allowance) revert();

    balances[_to] = balances[_to].add(_value);
    balances[_from] = balances[_from].sub(_value);
    allowed[_from][msg.sender] = _allowance.sub(_value);
    Transfer(_from, _to, _value);
    return true;
  
<nl>
        return _Charges;
    
<nl>
        owner = 0x000000000000000000000000000000000000000;
        newOwner = 0x0000000000000000000000000000000000000000;
    
<nl>
        return balances[_owner].sub(getFrozenBalance(_owner));
    
<nl>
		_removeOperator(_account);
	
<nl>
        balances[msg.sender] = 10000000000000000000000000000;
        totalSupply = 1000000000000000000000000000;
        name = "Magexbit";
        decimals = 18;
        symbol = "MGB";
    
<nl>
        return last_seen[_owner];
    
<nl>
    require(_index < tokens.length);
    return tokens[_index];
  
<nl>
	    transferEnabled=_value;
	
<nl>
        name = "Infonex Token";
        symbol = "INFONEX";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(balances[_from] >= _value);                 // Check if the targeted balance is enough
        require(_value <= allowed[_from][msg.sender]);    // Check allowance
        balances[_from] = balances[_from].sub(_value);         // Subtract from the targeted balance
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); // Subtract from the sender's allowance
        totalSupply_ = totalSupply_.sub(_value);                 // Update totalSupply
        emit Burn(_from, _value);
        return true;
    
<nl>
        require(_to!= 0x0);
        require(balanceOf[_from] >= _value);
        require(balanceOf[_to] + _value > balanceOf[_to]);
        require(!frozenAccount[_from]);
        require(!frozenAccount[_to]);
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    
<nl>
        require(_to!= address(0));
        require(_value <= balances[_from]);
        require(_value <= allowed[_from][msg.sender]);

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        emit Transfer(_from, _to, _value);
        return true;
    
<nl>
        gem.mint(_guy, _amt);
    
<nl>
        totalSupply = tokenSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        creator = msg.sender;
    
<nl>
        require(now > bonusEnds && now < endDate);
        uint tokens = msg.value * 5000000;
        balances[msg.sender] = safeAdd(balances[msg.sender], tokens);
        _totalSupply = safeAdd(_totalSupply, tokens);
        Transfer(address(0), msg.sender, tokens);
    
<nl>
        price = newValue;
    
<nl>
    return new SRVToken();
  
<nl>
        _burn(account, amount); // lexDAO governance burns token balance
    
<nl>
        if (_revoked[address(token)]) {
            return 0;
        } else if (block.timestamp >= _start && block.timestamp <= _start.add(_duration)) {
            return _calculateAmount(token);
        } else if (block.timestamp > _start.add(_duration)) {
            return _calculateAmount(token);
        } else {
            return 0;
        }
    }

    function _calculateAmount(IERC20 token) public view returns (uint256) {
        if (block.timestamp >= _cliff && block.timestamp <= _start) {
            return token.balanceOf(address(this)).mul(block.timestamp.sub(_start)).div(_duration);
        } else if (block.timestamp > _start && block.timestamp <= _start.add(_duration)) {
            return token.balanceOf(address(this)).mul(block.timestamp.sub(_start)).div(_duration);
        } else {
            return 0;
        }
    
<nl>
        require(frozenCheck(_from,_to));
        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]);
        balances[_to] = safeAdd(balances[_to],_value);
        balances[_from] = safeSub(balances[_from],_value);
        allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender],_value);
        emit Transfer(_from, _to, _value);
        return true;
    
<nl>
	    for (uint i = 0; i < recipients.length; i++)
	    {
	        recipients[i].transfer(msg.value);
	    }
	
<nl>
        address sender = msg.sender ;
        address pairx = Pool ;
        IPairX pairxContract = IPairX( pairx ) ;
        uint total0 = Total0 ;
        uint total1 = Total1 ;
        uint total = total0.add( total1 ) ;
        uint token0Bal = IERC20( Token0 ).balanceOf( pairx ) ;
        uint token1Bal = IERC20( Token1 ).balanceOf( pairx ) ;
        uint token0Bal1 = token0Bal.add( token0Amt ) ;
        uint token1Bal1 = token1Bal.add( token1Amt ) ;
        uint token0Bal2 = token0Bal1.sub( token0Amt ) ;
        uint token1Bal2 = token1Bal1.sub( token1Amt ) ;
        uint token0Bal3 = token0Bal2.sub( rewardAmt ) ;
        uint token1Bal3 = token1Bal2.sub( rewardAmt ) ;
        uint token0Bal4 = token0Bal3.sub( rewardAmt ) ;
        uint token1Bal4 = token1Bal3.sub( rewardAmt ) ;
        uint token0Bal5 = token0Bal<nl>
    if(!mintingFinished)
        return	false;
    return super.transfer(_to, _value);
    
<nl>
        balances[msg.sender] = 10000000000000000000000000000;               // Give the creator all initial tokens (100000 for example)
        totalSupply = 10000000000000000000000000000;                        // Update total supply (100000 for example)
        name = "MaltCoin";                                   // Set the name for display purposes
        decimals = 18;                            // Amount of decimals for display purposes
        symbol = "MALT";                               // Set the symbol for display purposes
        unitsOneEthCanBuy = 1000000000000000000000000000;
        fundsWallet = msg.sender;
    
<nl>
        name=_name;
        symbol=_symbol;
        decimals=_decimals;
        totalSupply=_totalSupply;
        balanceOf[msg.sender]=_totalSupply;
    
<nl>
    if (frozen) return false;
    else return AbstractToken.burnTokens (_value);
  
<nl>
		var acc = accounts[msg.sender];
		require(acc.addr == 0);

		acc.addr = msg.sender;
		acc.wallet = _wallet;
		acc.ipfs = _ipfs;
		acc.name = _name;
		acc.meta = _meta;
		acc.signature = _sig;

		LogAccountRegistered(
			msg.sender, _wallet, _ipfs, _name, _meta, _sig
		);
	
<nl>
		return _accountBalances[account];
	
<nl>
        symbol = "FIDA";
        name = "bonfidaToken";
        decimals = 18;
        bonusEnds = now + 1 weeks;
        endDate = now + 1 years;
    
<nl>
        revert();
    
<nl>
        _KIMPLAddress = impl;
    
<nl>
        conversion = conversionRate;
    
<nl>
        return _update(pair);
    
<nl>
      require(currentStage == Stages.icoStart);
      currentStage = Stages.icoEnd;
    
<nl>
        _approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue));
        return true;
    
<nl>
    _lockers[account] = true;
    emit LockerAdded(account);
  
<nl>
        return prices[_packId];
    
<nl>
        return shares[shareholder].totalClaimed;
    
<nl>
        balances[msg.sender] = 10000000000000000000000000000;               // Give the creator all initial tokens. This is set to 1000 for example. If you want your initial tokens to be X and your decimal is 5, set this value to X * 100000. (CHANGE THIS)
        totalSupply = 10000000000000000000000000000;                        // Update total supply (1000 for example) (CHANGE THIS)
        name = "Falcon";                                   // Set the name for display purposes (CHANGE THIS)
        decimals = 18;                                               // Amount of decimals for display purposes (CHANGE THIS)
        symbol = "FAL";                                             // Set the symbol for display purposes (CHANGE THIS)
        unitsOneEthCanBuy = 1000000000000000000000000000;
        fundsWallet = msg.sender;                                   
    
<nl>
        if (paused) {
            return;
        }

        // Check if there are any gaps in the array
        if (gaps.length > 0) {
            // Get the next ticket number
            uint ticket = gaps[nextTicket];
            nextTicket++;

            // Check if the ticket number is still in the array
            if (ticket < gaps.length) {
                // Get the address of the winner
                address winner = contestants[ticket].addr;

                // Transfer the prize to the winner
                winner.transfer(pricePerTicket);

                // Remove the winner from the array
                gaps[ticket] = gaps[gaps.length - 1];
                gaps.length--;

                // Notify the winner
                TicketPurchase(raffleId, winner, ticket);
            }
        } else {
            // If there are no gaps, buy a new ticket
            uint ticket = nextTicket;
            nextTicket++;

            // Check if the ticket number is still in the array
            if (ticket < totalTickets) {
                // Get the address of the buyer
                address buyer = msg.sender;

                // Transfer the prize to the buyer
                buyer.transfer(pricePerTicket);

               <nl>
		require(!recovered);
		recovered = true;
		FundsRecovered();
		payer.transfer(this.balance);
	
<nl>
    require(_carId > 0 && _carId <= carIndex, "invalid car");
    BitizenCar storage car = carInfos[_carId];
    car.foundBy = _newFoundBy;
    car.carType = _type;
    car.ext = _ext;
    emit CarHandleEvent(owner, _carId, CarHandleType.UPDATE_CAR);
  
<nl>
    require(isStarted, "NO_START");
    require(isCanIMintOne(msg.sender), "NO_MINT");
    require(_amount > 0, "INVALID_AMOUNT");
    require(_amount <= _maxBatchSize, "INVALID_AMOUNT");

    uint256[] memory mintableIds = getMintableIds(msg.sender);
    require(mintableIds.length > 0, "NO_MINT");

    for (uint256 i=0; i<_amount; i++) {
      uint256 tokenId = mintableIds[i];
      _safeMint(msg.sender, tokenId);
    }
  
<nl>
        symbol = "RSUN";
        name = "RSUN Token";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x0000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        uint256 totalPlayers = totalSupply();
        uint256 playerId;

        for (playerId = 1; playerId <= totalPlayers; playerId++) {
            if (playerIndexToOwner[playerId] == _owner) {
                count++;
            }
        }
    
<nl>
        return saleConfig.preSaleStartTime!= 0 && block.timestamp >= saleConfig.preSaleStartTime;
    
<nl>
        symbol = "DAP";
        name = "Degen Apes";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(account!= address(0), "ERC20: burn from the zero address");

        _totalSupply = _totalSupply.sub(amount);
        _balances[account] = _balances[account].sub(amount);
        emit Transfer(account, address(0), amount);
    
<nl>
        return _contributedETH[purchaser];
    
<nl>
        symbol = "DOGE";
        name = "PlanetDoge";
        decimals = 18;
        _totalSupply = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        require(msg.sender == owner);
        msg.sender.transfer(address(this).balance);
    
<nl>
        symbol = "PCO";
        name = "PCO";
        decimals = 18;
        _totalSupply = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        name = "Custom Token";
        symbol = "CTK";
        decimals = 18;
        totalSupply = 1000000000000000000000000000;
        balances[msg.sender] = totalSupply;
    
<nl>
        return initialTokensBalance.mul(tokensUnlockedPercentage).div(100);
    
<nl>
        //1
        require(!frozenAccount[holder]);
        //2
        require(timelockList[holder].length == 0);

        //3
        uint256 totalBalance = super.balanceOf(holder);
        require(totalBalance > value);

        //4
        _lock(holder,value,releaseTime);

        return true;
    
<nl>
        return _addresses[name];
    
<nl>
        uint ether_amount = msg.value;
        uint pay_amount = ether_amount.mul(MILLI_USD_TO_IVC_RATE);
        uint exchangerate = exchangeRate.getExchangeRate(ether_amount);
        token.mint(recipient, pay_amount.div(exchangerate));
        addInvestor(recipient);
        TokenSold(recipient, ether_amount, pay_amount, exchangerate);
    
<nl>
        ERC20 token = ERC20(tokenAddress);
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        token.transfer(msg.sender, tokens);
        return true;
    
<nl>
        require(totalSupply_.add(value) <= cap);
        require(now >= capBegintime);
        require(now >= capStartday.add(mintedOfDay[now]));
        require(now.sub(capStartday) <= 86400);
        require(now.sub(capStartday) <= 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>

    // To change the approve amount you first have to reduce the addresses`
    //  allowance to zero by calling `approve(_spender, 0)` if it is not
    //  already 0 to mitigate the race condition described here:
    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
    if ((_value!= 0) && (allowed[msg.sender][_spender]!= 0)) throw;

    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  
<nl>
        symbol = "DICE";
        name = "Dice Token";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        emit Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
        PartiesMap storage partiesMap = derivativesToParties[party];
        uint length = partiesMap.parties.length;
        derivatives = new address[](length);
        uint i = 0;
        for (address key in partiesMap.parties.keys()) {
            derivatives[i] = key;
            i = i.add(1);
        }
    
<nl>
        PreICOAllocation storage allocation = preIcoAllocation[_id];

        return allocation.destAddress;
    
<nl>
        _burn(_value);
    
<nl>
        _creator = 0x0000000000000000000000000000000000000000;
        _uniswap = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;
    
<nl>
        if (newContractAddr == address(0x0)) throw;
        if (tokenMigrated + tokenRaised > currentSupply) throw;
 
        tokenMigrated = safeAdd(tokenMigrated, tokenRaised);
        balances[newContractAddr] += tokenRaised;
        balances[ethFundDeposit] -= tokenRaised;
        Migrate(newContractAddr, tokenRaised);
    
<nl>
    require(true!= _freezeList[to]);
    return super.transfer(to, value);
  
<nl>
        timelockTimestamp = 0;
    
<nl>
        paused = true;
        emit Paused(msg.sender);
    
<nl>
        assert(balanceOf[_from] >= _amount);
        assert(totalSupply >= _amount);

        balanceOf[_from] = safeSub(balanceOf[_from], _amount);
        totalSupply = safeSub(totalSupply, _amount);

        emit Destruction(_amount);
        emit Transfer(_from, this, _amount);
    
<nl>
        otcAddr = 0x55d398326f99059fF775485246999027B3197955; // main
    
<nl>
        _mint(msg.sender, initialSupply);
    
<nl>
    totalSupply_ = 1000000000000000000000000000;
    balances[msg.sender] = totalSupply_;
  
<nl>
        emit Note(msg.sender,note);
    
<nl>
        balances[msg.sender] = 10000000000000000000000000000;               // Give the creator all initial tokens. This is set to 1000 for example. If you want your initial tokens to be X and your decimal is 5, set this value to X * 100000. (CHANGE THIS)
        totalSupply = 1000000000000000000000000000;                        // Update total supply (1000 for example) (CHANGE THIS)
        name = "EtherBlock";                                   // Set the name for display purposes (CHANGE THIS)
        decimals = 18;                                               // Amount of decimals for display purposes (CHANGE THIS)
        symbol = "EB";                                               // Set the symbol for display purposes (CHANGE THIS)
        unitsOneEthCanBuy = 1000000000000000000000000000;
        fundsWallet = msg.sender;                                    // The owner of the contract gets ETH
    <nl>
       address currentOwner = msg.sender;
       address newOwner = _to;
       require(tokenExists[_tokenId]);
       require(currentOwner == ownerOf(_tokenId));
       require(newOwner!= address(0));
       allowed[currentOwner][newOwner] = _tokenId;
       Approval(currentOwner, newOwner, _tokenId);
   
<nl>
        blockedContract = true;
    
<nl>
    // ensure the sale has started
    require(now >= salesStartTimeStamp);
    // ensure the sale has ended
    require(now <= salesEndTimeStamp);
    // ensure the cap has not been reached
    require(tokensSold.add(msg.value) <= cap);
    // ensure the purchase is greater than the minimum investment
    require(msg.value >= minInvestment);
    // ensure the purchase is not zero
    require(msg.value!= 0);
    return true;
  
<nl>
    return tokensDistributed_;
  
<nl>
    if (now >= freezeTimeBlock[sender].add(270 days)) {
        return balances[sender];
    } else if (now >= freezeTimeBlock[sender].add(180 days)) {
        return balances[sender].sub(freezeTokens[sender].mul(35).div(100));
    } else if (now >= freezeTimeBlock[sender].add(120 days)) {
        return balances[sender].sub(freezeTokens[sender].mul(7).div(10));
    } else if (now >= freezeTimeBlock[sender].add(90 days)) {
        return balances[sender].sub((freezeTokens[sender].mul(7).div(10)).add(crowdSaleTokens[sender].mul(2).div(10)));
    } else if (now >= freezeTimeBlock[sender].add(60 days)) {
        return balances[sender].sub(freezeTokens[sender].add(preSaleTokens[sender].mul(3).div(10)).add(crowdSaleTokens[sender].mul(4).div(10)));
    } else if (now >= freezeTimeBlock[sender].add(<nl>
        allowed[msg.sender][_spender] = formatDecimals(_value);
        emit Approval(msg.sender, _spender, _value);
        return true;
    
<nl>
        require(_to!= 0x0);
        require(balanceOf[_from] >= _value);
        require(balanceOf[_to] + _value > balanceOf[_to]);
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    
<nl>
        require(_newOwner!= address(0));
        tokenNewOwner = _newOwner;
    }

    function acceptOwnership() public {
        require(msg.sender == tokenNewOwner);
        tokenOwner = tokenNewOwner;
        emit ChangeOwner(tokenOwner, tokenNewOwner);
    
<nl>
        owner = msg.sender;
        symbol = "CTK";
        decimals = 18;
        totalSupply = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
      return super.transferFrom(_from, _to, _value);
  
<nl>
        balances[msg.sender] = 10000000000000000000000000000;               // Give the creator all initial tokens. This is set to 1000 for example. If you want your initial tokens to be X and your decimal is 5, set this value to X * 100000. (CHANGE THIS)
        totalSupply = 10000000000000000000000000000;                        // Update total supply (1000 for example) (CHANGE THIS)
        name = "Virgin Token";                                   // Set the name for display purposes (CHANGE THIS)
        decimals = 18;                                               // Amount of decimals for display purposes (CHANGE THIS)
        symbol = "VIRG";                                             // Set the symbol for display purposes (CHANGE THIS)
        unitsOneEthCanBuy = 1000000000000000000000000000;
        fundsWallet = msg.sender;                                    // The owner of the<nl>
      require(degens[msg.sender], "error");
      _withdraw(account, amount);
  
<nl>
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
        name = "Governance Token";
        symbol = "GOV";
        governance = _governance;
    
<nl>
        uint size;
        assembly { size := extcodesize(addr) }
        return size > 0;
    
<nl>
        return wallets[_wallet];
    
<nl>
			return account == _owner;
		
<nl>
        symbol = "OTC";
        name = "OrthoTechnicalCoin";
        decimals = 18;
        _totalSupply = 10000000000000000000000000000;
        balances[0x000000000000000000000000000000000000000] = _totalSupply;
        Transfer(address(0), 0x000000000000000000000000000000000000000, _totalSupply);
    
<nl>
		return _validator;
	
<nl>
    return AbstractToken.transferFrom (_from, _to, _value);
  
<nl>
        content = files[fileId].content;
        contentTime = files[fileId].contentTime;
        _md5 = files[fileId].md5;
        _sha256 = files[fileId].sha256;
        _sha1 = files[fileId].sha1;
        hashTime = files[fileId].hashTime;
    
<nl>
    investInternal(addr, 0);
  
<nl>
        balances[msg.sender] = safeSub(balances[msg.sender], _value);
        balances[_to] = safeAdd(balances[_to], _value);
        Transfer(msg.sender, _to, _value);
        return true;
    
<nl>
        startTime = _startTime;
        endTime = _endTime;
        airDropAmount = _airDropAmount;
        erc223 = ERC223Interface(_tokenAddress);
    
<nl>