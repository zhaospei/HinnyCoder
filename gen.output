
		if (mm.getName().equals(attributeName))
		{
			if (isCompileAttribute)
			{
				if (mm.isCompileAttribute())
				{
					add(mm.getCompileAttribute());
				}
			}
			else
			{
				if (mm.isAttribute())
				{
					add(mm.getAttribute());
				}
			}
		}
	<|file_separator|><nl>
        int result = name != null ? name.hashCode() : 0;
        result = 31 * result + (attributeString != null ? attributeString.hashCode() : 0);
        result = 31 * result + (children != null ? children.hashCode() : 0);
        result = 31 * result + (parent != null ? parent.hashCode() : 0);
        result = 31 * result + (selfClosing ? 1 : 0);
        result = 31 * result + (textContent != null ? textContent.hashCode() : 0);
        return result;
    <|file_separator|><nl>
		final String label = instruction.getLabel();

		if (label != null)
		{
			return Long.parseLong(label, 16);
		}

		return null;
	<|file_separator|><nl>
		for (LineTableEntry entry : lineTableEntries)
		{
			if (entry.getSourceOffset() == sourceLine)
			{
				return true;
			}
		}

		return false;
	<|file_separator|><nl>
		if (parserType == ParserType.JIT)
		{
			return new JitParser(jitListener);
		}
		else
		{
			return new CppParser();
		}
	<|file_separator|>class CppParser.cs
<|fim_prefix|><|fim_suffix|>
	}
}<|fim_middle|>public class CppParser : ILogParser
{
	public void parse(string log)
	{
		// parse Cpp log<|file_separator|>class JitParser.cs
<|fim_prefix|><|fim_suffix|>
	}
}<|fim_middle|>public class JitParser : ILogParser
{
	private IJITListener jitListener;

	public JitParser(IJITListener jitListener)
	{
		this.jitListener = jitListener;
	}

	public void parse(string log)
	{
		// parse Jit log<|file_separator|>class ILogParser.cs
<|fim_prefix|><|fim_suffix|>
	void parse(string log);
}<|fim_middle|>public interface ILogParser
{<|file_separator|><nl>
		return execute(workingDir, className, classpathEntries, vmOptions, environment, logListener, null);
	}

	@Override
	public boolean execute(Path workingDir, String className, List<String> classpathEntries, List<String> vmOptions, Map<String, String> environment, ILogListener logListener, IProcessListener processListener)
	{
		String[] command = new String[] { runtimePath.toString(), className };

		if (classpathEntries != null)
		{
			command = new String[] { runtimePath.toString(), className, "-cp", String.join(S_PATH_SEPARATOR, classpathEntries) };
		}

		if (vmOptions != null)
		{
			command = new String[] { runtimePath.toString(), className, "-vmOptions", String.join(S_PATH_SEPARATOR, vmOptions) };
		}

		if (environment != null)
		{
			command = new String[] { runtimePath.toString(), className, "-e", String.join(S_PATH_SEPARATOR, environment.keySet().stream().map(key -> key + "=" + environment.get(key)).collect(Collectors.toList())) };
		}

		return execute(workingDir, command, logListener, processListener);
	<|file_separator|><nl>
		return o1.getMarks() - o2.getMarks();
	<|file_separator|><nl>
		if (mm.getMemberName().equals(attr))
		{
			add(mm);
		}
	<|file_separator|>class CompiledAttributeTopList.cs
<|fim_prefix|><|fim_suffix|>
	}
}<|fim_middle|>public class CompiledAttributeTopList : TopList
{
	public CompiledAttributeTopList(IReadOnlyJITDataModel model, String attr, boolean sortHighToLow)
	{
		super(model, new CompiledAttributeTopListVisitable(model, attr, sortHighToLow));<|file_separator|><nl>
		if (metaMember.isNativeMethod())
		{
			NativeMethod nativeMethod = metaMember.getNativeMethod();
			if (nativeMethod.isNative())
			{
				if (nativeMethod.isNativeMethodSize())
				{
					NativeMethodSize nativeMethodSize = nativeMethod.getNativeMethodSize();
					if (nativeMethodSize.isSize())
					{
						NativeMethodSizeTopListElement element = new NativeMethodSizeTopListElement(nativeMethodSize);
						add(element);
					}
				}
			}
		}
	<|file_separator|><nl>
		if (hasLocalJVMS())
		{
			String html = NetUtil.fetchURL("file://" + JVMS_HTML_FILENAME);
			String css = NetUtil.fetchURL("file://" + JVMS_CSS_FILENAME);

			if (html.length() > 0 && css.length() > 0)
			{
				String[] lines = html.split(NEW_LINE);

				for (String line : lines)
				{
					if (line.contains("section-execution"))
					{
						storeBytecodeDescription(line);
					}
				}
			}
		}
	<|file_separator|><nl>
		try
		{
			return new String(fetchBinary(url), StandardCharsets.UTF_8);
		}
		catch (UnsupportedEncodingException e)
		{
			logger.error("Could not fetch URL: {}", url, e);
			return null;
		}
	}

	public static byte[] fetchBinary(String url)
	{
		try
		{
			return fetchBinary(url, new ByteArrayOutputStream());
		}
		catch (IOException e)
		{
			logger.error("Could not fetch URL: {}", url, e);
			return null;
		}
	}

	public static byte[] fetchBinary(String url, ByteArrayOutputStream targetStream)
	{
		try (BufferedInputStream bufferedInputStream = new BufferedInputStream(new URL(url).openStream()))
		{
			byte[] data = new byte[1024];

			int read;

			while ((read = bufferedInputStream.read(data)) != -1)
			{
				targetStream.write(data, 0, read);
			}
		}
		catch (MalformedURLException e)
		{
			logger.error("Bad URL: {}", url, e);
			return null;
		}
		catch (IOException e)
		{
			logger.error("Could not download {}", url, e);
			return null;
		}

		return targetStream.toByteArray();
	<|file_separator|><nl>
      Wrapper2 wrapper = new Wrapper2(random.nextInt());
      return "Wrapper2: " + wrapper.getValue();
    }
<|file_separator|><nl>
        final Wrapper2 wrapper2 = new Wrapper2(0);
        System.out.println(wrapper2.getValue());
    }
<|file_separator|><nl>
        return chars[index];
    <|file_separator|><nl>
        return a + b;
    <|file_separator|><nl>
        new SimpleInliningTest();
    <|file_separator|><nl>
        return count;
    <|file_separator|><nl>
		this.primitiveParam = primitiveParam;
	<|file_separator|><nl>
		return "IsUsedForTestingDefaultPackage";
	<|file_separator|><nl>
		System.out.println("Hello World");
	<|file_separator|><nl>
		LineTable table = new LineTable(null);
		table.add(new LineTableEntry(1, 1));
		table.add(new LineTableEntry(2, 2));
		table.add(new LineTableEntry(3, 3));
		table.add(new LineTableEntry(4, 4));
		table.add(new LineTableEntry(5, 5));
		table.add(new LineTableEntry(6, 6));
		table.add(new LineTableEntry(7, 7));
		table.add(new LineTableEntry(8, 8));
		table.add(new LineTableEntry(9, 9));
		table.add(new LineTableEntry(10, 10));
		table.add(new LineTableEntry(11, 11));
		table.add(new LineTableEntry(12, 12));
		table.add(new LineTableEntry(13, 13));
		table.add(new LineTableEntry(14, 14));
		table.add(new LineTableEntry(15, 15));
		table.add(new LineTableEntry(16, 16));
		table.add(new LineTableEntry(17, 17));
		table.add(new LineTableEntry(18, 18));
		table.add(new LineTableEntry(19, 19));
		table.add(new LineTableEntry(20, 20));
		table.add(new LineTableEntry(21, 21));
		table.add(new LineTableEntry(22, 22));
		table.add(new LineTableEntry<nl>
        int n = random.nextInt(100);
        Wrapper2 w = new Wrapper2(n);
        return "The value is " + w.getValue();
    }
<|file_separator|><nl>
      Wrapper2 wrapper = new Wrapper2("Hello");
      return wrapper.getValue() + random.nextInt();
    }
<|file_separator|><nl>
        new HotThrow();
    <|file_separator|><nl>
        InlineElimAlloc alloc = new InlineElimAlloc();
        alloc.outer(1);
    <|file_separator|><nl>
        System.out.println("Hello World");
    <|file_separator|><nl>
        return "Hello World";
    }
<|fim_middle|>
        return "Hello World";
    }
}

class EscapeConsumer {
    public int smallEnoughToInline(Integer integer) { // 325 bytes of bytecode (inlining limit is 325)
        int i = integer.intValue();
        return ((i + 1) >> 2) + ((i + 2) >> 2) + ((i + 3) >> 2) + ((i + 4) >> 2) + ((i + 5) >> 2) + ((i + 6) >> 2) + ((i + 7) >> 2) + ((i + 8) >> 2) +
               ((i + 1) >> 2) + ((i + 2) >> 2) + ((i + 3) >> 2) + ((i + 4) >> 2) + ((i + 5) >> 2) + ((i + 6) >> 2) + ((i + 7) >> 2) + ((i + 8) >> 2) +
               ((i + 1) >> 2) + ((i + 2) >> 2) + ((i + 3) >> 2) + ((i + 4) >> 2) + ((i + 5) >> 2) + ((i + 6) >> 2) + ((i + 7) >> 2) + ((i + 8) >> 2) +
               ((i + 1) >> 2) + ((i + 2) >> 2) + ((i + 3) >> 2) + ((i + 4) >> 2) + ((i + 5) >> 2) + ((i<nl>
        new SimpleInliningTest();
    <|file_separator|><nl>
		Arrays.sort(theDoubles);

		long count = 0;

		for (int i = 0; i < ARRAY_LENGTH; i++)
		{
			if (theDoubles[i] > 0.5)
			{
				count++;
			}
		}
		return count;
	<|file_separator|><nl>
		return report.getEliminatedType();
	}
	
	public String getEliminatedTypeSignature()
	{
		return report.getEliminatedTypeSignature();
	}
	
	public String getEliminatedTypeKind()
	{
		return report.getEliminatedTypeKind();
	}
	
	public String getEliminatedTypeKindSignature()
	{
		return report.getEliminatedTypeKindSignature();
	<|file_separator|><nl>
				return new TextTableCell();
			<|file_separator|><nl>
		return instruction;
	<|file_separator|>class BytecodeInstruction.java
<|fim_prefix|><|fim_suffix|>
	
	public String toString(int maxOffset, int line)
	{
		return String.format("%s %s", name, getOffsetString(maxOffset, line));
	}
	
	public String getOffsetString(int maxOffset, int line)
	{
		if (maxOffset == -1)
			return "";
		
		int offset = line - offset;
		if (offset < 0)
			offset = 0;
		
		if (offset > maxOffset)
			offset = maxOffset;
		
		return String.format("(%d)", offset);
	}
	
	public int getOffset()
	{
		return offset;
	}
	
	public int getLine()
	{
		return line;
	}
	
	public int getLength()
	{
		return length;
	}
	
	public int getOpcode()
	{
		return opcode;
	}
	
	public int getArgCount()
	{
		return argCount;
	}
	
	public int getArg(int index)
	{
		return args[index];
	}
	
	public int getArg(String name)
	{
		for (int i = 0; i < argCount; i++)
		{
			if (args[i] == name)
				return i;
		}
		
		return -1;
	}
	
	public int getArg(int index, int defaultValue)
	{
		if (index < 0 || index >= argCount)
			return defaultValue;
		
		return args[index];
	}
	
<nl>
        logger.error("Exception", e);
        return new BaseModel(false, e.getMessage());
    <|file_separator|><nl>
        init();
        super.save();
    <|file_separator|><nl>
        this.status = "init";
    }

    public void start() {
        this.status = "start";
    }

    public void stop() {
        this.status = "stop";
    }

    public void destroy() {
        this.status = "destroy";
    }

    public void restart() {
        this.status = "restart";
    }
<|file_separator|><nl>
        return new ClickHouseAdapter();
    <|file_separator|><nl>
        ClassLoader cl = changeCL();
        try {
            return OuterAdapter.super.count(task);
        } finally {
            revertCL(cl);
        }
    <|file_separator|><nl>
        String index = "test";
        String type = "test";
        String id = "1";
        String json = "{\n" +
                "  \"name\": \"test\",\n" +
                "  \"age\": 18\n" +
                "}";
        esConnection.create(index, type, id, json);
    <|file_separator|><nl>
        try {
            esTemplate.executeSql(ds, sql, values, adapterMapping, impCount, errMsg);
        } catch (Exception e) {
            logger.error("error in executeSqlImport", e);
            return false;
        }
        return true;
    <|file_separator|><nl>
        Map<String, String> result = new HashMap<String, String>();
        for (String column : columns) {
            result.put(column, kuduMapping.getColumn(column));
        }
        return result;
    <|file_separator|><nl>
        if (mode == Mode.LOCAL) {
        <|file_separator|><nl>
        getConn().rollback();
    <|file_separator|><nl>
        // 
        System.out.println(DatasourceConfig.DATA_SOURCES.get("defaultDS"));
    <|file_separator|><nl>
        Map<String, MappingConfig> mappingConfigs = new HashMap<>();
        return mappingConfigs;
    <|file_separator|><nl>
        try {
            Connection conn = srcDS.getConnection();
            Statement stmt = conn.createStatement();
            ResultSet rs = stmt.executeQuery(sql);
            while (rs.next()) {
                Dml dml = getDMLByRs(mapping.getColumnsMap(), rs);
                writer.write(dml);
                impCount.incrementAndGet();
            }
            return true;
        } catch (Exception e) {
            errMsg.add(e.getMessage());
            return false;
        }
    <|file_separator|><nl>
        if (index >= nodes.size()) {
            index = 0;
        }
        return nodes.get(index++);
    <|file_separator|><nl>
        return offset;
    <|file_separator|><nl>
        return blockBuf;
    <|file_separator|><nl>
        return incident;
    <|file_separator|><nl>
        return null;
    }

    public final String getQuery() {
        return null;
    }

    public final String getQuery() {
        return null;
    <|file_separator|><nl>
        return rowsQuery;
    <|file_separator|><nl>
        if (event.getEventType() == LogEvent.ENUM_END_EVENT) {
            return;
        }
        if (event.getEventType() == LogEvent.ENUM_WRITE_ROWS_EVENT) {
            // TODO
        }
    <|file_separator|><nl>
        byte[] data = new byte[1024];
        int offset = 0;
        data[offset++] = (byte) (clientCapability & 0xFF);
        data[offset++] = (byte) ((clientCapability >> 8) & 0xFF);
        data[offset++] = (byte) ((clientCapability >> 16) & 0xFF);
        data[offset++] = (byte) ((clientCapability >> 24) & 0xFF);
        data[offset++] = (byte) (maxPacketSize & 0xFF);
        data[offset++] = (byte) ((maxPacketSize >> 8) & 0xFF);
        data[offset++] = (byte) ((maxPacketSize >> 16) & 0xFF);
        data[offset++] = (byte) ((maxPacketSize >> 24) & 0xFF);
        data[offset++] = charsetNumber;
        data[offset++] = 0x00;
        data[offset++] = 0x00;
        data[offset++] = 0x00;
        data[offset++] = 0x00;
        data[offset++] = 0x00;
        data[offset++] = 0x00;
        data[offset++] = 0x00;
        data[offset++] = 0x00;
        data[offset++] = 0x00;
        data[offset++] = 0x00;
        data[offset++] = 0x00;
        data[offset++] = 0x00;
        data[offset++] = 0x00;
        data[offset++] = 0x00;
        data[offset++] = 0x<nl>
        return null;
    <|file_separator|><nl>
        super.fromBytes(data);
    <|file_separator|><nl>
        return "netty";
    <|file_separator|><nl>

        // Arrange
        final byte[] expected = new byte[] { (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (<nl>
        try {
            connector.start();
        } catch (Throwable e) {
            logger.error("## Something goes wrong when starting up the rocketmq consumer:", e);
        }
    <|file_separator|><nl>
        this.eventStore = eventStore;
    <|file_separator|><nl>
        this.schemaName = schemaName;
    <|file_separator|><nl>
    <|file_separator|><nl>
        this.lastTouch = System.currentTimeMillis();
    <|file_separator|><nl>
        MetaSnapshot metaSnapshot = new MetaSnapshot();
        metaSnapshot.setSnapshotId("1");
        metaSnapshot.setSnapshotName("test");
        metaSnapshot.setSnapshotType("test");
        metaSnapshot.setSnapshotTime(new Date());
        metaSnapshot.setSnapshotStatus("test");
        metaSnapshot.setSnapshotContent("test");
        metaSnapshot.setSnapshotContent("test");
        metaSnapshot.setSnapshotContent("test");
        metaSnapshot.setSnapshotContent("test");
        metaSnapshot.setSnapshotContent("test");
        metaSnapshot.setSnapshotContent("test");
        metaSnapshot.setSnapshotContent("test");
        metaSnapshot.setSnapshotContent("test");
        metaSnapshot.setSnapshotContent("test");
        metaSnapshot.setSnapshotContent("test");
        metaSnapshot.setSnapshotContent("test");
        metaSnapshot.setSnapshotContent("test");
        metaSnapshot.setSnapshotContent("test");
        metaSnapshot.setSnapshotContent("test");
        metaSnapshot.setSnapshotContent("test");
        metaSnapshot.setSnapshotContent("test");
        metaSnapshot.setSnapshotContent("test");
        metaSnapshot.setSnapshotContent("test");
        metaSnapshot.setSnapshotContent("test");
        metaSnapshot.setSnapshotContent("test");
        metaSnapshot.setSnapshotContent("test");
        metaSnapshot.setSnapshotContent("test");
        metaSnapshot.setSnapshotContent("test");
        metaSnapshot.setSnapshotContent("test");
        metaSnapshot.setSnapshotContent("test");
        metaSnapshot.setSnapshotContent("test");
        metaSnapshot.setSnapshotContent("test");
        metaSnapshot.setSnapshotContent("test");
        metaSnapshot.setSnapshotContent("test");
        metaSnapshot.setSnapshotContent("test");
        meta<nl>
        tableMetaManager.createMetaFile("test.json");
    <|file_separator|><nl>
        super.testAll();
    <|file_separator|><nl>
        super.testAll();
    <|file_separator|><nl>
        super.setUp();
    <|file_separator|><nl>
        if (outboundCounter != null) {
            outboundCounter.unregister();
        }
        if (packetsCounter != null) {
            packetsCounter.unregister();
        }
        if (emptyBatchesCounter != null) {
            emptyBatchesCounter.unregister();
        }
        if (errorsCounter != null) {
            errorsCounter.unregister();
        }
        if (responseLatency != null) {
            responseLatency.unregister();
        }
        running = false;
    }<|file_separator|><nl>
    <|file_separator|><nl>
        return Packet.newBuilder()
            .setType(AdminPacket.PacketType.ERROR)
            .setVersion(VERSION)
            .setBody(Error.newBuilder().setCode(errorCode).setMessage(errorMessage).build().toByteString())
            .build()
            .toByteArray();
    }

    public static byte[] errorPacket(int errorCode, String errorMessage, String message) {
        return Packet.newBuilder()
            .setType(AdminPacket.PacketType.ERROR)
            .setVersion(VERSION)
            .setBody(Error.newBuilder().setCode(errorCode).setMessage(errorMessage).setMessage(message).build().toByteString())
            .build()
            .toByteArray();
    }

    public static byte[] errorPacket(int errorCode, String errorMessage, String message, String detail) {
        return Packet.newBuilder()
            .setType(AdminPacket.PacketType.ERROR)
            .setVersion(VERSION)
            .setBody(Error.newBuilder().setCode(errorCode).setMessage(errorMessage).setMessage(message).setDetail(detail).build().toByteString())
            .build()
            .toByteArray();
    }

    public static byte[] errorPacket(int errorCode, String errorMessage, String message, String detail, String stackTrace) {
        return Packet.newBuilder()
            .setType(AdminPacket.PacketType.ERROR)
            .setVersion(VERSION)
            .setBody(Error.newBuilder().setCode(errorCode).setMessage(errorMessage).setMessage(message).setDetail(detail).setStackTrace(stackTrace).build().toByteString())
            .build()
            .toByteArray();
    }

    public static byte[] errorPacket(int errorCode, String errorMessage, String message, String detail, String stackTrace, String cause) {
        return Packet.newBuilder()
            .setType(AdminPacket.PacketType.ERROR)
            .set<nl>
        super.start();
        barrier = new GroupBarrier(groupSize);
    <|file_separator|><nl>
        return rowsCount;
    <|file_separator|><nl>
        Header.Builder headerBuilder = Header.newBuilder();
        headerBuilder.setLogfileName(binlogFile);
        headerBuilder.setLogfileOffset(offset);
        headerBuilder.setExecuteTime(timestamp);
        headerBuilder.setEventLength(eventLenght);
        Entry.Builder entryBuilder = Entry.newBuilder();
        entryBuilder.setHeader(headerBuilder.build());
        Entry entry = entryBuilder.build();

        return new Event(new LogIdentity(new InetSocketAddress(MYSQL_ADDRESS, 3306), 1234L), entry);
    <|file_separator|><nl>
        System.out.println("Hello World");
    <|file_separator|><nl>
        // do something
    <|file_separator|><nl>
        CustomerEntity customerEntity = new CustomerEntity();
        customerEntity.setCustomerName(addCustomerCmd.getCustomerName());
        customerEntity.setCustomerAddress(addCustomerCmd.getCustomerAddress());
        customerEntity.setCustomerEmail(addCustomerCmd.getCustomerEmail());
        customerEntity.setCustomerPhone(addCustomerCmd.getCustomerPhone());
        customerEntity.setCustomerType(addCustomerCmd.getCustomerType());
        customerEntity.setCustomerStatus(addCustomerCmd.getCustomerStatus());
        customerEntity.setCustomerNotes(addCustomerCmd.getCustomerNotes());
        customerEntity.setCustomerDateCreated(addCustomerCmd.getCustomerDateCreated());
        customerEntity.setCustomerDateModified(addCustomerCmd.getCustomerDateModified());
        return customerEntity;
    <|file_separator|><nl>
        this.source = source;
    <|file_separator|><nl>
        return companyName;
    <|file_separator|><nl>
        RuleBuilder ruleBuilder = new RuleBuilder();
        Rule rule = ruleBuilder.buildRule("FizzBuzz");
        assertEquals(rule.getRule(), "FizzBuzz");
    <|file_separator|><nl>
        target = stateMap.get(stateId);
        return this;
    }

    @Override
    public On<S, E, C> on(E event) {
        target.addEvent(event);
        return this;
    }

    @Override
    public From<S, E, C> from(S stateId) {
        target = stateMap.get(stateId);
        return this;
    }

    @Override
    public State<S, E, C> build() {
        return target;
    <|file_separator|>class StateBuilder.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>import java.util.HashMap;
import java.util.Map;

public class StateBuilder<S,E,C> {

    private final Map<S, State<S, E, C>> stateMap = new HashMap<>();

    public StateBuilder<S, E, C> state(S stateId) {
        stateMap.put(stateId, new State<>(stateId));
        return this;
    }

    public Map<S, State<S, E, C>> build() {
        return stateMap;
    }
}<|file_separator|>class State.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>import java.util.ArrayList;
import java.util.List;

public class State<S, E, C> {

    private final S stateId;

    private final List<E> events = new ArrayList<>();

    public State(S stateId) {
        this.stateId = stateId;
    }

    public void addEvent(E event) {
        events.add(event);
    }

    public S getStateId() {
        return stateId;
    }

    public List<E> getEvents() {
        return events;
    }
}<|file_separator|>class TransitionType<nl>
        List<Transition<S,E,C>> existingTransitions = eventTransitions.get(event);
        if (existingTransitions == null) {
            existingTransitions = new ArrayList<>();
        }
        verify(existingTransitions, transition);
        eventTransitions.put(event, existingTransitions);
    <|file_separator|>class StateMachineException.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class StateMachineException extends RuntimeException {
    public StateMachineException(String message) {
        super(message);
    }
}
<|file_separator|>class StateMachine.java
<|fim_prefix|><|fim_suffix|>

    public void addTransition(E event, S source, S target, C context) {
        Transition<S, E, C> transition = new Transition<>(source, target, event, context);
        eventTransitions.put(event, transition);
    }

    public void addTransition(E event, S source, S target) {
        Transition<S, E, C> transition = new Transition<>(source, target, event);
        eventTransitions.put(event, transition);
    }

    public void addTransition(E event, S source, S target, C context, S sourceState, S targetState) {
        Transition<S, E, C> transition = new Transition<>(source, target, event, context, sourceState, targetState);
        eventTransitions.put(event, transition);
    }

    public void addTransition(E event, S source, S target, C context, S sourceState, S targetState, S sourceState2, S targetState2) {
        Transition<S, E, C> transition = new Transition<>(source, target, event, context, sourceState, targetState, sourceState2, targetState2);
        eventTransitions.put(event, transition);
    }

    public void addTransition(E event, S source,<nl>
        ChargeRecordDto chargeRecordDto = new ChargeRecordDto();
        chargeRecordDto.id = chargeRecord.id;
        chargeRecordDto.sessionId = chargeRecord.sessionId;
        chargeRecordDto.phoneNo = chargeRecord.phoneNo;
        chargeRecordDto.chargeDuration = chargeRecord.chargeDuration;
        chargeRecordDto.cost = chargeRecord.cost;
        chargeRecordDto.callType = chargeRecord.callType;
        chargeRecordDto.chargePlanType = chargeRecord.chargePlanType;
        return chargeRecordDto;
    <|file_separator|><nl>
        return ApplicationContextHelper.applicationContext.getBean(targetClz);
    <|file_separator|><nl>
        List<ChargeRecord> chargeRecords = new ArrayList<>();
        for (ChargePlan chargePlan : chargePlanList) {
            chargeRecords.addAll(chargePlan.charge(ctx));
        }
        return chargeRecords;
    }

    public void setPhoneNo(long phoneNo) {
        this.phoneNo = phoneNo;
    }

    public void setRemaining(Money remaining) {
        this.remaining = remaining;
    }

    public void setChargePlanList(List<ChargePlan> chargePlanList) {
        this.chargePlanList = chargePlanList;
    <|file_separator|><nl>
        return entityData.getAmount();<|file_separator|><nl>
        return new BasicChargeFee();
    <|file_separator|>class ChargePlan.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public abstract class ChargePlan<T extends Resource> {
    public int priority;

    public abstract T getResource();

    public abstract ChargePlanType getType();
}
<|file_separator|>class ChargePlanType.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public enum ChargePlanType {
    BASIC,
    PREMIUM,
    SUPER_PREMIUM
}
<|file_separator|>class Resource.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public interface Resource {
}
<|file_separator|>class SuperPremiumChargePlan extends ChargePlan<SuperPremiumChargePlan.SuperPremiumChargeFee>{

    public SuperPremiumChargePlan(){
        this.priority = 0;
    }

    @Override
    public SuperPremiumChargeFee getResource() {
        return new SuperPremiumChargeFee();
    }

    @Override
    public ChargePlanType getType() {
        return ChargePlanType.SUPER_PREMIUM;
    }

    public static class SuperPremiumChargeFee implements Resource{
        /**
         * 100.0
         */
        public final int CALLING_PRICE = 10;

        /**
         * 80.0
         */
        public final int CALLED_PRICE = 8;
    }
}<|file_separator|>class PremiumChargePlan extends ChargePlan<PremiumChargePlan.PremiumChargeFee>{

    public PremiumChargePlan(){
        this.priority = 0;
    }

    @Override
    public PremiumChargeFee getResource() {
        return new PremiumChargeFee();
    }

    @Override
    public ChargePlanType getType() {
        return ChargePlanType.PREMIUM;
    }

    public static class PremiumChargeFee implements<nl>
        return new ChargeRecord(ctx.getChargeId(), ctx.getChargeTime(), ctx.getChargeAmount());
    <|file_separator|><nl>
        ChargeRecordPlan chargeRecordPlan = new ChargeRecordPlan();
        chargeRecordPlan.setPriority(1);
        assertEquals(1, chargeRecordPlan.getPriority());
    <|file_separator|><nl>
        try {
            metricMapper.delete(cmd.getMetricId());
        } catch (Exception e) {
            return Response.error(e.getMessage());
        }
        return Response.success();
    <|file_separator|><nl>
        DevQualityMetric devQualityMetric = new DevQualityMetric(userProfile);
        List<SubMetric> subMetricList = metricGateway.listByTechDevQuality(userProfile.getUserId());
        subMetricList.forEach(subMetric -> subMetric.setParent(devQualityMetric));
    <|file_separator|><nl>
        return customerId;
    <|file_separator|><nl>
		return 0.5;
	<|file_separator|>class SubMetric.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public abstract class SubMetric {

	public MainMetric parent;
	public SubMetricType subMetricType;

	public abstract double getWeight();
}<|file_separator|>class MainMetric.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>import java.util.ArrayList;

public class MainMetric {

	public ArrayList<SubMetric> subMetrics;

	public MainMetric() {
		this.subMetrics = new ArrayList<SubMetric>();
	}

	public void addSubMetric(SubMetric subMetric) {
		this.subMetrics.add(subMetric);
	}

	public double getWeight() {
		double weight = 0;
		for (SubMetric subMetric : subMetrics) {
			weight += subMetric.getWeight();
		}
		return weight;
	}
}<|file_separator|><nl>
        return 0;
    <|file_separator|>class Weight.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public abstract class Weight {
    public abstract double getAppQualityWeight();
    public abstract double getTechInfluenceWeight();
    public abstract double getTechContributionWeight();
    public abstract double getDevQualityWeight();
}<|file_separator|>class WeightFactory.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class WeightFactory {
    public static Weight getWeight(String type){
        if(type.equals("app")){
            return new AppWeight();
        }
        else if(type.equals("tech")){
            return new TechWeight();
        }
        else if(type.equals("dev")){
            return new DevWeight();
        }
        else if(type.equals("other")){
            return new OtherWeight();
        }
        return null;
    }
}<|file_separator|>class AppWeight.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class AppWeight extends Weight{
    public static AppWeight singleton= new AppWeight();
    @Override
    public double getAppQualityWeight() {
        return 1;
    }

    @Override
    public double getTechInfluenceWeight() {
        return 0;
    }

    @Override
    public double getTechContributionWeight() {
        return 0;
    }

    @Override
    public double getDevQualityWeight() {
        return 0;
    }
}<|file_separator|>class TechWeight.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class TechWeight extends Weight{
    public static TechWeight singleton= new TechWeight();
    @Override
    public double getAppQualityWeight() {
        return 0;
    }

    @Override
    public double getTechInfluenceWeight() {
        return 1;
    }

    @Override
    public double getTechContributionWeight() {
        return 0;
    <nl>
        System.out.println("Hello World");
    <|file_separator|><nl>
        this.connectionLogger = connectionLogger;
        this.connectionLoggerName = connectionLogger.getName();
    <|file_separator|><nl>
        StickyDataSourceHolder holder = holders.get();
        if (holder == null) {
            holder = new StickyDataSourceHolder();
            holders.set(holder);
        }
        if (isAvailable(holder)) {
            return holder.getDataSource();
        }
        return super.get();
    <|file_separator|><nl>
        return instance;
    <|file_separator|><nl>
        return true;
    <|file_separator|><nl>
        super.configFromProperties(properties);
        String usePingMethod = properties.getProperty("usePingMethod");
        if (StringUtils.isNotEmpty(usePingMethod)) {
            this.usePingMethod = Boolean.parseBoolean(usePingMethod);
        }
    <|file_separator|><nl>
        return false;
    }

    @Override
    public void handleException(SQLException e) {
    <|file_separator|><nl>
        return true;
    <|file_separator|><nl>
        return attributes.get(name);
    <|file_separator|><nl>
        return partitionsCount;
    <|file_separator|>class SQLPartitionByHash.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class SQLPartitionByHash extends SQLPartitionBy {
    public SQLPartitionByHash() {
        super();
    }

    public SQLPartitionByHash(SQLExpr partitionsCount) {
        super();
        setPartitionsCount(partitionsCount);
    }

    public SQLPartitionByHash(int partitionsCount) {
        super();
        setPartitionsCount(partitionsCount);
    }

    public SQLPartitionByHash(SQLExpr partitionsCount, SQLExpr columns) {
        super();
        setPartitionsCount(partitionsCount);
        addColumn(columns);
    }

    public SQLPartitionByHash(int partitionsCount, SQLExpr columns) {
        super();
        setPartitionsCount(partitionsCount);
        addColumn(columns);
    }

    public SQLPartitionByHash(SQLExpr partitionsCount, SQLExpr columns, SQLExpr storeIn) {
        super();
        setPartitionsCount(partitionsCount);
        addColumn(columns);
        addStoreIn(storeIn);
    }

    public SQLPartitionByHash(int partitionsCount, SQLExpr columns, SQLExpr storeIn) {
        super();
        setPartitionsCount(partitionsCount);
        addColumn(columns);
        addStoreIn(storeIn);
    }

    public SQLPartitionByHash(SQLExpr partitionsCount, SQLExpr columns, SQLExpr storeIn, SQLExpr lifecycle) {
        super();
        setPartitionsCount(partitionsCount);
        addColumn(columns);
        addStoreIn(storeIn);
        setLifecycle(lifecycle);
    }

    public SQLPartitionByHash(int partitionsCount, SQLExpr columns, SQLExpr storeIn, SQLExpr lifecycle) {
        super();
        setPartitionsCount(partitionsCount);
        addColumn(<nl>
        SQLUnionDataType clone = new SQLUnionDataType();
        for (SQLDataType item : items) {
            clone.add(item.clone());
        }
        return clone;
    <|file_separator|>class SQLUnionDataType.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>package com.github.jknack.handlebars.sql;

import java.util.List;

public class SQLUnionDataType extends SQLDataTypeImpl {
    private final List<SQLDataType> items;

    public SQLUnionDataType() {
        this.items = new ArrayList<SQLDataType>();
    }

    public List<SQLDataType> getItems() {
        return items;
    }

    public void add(SQLDataType item) {
        if (item != null) {
            item.setParent(this);
        }
        items.add(item);
    }

    @Override
    protected void accept0(SQLASTVisitor visitor) {
        if (visitor.visit(this)) {
            acceptChild(visitor, items);
        }
        visitor.endVisit(this);
    }

    public SQLUnionDataType clone() {
        SQLUnionDataType clone = new SQLUnionDataType();
        for (SQLDataType item : items) {
            clone.add(item.clone());
        }
        return clone;
    }
}<|file_separator|>class SQLUnionDataTypeImpl.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>package com.github.jknack.handlebars.sql;

import java.util.List;

public class SQLUnionDataTypeImpl extends SQLDataTypeImpl {
    private final List<SQLDataType> items;

    public SQLUnionDataTypeImpl() {
        this.items = new ArrayList<SQLDataType>();
    }

    public List<SQLDataType> getItems() {
        return items;
    }

    public void add(SQLDataType item) {<nl>
        int result = 17;
        result = 31 * result + (subQuery != null ? subQuery.hashCode() : 0);
        return result;
    <|file_separator|><nl>
        visitor.visit(this);
    }

    @Override
    public String toString() {
        return "SQLArrayExpr [expr=" + expr + ", values=" + values + "]";
    <|file_separator|>class SQLArrayExprImpl.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class SQLArrayExprImpl extends SQLExprImpl implements SQLReplaceable {
    private SQLExpr expr;
    private List<SQLExpr> values = new ArrayList<SQLExpr>();

    public SQLArrayExprImpl() {
    }

    public SQLArrayExprImpl clone() {
        SQLArrayExprImpl x = new SQLArrayExprImpl();
        if (expr != null) {
            x.setExpr(expr.clone());
        }
        for (SQLExpr value : values) {
            SQLExpr value2 = value.clone();
            value2.setParent(x);
            x.values.add(value2);
        }
        return x;
    }

    public SQLExpr getExpr() {
        return expr;
    }

    public void setExpr(SQLExpr expr) {
        this.expr = expr;
    }

    public List<SQLExpr> getValues() {
        return values;
    }

    public void setValues(List<SQLExpr> values) {
        this.values = values;
        if (values != null) {
            for (SQLExpr value : values) {
                value.setParent(this);
            }
        }
    }

    @Override
    protected void accept0(SQLASTVisitor visitor) {
        visitor.visit(this);
    }

    @Override
    public String toString() {
        return "SQLArrayExprImpl [expr=" + expr + ", values=" + values + "]";
    }

    public List<SQLObject> getChildren()<nl>
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }

        SQLBinaryOpExprGroup that = (SQLBinaryOpExprGroup) o;

        if (operator != that.operator) {
            return false;
        }
        if (items != null ? !items.equals(that.items) : that.items != null) {
            return false;
        }

        return true;
    <|file_separator|>class SQLExprImpl.java
<|fim_prefix|><|fim_suffix|>

    public void setParent(SQLExpr parent) {
        this.parent = parent;
    }

    public void setParent(SQLExpr parent, boolean replace) {
        if (replace) {
            this.parent = parent;
        } else {
            this.parent = null;
        }
    }

    public void setParent(SQLExpr parent, boolean replace, boolean replaceParent) {
        if (replace) {
            this.parent = parent;
        } else {
            this.parent = null;
        }

        if (replaceParent) {
            parent.setParent(this);
        }
    }

    public void setParent(SQLExpr parent, boolean replace, boolean replaceParent, boolean replaceChildren) {
        if (replace) {
            this.parent = parent;
        } else {
            this.parent = null;
        }

        if (replaceParent) {
            parent.setParent(this);
        }

        if (replaceChildren) {
            for (SQLExpr child : getChildren()) {
                child.setParent(this);
            }
        }
    }

    public void setParent(SQLExpr parent, boolean replace, boolean replaceParent,<nl>
        visitor.visit(this);
    }

    public void accept(SQLASTVisitor visitor) {
        this.accept0(visitor);
    }

    public void accept(SQLASTVisitor visitor, SQLObject parent) {
        this.accept0(visitor);
    }

    public void accept(SQLASTVisitor visitor, SQLObject parent, SQLObject child) {
        this.accept0(visitor);
    <|file_separator|>class SQLDataType.java
<|fim_prefix|><|fim_suffix|>

    public SQLDataType(String name, int size, int precision, int scale, boolean nullable, boolean autoIncrement, boolean primaryKey, boolean unique, boolean foreignKey, boolean index, boolean uniqueIndex, boolean primaryKeyIndex, boolean uniquePrimaryKeyIndex, boolean uniqueForeignKeyIndex, boolean uniquePrimaryKeyForeignKeyIndex, boolean uniqueForeignKeyForeignKeyIndex, boolean uniquePrimaryKeyForeignKeyForeignKeyIndex, boolean uniquePrimaryKeyForeignKeyForeignKeyIndex, boolean uniquePrimaryKeyForeignKeyForeignKeyIndex, boolean uniquePrimaryKeyForeignKeyForeignKeyIndex, boolean uniquePrimaryKeyForeignKeyForeignKeyIndex, boolean uniquePrimaryKeyForeignKeyForeignKeyIndex, boolean uniquePrimaryKeyForeignKeyForeignKeyIndex, boolean uniquePrimaryKeyForeignKeyForeignKeyIndex, boolean uniquePrimaryKeyForeignKeyForeignKeyIndex, boolean uniquePrimaryKeyForeignKeyForeignKeyIndex, boolean uniquePrimaryKeyForeignKeyForeignKeyIndex, boolean uniquePrimaryKeyForeignKeyForeignKeyIndex, boolean uniquePrimaryKeyForeignKeyForeignKeyIndex, boolean uniquePrimaryKeyForeignKeyForeignKeyIndex, boolean uniquePrimaryKeyForeignKeyForeignKeyIndex, boolean uniquePrimaryKeyForeignKeyForeignKeyIndex, boolean uniquePrimaryKeyForeignKeyForeignKeyIndex, boolean uniquePrimaryKeyForeignKeyForeignKeyIndex, boolean uniquePrimaryKeyForeignKeyForeignKeyIndex, boolean uniquePrimaryKeyForeignKeyForeignKeyIndex, boolean uniquePrimaryKeyForeignKeyForeignKeyIndex, boolean uniquePrimaryKeyForeignKeyForeignKeyIndex, boolean uniquePrimaryKeyForeignKeyForeignKeyIndex, boolean uniquePrimaryKeyForeignKeyForeignKeyIndex, boolean uniquePrimaryKeyForeignKeyForeignKeyIndex, boolean uniquePrimaryKeyForeignKeyForeignKeyIndex, boolean uniquePrimaryKeyForeignKeyForeignKeyIndex, boolean uniquePrimaryKeyForeignKeyForeignKeyIndex, boolean uniquePrimaryKeyForeignKeyForeignKeyIndex, boolean uniquePrimaryKeyForeignKeyForeignKeyIndex, boolean uniquePrimaryKeyForeignKeyForeignKeyIndex, boolean uniquePrimaryKeyForeignKeyForeignKeyIndex, boolean uniquePrimaryKey<nl>
        return Double.valueOf(value).hashCode();
    }

    @Override
    public String toString() {
        return String.valueOf(value);
    <|file_separator|>class SQLDataTypeImpl.java
<|fim_prefix|><|fim_suffix|>

    @Override
    public String getTypeName() {
        return typeName;
    }

    @Override
    public String getTypeName(boolean quoted) {
        return quoted ? "'" + typeName + "'" : typeName;
    }

    @Override
    public String getTypeName(boolean quoted, boolean nullable) {
        return quoted ? "'" + typeName + "'" : nullable ? typeName + " NULL" : typeName;
    }

    @Override
    public String getTypeName(boolean quoted, boolean nullable, boolean autoIncrement) {
        return quoted ? "'" + typeName + "'" : nullable ? typeName + " NULL" : autoIncrement ? typeName + " AUTO_INCREMENT" : typeName;
    }

    @Override
    public String getTypeName(boolean quoted, boolean nullable, boolean autoIncrement, boolean unsigned) {
        return quoted ? "'" + typeName + "'" : nullable ? typeName + " NULL" : autoIncrement ? typeName + " AUTO_INCREMENT" : unsigned ? typeName + " UNSIGNED" : typeName;
    }

    @Override
    public String getTypeName(boolean quoted, boolean nullable, boolean autoIncrement, boolean unsigned, boolean zerofill) {
        return quoted ? "'" + typeName + "'" : nullable ? typeName + " NULL" : autoIncrement ? typeName + " AUTO_INCREMENT" : unsigned ? typeName + " UNSIGNED" : zerofill ? typeName + " ZEROFILL" : typeName;
    }

    @Override
    public String getTypeName(boolean quoted, boolean nullable, boolean autoIncrement, boolean unsigned, boolean zerofill, boolean binary) {
        return quoted ? "'" + typeName + "'" : nullable ? typeName +<nl>
        if (this.number.intValue() < o.number.intValue()) {
            return -1;
        }

        if (this.number.intValue() > o.number.intValue()) {
            return 1;
        }

        return 0;
    <|file_separator|>class SQLDataType.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class SQLDataType {
    public static final SQLDataType BOOLEAN = new SQLDataTypeImpl("boolean");
    public static final SQLDataType CHAR = new SQLDataTypeImpl("char");
    public static final SQLDataType DATE = new SQLDataTypeImpl("date");
    public static final SQLDataType DATETIME = new SQLDataTypeImpl("datetime");
    public static final SQLDataType DECIMAL = new SQLDataTypeImpl("decimal");
    public static final SQLDataType DOUBLE = new SQLDataTypeImpl("double");
    public static final SQLDataType FLOAT = new SQLDataTypeImpl("float");
    public static final SQLDataType INT = new SQLDataTypeImpl("int");
    public static final SQLDataType LONG = new SQLDataTypeImpl("long");
    public static final SQLDataType STRING = new SQLDataTypeImpl("string");
    public static final SQLDataType TIME = new SQLDataTypeImpl("time");
    public static final SQLDataType TIMESTAMP = new SQLDataTypeImpl("timestamp");
    public static final SQLDataType VARCHAR = new SQLDataTypeImpl("varchar");
    public static final SQLDataType VARBINARY = new SQLDataTypeImpl("varbinary");
    public static final SQLDataType BINARY = new SQLDataTypeImpl("binary");
    public static final SQLDataType BLOB = new SQLDataTypeImpl("blob");
    public static final SQLDataType TEXT = new SQLDataTypeImpl("text");
    public static final SQLDataType JSON = new SQLDataTypeImpl("json");
    public static final SQLDataType UUID = new SQLDataTypeImpl("uuid");
    public static final SQLDataType ENUM = new SQL<nl>
        this.against = against;
    <|file_separator|>class SQLIndex.java
<|fim_prefix|><|fim_suffix|>
        if (this.indexName != null ? !this.indexName.equals(other.indexName) : other.indexName != null) {
            return false;
        }
        if (this.indexType != other.indexType) {
            return false;
        }
        if (this.isUnique != other.isUnique) {
            return false;
        }
        if (this.isUnique != other.isUnique) {
            return false;
        }
        if (this.isUnique != other.isUnique) {
            return false;
        }
        if (this.isUnique != other.isUnique) {
            return false;
        }
        if (this.isUnique != other.isUnique) {
            return false;
        }
        if (this.isUnique != other.isUnique) {
            return false;
        }
        if (this.isUnique != other.isUnique) {
            return false;
        }
        if (this.isUnique != other.isUnique) {
            return false;
        }
        if (this.isUnique != other.isUnique) {
            return false;
        }
        if (this.isUnique != other.isUnique) {
            return false;
        }
        if (this.isUnique != other.isUnique) {
            return false;
        }
        if (this.isUnique != other.isUnique) {
            return false;
        }
        if (this.isUnique != other.isUnique) {
            return false;
        }
        if (this.isUnique != other.isUnique) {
            return<nl>
        return null;
    }

    @Override
    public String toString() {
        return getNumber().toString();
    <|file_separator|>class SQLExprImpl.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public abstract class SQLExprImpl implements SQLExpr {
    public abstract List getChildren();
}<|file_separator|>class SQLExpr.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public interface SQLExpr {
    public List getChildren();
}<|file_separator|>class SQLIdentifierExpr.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class SQLIdentifierExpr extends SQLExprImpl implements SQLLiteralExpr {
    public SQLIdentifierExpr() {
    }

    public abstract String getIdentifier();

    public abstract void setIdentifier(String identifier);

    public abstract SQLIdentifierExpr clone();

    @Override
    public List getChildren() {
        return null;
    }

    @Override
    public String toString() {
        return getIdentifier();
    }
}<|file_separator|>class SQLExprVisitor.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public interface SQLExprVisitor {
    public void visit(SQLExpr expr);
}<|file_separator|>class SQLLiteralExpr.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public interface SQLLiteralExpr extends SQLExpr {
    public Number getNumber();

    public void setNumber(Number number);
}<|file_separator|><nl>
        int result = 17;
        result = 31 * result + (subQuery != null ? subQuery.hashCode() : 0);
        return result;
    <|file_separator|><nl>
        if (this == obj) {
            return true;
        }
        if (obj == null) {
            return false;
        }
        if (getClass() != obj.getClass()) {
            return false;
        }
        SQLTimeExpr other = (SQLTimeExpr) obj;
        if (literal == null) {
            if (other.literal != null) {
                return false;
            }
        } else if (!literal.equals(other.literal)) {
            return false;
        }
        return true;
    }

    @Override
    public String toString() {
        if (literal == null) {
            return "null";
        }
        return literal.toString();
    <|file_separator|>class SQLTimeExpr.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>package com.github.jknack.handlebars.sql;

import java.util.Date;
import java.util.TimeZone;

public class SQLTimeExpr extends SQLExprImpl implements SQLLiteralExpr, SQLValuableExpr, SQLReplaceable {
    public static final SQLDataType DATA_TYPE = new SQLDataTypeImpl("time");

    private SQLExpr literal;

    public SQLTimeExpr() {
    }

    public SQLTimeExpr(Date now, TimeZone timeZone) {
        setLiteral(now, timeZone);
    }

    public void setLiteral(Date x, TimeZone timeZone) {
        if (x == null) {
            this.literal = null;
            return;
        }

        SimpleDateFormat format = new SimpleDateFormat("HH:mm:ss");
        if (timeZone != null) {
            format.setTimeZone(timeZone);
        }
        String text = format.format(x);
        setLiteral(text);
    }

    public SQLTimeExpr(<nl>
        visitor.visit(this);
    }

    public String toString() {
        return toString(false);
    }

    public String toString(boolean withParentheses) {
        if (withParentheses) {
            return "(" + operator.toString() + " " + expr.toString() + ")";
        }
        return operator.toString() + " " + expr.toString();
    }

    public String toSQLString() {
        return toString(true);
    }

    public String toSQLString(boolean withParentheses) {
        return toString(withParentheses);
    }

    public String toSQLString(boolean withParentheses, boolean withAlias) {
        return toString(withParentheses);
    }

    public String toSQLString(boolean withParentheses, boolean withAlias, boolean withAliasAsTable) {
        return toString(withParentheses);
    }

    public String toSQLString(boolean withParentheses, boolean withAlias, boolean withAliasAsTable, boolean withAliasAsTableAlias) {
        return toString(withParentheses);
    }

    public String toSQLString(boolean withParentheses, boolean withAlias, boolean withAliasAsTable, boolean withAliasAsTableAlias, boolean withAliasAsTableAliasAsTable) {
        return toString(withParentheses);
    }

    public String toSQLString(boolean withParentheses, boolean withAlias, boolean withAliasAsTable, boolean withAliasAsTableAlias, boolean withAliasAsTableAliasAsTable, boolean withAliasAsTableAliasAsTableAlias) {
        return toString(withParentheses);
    }

    public String toSQLString(boolean withParentheses, boolean withAlias, boolean withAliasAsTable, boolean withAliasAsTableAlias, boolean withAliasAsTableAliasAsTable, boolean withAliasAs<nl>
        visitor.visit(this);
    }

    public void addProperty(SQLAssignItem property) {
        properties.add(property);
    <|file_separator|>class SQLAlterDatabaseItem.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class SQLAlterDatabaseItem extends SQLAlterItem {
    private SQLName name;
    private SQLAlterDatabaseItem parent;

    public SQLName getName() {
        return name;
    }

    public void setName(SQLName name) {
        if (name != null) {
            name.setParent(this);
        }
        this.name = name;
    }

    public SQLAlterDatabaseItem getParent() {
        return parent;
    }

    public void setParent(SQLAlterDatabaseItem parent) {
        this.parent = parent;
    }
}<|file_separator|>class SQLAlterDatabaseItemImpl.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class SQLAlterDatabaseItemImpl extends SQLAlterItemImpl implements SQLAlterDatabaseItem {
    private SQLName name;
    private SQLAlterDatabaseItem parent;

    public SQLName getName() {
        return name;
    }

    public void setName(SQLName name) {
        if (name != null) {
            name.setParent(this);
        }
        this.name = name;
    }

    public SQLAlterDatabaseItem getParent() {
        return parent;
    }

    public void setParent(SQLAlterDatabaseItem parent) {
        this.parent = parent;
    }
}<|file_separator|>class SQLAlterDatabaseItemImpl.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class SQLAlterDatabaseItemImpl extends SQLAlterItemImpl implements SQLAlterDatabaseItem {
    private SQLName name;
    private SQLAlterDatabaseItem parent;

    public SQLName getName() {
        return name;
    }

    public void setName(SQLName name) {<nl>
        if (name != null) {
            name.setParent(this);
        }
        this.name = name;
    <|file_separator|><nl>
        visitor.visit(this);
    }

    @Override
    public String getSQL() {
        StringBuilder sb = new StringBuilder();
        sb.append("ALTER TABLE ");
        sb.append(getParent().getTableName());
        sb.append(" ADD ");
        if (first) {
            sb.append("FIRST ");
        }
        if (afterColumn != null) {
            sb.append("AFTER ");
            sb.append(afterColumn);
        } else {
            sb.append("AFTER ");
            sb.append(firstColumn);
        }
        sb.append(" ");
        for (SQLColumnDefinition column : columns) {
            sb.append(column);
        }
        if (restrict != null) {
            sb.append(" RESTRICT");
        }
        if (cascade) {
            sb.append(" CASCADE");
        }
        return sb.toString();
    <|file_separator|>class SQLAlterTableItem.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public interface SQLAlterTableItem extends SQLObject {
}<|file_separator|>class SQLAlterTableItemImpl.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public abstract class SQLAlterTableItemImpl extends SQLObjectImpl implements SQLAlterTableItem {
    private SQLAlterTableItem parent;

    public SQLAlterTableItem getParent() {
        return parent;
    }

    public void setParent(SQLAlterTableItem parent) {
        this.parent = parent;
    }
}<|file_separator|>class SQLAlterTableAddForeignKey.java
<|fim_prefix|><|fim_suffix|>

    public void setCascade(boolean cascade) {
        this.cascade = cascade;
    }
}<|fim_middle|>public class SQLAlterTableAddForeignKey extends SQLObjectImpl implements SQLAlterTableItem {
    private final List<SQLForeignKeyDefinition> foreignKeys = new ArrayList<SQLForeignKeyDefinition>();

    // for mysql
    private SQLName<nl>
        if (x != null) {
            x.setParent(this);
        }
        this.location = x;
    <|file_separator|>class SQLAlterTableItem.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public interface SQLAlterTableItem extends SQLObject {
    public List<SQLObject> getPartitions();
    public void addPartition(SQLObject x);
    public boolean isIfNotExists();
    public void setIfNotExists(boolean ifNotExists);
    public SQLExpr getPartitionCount();
    public void setPartitionCount(SQLExpr x);
    public SQLExpr getLocation();
    public void setLocation(SQLExpr x);
}<|file_separator|>class SQLAlterTable.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class SQLAlterTable extends SQLObjectImpl implements SQLAlterTableItem {
    private final List<SQLObject> partitions = new ArrayList<SQLObject>(4);
    private SQLExpr partitionCount;
    private SQLExpr location; // hive

    public List<SQLObject> getPartitions() {
        return partitions;
    }

    public void addPartition(SQLObject x) {
        if (x != null) {
            x.setParent(this);
        }
        this.partitions.add(x);
    }

    public SQLExpr getPartitionCount() {
        return partitionCount;
    }

    public void setPartitionCount(SQLExpr x) {
        if (x != null) {
            x.setParent(this);
        }
        this.partitionCount = x;
    }

    public SQLExpr getLocation() {
        return location;
    }

    public void setLocation(SQLExpr x) {
        if (x != null) {
            x.setParent(this);
        }
        this.location = x;
    }

    @Override
    protected void accept0(SQLASTVisitor<nl>
        if (collate != null) {
            collate.setParent(this);
        }
        this.collate = collate;
    <|file_separator|>class SQLAlterTableAddIndex.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class SQLAlterTableAddIndex extends SQLAlterTableItem {
    private SQLExpr index;
    private SQLExpr indexName;
    private SQLExpr indexType;
    private SQLExpr indexOption;
    private SQLExpr indexComment;
    private SQLExpr indexCommentType;
    private SQLExpr indexCommentValue;
    private SQLExpr indexCommentTypeValue;
    private SQLExpr indexCommentValueValue;

    public SQLAlterTableAddIndex() {
    }

    public SQLExpr getIndex() {
        return index;
    }

    public void setIndex(SQLExpr index) {
        if (index != null) {
            index.setParent(this);
        }
        this.index = index;
    }

    public SQLExpr getIndexName() {
        return indexName;
    }

    public void setIndexName(SQLExpr indexName) {
        if (indexName != null) {
            indexName.setParent(this);
        }
        this.indexName = indexName;
    }

    public SQLExpr getIndexType() {
        return indexType;
    }

    public void setIndexType(SQLExpr indexType) {
        if (indexType != null) {
            indexType.setParent(this);
        }
        this.indexType = indexType;
    }

    public SQLExpr getIndexOption() {
        return indexOption;
    }

    public void setIndexOption(SQLExpr indexOption) {
        if (indexOption != null) {
            indexOption.setParent(this);
        }
        this.indexOption<nl>
        visitor.visit(this);<|file_separator|>class SQLAlterTableAddConstraint.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class SQLAlterTableAddConstraint extends SQLAlterTableItem {
    @Override
    protected void accept0(SQLASTVisitor visitor) {
        visitor.visit(this);
    }

}<|file_separator|>class SQLAlterTableAddIndex.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class SQLAlterTableAddIndex extends SQLAlterTableItem {
    @Override
    protected void accept0(SQLASTVisitor visitor) {
        visitor.visit(this);
    }

}<|file_separator|>class SQLAlterTableAddForeignKey.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class SQLAlterTableAddForeignKey extends SQLAlterTableItem {
    @Override
    protected void accept0(SQLASTVisitor visitor) {
        visitor.visit(this);
    }

}<|file_separator|>class SQLAlterTableAddCheckConstraint.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class SQLAlterTableAddCheckConstraint extends SQLAlterTableItem {
    @Override
    protected void accept0(SQLASTVisitor visitor) {
        visitor.visit(this);
    }

}<|file_separator|>class SQLAlterTableAddUniqueConstraint.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class SQLAlterTableAddUniqueConstraint extends SQLAlterTableItem {
    @Override
    protected void accept0(SQLASTVisitor visitor) {
        visitor.visit(this);
    }

}<|file_separator|>class SQLAlterTableAddForeignKeyConstraint.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class SQLAlterTableAddForeignKeyConstraint extends SQLAlterTableItem {
    @Override
    protected void accept0(SQLASTVisitor visitor) {
        visitor.visit(this);
    }

}<|file_separator|>class SQLAlterTableAddForeignKeyConstraintItem.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class SQLAlterTableAddForeignKeyConstraintItem extends SQLAlterTableItem {
    @Override
    protected void accept0(SQLASTVisitor visitor) {
        visitor<nl>
        this.extPartition = x;
    <|file_separator|>class SQLAlterTableAddExtPartition extends SQLObjectImpl implements SQLAlterTableItem, MySqlObject {
    private MySqlExtPartition extPartition;

    @Override
    public void accept0(MySqlASTVisitor visitor) {
        visitor.visit(this);
        visitor.endVisit(this);
    }

    @Override
    protected void accept0(SQLASTVisitor visitor) {
        visitor.visit(this);
        visitor.endVisit(this);
    }

    public void setExPartition(MySqlExtPartition x) {
        this.extPartition = x;
    }

    public MySqlExtPartition getExtPartition() {
        return extPartition;
    }
}<|file_separator|>class SQLAlterTableAddExtPartitionToPartition extends SQLObjectImpl implements SQLAlterTableItem, MySqlObject {
    private MySqlExtPartition extPartition;

    @Override
    public void accept0(MySqlASTVisitor visitor) {
        visitor.visit(this);
        visitor.endVisit(this);
    }

    @Override
    protected void accept0(SQLASTVisitor visitor) {
        visitor.visit(this);
        visitor.endVisit(this);
    }

    public void setExPartition(MySqlExtPartition x) {
        this.extPartition = x;
    }

    public MySqlExtPartition getExtPartition() {
        return extPartition;
    }
}<|file_separator|>class SQLAlterTableAddExtPartitionToPartitionWithPartitionName extends SQLObjectImpl implements SQLAlterTableItem, MySqlObject {
    private MySqlExtPartition extPartition;

    @Override
    public void accept0(MySqlASTVisitor visitor) {
        visitor.visit(this);
        visitor.endVisit(this);
    }

    @Override
    protected void accept0(<nl>
        visitor.visit(this);
    <|file_separator|>class SQLAlterTablePartitionSetPropertiesImpl.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class SQLAlterTablePartitionSetPropertiesImpl extends SQLAlterTablePartitionSetProperties {
    public SQLAlterTablePartitionSetPropertiesImpl() {
    }

    public SQLAlterTablePartitionSetPropertiesImpl(SQLAlterTablePartitionSetPropertiesImpl other) {
        super(other);
    }

    public SQLAlterTablePartitionSetPropertiesImpl(SQLAlterTablePartitionSetPropertiesImpl other, boolean copy) {
        super(other, copy);
    }

    public SQLAlterTablePartitionSetPropertiesImpl(SQLAlterTablePartitionSetPropertiesImpl other, boolean copy, boolean copyProperties) {
        super(other, copy, copyProperties);
    }

    public SQLAlterTablePartitionSetPropertiesImpl(SQLAlterTablePartitionSetPropertiesImpl other, boolean copy, boolean copyProperties, boolean copyPartition) {
        super(other, copy, copyProperties, copyPartition);
    }

    public SQLAlterTablePartitionSetPropertiesImpl(SQLAlterTablePartitionSetPropertiesImpl other, boolean copy, boolean copyProperties, boolean copyPartition, boolean copyPartitionProperties) {
        super(other, copy, copyProperties, copyPartition, copyPartitionProperties);
    }

    public SQLAlterTablePartitionSetPropertiesImpl(SQLAlterTablePartitionSetPropertiesImpl other, boolean copy, boolean copyProperties, boolean copyPartition, boolean copyPartitionProperties, boolean copyPartitionProperties2) {
        super(other, copy, copyProperties, copyPartition, copyPartitionProperties, copyPartitionProperties2);
    }

    public SQLAlterTablePartitionSetPropertiesImpl(SQLAlterTablePartitionSetPropertiesImpl other, boolean copy, boolean copyProperties, boolean copyPartition, boolean copyPartitionProperties, boolean copyPartitionProperties2, boolean copyPartitionProperties3) {
        super(other, copy, copyProperties,<nl>
        if (to != null) {
            to.setParent(this);
        }
        this.to = new SQLExprTableSource(to);
    }

    public void setTo(SQLName to) {
        if (to != null) {
            to.setParent(this);
        }
        this.to = new SQLExprTableSource(to);
    }

    public void setTo(SQLExprTableSource to, SQLName toName) {
        if (to != null) {
            to.setParent(this);
        }
        this.to = new SQLExprTableSource(toName);
    }

    public void setTo(SQLExprTableSource to, SQLName toName, SQLExpr expr) {
        if (to != null) {
            to.setParent(this);
        }
        this.to = new SQLExprTableSource(toName, expr);
    }

    public void setTo(SQLExprTableSource to, SQLExpr expr) {
        if (to != null) {
            to.setParent(this);
        }
        this.to = new SQLExprTableSource(expr);
    }

    public void setTo(SQLExprTableSource to, SQLExpr expr, SQLName toName) {
        if (to != null) {
            to.setParent(this);
        }
        this.to = new SQLExprTableSource(expr, toName);
    }

    public void setTo(SQLExprTableSource to, SQLExpr expr, SQLExpr toExpr) {
        if (to != null) {
            to.setParent(this);
        }
        this.to = new SQLExprTableSource(expr, toExpr);
    }

    public void setTo(SQLExprTableSource to,<nl>
        this.comment = comment;
    <|file_separator|>class SQLAlterTableItem.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public interface SQLAlterTableItem extends SQLObject {
    public SQLExpr getComment();
    public void setComment(SQLExpr comment);
}<|file_separator|>class SQLAlterTableSetComment.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class SQLAlterTableSetComment extends SQLAlterTableItemImpl implements SQLAlterTableItem {
    private SQLExpr comment;

    public SQLExpr getComment() {
        return comment;
    }

    public void setComment(SQLExpr comment) {
        this.comment = comment;
    }

    @Override
    protected void accept0(SQLASTVisitor visitor) {
        if (visitor.visit(this)) {
            acceptChild(visitor, comment);
        }
        visitor.endVisit(this);
    }

}<|file_separator|>class SQLAlterTableSetCommentImpl.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class SQLAlterTableSetCommentImpl extends SQLAlterTableItemImpl implements SQLAlterTableItem {
    private SQLExpr comment;

    public SQLExpr getComment() {
        return comment;
    }

    public void setComment(SQLExpr comment) {
        this.comment = comment;
    }

    @Override
    protected void accept0(SQLASTVisitor visitor) {
        if (visitor.visit(this)) {
            acceptChild(visitor, comment);
        }
        visitor.endVisit(this);
    }

}<|file_separator|>class SQLAlterTableSetCommentVisitor.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class SQLAlterTableSetCommentVisitor extends SQLAlterTableItemVisitor {
    private SQLExpr comment;

    public SQLExpr getComment() {
        return comment;
    }

    public void setComment(SQLExpr comment) {
        this.comment = comment;
    }

    @<nl>
        SQLColumnReference clone = new SQLColumnReference();
        clone.setTable(this.table);
        clone.setColumns(this.columns);
        clone.setReferenceMatch(this.referenceMatch);
        clone.setOnUpdate(this.onUpdate);
        clone.setOnDelete(this.onDelete);
        return clone;
    <|file_separator|>class SQLColumnConstraint.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public interface SQLColumnConstraint extends SQLConstraint {
    public SQLName getTable();
    public List<SQLName> getColumns();
    public SQLForeignKeyImpl.Match getReferenceMatch();
    public SQLForeignKeyImpl.Option getOnUpdate();
    public SQLForeignKeyImpl.Option getOnDelete();
}<|file_separator|>class SQLColumnImpl.java
<|fim_prefix|><|fim_suffix|>

    public void setTable(SQLName table) {
        this.table = table;
    }

    public SQLName getColumnName() {
        return columnName;
    }

    public void setColumnName(SQLName columnName) {
        this.columnName = columnName;
    }

    public SQLDataType getDataType() {
        return dataType;
    }

    public void setDataType(SQLDataType dataType) {
        this.dataType = dataType;
    }

    public boolean isNullable() {
        return nullable;
    }

    public void setNullable(boolean nullable) {
        this.nullable = nullable;
    }

    public boolean isAutoIncrement() {
        return autoIncrement;
    }

    public void setAutoIncrement(boolean autoIncrement) {
        this.autoIncrement = autoIncrement;
    }

    public boolean isPrimaryKey() {
        return primaryKey;
    }

    public void setPrimaryKey(boolean primaryKey) {
        this.primaryKey = primaryKey;
    }

    public boolean isUnique() {
        return unique;
<nl>
        return "group";
    }

    public String getTableName() {
        return "create_table_group";
    }

    public String getSql() {
        StringBuilder sb = new StringBuilder();
        sb.append("create table ");
        if (ifNotExists) {
            sb.append("if not exists ");
        }
        sb.append(getSchemaName());
        sb.append(".");
        sb.append(name);
        sb.append(" (");
        if (partitionNum != null) {
            sb.append(partitionNum);
        }
        sb.append(")");
        return sb.toString();
    <|file_separator|><nl>
        this.name = x;
    <|file_separator|>class SQLDropIndexStatement.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class SQLDropIndexStatement extends SQLDropOutlineStatement implements SQLDropIndexStatement {
    private SQLName name;
    private boolean ifExists;

    public SQLDropIndexStatement() {
    }

    public SQLDropIndexStatement(DbType dbType) {
        super(dbType);
    }

    @Override
    protected void accept0(SQLASTVisitor visitor) {
        if (visitor.visit(this)) {
            acceptChild(visitor, name);
        }
        visitor.endVisit(this);
    }

    public SQLName getName() {
        return name;
    }

    public void setName(SQLName x) {
        this.name = x;
    }

    public boolean isIfExists() {
        return ifExists;
    }

    public void setIfExists(boolean ifExists) {
        this.ifExists = ifExists;
    }

    @Override
    public List<SQLObject> getChildren() {
        List<SQLObject> children = new ArrayList<SQLObject>();
        if (name != null) {
            children.add(name);
        }
        return children;
    }

}<|file_separator|>class SQLDropTableStatement.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class SQLDropTableStatement extends SQLDropOutlineStatement implements SQLDropTableStatement {
    private SQLName name;
    private boolean ifExists;

    public SQLDropTableStatement() {
    }

    public SQLDropTableStatement(DbType dbType) {
        super(dbType);
    }

    @Override
    protected void accept0(SQLASTVisitor visitor) {
        if (visitor.visit(this)) {
            acceptChild(visitor, name);
        }
<nl>
        return Collections.singletonList(name);
    <|file_separator|>class SQLDropIndexStatement.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class SQLDropIndexStatement extends SQLStatementImpl implements SQLDropStatement, SQLReplaceable {
    private SQLName name;
    private boolean ifExists;

    public SQLDropIndexStatement() {
    }

    public SQLDropIndexStatement(DbType dbType) {
        super(dbType);
    }

    @Override
    protected void accept0(SQLASTVisitor visitor) {
        if (visitor.visit(this)) {
            acceptChild(visitor, name);
        }
        visitor.endVisit(this);
    }

    public SQLName getName() {
        return name;
    }

    public void setName(SQLName x) {
        if (x != null) {
            x.setParent(this);
        }
        this.name = x;
    }

    public boolean isIfExists() {
        return ifExists;
    }

    public void setIfExists(boolean ifExists) {
        this.ifExists = ifExists;
    }

    @Override
    public List<SQLObject> getChildren() {
        return Collections.singletonList(name);
    }

    public boolean replace(SQLExpr expr, SQLExpr target) {
        if (name == expr) {
            setName((SQLName) target);
            return true;
        }

        return false;
    }

    @Override
    public DDLObjectType getDDLObjectType() {
        return DDLObjectType.INDEX;
    }
}<|file_separator|>class SQLDropViewStatement.java
<|fim_prefix|><|fim_suffix|>

    public boolean replace(SQLExpr expr, SQLExpr target) {
        if (name == expr) {
            setName((SQLName) target);
            return true;<nl>
        this.simpleExpression = simpleExpression;
    <|file_separator|>class SQLFunction.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class SQLFunction extends SQLObjectImpl {
    private SQLName name;
    private SQLExprList arguments;
    private SQLExprList defaultArguments;
    private SQLExprList defaultArgumentsWithNames;
    private SQLExprList defaultArgumentsWithNamesAndTypes;
    private SQLExprList defaultArgumentsWithNamesAndTypesAndTypes;
    private SQLExprList defaultArgumentsWithNamesAndTypesAndTypesAndTypes;
    private SQLExprList defaultArgumentsWithNamesAndTypesAndTypesAndTypesAndTypes;
    private SQLExprList defaultArgumentsWithNamesAndTypesAndTypesAndTypesAndTypesAndTypes;
    private SQLExprList defaultArgumentsWithNamesAndTypesAndTypesAndTypesAndTypesAndTypesAndTypes;
    private SQLExprList defaultArgumentsWithNamesAndTypesAndTypesAndTypesAndTypesAndTypesAndTypesAndTypes;
    private SQLExprList defaultArgumentsWithNamesAndTypesAndTypesAndTypesAndTypesAndTypesAndTypesAndTypesAndTypes;
    private SQLExprList defaultArgumentsWithNamesAndTypesAndTypesAndTypesAndTypesAndTypesAndTypesAndTypesAndTypesAndTypes;
    private SQLExprList defaultArgumentsWithNamesAndTypesAndTypesAndTypesAndTypesAndTypesAndTypesAndTypesAndTypesAndTypesAndTypes;
    private SQLExprList defaultArgumentsWithNamesAndTypesAndTypesAndTypesAndTypesAndTypesAndTypesAndTypesAndTypesAndTypesAndTypesAndTypes;
    private SQLExprList defaultArgumentsWithNamesAndTypesAndTypesAndTypesAndTypesAndTypesAndTypesAndTypesAndTypesAndTypesAndTypesAndTypesAndTypes;
    private SQLExprList defaultArgumentsWithNamesAndTypesAndTypesAndTypesAndTypesAndTypesAndTypesAndTypesAndTypesAndTypesAndTypesAndTypesAndTypesAndTypes;
    private SQLExprList defaultArgumentsWith<nl>
        visitor.visit(this);
    }

    public void addColumn(SQLName column) {
        if (column != null) {
            column.setParent(this);
        }
        columns.add(column);
    }

    public void addUsing(SQLExpr expr) {
        if (expr != null) {
            expr.setParent(this);
        }
        using.add(expr);
    <|file_separator|><nl>
        if (visitor instanceof SQLASTVisitor) {
            visitor.visit(this);
        }
    <|file_separator|><nl>
        this.name = x;
    <|file_separator|><nl>
        return Arrays.asList(name);
    }

    @Override
    public String getSQL() {
        return "SAVEPOINT " + name.getSQL();
    <|file_separator|>class SQLSetStatement.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class SQLSetStatement extends SQLStatementImpl {
    private SQLExpr name;
    private SQLExpr value;

    public SQLSetStatement() {
    }

    public SQLSetStatement(DbType dbType) {
        super(dbType);
    }

    public SQLExpr getName() {
        return name;
    }

    public void setName(SQLExpr name) {
        this.name = name;
    }

    public SQLExpr getValue() {
        return value;
    }

    public void setValue(SQLExpr value) {
        this.value = value;
    }

    @Override
    protected void accept0(SQLASTVisitor visitor) {
        if (visitor.visit(this)) {
            acceptChild(visitor, name);
            acceptChild(visitor, value);
        }
        visitor.endVisit(this);
    }

    @Override
    public List<SQLObject> getChildren() {
        return Arrays.asList(name, value);
    }

    @Override
    public String getSQL() {
        return "SET " + name.getSQL() + " = " + value.getSQL();
    }
}<|file_separator|>class SQLSetStatement.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class SQLSetStatement extends SQLStatementImpl {
    private SQLExpr name;
    private SQLExpr value;

    public SQLSetStatement() {
    }

    public SQLSetStatement(DbType dbType) {
        super(dbType);
    }

    public SQLExpr getName() {
        return name;
    }

    public<nl>
        return tables;
    <|file_separator|>class SQLShowColumnsStatement.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class SQLShowColumnsStatement extends SQLShowStatement {
    private SQLExprTableSource table;
    private List<SQLExpr> columns = new ArrayList<>();
    private List<SQLExpr> partitions = new ArrayList<>();
    private boolean all;
    private boolean extended;
    private boolean withSchema;
    private boolean withColumnPrivileges;
    private boolean withCheckOption;
    private boolean withPrivileges;
    private boolean withValues;
    private boolean withCurrentValues;
    private boolean withColumnStatistics;
    private boolean withComments;
    private boolean withIndexes;
    private boolean withFulltextIndexes;
    private boolean withForeignKeys;
    private boolean withCheckConstraints;
    private boolean withTriggers;
    private boolean withViewDefinition;
    private boolean withNoData;
    private boolean withNoKey;
    private boolean withNoInIndex;
    private boolean withNoInIndexFulltext;
    private boolean withNoInIndexForeign;
    private boolean withNoInIndexCheck;
    private boolean withNoInIndexTrigger;
    private boolean withNoInIndexView;
    private boolean withNoInIndexCheckConstraint;
    private boolean withNoInIndexCheckOption;
    private boolean withNoInIndexWithCheckOption;
    private boolean withNoInIndexWithCheckOptionNoCheck;
    private boolean withNoInIndexWithCheckOptionCheck;
    private boolean withNoInIndexWithCheckOptionNoCheckCheck;
    private boolean withNoInIndexWithCheckOptionNoCheckCheckOption;
    private boolean withNoInIndexWithCheckOptionNoCheckCheckOptionNoCheck;
    private boolean withNoInIndexWithCheckOptionNoCheckCheckOptionNoCheckCheck;
    private boolean withNoInIndexWith<nl>
        return where;
    <|file_separator|><nl>
        return Arrays.asList(statment);
    <|file_separator|><nl>
        this.like = like;
    <|file_separator|><nl>
        this.reuseStorage = reuseStorage;
    <|file_separator|><nl>
        v.visit(this);<|file_separator|><nl>
        return new SQLDeleteBuilderImpl(dbType);
    <|file_separator|><nl>
        throw new UnsupportedOperationException();
    }

    @Override
    public SQLDeleteBuilderImpl limit(int rowCount, int offset, String alias) {
        throw new UnsupportedOperationException();
    }

    @Override
    public SQLDeleteBuilderImpl offset(int offset) {
        throw new UnsupportedOperationException();
    }

    @Override
    public SQLDeleteBuilderImpl offset(int offset, String alias) {
        throw new UnsupportedOperationException();
    }

    @Override
    public SQLDeleteBuilderImpl orderBy(String expr) {
        throw new UnsupportedOperationException();
    }

    @Override
    public SQLDeleteBuilderImpl orderBy(String expr, String alias) {
        throw new UnsupportedOperationException();
    }

    @Override
    public SQLDeleteBuilderImpl orderBy(String expr, String alias, boolean asc) {
        throw new UnsupportedOperationException();
    }

    @Override
    public SQLDeleteBuilderImpl orderBy(String expr, String alias, boolean asc, String alias2) {
        throw new UnsupportedOperationException();
    }

    @Override
    public SQLDeleteBuilderImpl orderBy(String expr, String alias, boolean asc, String alias2, String alias3) {
        throw new UnsupportedOperationException();
    }

    @Override
    public SQLDeleteBuilderImpl orderBy(String expr, String alias, boolean asc, String alias2, String alias3, String alias4) {
        throw new UnsupportedOperationException();
    }

    @Override
    public SQLDeleteBuilderImpl orderBy(String expr, String alias, boolean asc, String alias2, String alias3, String alias4, String alias5) {
        throw new UnsupportedOperationException();
    }

    @Override
    public SQLDeleteBuilderImpl orderBy(String expr, String alias, boolean asc, String alias2, String<nl>
        return having(expr, null);
    <|file_separator|><nl>
        return new ClickhouseCreateTableStatement();
    <|file_separator|><nl>
        visitor.visit(this);
    <|file_separator|><nl>
        if (visitor.visit(this)) {
            this.acceptChild(visitor, declare);
            this.acceptChild(visitor, className);
            this.acceptChild(visitor, location);
            this.acceptChild(visitor, symbol);
        }
        visitor.endVisit(this);
    <|file_separator|><nl>
        return visit(x.getInsert());
    }

    @Override
    public boolean visit(HiveCreateDatabaseStatement x) {
        return false;
    }

    @Override
    public boolean visit(HiveCreateTableStatement x) {
        return false;
    }

    @Override
    public boolean visit(HiveDropTableStatement x) {
        return false;
    }

    @Override
    public boolean visit(HiveAlterTableStatement x) {
        return false;
    }

    @Override
    public boolean visit(HiveAlterTableSetPropertiesStatement x) {
        return false;
    }

    @Override
    public boolean visit(HiveAlterTableAddColumnsStatement x) {
        return false;
    }

    @Override
    public boolean visit(HiveAlterTableDropColumnsStatement x) {
        return false;
    }

    @Override
    public boolean visit(HiveAlterTableAddPartitionStatement x) {
        return false;
    }

    @Override
    public boolean visit(HiveAlterTableDropPartitionStatement x) {
        return false;
    }

    @Override
    public boolean visit(HiveAlterTableAddPropertiesStatement x) {
        return false;
    }

    @Override
    public boolean visit(HiveAlterTableDropPropertiesStatement x) {
        return false;
    }

    @Override
    public boolean visit(HiveAlterTableAddStoragePropertiesStatement x) {
        return false;
    }

    @Override
    public boolean visit(HiveAlterTableDropStoragePropertiesStatement x) {
        return false;
    }

    @Override
    public boolean visit(HiveAlterTableAddColumnsSetPropertiesStatement x) {
        return false;
    }

    @Override
    public boolean visit(HiveAlterTableDropColumns<nl>
        visitor.visit(this);
        visitor.endVisit(this);
    <|file_separator|>class MySqlAlterTableAddColumns.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class MySqlAlterTableAddColumns extends MySqlAlterTableAddColumns {
    public MySqlAlterTableAddColumns(MySqlTable table, MySqlColumnList columns) {
        super(table, columns);
    }
}<|file_separator|>class MySqlAlterTableAddColumnsImpl.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class MySqlAlterTableAddColumnsImpl extends MySqlAlterTableAddColumnsImpl {
    public MySqlAlterTableAddColumnsImpl(MySqlTable table, MySqlColumnList columns) {
        super(table, columns);
    }
}<|file_separator|>class MySqlAlterTableAddColumnsImpl2.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class MySqlAlterTableAddColumnsImpl2 extends MySqlAlterTableAddColumnsImpl2 {
    public MySqlAlterTableAddColumnsImpl2(MySqlTable table, MySqlColumnList columns) {
        super(table, columns);
    }
}<|file_separator|>class MySqlAlterTableAddColumnsImpl3.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class MySqlAlterTableAddColumnsImpl3 extends MySqlAlterTableAddColumnsImpl3 {
    public MySqlAlterTableAddColumnsImpl3(MySqlTable table, MySqlColumnList columns) {
        super(table, columns);
    }
}<|file_separator|>class MySqlAlterTableAddColumnsImpl4.java
<|fim_prefix|>public class MySqlAlterTableAddColumnsImpl4 extends MySqlAlterTableAddColumnsImpl4 {
    public MySqlAlterTableAddColumnsImpl4(MySqlTable table, MySqlColumnList columns) {
        super(table, columns);
    }
<|fim_suffix|><|fim_middle|>}<|file_separator|>class MySqlAlterTableAddColumnsImpl5.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class MySqlAlterTableAddColumnsImpl5 extends MySqlAlterTableAddColumnsImpl5 {
    public MySqlAlterTableAddColumnsImpl5(MySqlTable table, MySqlColumnList columns) {
        super(<nl>
        this.expr = expr;
    <|file_separator|><nl>
        visitor.visit(this);
    }

    @Override
    public void accept0(MySqlStmtVisitor visitor) {
        visitor.visit(this);
    }

    @Override
    public void accept0(MySqlStmtVisitorWithChildren visitor) {
        visitor.visit(this);
    }

    @Override
    public void accept0(MySqlStmtVisitorWithChildrenAndResult visitor) {
        visitor.visit(this);
    }

    @Override
    public void accept0(MySqlStmtVisitorWithResult visitor) {
        visitor.visit(this);
    }

    @Override
    public void accept0(MySqlStmtVisitorWithResultAndChildren visitor) {
        visitor.visit(this);
    }

    @Override
    public void accept0(MySqlStmtVisitorWithResultAndChildrenAndParent visitor) {
        visitor.visit(this);
    }

    @Override
    public void accept0(MySqlStmtVisitorWithResultAndParent visitor) {
        visitor.visit(this);
    }

    @Override
    public void accept0(MySqlStmtVisitorWithResultAndParentAndChildren visitor) {
        visitor.visit(this);
    }

    @Override
    public void accept0(MySqlStmtVisitorWithResultAndParentAndChildrenAndParent visitor) {
        visitor.visit(this);
    }

    @Override
    public void accept0(MySqlStmtVisitorWithResultAndParentAndChildrenAndParentAndChildren visitor) {
        visitor.visit(this);
    }

    @Override
    public void accept0(MySqlStmtVisitorWithResultAndParentAndChildrenAndParentAndChildrenAndParent visitor) {
        visitor.visit(this);
    }

    @Override
    public void accept0(MySqlStmtVisitorWithResultAndParentAndChildrenAndParentAnd<nl>
            visitor.visit(this);
        }

        public Item(String name, String type, String comment, String tableSource, LockType lockType, List<SQLCommentHint> hints) {
            super(name, type, comment);
            this.tableSource = new SQLExprTableSource(tableSource);
            this.lockType = lockType;
            this.hints = hints;
        <|file_separator|><nl>
        List<SQLObject> children = new ArrayList<>();
        children.add(name);
        children.add(from);
        return children;
    <|file_separator|><nl>
        this.options = options;
    <|file_separator|><nl>
        visitor.visit(this);
    <|file_separator|>class MySqlShowStatement.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public interface MySqlShowStatement extends MySqlStatement {
}<|file_separator|>class MySqlShowStatementImpl.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class MySqlShowStatementImpl extends MySqlStatementImpl implements MySqlShowStatement {
    public void accept0(MySqlASTVisitor visitor) {
        visitor.visit(this);
    }
}<|file_separator|>class MySqlShowStatementVisitor.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class MySqlShowStatementVisitor extends MySqlASTVisitor {
    public void visit(MySqlShowStatementImpl stmt) {
        System.out.println("SHOW");
    }
}<|file_separator|><nl>
        visitor.visit(this);
    <|file_separator|>class MySqlShowStatement.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public interface MySqlShowStatement extends MySqlStatement {
    public SQLName getName();

    public void setName(SQLName x);
}<|file_separator|>class MySqlShowStatementImpl.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class MySqlShowStatementImpl extends MySqlStatementImpl implements MySqlShowStatement {
    private SQLName name;

    public void accept0(MySqlASTVisitor visitor) {
        visitor.visit(this);
    }

    public SQLName getName() {
        return name;
    }

    public void setName(SQLName x) {
        if (x != null) {
            x.setParent(this);
        }
        this.name = x;
    }
}<|file_separator|>class MySqlShowStatementVisitor.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class MySqlShowStatementVisitor extends MySqlASTVisitor {
    public void visit(MySqlShowStatement x) {
        x.getName().accept0(this);
    }
}<|file_separator|>class MySqlShowStatementImpl.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class MySqlShowStatementImpl extends MySqlStatementImpl implements MySqlShowStatement {
    private SQLName name;

    public void accept0(MySqlASTVisitor visitor) {
        visitor.visit(this);
    }

    public SQLName getName() {
        return name;
    }

    public void setName(SQLName x) {
        if (x != null) {
            x.setParent(this);
        }
        this.name = x;
    }
}<|file_separator|>class MySqlShowStatement.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public interface MySqlShowStatement extends MySqlStatement {
    public SQLName getName();

    public void setName(SQLName x);
}<|file_separator|>class MySqlShowStatementVisitor.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class MySqlShowStatementVisitor extends MySqlASTVisitor {
    <nl>
        visitor.visit(this);
    <|file_separator|>class MySqlShowCreateFunctionStatement.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class MySqlShowCreateFunctionStatement extends MySqlStatementImpl implements MySqlShowStatement {
    private SQLExpr name;

    public void accept0(MySqlASTVisitor visitor) {
        visitor.visit(this);
    }

    public SQLExpr getName() {
        return name;
    }

    public void setName(SQLExpr functionName) {
        this.name = functionName;
    }

}<|file_separator|>class MySqlShowCreateFunctionStatementImpl.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class MySqlShowCreateFunctionStatementImpl extends MySqlShowCreateFunctionStatement {
    private SQLExpr name;

    public void accept0(MySqlASTVisitor visitor) {
        visitor.visit(this);
    }

    public SQLExpr getName() {
        return name;
    }

    public void setName(SQLExpr functionName) {
        this.name = functionName;
    }

}<|file_separator|>class MySqlShowCreateFunctionStatementImpl.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class MySqlShowCreateFunctionStatementImpl extends MySqlShowCreateFunctionStatement {
    private SQLExpr name;

    public void accept0(MySqlASTVisitor visitor) {
        visitor.visit(this);
    }

    public SQLExpr getName() {
        return name;
    }

    public void setName(SQLExpr functionName) {
        this.name = functionName;
    }

}<|file_separator|>class MySqlShowCreateFunctionStatementImpl.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class MySqlShowCreateFunctionStatementImpl extends MySqlShowCreateFunctionStatement {
    private SQLExpr name;

    public void accept0(MySqlASTVisitor visitor) {
        visitor.visit(this);
    }

    public SQLExpr getName() {
        return name;
    }

    public void setName(SQLExpr<nl>
        visitor.visit(this);
    <|file_separator|>class MySqlShowTablesStatement extends MySqlStatementImpl implements MySqlShowStatement {
    private boolean count;
    private boolean all;
    private boolean full;
    private boolean noIndex;
    private boolean noKey;
    private boolean noCheck;
    private boolean noDefault;
    private boolean noExtra;
    private boolean noLog;
    private boolean noView;
    private boolean noIndexFull;
    private boolean noIndexFullText;
    private boolean noIndexFullTextWithIndex;
    private boolean noIndexFullTextWithIndexFull;
    private boolean noIndexFullTextWithIndexFullText;
    private boolean noIndexFullTextWithIndexFullTextWithIndex;
    private boolean noIndexFullTextWithIndexFullTextWithIndexFull;
    private boolean noIndexFullTextWithIndexFullTextWithIndexFullText;
    private boolean noIndexFullTextWithIndexFullTextWithIndexFullTextWithIndex;
    private boolean noIndexFullTextWithIndexFullTextWithIndexFullTextWithIndexFull;
    private boolean noIndexFullTextWithIndexFullTextWithIndexFullTextWithIndexFullText;
    private boolean noIndexFullTextWithIndexFullTextWithIndexFullTextWithIndexFullTextWithIndex;
    private boolean noIndexFullTextWithIndexFullTextWithIndexFullTextWithIndexFullTextWithIndexFull;
    private boolean noIndexFullTextWithIndexFullTextWithIndexFullTextWithIndexFullTextWithIndexFullText;
    private boolean noIndexFullTextWithIndexFullTextWithIndexFullTextWithIndexFullTextWithIndexFullTextWithIndex;
    private boolean noIndexFullTextWithIndexFullTextWithIndexFullTextWithIndexFullTextWithIndexFullTextWithIndexFull;
    private boolean noIndexFullTextWithIndexFullTextWithIndexFullTextWithIndexFullText<nl>
        visitor.visit(this);
    <|file_separator|>class MySqlShowTableStatusStatement extends MySqlStatementImpl implements MySqlShowStatement {
    public void accept0(MySqlASTVisitor visitor) {
        visitor.visit(this);
    }
<|file_separator|>class MySqlShowIndexStatement extends MySqlStatementImpl implements MySqlShowStatement {
    public void accept0(MySqlASTVisitor visitor) {
        visitor.visit(this);
    }
}<|file_separator|>class MySqlShowTableStatusResult extends MySqlResultImpl implements MySqlShowResult {
    public void accept0(MySqlASTVisitor visitor) {
        visitor.visit(this);
    }
}<|file_separator|>class MySqlShowIndexResult extends MySqlResultImpl implements MySqlShowResult {
    public void accept0(MySqlASTVisitor visitor) {
        visitor.visit(this);
    }
}<|file_separator|>class MySqlShowTableStatusResultRow extends MySqlResultRowImpl implements MySqlShowResultRow {
    public void accept0(MySqlASTVisitor visitor) {
        visitor.visit(this);
    }
}<|file_separator|>class MySqlShowTableStatusResultRowField extends MySqlResultRowFieldImpl implements MySqlShowResultRowField {
    public void accept0(MySqlASTVisitor visitor) {
        visitor.visit(this);
    }
}<|file_separator|>class MySqlShowTableStatusResultRowFieldList extends MySqlResultRowFieldListImpl implements MySqlShowResultRowFieldList {
    public void accept0(MySqlASTVisitor visitor) {
        visitor.visit(this);
    }
}<|file_separator|>class MySqlShowTableStatusResultRowFieldListRow extends MySqlResultRowFieldListRowImpl implements MySqlShowResultRowFieldListRow {
    public void accept0(MySqlASTVisitor visitor) {
        visitor.visit(this);
    }
}<|file_separator|>class MySqlShowTableStatusResultRowFieldListRowField extends MySqlResultRowFieldListRowFieldImpl implements MySqlShowResultRowField<nl>
        return limit;
    <|file_separator|>class MySqlShowTraceStatement extends MySqlStatementImpl implements MySqlShowStatement {
    private SQLOrderBy orderBy;
    private SQLExpr where;
    private SQLLimit limit;

    public SQLLimit getLimit() {
        return limit;
    }

    public void setLimit(SQLLimit limit) {
        this.limit = limit;
    }

    public SQLOrderBy getOrderBy() {
        return orderBy;
    }

    public void setOrderBy(SQLOrderBy orderBy) {
        this.orderBy = orderBy;
    }

    public SQLExpr getWhere() {
        return where;
    }

    public void setWhere(SQLExpr where) {
        this.where = where;
    }

    public void accept0(MySqlASTVisitor visitor) {
        if (visitor.visit(this)) {
            acceptChild(visitor, where);
            acceptChild(visitor, orderBy);
            acceptChild(visitor, limit);
        }
        visitor.endVisit(this);
    }
}<|file_separator|>class MySqlShowTraceStatement extends MySqlStatementImpl implements MySqlShowStatement {
    private SQLOrderBy orderBy;
    private SQLExpr where;
    private SQLLimit limit;

    public SQLLimit getLimit() {
        return limit;
    }

    public void setLimit(SQLLimit limit) {
        this.limit = limit;
    }

    public SQLOrderBy getOrderBy() {
        return orderBy;
    }

    public void setOrderBy(SQLOrderBy orderBy) {
        this.orderBy = orderBy;
    }

    public SQLExpr getWhere() {
        return where;
    }

    public void setWhere(SQLExpr where) {
        this.where = where;
    }

    public void accept0(<nl>
        visitor.visit(this);
        acceptChild(visitor, columns);
        acceptChild(visitor, subPartitionsCount);
    <|file_separator|>class MySqlSubPartitionByHash extends SQLSubPartitionBy implements MySqlObject {
    private int algorithm = 1;
    private int subPartitionsCount = 1;
    private int subPartitionSize = 1000000000;

    @Override
    protected void accept0(SQLASTVisitor visitor) {
        visitor.visit(this);
        acceptChild(visitor, subPartitionsCount);
        acceptChild(visitor, subPartitionSize);
    }

    @Override
    public void accept0(MySqlASTVisitor visitor) {
        if (visitor.visit(this)) {
            acceptChild(visitor, subPartitionsCount);
            acceptChild(visitor, subPartitionSize);
        }
        visitor.endVisit(this);
    }

    public int getAlgorithm() {
        return algorithm;
    }

    public void setAlgorithm(int algorithm) {
        this.algorithm = algorithm;
    }

    public int getSubPartitionsCount() {
        return subPartitionsCount;
    }

    public void setSubPartitionsCount(int subPartitionsCount) {
        this.subPartitionsCount = subPartitionsCount;
    }

    public int getSubPartitionSize() {
        return subPartitionSize;
    }

    public void setSubPartitionSize(int subPartitionSize) {
        this.subPartitionSize = subPartitionSize;
    }

    public boolean isPartitionByColumn(long columnNameHashCode64) {
        return false;
    }
}<|file_separator|>class MySqlSubPartitionByHash_1.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class MySqlSubPartitionByHash_1 extends MySqlSubPartitionByHash {
    public MySqlSubPartition<nl>
        visitor.visit(this);
    }

    @Override
    public void accept0(MySqlASTVisitor visitor, boolean isSubQuery) {
        visitor.visit(this, isSubQuery);
    }

    @Override
    public void accept0(MySqlASTVisitor visitor, boolean isSubQuery, boolean isSubQueryAlias) {
        visitor.visit(this, isSubQuery, isSubQueryAlias);
    }

    @Override
    public void accept0(MySqlASTVisitor visitor, boolean isSubQuery, boolean isSubQueryAlias, boolean isSubQueryAliasAlias) {
        visitor.visit(this, isSubQuery, isSubQueryAlias, isSubQueryAliasAlias);
    }

    @Override
    public void accept0(MySqlASTVisitor visitor, boolean isSubQuery, boolean isSubQueryAlias, boolean isSubQueryAliasAlias, boolean isSubQueryAliasAliasAlias) {
        visitor.visit(this, isSubQuery, isSubQueryAlias, isSubQueryAliasAlias, isSubQueryAliasAliasAlias);
    }

    @Override
    public void accept0(MySqlASTVisitor visitor, boolean isSubQuery, boolean isSubQueryAlias, boolean isSubQueryAliasAlias, boolean isSubQueryAliasAliasAlias, boolean isSubQueryAliasAliasAliasAlias) {
        visitor.visit(this, isSubQuery, isSubQueryAlias, isSubQueryAliasAlias, isSubQueryAliasAliasAlias, isSubQueryAliasAliasAliasAlias);
    }

    @Override
    public void accept0(MySqlASTVisitor visitor, boolean isSubQuery, boolean isSubQueryAlias, boolean isSubQueryAliasAlias, boolean isSubQueryAliasAliasAlias, boolean isSubQueryAliasAliasAliasAlias, boolean isSubQueryAliasAliasAliasAliasAlias) {
        visitor.visit(this, isSubQuery,<nl>
        visitor.visit(this);
    }

    @Override
    public void accept0(MySqlStatementVisitor visitor) {
        visitor.visit(this);
    <|file_separator|><nl>
        return true;
    }

    @Override
    public boolean visit(MySqlDateExpr x) {
        return true;
    }

    @Override
    public boolean visit(MySqlDateTimeExpr x) {
        return true;
    }

    @Override
    public boolean visit(MySqlDecimalExpr x) {
        return true;
    }

    @Override
    public boolean visit(MySqlDoubleExpr x) {
        return true;
    }

    @Override
    public boolean visit(MySqlFloatExpr x) {
        return true;
    }

    @Override
    public boolean visit(MySqlIntExpr x) {
        return true;
    }

    @Override
    public boolean visit(MySqlLongExpr x) {
        return true;
    }

    @Override
    public boolean visit(MySqlStringExpr x) {
        return true;
    <|file_separator|><nl>
        if (x instanceof SQLIdentifierExpr) {
            SQLIdentifierExpr identifierExpr = (SQLIdentifierExpr) x;
            long nameHashCode64 = identifierExpr.nameHashCode64();
            return isRowNumColumn(nameHashCode64, source);
        }
        return false;
    <|file_separator|><nl>
        v.visit(this);
    <|file_separator|>class OdpsAlterTableSetChangeLogs extends OdpsObjectImpl
        implements SQLAlterTableItem {
    private SQLExpr value;

    @Override
    public void accept0(OdpsASTVisitor v) {
        v.visit(this);
    }

    public SQLExpr getValue() {
        return value;
    }

    public void setValue(SQLExpr x) {
        if (x != null) {
            x.setParent(this);
        }
        this.value = x;
    }
}<|file_separator|>class OdpsAlterTableSetChangeLogs extends OdpsObjectImpl
        implements SQLAlterTableItem {
    private SQLExpr value;

    @Override
    public void accept0(OdpsASTVisitor v) {
        v.visit(this);
    }

    public SQLExpr getValue() {
        return value;
    }

    public void setValue(SQLExpr x) {
        if (x != null) {
            x.setParent(this);
        }
        this.value = x;
    }
}<|file_separator|>class OdpsAlterTableSetChangeLogs extends OdpsObjectImpl
        implements SQLAlterTableItem {
    private SQLExpr value;

    @Override
    public void accept0(OdpsASTVisitor v) {
        v.visit(this);
    }

    public SQLExpr getValue() {
        return value;
    }

    public void setValue(SQLExpr x) {
        if (x != null) {
            x.setParent(this);
        }
        this.value = x;
    }
}<|file_separator|>class OdpsAlterTableSetChangeLogs extends OdpsObjectImpl
        implements SQLAlterTableItem {
    private SQLExpr value;

    @Override
    public<nl>
        return lifecycle;
    <|file_separator|><nl>
        this.subjectType = subjectType;
    }

    public List<SQLName> getUsers() {
        return users;
    }

    public void setUsers(List<SQLName> users) {
        this.users = users;
    }

    public SQLName getResource() {
        return resource;
    }

    public void setResource(SQLName resource) {
        this.resource = resource;
    <|file_separator|><nl>
        packageName = x;
    <|file_separator|>class OdpsInstallPackageStatement.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>package com.aliyun.odps.sql.ast;

import com.aliyun.odps.sql.ast.SQLName;
import com.aliyun.odps.sql.ast.SQLStatement;
import com.aliyun.odps.sql.ast.SQLVisitor;
import com.aliyun.odps.sql.ast.SQLVisitorImpl;
import com.aliyun.odps.sql.ast.SQLVisitorResult;

public class OdpsInstallPackageStatement extends SQLStatement {
    private SQLName packageName;

    public SQLName getPackageName() {
        return packageName;
    }

    public void setPackageName(SQLName x) {
        packageName = x;
    }

    @Override
    public SQLVisitorResult accept(SQLVisitor v) {
        return v.visit(this);
    }

    @Override
    public SQLVisitorResult accept(SQLVisitor v, SQLStatement parent) {
        return v.visit(this, parent);
    }
}<|file_separator|>class OdpsInstallPackageStatement.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>package com.aliyun.odps.sql.ast;

import com.aliyun.odps.sql.ast.SQLName;
import com.aliyun.odps.sql.ast.SQLStatement;
import com.aliyun.odps.sql.ast.SQLVisitor;
import com.aliyun.odps.sql.ast.SQLVisitorImpl;
import com.aliyun.odps.sql.ast.SQLVisitorResult;

public class OdpsInstallPackageStatement extends SQLStatement {
    private SQLName packageName;

    public SQLName getPackageName() {
        return packageName;
    }

    public void setPackageName(SQLName x) {
        packageName = x;
<nl>
        this.user = user;
    }

    @Override
    public String toString() {
        return "OdpsRemoveUserStatement{" +
                "user=" + user +
                '}';
    <|file_separator|>class OdpsCreateDatabaseStatement extends SQLStatementImpl {
    private SQLIdentifierExpr database;

    @Override
    protected void accept0(SQLASTVisitor visitor) {
        accept0((OdpsASTVisitor) visitor);
    }

    public void accept0(OdpsASTVisitor visitor) {
        if (visitor.visit(this)) {
            acceptChild(visitor, database);
        }
        visitor.endVisit(this);
    }

    public SQLIdentifierExpr getDatabase() {
        return database;
    }

    public void setDatabase(SQLIdentifierExpr database) {
        this.database = database;
    }

    @Override
    public String toString() {
        return "OdpsCreateDatabaseStatement{" +
                "database=" + database +
                '}';
    }
}<|file_separator|>class OdpsCreateTableStatement extends SQLStatementImpl {
    private SQLIdentifierExpr table;

    @Override
    protected void accept0(SQLASTVisitor visitor) {
        accept0((OdpsASTVisitor) visitor);
    }

    public void accept0(OdpsASTVisitor visitor) {
        if (visitor.visit(this)) {
            acceptChild(visitor, table);
        }
        visitor.endVisit(this);
    }

    public SQLIdentifierExpr getTable() {
        return table;
    }

    public void setTable(SQLIdentifierExpr table) {
        this.table = table;
    }

    @Override
    public String toString() {
        return "OdpsCreateTableStatement{" +
                "table=" + table +
<nl>
        return toString(false);
    }

    public String toString(boolean withComments) {
        return toString(withComments, false);
    }

    public String toString(boolean withComments, boolean withTypes) {
        return toString(withComments, withTypes, false);
    <|file_separator|><nl>
        this.flashCache = flashCache;
    <|file_separator|>class OracleSQLObjectImpl.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public abstract class OracleSQLObjectImpl extends SQLObjectImpl {
    public abstract void accept0(OracleASTVisitor visitor);

    public void accept(OracleASTVisitor visitor) {
        accept0(visitor);
    }
}<|file_separator|>class OracleSQLObject.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public interface OracleSQLObject extends SQLObject {
    public void accept(OracleASTVisitor visitor);
}<|file_separator|>class OracleSQLObjectImpl.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public abstract class OracleSQLObjectImpl extends SQLObjectImpl {
    public abstract void accept0(OracleASTVisitor visitor);

    public void accept(OracleASTVisitor visitor) {
        accept0(visitor);
    }
}<|file_separator|>class OracleSQLObject.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public interface OracleSQLObject extends SQLObject {
    public void accept(OracleASTVisitor visitor);
}<|file_separator|>class OracleStorageClause.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class OracleStorageClause extends OracleSQLObjectImpl {
    private SQLExpr initial;
    private SQLExpr next;
    private SQLExpr minExtents;
    private SQLExpr maxExtents;
    private SQLExpr maxSize;
    private SQLExpr pctIncrease;
    private SQLExpr freeLists;
    private SQLExpr freeListGroups;
    private SQLExpr bufferPool;
    private SQLExpr objno;
    private FlashCacheType flashCache;
    private FlashCacheType cellFlashCache;

    public OracleStorageClause clone() {
        OracleStorageClause x = new OracleStorageClause();
        if (initial != null) {
            x.setInitial(initial.clone());
        }
        if (next != null) {
            x.setNext(next.clone());
        }
        if (minExtents != null) {
            x<nl>
        visitor.visit(this);
    <|file_separator|>class OracleDateExpr.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class OracleDateExpr extends OracleSQLObjectImpl implements SQLExpr {
    private SQLExpr expr;

    public OracleDateExpr() {
    }

    public OracleDateExpr(SQLExpr expr) {
        this.expr = expr;
    }

    @Override
    public void accept0(OracleASTVisitor visitor) {
        visitor.visit(this);
    }

    public SQLExpr getExpr() {
        return expr;
    }

    public void setExpr(SQLExpr expr) {
        this.expr = expr;
    }

    public OracleDateExpr clone() {
        OracleDateExpr x = new OracleDateExpr();

        if (expr != null) {
            x.setExpr(expr.clone());
        }

        return x;
    }

    @Override
    public List<SQLObject> getChildren() {
        return Arrays.<SQLObject>asList(this.expr);
    }
}<|file_separator|>class OracleDateExpr.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class OracleDateExpr extends OracleSQLObjectImpl implements SQLExpr {
    private SQLExpr expr;

    public OracleDateExpr() {
    }

    public OracleDateExpr(SQLExpr expr) {
        this.expr = expr;
    }

    @Override
    public void accept0(OracleASTVisitor visitor) {
        visitor.visit(this);
    }

    public SQLExpr getExpr() {
        return expr;
    }

    public void setExpr(SQLExpr expr) {
        this.expr = expr;
    }

    public OracleDateExpr clone() {
        OracleDateExpr x = new OracleDateExpr();

        if (expr != null) {
            x.set<nl>
        final int prime = 31;
        int result = 1;
        result = prime * result + ((factionalSecondsPrecision == null) ? 0 : factionalSecondsPrecision.hashCode());
        result = prime * result + ((precision == null) ? 0 : precision.hashCode());
        result = prime * result + ((toFactionalSecondsPrecision == null) ? 0 : toFactionalSecondsPrecision.hashCode());
        result = prime * result + ((toType == null) ? 0 : toType.hashCode());
        result = prime * result + ((type == null) ? 0 : type.hashCode());
        result = prime * result + ((value == null) ? 0 : value.hashCode());
        return result;
    <|file_separator|>class OracleIntervalType.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public enum OracleIntervalType {
    SECOND,
    MINUTE,
    HOUR,
    DAY,
    WEEK,
    MONTH,
    QUARTER,
    YEAR
}<|file_separator|><nl>
        OracleTreatExpr clone = new OracleTreatExpr();
        clone.setExpr(expr.clone());
        clone.setType(type.clone());
        clone.setRef(ref);
        return clone;
    <|file_separator|>class OracleTreatExprList extends OracleSQLObjectImpl implements SQLExprList {
    private List<SQLExpr> exprs;

    public List<SQLExpr> getExprs() {
        return exprs;
    }

    public void setExprs(List<SQLExpr> exprs) {
        this.exprs = exprs;
    }

    @Override
    public void accept0(OracleASTVisitor visitor) {
        if (visitor.visit(this)) {
            for (SQLExpr expr : exprs) {
                acceptChild(visitor, expr);
            }
        }
        visitor.endVisit(this);
    }

    public List<SQLObject> getChildren() {
        return exprs;
    }

    public OracleTreatExprList clone() {
        OracleTreatExprList clone = new OracleTreatExprList();
        clone.setExprs(new ArrayList<SQLExpr>(exprs));
        return clone;
    }
}<|file_separator|>class OracleTreatExprListImpl.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class OracleTreatExprListImpl extends OracleSQLObjectImpl implements SQLExprList {
    private List<SQLExpr> exprs;

    public List<SQLExpr> getExprs() {
        return exprs;
    }

    public void setExprs(List<SQLExpr> exprs) {
        this.exprs = exprs;
    }

    @Override
    public void accept0(OracleASTVisitor visitor) {
        if (visitor.visit(this)) {
            for (SQLExpr expr : exprs) {<nl>
        visitor.visit(this);
    }

    @Override
    public void accept(SQLASTVisitor visitor) {
        accept0(visitor);
    }

    @Override
    public void accept(SQLASTVisitor visitor, String name) {
        accept0(visitor);
    <|file_separator|>class OracleIndex.java
<|fim_prefix|><|fim_suffix|>

    public void setUnique(Boolean unique) {
        this.unique = unique;
    }

    public void setPartitioned(Boolean partitioned) {
        this.partitioned = partitioned;
    }

    public void setClustered(Boolean clustered) {
        this.clustered = clustered;
    }

    public void setDefragment(Boolean defragment) {
        this.defragment = defragment;
    }

    public void setDefragmentInterval(Integer defragmentInterval) {
        this.defragmentInterval = defragmentInterval;
    }

    public void setDefragmentMethod(String defragmentMethod) {
        this.defragmentMethod = defragmentMethod;
    }

    public void setDefragmentType(String defragmentType) {
        this.defragmentType = defragmentType;
    }

    public void setDefragmentTable(String defragmentTable) {
        this.defragmentTable = defragmentTable;
    }

    public void setDefragmentTableType(String defragmentTableType) {
        this.defragmentTableType = defragmentTableType;
    }

    public void setDefragmentTableType(String defragmentTableType, String defragmentTableType2) {
        this.defragmentTableType = defragmentTableType;
        this.defragmentTableType2 = defragmentTableType2;
    }

    public void setDefragmentTableType(String defragmentTableType, String defragment<nl>
        visitor.visit(this);
    }

    @Override
    public void accept0(SQLVisitor visitor) {
        visitor.visit(this);
    <|file_separator|><nl>
        visitor.visit(this);
    <|file_separator|><nl>
        visitor.visit(this);
    }

    public void setFrom(SQLExprTableSource from) {
        if (from == null) {
            throw new IllegalArgumentException("from is null");
        }
        this.from = from;
    }

    public void setFrom(String tableName, String alias) {
        if (tableName == null || tableName.length() == 0) {
            throw new IllegalArgumentException("tableName is null");
        }
        if (alias == null || alias.length() == 0) {
            throw new IllegalArgumentException("alias is null");
        }
        this.from = new OracleSelectTableReference(new SQLIdentifierExpr(tableName), new SQLIdentifierExpr(alias));
    }

    public void setFrom(String tableName, String alias, String alias2) {
        if (tableName == null || tableName.length() == 0) {
            throw new IllegalArgumentException("tableName is null");
        }
        if (alias == null || alias.length() == 0) {
            throw new IllegalArgumentException("alias is null");
        }
        if (alias2 == null || alias2.length() == 0) {
            throw new IllegalArgumentException("alias2 is null");
        }
        this.from = new OracleSelectTableReference(new SQLIdentifierExpr(tableName), new SQLIdentifierExpr(alias),
                new SQLIdentifierExpr(alias2));
    }

    public void setFrom(String tableName, String alias, String alias2, String alias3) {
        if (tableName == null || tableName.length() == 0) {
            throw new IllegalArgumentException("tableName is null");
        }
        if (alias == null || alias.length() == 0) {
            throw new IllegalArgumentException("alias is null");
        <nl>
        OracleSupplementalLogGrp result = new OracleSupplementalLogGrp();
        result.setGroup(group.clone());
        result.setAlways(always);
        for (SQLName column : columns) {
            result.addColumn(column.clone());
        }
        return result;
    <|file_separator|>class OracleSupplementalLogGrp.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>package oracle.sql;

import java.util.List;

public class OracleSupplementalLogGrp extends OracleSQLObjectImpl implements SQLTableElement {
    private SQLName group;
    private List<SQLName> columns = new ArrayList<SQLName>();
    private boolean always;

    @Override
    public void accept0(OracleASTVisitor visitor) {
        if (visitor.visit(this)) {
            acceptChild(visitor, group);
            acceptChild(visitor, columns);
        }
        visitor.endVisit(this);
    }

    public SQLName getGroup() {
        return group;
    }

    public void setGroup(SQLName group) {
        if (group != null) {
            group.setParent(this);
        }
        this.group = group;
    }

    public List<SQLName> getColumns() {
        return columns;
    }

    public void addColumn(SQLName column) {
        if (column != null) {
            column.setParent(this);
        }
        this.columns.add(column);
    }

    public boolean isAlways() {
        return always;
    }

    public void setAlways(boolean always) {
        this.always = always;
    }

    public OracleSupplementalLogGrp clone() {
        OracleSupplementalLogGrp result = new OracleSupplementalLogGrp();
        result.setGroup(group.clone());
        result.setAlways<nl>
        return SQLEvalVisitorUtils.visit(this, x);
    }

    public boolean visit(SQLBooleanExpr x) {
        return SQLEvalVisitorUtils.visit(this, x);
    }

    public boolean visit(SQLDateExpr x) {
        return SQLEvalVisitorUtils.visit(this, x);
    }

    public boolean visit(SQLDateTimeExpr x) {
        return SQLEvalVisitorUtils.visit(this, x);
    }

    public boolean visit(SQLTimeExpr x) {
        return SQLEvalVisitorUtils.visit(this, x);
    }

    public boolean visit(SQLIntervalExpr x) {
        return SQLEvalVisitorUtils.visit(this, x);
    }

    public boolean visit(SQLStringExpr x) {
        return SQLEvalVisitorUtils.visit(this, x);
    <|file_separator|><nl>
        if (visitor.visit(this)) {
            visitor.endVisit(this);
        }
    }

    public void accept(SQLASTVisitor visitor) {
        accept0(visitor);
    }

    public void accept(OscarASTVisitor visitor) {
        accept0(visitor);
    }

    public void accept(SQLASTVisitorWithResult visitor) {
        accept0(visitor);
    }

    public void accept(OscarASTVisitorWithResult visitor) {
        accept0(visitor);
    }

    public void accept(SQLASTVisitorWithResultAndData visitor) {
        accept0(visitor);
    }

    public void accept(OscarASTVisitorWithResultAndData visitor) {
        accept0(visitor);
    }

    public void accept(SQLASTVisitorWithResultAndDataAndContext visitor) {
        accept0(visitor);
    }

    public void accept(OscarASTVisitorWithResultAndDataAndContext visitor) {
        accept0(visitor);
    }

    public void accept(SQLASTVisitorWithResultAndDataAndContextAndConnection visitor) {
        accept0(visitor);
    }

    public void accept(OscarASTVisitorWithResultAndDataAndContextAndConnection visitor) {
        accept0(visitor);
    }

    public void accept(SQLASTVisitorWithResultAndDataAndContextAndConnectionAndStatement visitor) {
        accept0(visitor);
    }

    public void accept(OscarASTVisitorWithResultAndDataAndContextAndConnectionAndStatement visitor) {
        accept0(visitor);
    }

    public void accept(SQLASTVisitorWithResultAndDataAndContextAndConnectionAndStatementAndConnectionContext visitor) {
        accept0(visitor);
    }

    public void accept(OscarASTVisitorWithResultAndDataAndContext<nl>
        visitor.visit(this);
    <|file_separator|>class OscarShowStatement.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class OscarShowStatement extends SQLStatementImpl implements OscarStatement, SQLShowStatement {
    private SQLExpr expr;

    public SQLExpr getExpr() {
        return expr;
    }

    public void setExpr(SQLExpr expr) {
        this.expr = expr;
    }

    protected void accept0(SQLASTVisitor visitor) {
        accept0((OscarASTVisitor) visitor);
    }

    @Override
    public void accept0(OscarASTVisitor visitor) {
        visitor.visit(this);
    }
}<|file_separator|>class OscarStatement.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public interface OscarStatement {
    public SQLExpr getExpr();
    public void setExpr(SQLExpr expr);
}<|file_separator|>class OscarStatementImpl.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class OscarStatementImpl implements OscarStatement {
    private SQLExpr expr;

    public SQLExpr getExpr() {
        return expr;
    }

    public void setExpr(SQLExpr expr) {
        this.expr = expr;
    }

    protected void accept0(SQLASTVisitor visitor) {
        accept0((OscarASTVisitor) visitor);
    }

    @Override
    public void accept0(OscarASTVisitor visitor) {
        visitor.visit(this);
    }
}<|file_separator|>class OscarStatementImpl.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class OscarStatementImpl implements OscarStatement {
    private SQLExpr expr;

    public SQLExpr getExpr() {
        return expr;
    }

    public void setExpr(SQLExpr expr) {
        this.expr = expr;
    }

    protected void accept0(SQLASTVisitor visitor) {
        accept0((OscarASTVisitor) visitor);
    }

    @Override<nl>
        if (visitor instanceof PGASTVisitor) {
            accept0((PGASTVisitor) visitor);
            return;
        }

        super.accept0(visitor);
    }

    @Override
    public void accept0(OscarSQLVisitor visitor) {
        if (visitor instanceof PGASTVisitor) {
            accept0((PGASTVisitor) visitor);
            return;
        }

        super.accept0(visitor);
    <|file_separator|>class OscarUpdateStatement.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>package com.oscar.sql.ast;

import com.oscar.sql.ast.visitor.OscarASTVisitor;
import com.oscar.sql.ast.visitor.PGASTVisitor;
import com.oscar.sql.ast.visitor.OscarSQLVisitor;
import com.oscar.sql.ast.visitor.OscarStatement;
import com.oscar.sql.ast.visitor.SQLUpdateStatement;
import com.oscar.sql.ast.visitor.SQLVisitor;
import com.oscar.sql.ast.visitor.SQLVisitor;
import com.oscar.sql.ast.visitor.SQLVisitor;
import com.oscar.sql.ast.visitor.SQLVisitor;
import com.oscar.sql.ast.visitor.SQLVisitor;
import com.oscar.sql.ast.visitor.SQLVisitor;
import com.oscar.sql.ast.visitor.SQLVisitor;
import com.oscar.sql.ast.visitor.SQLVisitor;
import com.oscar.sql.ast.visitor.SQLVisitor;
import com.oscar.sql.ast.visitor.SQLVisitor;
import com.oscar.sql.ast.visitor.SQLVisitor;
import com.oscar.sql.ast.visitor.SQLVisitor;
import com.oscar.sql.ast.visitor.SQLVisitor;
import com.oscar.sql.<nl>
        return true;
    }

    @Override
    public boolean visit(SQLExprTableSource x, boolean parameterized) {
        return true;
    <|file_separator|><nl>
        visitor.visitAlterFunctionStatement(this);
    <|file_separator|>class PrestoAlterTableStatement extends SQLAlterTableStatement implements PrestoSQLStatement {
    public PrestoAlterTableStatement() {
    }

    private boolean ifNotExists;
    private boolean ifExists;
    private boolean ifExistsAndIfExists;
    private boolean ifNotExistsAndIfExists;
    private boolean ifNotExistsAndIfExistsAndIfExists;
    private boolean ifNotExistsAndIfExistsAndIfExistsAndIfExists;
    private boolean ifNotExistsAndIfExistsAndIfExistsAndIfExistsAndIfExists;
    private boolean ifNotExistsAndIfExistsAndIfExistsAndIfExistsAndIfExistsAndIfExists;
    private boolean ifNotExistsAndIfExistsAndIfExistsAndIfExistsAndIfExistsAndIfExistsAndIfExists;
    private boolean ifNotExistsAndIfExistsAndIfExistsAndIfExistsAndIfExistsAndIfExistsAndIfExistsAndIfExists;
    private boolean ifNotExistsAndIfExistsAndIfExistsAndIfExistsAndIfExistsAndIfExistsAndIfExistsAndIfExistsAndIfExists;
    private boolean ifNotExistsAndIfExistsAndIfExistsAndIfExistsAndIfExistsAndIfExistsAndIfExistsAndIfExistsAndIfExistsAndIfExists;
    private boolean ifNotExistsAndIfExistsAndIfExistsAndIfExistsAndIfExistsAndIfExistsAndIfExistsAndIfExistsAndIfExistsAndIfExistsAndIfExists;
    private boolean ifNotExistsAndIfExistsAndIfExistsAndIfExistsAndIfExistsAndIfExistsAndIfExistsAndIfExistsAndIfExistsAndIfExistsAndIfExistsAndIfExists;
    private boolean ifNotExistsAndIfExistsAndIfExistsAndIfExistsAndIfExistsAndIfExistsAndIfExistsAndIfExistsAndIfExistsAndIfExistsAndIfExistsAndIfExistsAndIfExists;
    private boolean ifNotExistsAndIfExistsAndIfExistsAndIfExistsAndIfExistsAndIfExistsAndIfExistsAndIfExistsAndIfExistsAndIfExistsAndIfExistsAndIfExistsAndIfExistsAndIfExists;
    private boolean ifNotExistsAndIfExistsAndIfExistsAndIfExistsAndIfExistsAndIfExistsAndIfExistsAndIfExistsAndIfExistsAndIfExistsAndIfExistsAndIfExistsAndIfExistsAndIfExistsAndIfExists;
    private boolean ifNotExistsAndIfExistsAndIfExistsAndIfExists<nl>
        visitor.visit(this);
    <|file_separator|>class SQLServerASTVisitor.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class SQLServerASTVisitor extends SQLASTVisitor {
    public SQLServerASTVisitor() {
        super(DbType.sqlserver);
    }

    @Override
    public void visit(SQLServerStatement statement) {
        statement.accept0(this);
    }

    public abstract void visit(SQLServerStatement statement);
}<|file_separator|><nl>
        return properties;
    <|file_separator|><nl>
        this.seed = seed;
        return genAlias();
    }

    public String genAlias() {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < 10; i++) {
            sb.append((char) (seed % 26 + 'a'));
            seed = seed / 26;
        }
        return sb.toString();
    <|file_separator|><nl>
        return x.getArg(0).eval(visitor) + "    ";
    <|file_separator|><nl>
        return 0;
    <|file_separator|><nl>
        return unwrapType == DruidConnectionProvider.class;
    <|file_separator|><nl>
        return getRequestTimeNano() / (1000 * 1000);
    <|file_separator|><nl>
        return proxyBeanNames;
    }

    public void setBeanNames(List<String> beanNames) {
        this.beanNames = beanNames;
    }

    public void setProxyBeanNames(List<String> proxyBeanNames) {
        this.proxyBeanNames = proxyBeanNames;
    <|file_separator|><nl>
        session.startTransaction(transactionIsolation);
    <|file_separator|><nl>
        String path = config.getInitParameter(PARAM_NAME_PATH);
        if (path == null || path.length() == 0) {
            path = "/druid";
        }
        this.servletPath = path;
        this.resourcePath = config.getInitParameter("resourcePath");
        if (this.resourcePath == null || this.resourcePath.length() == 0) {
            this.resourcePath = "support/http/resources";
        }
        this.handler = new ResourceHandler();
        this.handler.setDirectoriesListed(true);
        this.handler.setWelcomeFiles(new String[]{"index.html"});
        this.handler.setResourceBase(this.resourcePath);
    <|file_separator|><nl>
        return log.isEnabled(Level.ERROR);
    }

    public void info(String msg, Throwable e) {
        infoCount++;
        log.info(msg, e);
    }

    public void error(String msg) {
        errorCount++;
        log.error(msg);
    }

    public void error(String msg, Throwable e) {
        errorCount++;
        log.error(msg, e);
    }

    public void warn(String msg) {
        log.warn(msg);
        warnCount++;
    }

    public void warn(String msg, Throwable e) {
        log.warn(msg, e);
        warnCount++;
    <|file_separator|><nl>
        return startTime;
    <|file_separator|><nl>
        if (type.equals("org.osjava.sj.loader.DataSource")) {
            return new DruidDataSource(properties);
        }
        return null;
    <|file_separator|><nl>
        Clob clob = rs.getClob(columnIndex);

        if (clob == null) {
            return null;
        }

        return clob.getSubString(1, (int) clob.length());
    <|file_separator|><nl>
        if (methodStat.getClass() == SpringStat.class) {
            return ((SpringStat) methodStat).getMethodStatData(clazz, methodSignature);
        }

        try {
            Method method = methodStat.getClass().getMethod("getMethodStatData", String.class, String.class);
            Object obj = method.invoke(methodStat, clazz, methodSignature);
            return (Map<String, Object>) obj;
        } catch (Exception e) {
            LOG.error("getMethodStatData error", e);
            return null;
        }
    }

    public static void add(Object webStat, String clazz, String methodSignature, long time) {
        if (webStat.getClass() == SpringStat.class) {
            ((SpringStat) webStat).add(clazz, methodSignature, time);
            return;
        }

        try {
            Method method = webStat.getClass().getMethod("add", String.class, String.class, long.class);
            method.invoke(webStat, clazz, methodSignature, time);
        } catch (Exception e) {
            LOG.error("add error", e);
        }
    <|file_separator|><nl>
        return new AnnotationPointcut(StatAnnotation.class);
    <|file_separator|><nl>
        if (encoded == null) {
            return null;
        }

        final int length = encoded.length();
        if (length % 2 != 0) {
            throw new IllegalArgumentException("Encoded string must be even length");
        }

        byte[] bytes = new byte[length / 2];
        for (int i = 0; i < length; i += 2) {
            int b = HEX_NUMBER_TABLE[encoded.charAt(i)] << 4;
            b |= HEX_NUMBER_TABLE[encoded.charAt(i + 1)];
            bytes[i / 2] = (byte) b;
        }
        return bytes;
    <|file_separator|><nl>
        if (builtinDataTypes == null) {
            builtinDataTypes = new HashSet<>();
            loadDataTypes(builtinDataTypes);
        }
        return builtinDataTypes.contains(dataType);
    <|file_separator|><nl>
        if (pattern.endsWith("*")) {
            return endsWithMatch(pattern, source);
        } else if (pattern.startsWith("*")) {
            return startsWithMatch(pattern, source);
        } else {
            return equals(pattern, source);
        }
    }

    private boolean endsWithMatch(String pattern, String source) {
        int patternLength = pattern.length();
        int sourceLength = source.length();
        if (patternLength > sourceLength) {
            return false;
        }
        int patternIndex = patternLength - 1;
        int sourceIndex = sourceLength - 1;
        while (patternIndex >= 0 && sourceIndex >= 0) {
            if (pattern.charAt(patternIndex) != source.charAt(sourceIndex)) {
                return false;
            }
            patternIndex--;
            sourceIndex--;
        }
        return true;
    }

    private boolean startsWithMatch(String pattern, String source) {
        int patternLength = pattern.length();
        int sourceLength = source.length();
        if (patternLength > sourceLength) {
            return false;
        }
        int patternIndex = 0;
        int sourceIndex = 0;
        while (patternIndex < patternLength && sourceIndex < sourceLength) {
            if (pattern.charAt(patternIndex) != source.charAt(sourceIndex)) {
                return false;
            }
            patternIndex++;
            sourceIndex++;
        }
        return true;
    }

    private boolean equals(String pattern, String source) {
        return pattern.equals(source);
    <|file_separator|><nl>
        if (reset) {
            invokeCount = 0;
        }
        return new WallFunctionStatValue(invokeCount);
    <|file_separator|><nl>
        return false;
    <|file_separator|><nl>
        return errorCode;
    <|file_separator|>class IllegalSQLObjectViolation.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class IllegalSQLObjectViolation implements Violation {
    private final String message;
    private final String sqlPart;
    private final int errorCode;

    public IllegalSQLObjectViolation(int errorCode, String message, String sqlPart) {
        this.errorCode = errorCode;
        this.message = message;
        this.sqlPart = sqlPart;
    }

    public String getSqlPart() {
        return sqlPart;
    }

    public String toString() {
        return this.sqlPart;
    }

    public String getMessage() {
        return message;
    }

    @Override
    public int getErrorCode() {
        return errorCode;
    }

}<|file_separator|>class IllegalSQLObjectViolationTest.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>import static org.junit.Assert.*;

import org.junit.Test;

public class IllegalSQLObjectViolationTest {

    @Test
    public void test() {
        IllegalSQLObjectViolation sql = new IllegalSQLObjectViolation(1, "test", "test");
        assertEquals("test", sql.getSqlPart());
        assertEquals("test", sql.toString());
        assertEquals("test", sql.getMessage());
        assertEquals(1, sql.getErrorCode());
    }

}<|file_separator|><nl>
        dataSource = createDataSourceFromResource(resource);
    <|file_separator|><nl>
        return QUERIES[index];
    <|file_separator|><nl>
        C3P0DataSource dataSource = new C3P0DataSource();
        dataSource.setDriverClass(driverClass);
        dataSource.setJdbcUrl(jdbcUrl);
        dataSource.setUser(user);
        dataSource.setPassword(password);
        dataSource.setMinPoolSize(minPoolSize);
        dataSource.setMaxPoolSize(maxPoolSize);
        dataSource.setAcquireIncrement(5);
        dataSource.setIdleConnectionTestPeriod(0L);
        dataSource.setMaxIdleTime(0L);

        for (int i = 0; i < loopCount; ++i) {
            p0(dataSource, "c3p0", threadCount);
        }
        System.out.println();
    }<|file_separator|><nl>
                    try {
                        startLatch.await();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    TestUtil.test(dataSource, LOOP_COUNT, blockedStat, waitedStat);
                    endLatch.countDown();
                <|file_separator|><nl>
    <|file_separator|><nl>
        return null;
    <|file_separator|><nl>
        $this->assertEquals(1, 1);
    <|file_separator|><nl>
        Thread.currentThread().setContextClassLoader(null);
        try {
            JdbcUtils.close(dataSource);
            fail("Expected NullPointerException");
        } catch (NullPointerException e) {
            // expected
        }
    <|file_separator|><nl>
        // ...
    <|file_separator|><nl>
        $this->assertTrue(true);
    <|file_separator|><nl>
        $this->assertEquals(1, 1);
    <|file_separator|><nl>
        $this->assertTrue(true);
    <|file_separator|><nl>
                return true;
            <|file_separator|><nl>
        $this->assertEquals(1, 1);
    <|file_separator|><nl>
        DruidDataSource dataSource = (DruidDataSource) JdbcUtils.getDataSource("jdbc:mock:xxx");
        DruidStatManager statManager = dataSource.getStatManager();
        DruidStat stat = statManager.getStat("test");
        assertEquals(0, stat.getStatCount());
    }

    public void test_query() throws Exception {
        DruidDataSource dataSource = (DruidDataSource) JdbcUtils.getDataSource("jdbc:mock:xxx");
        DruidStatManager statManager = dataSource.getStatManager();
        DruidStat stat = statManager.getStat("test");
        assertEquals(0, stat.getStatCount());
    }

    public void test_update() throws Exception {
        DruidDataSource dataSource = (DruidDataSource) JdbcUtils.getDataSource("jdbc:mock:xxx");
        DruidStatManager statManager = dataSource.getStatManager();
        DruidStat stat = statManager.getStat("test");
        assertEquals(0, stat.getStatCount());
    <|file_separator|><nl>
        DruidDataSource dataSource = new DruidDataSource();
        dataSource.setUrl("jdbc:mock:xxx");
        dataSource.setFilters("stat");
        dataSource.setTestOnBorrow(false);
        dataSource.setConnectionProperties("druid.stat.slowSqlMillis=1");
        dataSource.setDriver(new MockDriver());
        dataSource.init();

        DruidDataSource dataSource2 = new DruidDataSource();
        dataSource2.setUrl("jdbc:mock:xxx");
        dataSource2.setFilters("stat");
        dataSource2.setTestOnBorrow(false);
        dataSource2.setConnectionProperties("druid.stat.slowSqlMillis=1");
        dataSource2.setDriver(new MockDriver());
        dataSource2.init();

        DruidDataSource dataSource3 = new DruidDataSource();
        dataSource3.setUrl("jdbc:mock:xxx");
        dataSource3.setFilters("stat");
        dataSource3.setTestOnBorrow(false);
        dataSource3.setConnectionProperties("druid.stat.slowSqlMillis=1");
        dataSource3.setDriver(new MockDriver());
        dataSource3.init();

        DruidDataSource dataSource4 = new DruidDataSource();
        dataSource4.setUrl("jdbc:mock:xxx");
        dataSource4.setFilters("stat");
        dataSource4.setTestOnBorrow(false);
        dataSource4.setConnectionProperties("druid.stat.slowSqlMillis=1");
        dataSource4.setDriver(new MockDriver());
        dataSource4.init();

        DruidDataSource dataSource5 = new DruidDataSource();
        dataSource5.setUrl("jdbc:mock:xxx");
        dataSource5.setFilters("stat");
        dataSource5.setTestOnBorrow(false);
        dataSource5.setConnectionProperties("druid.stat.slowSqlMillis=1");
        dataSource5.set<nl>
        ConfigFilter configFilter = new ConfigFilter();
        configFilter.loadClassPath("classpath:test.properties");
        assertEquals("classpath:test.properties", configFilter.getClassPath());
    <|file_separator|><nl>
        WallConfig config = new WallConfig();
        config.setConditionOpBitwseAllow(true);
        Assert.assertTrue(WallUtils.isValidateMySql(//
                "SELECT * from t where (id = 1) & 2", config)); //
    <|file_separator|><nl>
                return null;
            <|file_separator|><nl>
        WallConfig config = new WallConfig();
        config.setMinusAllow(true);
        Assert.assertTrue(WallUtils.isValidateOracle(//
                "SELECT * FROM A MINUS SELECT * FROM B", config)); //
    <|file_separator|><nl>
        return null;
    <|file_separator|><nl>
        Assert.assertFalse(WallUtils.isValidateMySql(//
                "select * from t where 1=1 AND status = 1")); //
    <|file_separator|><nl>
        WallProvider.setTenantValue(123);
        MySqlWallProvider provider = new MySqlWallProvider(config);
        config.setSelectWhereAlwayTrueCheck(false);
        WallCheckResult checkResult = provider.check(sql);
        Assert.assertEquals(0, checkResult.getViolations().size());
        String resultSql = SQLUtils.toSQLString(checkResult.getStatementList(), JdbcConstants.MYSQL);
        Assert.assertEquals(expect_sql, resultSql);

        provider.reset();
        config.setSelectWhereAlwayTrueCheck(true);
        checkResult = provider.check(sql);
        Assert.assertEquals(1, checkResult.getViolations().size());
    }

    public void testOracle() throws Exception {
        WallProvider.setTenantValue(123);
        OracleWallProvider provider = new OracleWallProvider(config);
        config.setSelectWhereAlwayTrueCheck(false);
        WallCheckResult checkResult = provider.check(sql);
        Assert.assertEquals(0, checkResult.getViolations().size());
        String resultSql = SQLUtils.toSQLString(checkResult.getStatementList(), JdbcConstants.ORACLE);
        Assert.assertEquals(expect_sql, resultSql);

        provider.reset();
        config.setSelectWhereAlwayTrueCheck(true);
        checkResult = provider.check(sql);
        Assert.assertEquals(1, checkResult.getViolations().size());
    }

    public void testOracle2() throws Exception {
        WallProvider.setTenantValue(123);
        OracleWallProvider provider = new OracleWallProvider(config);
        config.setSelectWhereAlwayTrueCheck(false);
        WallCheckResult checkResult = provider.check(sql);
<nl>
        WallProvider.setTenantValue(123);
        MySqlWallProvider provider = new MySqlWallProvider(config_callback);
        WallCheckResult checkResult = provider.check(sql);
        Assert.assertEquals(0, checkResult.getViolations().size());

        String resultSql = SQLUtils.toSQLString(checkResult.getStatementList(), JdbcConstants.MYSQL);
        Assert.assertEquals(expect_sql, resultSql);
    }

    public void testOracle() throws Exception {
        WallProvider.setTenantValue(123);
        OracleWallProvider provider = new OracleWallProvider(config);
        WallCheckResult checkResult = provider.check(sql);
        Assert.assertEquals(0, checkResult.getViolations().size());

        String resultSql = SQLUtils.toSQLString(checkResult.getStatementList(), JdbcConstants.ORACLE);
        Assert.assertEquals(expect_sql, resultSql);
    }

    public void testOracle2() throws Exception {
        WallProvider.setTenantValue(123);
        OracleWallProvider provider = new OracleWallProvider(config_callback);
        WallCheckResult checkResult = provider.check(sql);
        Assert.assertEquals(0, checkResult.getViolations().size());

        String resultSql = SQLUtils.toSQLString(checkResult.getStatementList(), JdbcConstants.ORACLE);
        Assert.assertEquals(expect_sql, resultSql);
    }

    public void testSqlServer() throws Exception {
        WallProvider.setTenantValue(123);
        SqlServerWallProvider provider = new SqlServerWallProvider(config);
        WallCheckResult checkResult = provider.check(sql);
        Assert.assertEquals(0, checkResult.getViolations().size());

        String resultSql = SQL<nl>
        Assert.assertFalse(WallUtils.isValidateMySql(sql, config));
    <|file_separator|><nl>
        Assert.assertTrue(WallUtils.isValidateOracle(sql, config));
    <|file_separator|><nl>
        WallConfig config = new WallConfig();
        config.setSelectHavingAlwayTrueCheck(false);
        config.setConditionAndAlwayTrueAllow(false);
        config.setCommentAllow(false);

        Assert.assertTrue(WallUtils.isValidateMySql(sql, config));
        Assert.assertTrue(WallUtils.isValidateMySql(sql1, config));
    <|file_separator|><nl>
        Assert.assertTrue(WallUtils.isValidateOracle(sql));
    <|file_separator|><nl>
        WallProvider provider = new SQLServerWallProvider();
        Assert.assertTrue(provider.checkValid(sql));
        WallTableStat tableStat = provider.getTableStat("t");
        Assert.assertEquals(1, tableStat.getInsertCount());
    <|file_separator|><nl>
        WallProvider provider = new OracleWallProvider();
        Assert.assertTrue(provider.checkValid(sql));
        WallTableStat tableStat = provider.getTableStat("t");
        Assert.assertEquals(1, tableStat.getSelectCount());
    <|file_separator|><nl>
        $this->assertFalse(true);
    <|file_separator|><nl>
        $this->assertFalse(true);
    <|file_separator|><nl>
        $this->assertFalse(true);
    <|file_separator|><nl>
        $this->assertFalse(false);
    <|file_separator|><nl>
        $this->assertFalse(true);
    <|file_separator|><nl>
        $this->assertFalse(true);
    <|file_separator|><nl>
        $this->assertEquals(1, 1);
    <|file_separator|><nl>
        Assert.assertFalse(WallUtils.isValidateMySql(//
                "select * from t where FID = 1 OR NOT(UNHEX(HEX(FNAME)) = FNAME)")); //
    <|file_separator|><nl>
        WallProvider provider = new MySqlWallProvider();

        Assert.assertFalse(provider.checkValid(//
                "SELECT COUNT(1) AS count FROM `team` " + //
                        "WHERE `team_type` = 'normal' AND 1 = 1 AND `city_id` IN (0,10)"));

        Assert.assertEquals(1, provider.getTableStats().size());
    <|file_separator|><nl>
        WallProvider provider = new MySqlWallProvider();

        Assert.assertTrue(provider.checkValid(//
                "select * from t"));

        Assert.assertEquals(1, provider.getTableStats().size());
    <|file_separator|><nl>
        assertTrue(true);
    <|file_separator|><nl>
        assertTrue(true);
    <|file_separator|><nl>
        assertTrue(true);
    <|file_separator|><nl>
        $this->assertFalse(true);
    <|file_separator|><nl>
        $this->assertFalse(false);
    <|file_separator|><nl>
        $this->assertFalse(true);
    <|file_separator|><nl>
        Assert.assertFalse(WallUtils.isValidateOracle(sql, config));
    <|file_separator|><nl>
        Assert.assertTrue(WallUtils.isValidateOracle("select * from TAB join TAB on TAB.COL = TAB.COL"));
        Assert.assertTrue(WallUtils.isValidateOracle("select * from TAB join TAB on TAB.COL = TAB.COL"));
        Assert.assertTrue(WallUtils.isValidateOracle("select * from TAB join TAB on TAB.COL = TAB.COL"));
        Assert.assertTrue(WallUtils.isValidateOracle("select * from TAB join TAB on TAB.COL = TAB.COL"));
    <|file_separator|><nl>
        assertTrue(true);
    <|file_separator|><nl>
        assertEquals(1, 1);
    <|file_separator|><nl>
        Assert.assertFalse(WallUtils.isValidateSqlServer("SELECT id from T where 1=1 and 1!=1 union select system_user;"));
    <|file_separator|><nl>
        // TODO: test stuff
    <|file_separator|><nl>
        assertTrue(true);
    <|file_separator|><nl>
        DruidDataSource dataSource = new DruidDataSource();
        dataSource.setUrl("jdbc:mock:xxx");
        dataSource.setMinEvictableIdleTimeMillis(10);
        dataSource.setTimeBetweenEvictionRunsMillis(10);
    <|file_separator|><nl>
        JMXExporter exporter = new JMXExporter();
        exporter.export();
    <|file_separator|><nl>
        DruidDataSourceFactory druidDataSourceFactory = new DruidDataSourceFactory();
        druidDataSourceFactory.setDriverClassName("com.mysql.jdbc.Driver");
        druidDataSourceFactory.setUrl("jdbc:mysql://localhost:3306/test");
        druidDataSourceFactory.setUsername("root");
        druidDataSourceFactory.setPassword("root");
        dataSource = druidDataSourceFactory.getDataSource();
        assertNotNull(dataSource);
    <|file_separator|><nl>
        dataSource = new DruidDataSource();
    <|file_separator|><nl>
                return stmt.executeQuery(sql);
            <|file_separator|><nl>
                try {
                    dataSource.getConnection().commit();
                } catch (Exception e) {
                    errorCount.incrementAndGet();
                } finally {
                    endLatch.countDown();
                }
            <|file_separator|><nl>
        dataSource = new DruidDataSource();
    <|file_separator|><nl>
        dataSource.setTestOnBorrow(true);
        dataSource.setTestOnReturn(true);
        dataSource.setTestWhileIdle(true);
        dataSource.setValidationQuery("select 1");
        dataSource.setValidationInterval(1000);
        dataSource.setTestOnBorrow(true);
        dataSource.setTestOnReturn(true);
        dataSource.setTestWhileIdle(true);
        dataSource.setValidationQuery("select 1");
        dataSource.setValidationInterval(1000);
        dataSource.setTestOnBorrow(true);
        dataSource.setTestOnReturn(true);
        dataSource.setTestWhileIdle(true);
        dataSource.setValidationQuery("select 1");
        dataSource.setValidationInterval(1000);
        dataSource.setTestOnBorrow(true);
        dataSource.setTestOnReturn(true);
        dataSource.setTestWhileIdle(true);
        dataSource.setValidationQuery("select 1");
        dataSource.setValidationInterval(1000);
        dataSource.setTestOnBorrow(true);
        dataSource.setTestOnReturn(true);
        dataSource.setTestWhileIdle(true);
        dataSource.setValidationQuery("select 1");
        dataSource.setValidationInterval(1000);
        dataSource.setTestOnBorrow(true);
        dataSource.setTestOnReturn(true);
        dataSource.setTestWhileIdle(true);
        dataSource.setValidationQuery("select 1");
        dataSource.setValidationInterval(1000);
        dataSource.setTestOnBorrow(true);
        dataSource.setTestOnReturn(true);
        dataSource.setTestWhileIdle(true);
        dataSource.setValidationQuery("select 1");
        dataSource.setValidationInterval<nl>
        dataSource = new DruidDataSource();
    <|file_separator|><nl>
        Connection conn = dataSource.getConnection();
        conn.setAutoCommit(false);

        conn.close();
        conn.rollback();
        conn.rollback(null);
    <|file_separator|><nl>
        DruidDataSource dataSource = new DruidDataSource();
        dataSource.setUrl("jdbc:mock:xxx");
        dataSource.setTestOnBorrow(false);

        dataSource.init();
        dataSource.close();
    <|file_separator|><nl>
        super.setUp();
        dataSource = new DruidDataSource();
        dataSource.setDriverClassName("com.mysql.jdbc.Driver");
        dataSource.setUrl("jdbc:mysql://127.0.0.1:3306/test");
        dataSource.setUsername("root");
        dataSource.setPassword("root");
        dataSource.setTestWhileIdle(true);
        dataSource.setTestOnBorrow(true);
        dataSource.setTestOnReturn(true);
        dataSource.setValidationQuery("select 1");
        dataSource.setValidationInterval(1000 * 10);
        dataSource.setTimeBetweenEvictionRunsMillis(1000 * 10);
        dataSource.setMaxActive(100);
        dataSource.setMaxIdle(10);
        dataSource.setMinIdle(10);
        dataSource.setPoolPreparedStatements(true);
        dataSource.setMaxOpenPreparedStatements(100);
        dataSource.setRemoveAbandonedTimeout(1000 * 10);
        dataSource.setRemoveAbandoned(true);
        dataSource.setLogAbandoned(true);
        dataSource.setFilters("stat");
        dataSource.setConnectionProperties("druid.stat.mergeSql=true;druid.stat.slowSqlMillis=1000");
        dataSource.setPoolPreparedStatementPerConnectionSize(10);
        dataSource.setSharePreparedStatements(true);
        dataSource.setTestWhileIdle(true);
        dataSource.setTestOnBorrow(true);
        dataSource.setTestOnReturn(true);
        dataSource.setValidationQuery("select 1");
        dataSource.setValidationInterval(1000 * 10);
        dataSource.setTimeBetweenEvictionRunsMillis(1000 * 10);
        dataSource.set<nl>
        ManagedDataSource managedDataSource = new ManagedDataSource(dataSource);
        Assert.assertEquals(dataSource, managedDataSource.getDataSource());
    <|file_separator|><nl>
        DruidDataSourceStatManager.clear();
    <|file_separator|><nl>
        PreparedStatementProxyImpl proxy = new PreparedStatementProxyImpl(dataSource.getConnection().prepareStatement("select * from t where id = ?"));
        proxy.setObject(1, 1);
        proxy.setObject(2, "a");
        proxy.setObject(3, "b");
        proxy.setObject(4, "c");
        proxy.setObject(5, "d");
        proxy.setObject(6, "e");
        proxy.setObject(7, "f");
        proxy.setObject(8, "g");
        proxy.setObject(9, "h");
        proxy.setObject(10, "i");
        proxy.setObject(11, "j");
        proxy.setObject(12, "k");
        proxy.setObject(13, "l");
        proxy.setObject(14, "m");
        proxy.setObject(15, "n");
        proxy.setObject(16, "o");
        proxy.setObject(17, "p");
        proxy.setObject(18, "q");
        proxy.setObject(19, "r");
        proxy.setObject(20, "s");
        proxy.setObject(21, "t");
        proxy.setObject(22, "u");
        proxy.setObject(23, "v");
        proxy.setObject(24, "w");
        proxy.setObject(25, "x");
        proxy.setObject(26, "y");
        proxy.setObject(27, "z");
        proxy.setObject(28, "aa");
        proxy.setObject(29, "bb");
        proxy.setObject(30, "cc");
        proxy.setObject(31, "dd");
        proxy.setObject(32<nl>
        DruidDataSource dataSource = new DruidDataSource();
        dataSource.setOracle(true);
        dataSource.setUrl("jdbc:mock:xxx");
        dataSource.setDriver(new OracleMockDriver());
        dataSource.setPoolPreparedStatements(true);
        dataSource.setConnectionProperties("defaultRowPrefetch=50");
        dataSource.setDbType("oracle");
        // dataSource.setFilters("log4j");
        dataSource.setDataSource(dataSource);
        dataSource.setPoolPreparedStatements(true);
        dataSource.setConnectionProperties("defaultRowPrefetch=50");
        dataSource.setDbType("oracle");
        // dataSource.setFilters("log4j");
        dataSource.setDataSource(dataSource);
        dataSource.setPoolPreparedStatements(true);
        dataSource.setConnectionProperties("defaultRowPrefetch=50");
        dataSource.setDbType("oracle");
        // dataSource.setFilters("log4j");
        dataSource.setDataSource(dataSource);
        dataSource.setPoolPreparedStatements(true);
        dataSource.setConnectionProperties("defaultRowPrefetch=50");
        dataSource.setDbType("oracle");
        // dataSource.setFilters("log4j");
        dataSource.setDataSource(dataSource);
        dataSource.setPoolPreparedStatements(true);
        dataSource.setConnectionProperties("defaultRowPrefetch=50");
        dataSource.setDbType("oracle");
        // dataSource.setFilters("log4j");
        dataSource.setDataSource(dataSource);
        dataSource.setPoolPreparedStatements(true);
        dataSource.setConnectionProperties("defaultRowPrefetch=50");
        dataSource.setDbType("oracle");
        // dataSource.setFilters("log4j");
        dataSource.setDataSource(dataSource);
        dataSource.setPoolPreparedStatements(true);
        dataSource.<nl>
        DruidDataSource dataSource = new DruidDataSource();
        dataSource.setOracle(true);
        dataSource.setUrl("jdbc:mock:xxx");
        dataSource.setDriver(new OracleMockDriverJdbc3());
        dataSource.setPoolPreparedStatements(true);
        dataSource.setConnectionProperties("defaultRowPrefetch=50");
        dataSource.setDbType("oracle");
        // dataSource.setFilters("log4j");
        dataSource.setConnectionProperties("defaultRowPrefetch=50");
        dataSource.setDbType("oracle");
        dataSource.setFilters("log4j");
        dataSource.setConnectionProperties("defaultRowPrefetch=50");
        dataSource.setDbType("oracle");
        dataSource.setFilters("log4j");
        dataSource.setConnectionProperties("defaultRowPrefetch=50");
        dataSource.setDbType("oracle");
        dataSource.setFilters("log4j");
        dataSource.setConnectionProperties("defaultRowPrefetch=50");
        dataSource.setDbType("oracle");
        dataSource.setFilters("log4j");
        dataSource.setConnectionProperties("defaultRowPrefetch=50");
        dataSource.setDbType("oracle");
        dataSource.setFilters("log4j");
        dataSource.setConnectionProperties("defaultRowPrefetch=50");
        dataSource.setDbType("oracle");
        dataSource.setFilters("log4j");
        dataSource.setConnectionProperties("defaultRowPrefetch=50");
        dataSource.setDbType("oracle");
        dataSource.setFilters("log4j");
        dataSource.setConnectionProperties("defaultRowPrefetch=50");
        dataSource.setDbType("oracle");
        dataSource.setFilters("log4j");
        dataSource.setConnectionProperties("defaultRowPrefetch=50");
        dataSource<nl>
        DruidDataSourceStatManager.getInstance().getDataSourceList().size();
    }
<|file_separator|><nl>
        DruidDataSourceStatManager.getInstance().getDataSourceList().add(dataSource);
        Assert.assertEquals(1, JdbcStatManager.getInstance().getSqlList().size());
    <|file_separator|><nl>
                try {
                    latch_0.await();
                    Connection conn = dataSource.getConnection();
                    conn.close();
                } catch (Exception ex) {
                    ex.printStackTrace();
                }
            <|file_separator|><nl>
        DruidDataSourceStatManager.getInstance().getDataSourceList().add(dataSource);
        Assert.assertEquals(1, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
        Assert.assertEquals(1, JdbcStatManager.getInstance().getSqlList().size());
    }

    public void test_query() throws Exception {
        DruidDataSourceStatManager.getInstance().getDataSourceList().add(dataSource);
        Assert.assertEquals(1, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
        Assert.assertEquals(1, JdbcStatManager.getInstance().getSqlList().size());
    <|file_separator|><nl>
        DruidDataSourceStatManager.getInstance().getDataSourceList().add(dataSource);
        Assert.assertEquals(1, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
        Assert.assertEquals(1, JdbcStatManager.getInstance().getSqlList().size());
    }

    public void test_connect_2() throws Exception {
        DruidDataSourceStatManager.getInstance().getDataSourceList().add(dataSource);
        Assert.assertEquals(1, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
        Assert.assertEquals(1, JdbcStatManager.getInstance().getSqlList().size());
    }

    public void test_connect_3() throws Exception {
        DruidDataSourceStatManager.getInstance().getDataSourceList().add(dataSource);
        Assert.assertEquals(1, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
        Assert.assertEquals(1, JdbcStatManager.getInstance().getSqlList().size());
    }

    public void test_connect_4() throws Exception {
        DruidDataSourceStatManager.getInstance().getDataSourceList().add(dataSource);
        Assert.assertEquals(1, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
        Assert.assertEquals(1, JdbcStatManager.getInstance().getSqlList().size());
    }

    public void test_connect_5() throws Exception {
        DruidDataSourceStatManager.getInstance().getDataSourceList().add(dataSource);
        Assert.assertEquals(1, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
        Assert.assertEquals(1, JdbcStatManager.getInstance().getSqlList().size());
    }

    public void test_connect_6() throws Exception {
        DruidDataSourceStatManager.getInstance().getDataSourceList().add(dataSource);
        Assert.assertEquals(1, DruidDataSourceStatManager.<nl>
        DruidDataSourceStatManager.getInstance().getDataSourceList().add(dataSource);
        Assert.assertEquals(1, JdbcStatManager.getInstance().getSqlList().size());
    <|file_separator|><nl>
        DruidDataSourceStatManager.getInstance().getDataSourceList().add(dataSource);
        Assert.assertEquals(1, DruidDataSourceStatManager.getInstance().getDataSourceList().size());
        Assert.assertEquals(1, JdbcStatManager.getInstance().getSqlList().size());
    <|file_separator|><nl>
        dataSource = new DruidDataSource();
        dataSource.setValidationQuery("select 1");
        dataSource.setJdbcUrl("jdbc:mysql://localhost:3306/test");
        dataSource.setUsername("root");
        dataSource.setPassword("root");
        dataSource.setDriverClassName("com.mysql.jdbc.Driver");
        dataSource.setTestWhileIdle(true);
        dataSource.setTestOnBorrow(true);
        dataSource.setTestOnReturn(true);
        dataSource.setValidationQueryTimeout(10);
        dataSource.setValidationInterval(10);
        dataSource.setValidationQueryTimeout(10);
        dataSource.setValidationQueryTimeout(10);
        dataSource.setValidationQueryTimeout(10);
        dataSource.setValidationQueryTimeout(10);
        dataSource.setValidationQueryTimeout(10);
        dataSource.setValidationQueryTimeout(10);
        dataSource.setValidationQueryTimeout(10);
        dataSource.setValidationQueryTimeout(10);
        dataSource.setValidationQueryTimeout(10);
        dataSource.setValidationQueryTimeout(10);
        dataSource.setValidationQueryTimeout(10);
        dataSource.setValidationQueryTimeout(10);
        dataSource.setValidationQueryTimeout(10);
        dataSource.setValidationQueryTimeout(10);
        dataSource.setValidationQueryTimeout(10);
        dataSource.setValidationQueryTimeout(10);
        dataSource.setValidationQueryTimeout(10);
        dataSource.setValidationQueryTimeout(10);
        dataSource.setValidationQueryTimeout(10);
        dataSource.setValidationQueryTimeout(10);
        dataSource.setValidationQueryTimeout(10);
        dataSource.setValidationQueryTimeout(10);
        dataSource.setValidationQuery<nl>
        MSSQLValidConnectionChecker checker = new MSSQLValidConnectionChecker();

        MockConnection conn = new MockConnection();
        conn.setException(new SQLException("error"));

        Assert.assertFalse(checker.isValidConnection(conn, "select 1", 10));
    }

    public void test_timeout() throws Exception {
        MSSQLValidConnectionChecker checker = new MSSQLValidConnectionChecker();

        MockConnection conn = new MockConnection();
        conn.setException(new SQLException("timeout"));

        Assert.assertFalse(checker.isValidConnection(conn, "select 1", 10));
    <|file_separator|><nl>
        ConnectionStatistic connectionStatistic = new ConnectionStatistic();
        connectionStatistic.addConnection();
        assertEquals(1, connectionStatistic.getConnections());
    <|file_separator|><nl>
        super.setUp();
        dataSource = new DruidDataSource();
        dataSource.setDriverClassName("com.mysql.jdbc.Driver");
        dataSource.setUrl("jdbc:mysql://127.0.0.1:3306/test");
        dataSource.setUsername("root");
        dataSource.setPassword("root");
    <|file_separator|><nl>
        SpringStat springStat = new SpringStat();

        SpringMethodInfo a1 = new SpringMethodInfo(A.class, A.class.getMethod("f", int.class));
        SpringMethodInfo a2 = new SpringMethodInfo(A.class, A.class.getMethod("f", int.class));

        SpringMethodStat methodStat1 = springStat.getMethodStat(a1, true);
        SpringMethodStat methodStat2 = springStat.getMethodStat(a2, true);
        Assert.assertSame(methodStat1, methodStat2);
    <|file_separator|><nl>
        assertEquals(1, 1);
    <|file_separator|><nl>
        Assert.assertEquals("SELECT count(DISTINCT *)nFROM t", SQLUtils.format(sql, JdbcUtils.ORACLE_UNIQUE));
    <|file_separator|><nl>
        $this->assertFileExists('C:\Users\user\Desktop\test.txt');
    <|file_separator|><nl>
        assertEquals(1, 1);
    <|file_separator|><nl>
        List<String> list = Arrays.asList("a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z");
        List<String> result = GroupingSets.groupingSets(list, 3);
        assertEquals(Arrays.asList(Arrays.asList("a", "b", "c"), Arrays.asList("d", "e", "f"), Arrays.asList("g", "h", "i"), Arrays.asList("j", "k", "l"), Arrays.asList("m", "n", "o"), Arrays.asList("p", "q", "r"), Arrays.asList("s", "t", "u"), Arrays.asList("v", "w", "x"), Arrays.asList("y", "z")));
    <|file_separator|><nl>
        String result = SQLUtils.refactor(sql, JdbcConstants.SQLSERVER, mapping);
        assertEquals("ALTER TABLE user_01n" +
                "tDROP INDEX pk_user;", result);
    <|file_separator|><nl>
        String sql = "select * from (select * from t1 where id = 1) t1 union select * from (select * from t1 where id = 2) t2";
        String sql2 = "select * from (select * from t1 where id = 1) t1 union all select * from (select * from t1 where id = 2) t2";
        String sql3 = "select * from (select * from t1 where id = 1) t1 union all select * from (select * from t1 where id = 2) t2";
        String sql4 = "select * from (select * from t1 where id = 1) t1 union all select * from (select * from t1 where id = 2) t2";
        String sql5 = "select * from (select * from t1 where id = 1) t1 union all select * from (select * from t1 where id = 2) t2";
        String sql6 = "select * from (select * from t1 where id = 1) t1 union all select * from (select * from t1 where id = 2) t2";
        String sql7 = "select * from (select * from t1 where id = 1) t1 union all select * from (select * from t1 where id = 2) t2";
        String sql8 = "select * from (select * from t1 where id = 1) t1 union all select * from (select * from t1 where id = 2) t2";
        String sql9 = "select * from (select * from t1 where id = 1) t1 union all select * from (select * from t1 where id = 2) t2";
        String sql10<nl>
        String sql = "select * from (select * from t1 where id = 1) t1 union select * from (select * from t1 where id = 1) t1";
        String sql2 = "select * from (select * from t1 where id = 1) t1 union select * from (select * from t1 where id = 1) t1";
        String sql3 = "select * from (select * from t1 where id = 1) t1 union select * from (select * from t1 where id = 1) t1";
        String sql4 = "select * from (select * from t1 where id = 1) t1 union select * from (select * from t1 where id = 1) t1";
        String sql5 = "select * from (select * from t1 where id = 1) t1 union select * from (select * from t1 where id = 1) t1";
        String sql6 = "select * from (select * from t1 where id = 1) t1 union select * from (select * from t1 where id = 1) t1";
        String sql7 = "select * from (select * from t1 where id = 1) t1 union select * from (select * from t1 where id = 1) t1";
        String sql8 = "select * from (select * from t1 where id = 1) t1 union select * from (select * from t1 where id = 1) t1";
        String sql9 = "select * from (select * from t1 where id = 1) t1 union select * from (select * from t1 where id = 1) t1";
        String sql10 = "select * from (select *<nl>
        assertEquals("t_like_count", visitor.unwrapShardingTable("t_like_count0057"));
    <|file_separator|><nl>
        String sql = "SELECT a from b where c <> 1 LIMIT 18446744073709551615 OFFSET 0";
        PostgreSQLStatementParser parser = new PostgreSQLStatementParser(sql);
        SQLStatement sqlStatement = parser.parseStatement();
        StringBuilder sb = new StringBuilder();
        PostgreSQLOutputVisitor visitor = new PostgreSQLOutputVisitor(sb);
        visitor.setPrettyFormat(false);
        sqlStatement.accept(visitor);
        assertEquals("SELECT a FROM b WHERE c <> 1 LIMIT 18446744073709551615 OFFSET 0", sb.toString());
    <|file_separator|><nl>
        String sql = "SELECT /*+ NO_INDEX(t) */ col1 FROM table1,table2";
        MySqlStatementParser parser = new MySqlStatementParser(sql);
        SQLStatement stmt = parser.parseStatementList().get(0);
        parser.match(Token.EOF);
        String output = SQLUtils.toMySqlString(stmt);
        Assert.assertEquals("SELECT col1nFROM table1, table2", output);
    }

    public void test_hints_2() throws Exception {
        String sql = "SELECT /*+ NO_INDEX(t) */ col1 FROM table1,table2";
        MySqlStatementParser parser = new MySqlStatementParser(sql);
        SQLStatement stmt = parser.parseStatementList().get(0);
        parser.match(Token.EOF);
        String output = SQLUtils.toMySqlString(stmt);
        Assert.assertEquals("SELECT col1nFROM table1, table2", output);
    }

    public void test_hints_3() throws Exception {
        String sql = "SELECT /*+ NO_INDEX(t) */ col1 FROM table1,table2";
        MySqlStatementParser parser = new MySqlStatementParser(sql);
        SQLStatement stmt = parser.parseStatementList().get(0);
        parser.match(Token.EOF);
        String output = SQLUtils.toMySqlString(stmt);
        Assert.assertEquals("SELECT col1nFROM table1, table2", output);
    }

    public void test_hints_4() throws Exception {
        String sql = "SELECT /*+ NO_INDEX(t) */ col1 FROM table1,table2";
        MySqlStatementParser parser = new MySqlStatementParser(sql);
        SQLStatement stmt = parser.parseStatementList().get(0);
        parser<nl>
        // TODO: Implement this test
    <|file_separator|><nl>
        String sql = "CREATE TABLE test_04 (id INT NOT NULL PRIMARY KEY, name VARCHAR(20))";
        this.execute(sql);
    <|file_separator|><nl>
        DB2SelectTest_30.test_0();
    <|file_separator|>class DB2SelectTest_20 extends DB2Test {
    public void test_0() throws Exception {
        DB2SelectTest_20.test_0();
    }
}<|file_separator|>class DB2SelectTest_10 extends DB2Test {
    public void test_0() throws Exception {
        DB2SelectTest_10.test_0();
    }
}<|file_separator|>class DB2SelectTest_15 extends DB2Test {
    public void test_0() throws Exception {
        DB2SelectTest_15.test_0();
    }
}<|file_separator|>class DB2SelectTest_25 extends DB2Test {
    public void test_0() throws Exception {
        DB2SelectTest_25.test_0();
    }
}<|file_separator|>class DB2SelectTest_12 extends DB2Test {
    public void test_0() throws Exception {
        DB2SelectTest_12.test_0();
    }
}<|file_separator|>class DB2SelectTest_18 extends DB2Test {
    public void test_0() throws Exception {
        DB2SelectTest_18.test_0();
    }
}<|file_separator|>class DB2SelectTest_11 extends DB2Test {
    public void test_0() throws Exception {
        DB2SelectTest_11.test_0();
    }
}<|file_separator|>class DB2SelectTest_21 extends DB2Test {
    public void test_0() throws Exception {
        DB2SelectTest_21.test_0();
    }
}<|file_separator|>class DB2SelectTest_14 extends DB2Test {
    public void test_0() throws Exception {
        DB2SelectTest_<nl>
        DB2SelectTest.test_0();
    <|file_separator|>class DB2SelectTest_10.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class DB2SelectTest_10 extends DB2Test {
    public void test_0() throws Exception {
        DB2SelectTest.test_0();
    }
}<|file_separator|>class DB2SelectTest_11.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class DB2SelectTest_11 extends DB2Test {
    public void test_0() throws Exception {
        DB2SelectTest.test_0();
    }
}<|file_separator|>class DB2SelectTest_12.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class DB2SelectTest_12 extends DB2Test {
    public void test_0() throws Exception {
        DB2SelectTest.test_0();
    }
}<|file_separator|>class DB2SelectTest_13.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class DB2SelectTest_13 extends DB2Test {
    public void test_0() throws Exception {
        DB2SelectTest.test_0();
    }
}<|file_separator|>class DB2SelectTest_14.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class DB2SelectTest_14 extends DB2Test {
    public void test_0() throws Exception {
        DB2SelectTest.test_0();
    }
}<|file_separator|>class DB2SelectTest_15.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class DB2SelectTest_15 extends DB2Test {
    public void test_0() throws Exception {
        DB2SelectTest.test_0();
    }
}<|file_separator|>class DB2SelectTest_16.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class DB2SelectTest_16 extends DB2Test {
    public void test_0() throws Exception {
        DB2SelectTest.test_0();<nl>
        DB2SelectTest_9.test_0();
    <|file_separator|>class DB2SelectTest_10 extends DB2Test {
    public void test_0() throws Exception {
        DB2SelectTest_10.test_0();
    }
}<|file_separator|>class DB2SelectTest_11 extends DB2Test {
    public void test_0() throws Exception {
        DB2SelectTest_11.test_0();
    }
}<|file_separator|>class DB2SelectTest_12 extends DB2Test {
    public void test_0() throws Exception {
        DB2SelectTest_12.test_0();
    }
}<|file_separator|>class DB2SelectTest_13 extends DB2Test {
    public void test_0() throws Exception {
        DB2SelectTest_13.test_0();
    }
}<|file_separator|>class DB2SelectTest_15 extends DB2Test {
    public void test_0() throws Exception {
        DB2SelectTest_15.test_0();
    }
}<|file_separator|>class DB2SelectTest_14 extends DB2Test {
    public void test_0() throws Exception {
        DB2SelectTest_14.test_0();
    }
}<|file_separator|>class DB2SelectTest_16 extends DB2Test {
    public void test_0() throws Exception {
        DB2SelectTest_16.test_0();
    }
}<|file_separator|>class DB2SelectTest_17 extends DB2Test {
    public void test_0() throws Exception {
        DB2SelectTest_17.test_0();
    }
}<|file_separator|>class DB2SelectTest_18 extends DB2Test {
    public void test_0() throws Exception {
        DB2SelectTest_1<nl>
        Assert.assertEquals(1.0, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "acos(1.0)", 12L));
    <|file_separator|><nl>
        assertEquals(1, "a".length());
    <|file_separator|><nl>
        assertEquals(1, 1);
    <|file_separator|><nl>
        Assert.assertEquals(false, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "? > ?", (short) 1, (byte) 2));
    <|file_separator|><nl>
        Assert.assertEquals(true, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "?>?", new Date(), (byte) 2));
    }

    public void test_Timestamp() throws Exception {
        Assert.assertEquals(true, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "?>?", new Timestamp(1000), (byte) 2));
    }

    public void test_Boolean() throws Exception {
        Assert.assertEquals(true, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "?>?", true, (byte) 2));
    }

    public void test_Null() throws Exception {
        Assert.assertEquals(true, SQLEvalVisitorUtils.evalExpr(JdbcConstants.MYSQL, "?>?", null, (byte) 2));
    <|file_separator|><nl>
        // TODO: Implement test
    <|file_separator|><nl>
        String sql = "CREATE TABLE test_27 (id NUMBER)";
        this.execute(sql);
    <|file_separator|><nl>
        String sql = "CREATE TABLE test (id INT)";
        this.execute(sql);
    <|file_separator|><nl>
        String sql = "CREATE TABLE test (id INT)";
        this.execute(sql);
    <|file_separator|><nl>
        String sql = new String(Files.readAllBytes(Paths.get(resource)));
        HiveResource hive = new HiveResource();
        hive.setDriver("org.apache.hive.jdbc.HiveDriver");
        hive.setJdbcUrl("jdbc:hive2://localhost:10000/default");
        hive.setUserName("root");
        hive.setPassword("");
        hive.setConnectTimeout(10000);
        hive.setReadTimeout(10000);
        hive.setConnectionTimeout(10000);
        hive.setDriver("org.apache.hive.jdbc.HiveDriver");
        hive.setJdbcUrl("jdbc:hive2://localhost:10000/default");
        hive.setUserName("root");
        hive.setPassword("");
        hive.setConnectTimeout(10000);
        hive.setReadTimeout(10000);
        hive.setConnectionTimeout(10000);
        hive.setDriver("org.apache.hive.jdbc.HiveDriver");
        hive.setJdbcUrl("jdbc:hive2://localhost:10000/default");
        hive.setUserName("root");
        hive.setPassword("");
        hive.setConnectTimeout(10000);
        hive.setReadTimeout(10000);
        hive.setConnectionTimeout(10000);
        hive.setDriver("org.apache.hive.jdbc.HiveDriver");
        hive.setJdbcUrl("jdbc:hive2://localhost:10000/default");
        hive.setUserName("root");
        hive.setPassword("");
        hive.setConnectTimeout(10000);
        hive.setReadTimeout<nl>
        String sql = "SELECT @var1:=COUNT(*) FROM t1;";

        SQLStatementParser parser = new MySqlStatementParser(sql);
        List<SQLStatement> stmtList = parser.parseStatementList();

        String text = output(stmtList);

        Assert.assertEquals("SELECT @var1 := COUNT(*)nFROM t1;", text);
    <|file_separator|><nl>
        assertEquals(true, true);
    <|file_separator|><nl>
        this.delete();
    <|file_separator|>class MySqlDeleteTest_1.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class MySqlDeleteTest_1 extends MysqlTest {
    public void test_0() throws Exception {
        this.delete();
    }
}<|file_separator|><nl>
        System.out.println("Hello World!");
    <|file_separator|><nl>
        String sql = "SELECT ExtractValue('<a><b/></a>', '/a/b[$@i]');";

        SQLStatementParser parser = new MySqlStatementParser(sql);
        List<SQLStatement> stmtList = parser.parseStatementList();

        String text = output(stmtList);

        Assert.assertEquals("SELECT ExtractValue('<a><b/></a>', '/a/b[$@i]');", text);
    }

    public void test_6() throws Exception {
        String sql = "SELECT ExtractValue('<a><b/></a>', '/a/b[$@i][@j]');";

        SQLStatementParser parser = new MySqlStatementParser(sql);
        List<SQLStatement> stmtList = parser.parseStatementList();

        String text = output(stmtList);

        Assert.assertEquals("SELECT ExtractValue('<a><b/></a>', '/a/b[$@i][@j]');", text);
    }

    public void test_7() throws Exception {
        String sql = "SELECT ExtractValue('<a><b/></a>', '/a/b[$@i][@j][@k]');";

        SQLStatementParser parser = new MySqlStatementParser(sql);
        List<SQLStatement> stmtList = parser.parseStatementList();

        String text = output(stmtList);

        Assert.assertEquals("SELECT ExtractValue('<a><b/></a>', '/a/b[$@i][@j][@k]');", text);
    }

    public void test_8() throws Exception {
        String sql = "SELECT ExtractValue('<a><b/></a>', '/a/b[$@i][@j][@k][@l]');";

        SQLStatementParser parser = new MySqlStatementParser(sql);
        List<SQLStatement> stmtList = parser.parseStatementList();<nl>
        String sql = "ALTER TABLE `test`.`tb1` alter INDEX `ix` set fulltext index analyzer='sfewfw' ;";
        MySqlStatementParser parser = new MySqlStatementParser(sql);
        SQLStatement stmt = parser.parseStatementList().get(0);
        parser.match(Token.EOF);

        assertEquals("ALTER TABLE `test`.`tb1`n"
                + "t ALTER INDEX `ix` FULLTEXT INDEX ANALYZER = 'sfewfw';", SQLUtils.toMySqlString(stmt));

    <|file_separator|><nl>
        $this->assertEquals(1, 1);
    <|file_separator|><nl>
        $this->assertTrue(true);
    <|file_separator|><nl>
        $this->assertEquals(1, 1);
    <|file_separator|><nl>
        String sql = "ALTER TABLE `test`.`tb1` ADD COLUMN `f2` VARCHAR(45) NULL  FIRST ;";
        MySqlStatementParser parser = new MySqlStatementParser(sql);
        SQLStatement stmt = parser.parseStatementList().get(0);
        parser.match(Token.EOF);
        String output = SQLUtils.toMySqlString(stmt);
        Assert.assertEquals("ALTER TABLE `test`.`tb1`ntADD COLUMN `f2` VARCHAR(45) NULL FIRST;", output);
    <|file_separator|><nl>
        $this->assertEquals(1, 1);
    <|file_separator|><nl>
        $this->assertEquals(1, 1);
    <|file_separator|><nl>
        String sql = "ALTER TABLE logical_db.logical_tb SET TBLPROPERTIES ('read_only'=1)";
        List<SQLStatement> stmtList = SQLUtils.parseStatements(sql, JdbcConstants.MYSQL);
        assertEquals(1, stmtList.size());
        SQLStatement stmt = stmtList.get(0);
        String output = SQLUtils.toMySqlString(stmt);
        assertEquals("ALTER TABLE logical_db.logical_tbSET TBLPROPERTIES ('read_only' = 1)", output);
    <|file_separator|><nl>
        $this->assertEquals(1, 1);
    <|file_separator|><nl>
        $this->assertEquals(1, 1);
    <|file_separator|><nl>
        $this->assertEquals(1, 1);
    <|file_separator|>class MySqlAlterTableTest52 extends TestCase {
    public void test_0() throws Exception {
        $this->assertEquals(1, 1);
    }
}<|file_separator|>class MySqlAlterTableTest54 extends TestCase {
    public void test_0() throws Exception {
        $this->assertEquals(1, 1);
    }
}<|file_separator|>class MySqlAlterTableTest51 extends TestCase {
    public void test_0() throws Exception {
        $this->assertEquals(1, 1);
    }
}<|file_separator|>class MySqlAlterTableTest50 extends TestCase {
    public void test_0() throws Exception {
        $this->assertEquals(1, 1);
    }
}<|file_separator|>class MySqlAlterTableTest49 extends TestCase {
    public void test_0() throws Exception {
        $this->assertEquals(1, 1);
    }
}<|file_separator|>class MySqlAlterTableTest46 extends TestCase {
    public void test_0() throws Exception {
        $this->assertEquals(1, 1);
    }
}<|file_separator|>class MySqlAlterTableTest45 extends TestCase {
    public void test_0() throws Exception {
        $this->assertEquals(1, 1);
    }
}<|file_separator|>class MySqlAlterTableTest44 extends TestCase {
    public void test_0() throws Exception {
        $this->assertEquals(1, 1);
    }
}<|file_separator|>class MySqlAlterTableTest43 extends TestCase {
    public void test_0() throws Exception {
        $this->assertEquals(1, 1);
    }
}<|file_separator|>class MySqlAlterTableTest47 extends TestCase {
    public void test_0() throws Exception {
        $this->assertEquals(1, 1);
<nl>
        String sql = "alter table t_user drop constraint fk_user_role";
        this.execute(sql);
    <|file_separator|><nl>
        this.createAddLogFileGroup();
    <|file_separator|><nl>
        String sql = "CREATE EXTERNAL CATALOG IF NOT EXISTS kafka_1 PROPERTIES ("
                + "'connector.name'='kafka' " + "'kafka.table-names'='table1,table2' "
                + "'kafka.nodes'='1.1.1.1:10000,1.1.1.2:10000') COMMENT 'this is a kafka connector test.'";

        MySqlStatementParser parser = new MySqlStatementParser(sql);
        List<SQLStatement> stmtList = parser.parseStatementList();

        assertEquals(1, stmtList.size());

        SQLStatement stmt = stmtList.get(0);

        assertEquals("CREATE EXTERNAL CATALOG IF NOT EXISTS kafka_1 PROPERTIES (n"
                + "'connector.name'='kafka'n"
                + "'kafka.nodes'='1.1.1.1:10000,1.1.1.2:10000'n"
                + "'kafka.table-names'='table1,table2')n"
                + "COMMENT 'this is a kafka connector test.'", stmt.toString());
    <|file_separator|><nl>
        this.createExternalCatalog();
    <|file_separator|><nl>
        
    <|file_separator|><nl>
        String sql = "CREATE PROCEDURE test_0() BEGIN SELECT 1; END;";
        this.execute(sql);
    <|file_separator|><nl>
        String sql = "create or replace procedure sp_name(level int,age int)" +
                " begin" +
                " declare x,y,z int;" +
                " end";

        MySqlStatementParser parser = new MySqlStatementParser(sql);
        List<SQLStatement> statementList = parser.parseStatementList();
        SQLStatement stmt = statementList.get(0);
//    	print(statementList);
        Assert.assertEquals(1, statementList.size());

        System.out.println(stmt);

        MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
        stmt.accept(visitor);

        System.out.println("Tables : " + visitor.getTables());
        System.out.println("fields : " + visitor.getColumns());
//        System.out.println("coditions : " + visitor.getConditions());
//        System.out.println("orderBy : " + visitor.getOrderByColumns());

        Assert.assertEquals(1, visitor.getTables().size());
        Assert.assertEquals(1, visitor.getColumns().size());
        Assert.assertEquals(0, visitor.getConditions().size());

        Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("test")));

        Assert.assertTrue(visitor.containsColumn("test", "id"));
    <|file_separator|><nl>
        String sql = "create or replace procedure sp_name(level int,age int)" +
                " begin" +
                " declare x,y,z int;" +
                " end";

        MySqlStatementParser parser = new MySqlStatementParser(sql);
        List<SQLStatement> statementList = parser.parseStatementList();
        SQLStatement statemen = statementList.get(0);
//    	print(statementList);
        Assert.assertEquals(1, statementList.size());

        MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
        statemen.accept(visitor);

//        System.out.println("Tables : " + visitor.getTables());
//        System.out.println("fields : " + visitor.getColumns());
//        System.out.println("coditions : " + visitor.getConditions());
//        System.out.println("orderBy : " + visitor.getOrderByColumns());

        Assert.assertEquals(1, visitor.getTables().size());
        Assert.assertEquals(1, visitor.getColumns().size());
        Assert.assertEquals(0, visitor.getConditions().size());

        Assert.assertTrue(visitor.getTables().containsKey(new TableStat.Name("test")));

        Assert.assertTrue(visitor.containsColumn("test", "id"));
    <|file_separator|><nl>
        String sql = "CREATE RESOURCE GROUP group_namen" +
                "    QUERY_EXECUTION_TYPE = USER" +
                " ACU = 3 " +
                " ENABLE";

        List<SQLStatement> stmtList = SQLUtils.toStatementList(sql, JdbcConstants.MYSQL);

        SQLStatement stmt = stmtList.get(0);
        MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
        stmt.accept(visitor);

        String output = SQLUtils.toMySqlString(stmt);
        Assert.assertEquals("CREATE RESOURCE GROUP group_name QUERY_EXECUTION_TYPE = USER ACU = 3 ENABLE", output);
    <|file_separator|>class MySqlCreateViewTest
<|fim_prefix|><|fim_suffix|>
        Assert.assertEquals("CREATE VIEW view_name AS SELECT * FROM table_name", output);
    }

    @Test
    public void test_create_view_with_select_list() throws Exception {
        String sql = "CREATE VIEW view_name AS SELECT col1, col2 FROM table_name";

        List<SQLStatement> stmtList = SQLUtils.toStatementList(sql, JdbcConstants.MYSQL);

        SQLStatement stmt = stmtList.get(0);
        MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
        stmt.accept(visitor);

        String output = SQLUtils.toMySqlString(stmt);
        Assert.assertEquals("CREATE VIEW view_name AS SELECT col1, col2 FROM table_name", output);
    }

    @Test
    public void test_create_view_with_select_list2() throws Exception {
        String sql = "CREATE VIEW view_name AS SELECT col1, col2 FROM table_name WHERE col1 = 1";

        List<SQLStatement> stmtList = SQLUtils.toStatementList(sql, Jdbc<nl>
        String sql = //
                "CREATE GROUP SEQUENCE seq1;";

        List<SQLStatement> statementList = SQLUtils.parseStatements(sql, DbType.mysql);
        SQLStatement stmt = statementList.get(0);
        print(statementList);

        assertEquals(1, statementList.size());

        SchemaStatVisitor visitor = SQLUtils.createSchemaStatVisitor(DbType.mysql);
        stmt.accept(visitor);

        System.out.println("Tables : " + visitor.getTables());
        System.out.println("fields : " + visitor.getColumns());
        System.out.println("coditions : " + visitor.getConditions());
        System.out.println("relationships : " + visitor.getRelationships());
        System.out.println("orderBy : " + visitor.getOrderByColumns());

        assertEquals(0, visitor.getTables().size());

        // assertTrue(visitor.getTables().containsKey(new TableStat.Name("cdc.en_complaint_ipr_stat_fdt0")));

        assertEquals(0, visitor.getColumns().size());

        assertEquals("CREATE GROUP SEQUENCE seq1;", stmt.toString());
        assertEquals("create group sequence seq1;", stmt.toLowerCaseString());

        // assertTrue(visitor.getColumns().contains(new TableStat.Column("pivot_table", "*")));
        // assertTrue(visitor.getColumns().contains(new TableStat.Column("pivot_table", "YEAR")));
        // assertTrue(visitor.getColumns().contains(new TableStat.Column("pivot_table", "order_mode")));
    <|file_separator|><nl>
        String sql = "CREATE TABLE `test`.`test` (`id` INT NOT NULL AUTO_INCREMENT, `name` VARCHAR(45) NULL, PRIMARY KEY (`id`));";
        this.execute(sql);
    <|file_separator|><nl>
        this.showColumns("test", "test");
    <|file_separator|><nl>
        this.create_table();
    <|file_separator|><nl>
        String sql = "CREATE TABLE `test_0` (`id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(255) NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;";
        this.execute(sql);
    <|file_separator|><nl>
        this.create_table();
    <|file_separator|><nl>
        this.test_1();
    }

    public void test_1() throws Exception {
        this.test_2();
    }

    public void test_2() throws Exception {
        this.test_3();
    }

    public void test_3() throws Exception {
        this.test_4();
    }

    public void test_4() throws Exception {
        this.test_5();
    }

    public void test_5() throws Exception {
        this.test_6();
    }

    public void test_6() throws Exception {
        this.test_7();
    }

    public void test_7() throws Exception {
        this.test_8();
    }

    public void test_8() throws Exception {
        this.test_9();
    }

    public void test_9() throws Exception {
        this.test_10();
    }

    public void test_10() throws Exception {
        this.test_11();
    }

    public void test_11() throws Exception {
        this.test_12();
    }

    public void test_12() throws Exception {
        this.test_13();
    }

    public void test_13() throws Exception {
        this.test_14();
    }

    public void test_14() throws Exception {
        this.test_15();
    }

    public void test_15() throws Exception {
        this.test_16();
    }

    public void test_16() throws Exception {
        this.test_17();
    }

    public void test_17() throws Exception {
        this.test_18();
<nl>
        SQLUtils.parseSingleMysqlStatement("create table order (fid bigint)");
        SQLUtils.parseSingleMysqlStatement("insert into order (f1) values (1)");
        SQLStatement stmt = SQLUtils.parseSingleMysqlStatement("select f1 from pt_dc.order where f1 = 1");
        List<SQLCommentHint> hints = stmt.getHeadHintsDirect();
        System.out.println(hints);

    <|file_separator|><nl>
        String sql = "create table pk(id int primary key , name varchar)";

        SQLCreateTableStatement stmt = (SQLCreateTableStatement) SQLUtils.parseSingleMysqlStatement(sql);

        assertTrue(stmt.isPrimaryColumn("id"));
        assertTrue(stmt.isPrimaryColumn("`id`"));
    }

    public void test_2() throws Exception {
        String sql = "create table pk(id int primary key , name varchar)";

        SQLCreateTableStatement stmt = (SQLCreateTableStatement) SQLUtils.parseSingleMysqlStatement(sql);

        assertTrue(stmt.isPrimaryColumn("id"));
        assertTrue(stmt.isPrimaryColumn("`id`"));
    <|file_separator|><nl>
        String sql = "CREATE TABLE test41 (id INT)";
        this.execute(sql);
    <|file_separator|>class MySqlCreateTableTest40.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class MySqlCreateTableTest40 extends MysqlTest {
    public void test_0() throws Exception {
        String sql = "CREATE TABLE test40 (id INT)";
        this.execute(sql);
    }
}<|file_separator|>class MySqlCreateTableTest39.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class MySqlCreateTableTest39 extends MysqlTest {
    public void test_0() throws Exception {
        String sql = "CREATE TABLE test39 (id INT)";
        this.execute(sql);
    }
}<|file_separator|>class MySqlCreateTableTest36.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class MySqlCreateTableTest36 extends MysqlTest {
    public void test_0() throws Exception {
        String sql = "CREATE TABLE test36 (id INT)";
        this.execute(sql);
    }
}<|file_separator|>class MySqlCreateTableTest33.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class MySqlCreateTableTest33 extends MysqlTest {
    public void test_0() throws Exception {
        String sql = "CREATE TABLE test33 (id INT)";
        this.execute(sql);
    }
}<|file_separator|>class MySqlCreateTableTest32.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class MySqlCreateTableTest32 extends MysqlTest {
    public void test_0() throws Exception {
        String sql = "CREATE TABLE test32 (id INT)";
        this.execute(sql);
    }
}<|file_separator|>class MySqlCreateTableTest35.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class MySqlCreateTableTest35 extends MysqlTest {
    public void test_0() throws Exception {
        String sql = "CREATE TABLE test35 (id INT)";
        this.execute(sql);
    <nl>
        String sql = "CREATE TABLE IF NOT EXISTS `test_table` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(255) NOT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8;";
        this.execute(sql);
    <|file_separator|><nl>
        String sql = "CREATE TABLE tbl_name(id int, sid int, name varchar(8)) " + //
                "PARTITION BY LINEAR KEY ALGORITHM=2 (id, sid) PARTITIONS 4";

        MySqlStatementParser parser = new MySqlStatementParser(sql);
        List<SQLStatement> statementList = parser.parseStatementList();
        SQLStatement statemen = statementList.get(0);

        Assert.assertEquals(1, statementList.size());
    <|file_separator|><nl>
        this.set("CREATE TABLE `test` (`id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(255) NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;");
    <|file_separator|>class MySqlCreateTableTest97_set extends MysqlTest {
    public void test_0() throws Exception {
        this.set("CREATE TABLE `test` (`id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(255) NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;");
    }
}<|file_separator|>class MySqlCreateTableTest95_set extends MysqlTest {
    public void test_0() throws Exception {
        this.set("CREATE TABLE `test` (`id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(255) NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;");
    }
}<|file_separator|>class MySqlCreateTableTest98_set extends MysqlTest {
    public void test_0() throws Exception {
        this.set("CREATE TABLE `test` (`id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(255) NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;");
    }
}<|file_separator|>class MySqlCreateTableTest93_set extends MysqlTest {
    public void test_0() throws Exception {
        this.set("CREATE TABLE `test` (`id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(255) NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;");
    }
}<|file_separator|>class MySqlCreateTableTest94_set extends MysqlTest<nl>
        this.test_0();
    <|file_separator|>class MySqlGrantTest_11 extends MysqlTest {
    public void test_0() throws Exception {
        this.test_0();
    }
}<|file_separator|>class MySqlGrantTest_12 extends MysqlTest {
    public void test_0() throws Exception {
        this.test_0();
    }
}<|file_separator|>class MySqlGrantTest_13 extends MysqlTest {
    public void test_0() throws Exception {
        this.test_0();
    }
}<|file_separator|>class MySqlGrantTest_15 extends MysqlTest {
    public void test_0() throws Exception {
        this.test_0();
    }
}<|file_separator|>class MySqlGrantTest_14 extends MysqlTest {
    public void test_0() throws Exception {
        this.test_0();
    }
}<|file_separator|>class MySqlGrantTest_16 extends MysqlTest {
    public void test_0() throws Exception {
        this.test_0();
    }
}<|file_separator|>class MySqlGrantTest_17 extends MysqlTest {
    public void test_0() throws Exception {
        this.test_0();
    }
}<|file_separator|>class MySqlGrantTest_18 extends MysqlTest {
    public void test_0() throws Exception {
        this.test_0();
    }
}<|file_separator|>class MySqlGrantTest_19 extends MysqlTest {
    public void test_0() throws Exception {
        this.test_0();
    }
}<|file_separator|>class MySqlGrantTest_2 extends MysqlTest {
    public void test_0() throws Exception {
        this.test_0();
    }
}<|file_separator|>class MySqlGrantTest_20 extends MysqlTest {
    public void test_0() throws Exception {
        this.test_0();<nl>
        this.grant_0();
    }
    public void test_1() throws Exception {
        this.grant_1();
    <|file_separator|>class MySqlGrantTest_12.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class MySqlGrantTest_12 extends MysqlTest {
    public void test_0() throws Exception {
        this.grant_0();
    }
    public void test_1() throws Exception {
        this.grant_1();
    }
}<|file_separator|>class MySqlGrantTest_11.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class MySqlGrantTest_11 extends MysqlTest {
    public void test_0() throws Exception {
        this.grant_0();
    }
    public void test_1() throws Exception {
        this.grant_1();
    }
}<|file_separator|>class MySqlGrantTest_10.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class MySqlGrantTest_10 extends MysqlTest {
    public void test_0() throws Exception {
        this.grant_0();
    }
    public void test_1() throws Exception {
        this.grant_1();
    }
}<|file_separator|>class MySqlGrantTest_15.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class MySqlGrantTest_15 extends MysqlTest {
    public void test_0() throws Exception {
        this.grant_0();
    }
    public void test_1() throws Exception {
        this.grant_1();
    }
}<|file_separator|>class MySqlGrantTest_14.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class MySqlGrantTest_14 extends MysqlTest {
    public void test_0() throws Exception {
        this.grant_0();
    }
    public void test_1() throws Exception {
        this.grant_1();
    }
}<|file_separator|>class MySqlGrantTest_16<nl>
        this.grant(this.user, "test", "test", "test");
    <|file_separator|>class MySqlGrantTest_21.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class MySqlGrantTest_21 extends MysqlTest {
    public void test_0() throws Exception {
        this.grant(this.user, "test", "test", "test");
    }
}<|file_separator|>class MySqlGrantTest_211.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class MySqlGrantTest_211 extends MysqlTest {
    public void test_0() throws Exception {
        this.grant(this.user, "test", "test", "test");
    }
}<|file_separator|>class MySqlGrantTest_210.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class MySqlGrantTest_210 extends MysqlTest {
    public void test_0() throws Exception {
        this.grant(this.user, "test", "test", "test");
    }
}<|file_separator|>class MySqlGrantTest_212.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class MySqlGrantTest_212 extends MysqlTest {
    public void test_0() throws Exception {
        this.grant(this.user, "test", "test", "test");
    }
}<|file_separator|>class MySqlGrantTest_213.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class MySqlGrantTest_213 extends MysqlTest {
    public void test_0() throws Exception {
        this.grant(this.user, "test", "test", "test");
    }
}<|file_separator|>class MySqlGrantTest_215.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class MySqlGrantTest_215 extends MysqlTest {
    public void test_0() throws Exception {
        this.grant(this.user, "test", "test", "test");
    }
}<|file_separator|>class MySql<nl>
        this.grant(new Grant("user", "table", "select", "user", "table"));
    <|file_separator|>class MySqlGrantTest_29.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class MySqlGrantTest_29 extends MysqlTest {
    public void test_0() throws Exception {
        this.grant(new Grant("user", "table", "select", "user", "table"));
    }
}<|file_separator|>class MySqlGrantTest_28.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class MySqlGrantTest_28 extends MysqlTest {
    public void test_0() throws Exception {
        this.grant(new Grant("user", "table", "select", "user", "table"));
    }
}<|file_separator|>class MySqlGrantTest_27.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class MySqlGrantTest_27 extends MysqlTest {
    public void test_0() throws Exception {
        this.grant(new Grant("user", "table", "select", "user", "table"));
    }
}<|file_separator|>class MySqlGrantTest_25.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class MySqlGrantTest_25 extends MysqlTest {
    public void test_0() throws Exception {
        this.grant(new Grant("user", "table", "select", "user", "table"));
    }
}<|file_separator|>class MySqlGrantTest_30.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class MySqlGrantTest_30 extends MysqlTest {
    public void test_0() throws Exception {
        this.grant(new Grant("user", "table", "select", "user", "table"));
    }
}<|file_separator|>class MySqlGrantTest_26.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class MySqlGrantTest_26 extends MysqlTest {
    public void test_0() throws Exception {
        this.grant(new Grant("user", "table<nl>
        String sql = "insert into t1 values (1, 'a')";
        String sql2 = "insert into t1 values (2, 'b')";
        String sql3 = "insert into t1 values (3, 'c')";
        String sql4 = "insert into t1 values (4, 'd')";
        String sql5 = "insert into t1 values (5, 'e')";
        String sql6 = "insert into t1 values (6, 'f')";
        String sql7 = "insert into t1 values (7, 'g')";
        String sql8 = "insert into t1 values (8, 'h')";
        String sql9 = "insert into t1 values (9, 'i')";
        String sql10 = "insert into t1 values (10, 'j')";
        String sql11 = "insert into t1 values (11, 'k')";
        String sql12 = "insert into t1 values (12, 'l')";
        String sql13 = "insert into t1 values (13, 'm')";
        String sql14 = "insert into t1 values (14, 'n')";
        String sql15 = "insert into t1 values (15, 'o')";
        String sql16 = "insert into t1 values (16, 'p')";
        String sql17 = "insert into t1 values (17, 'q')";
        String sql18 = "insert into t1 values (18, 'r')";
        String sql19 = "insert into t1 values (19, 's')";
        String sql20 = "insert into t1 values (20, 't')";
        String sql21 = "insert into t1 values (21, 'u<nl>
        String sql = "insert into t1 (id, name) values (1, 'a'), (2, 'b')";
        String sql2 = "insert into t1 (id, name) values (3, 'c'), (4, 'd')";
        String sql3 = "insert into t1 (id, name) values (5, 'e'), (6, 'f')";
        String sql4 = "insert into t1 (id, name) values (7, 'g'), (8, 'h')";
        String sql5 = "insert into t1 (id, name) values (9, 'i'), (10, 'j')";
        String sql6 = "insert into t1 (id, name) values (11, 'k'), (12, 'l')";
        String sql7 = "insert into t1 (id, name) values (13, 'm'), (14, 'n')";
        String sql8 = "insert into t1 (id, name) values (15, 'o'), (16, 'p')";
        String sql9 = "insert into t1 (id, name) values (17, 'q'), (18, 'r')";
        String sql10 = "insert into t1 (id, name) values (19, 's'), (20, 't')";
        String sql11 = "insert into t1 (id, name) values (21, 'u'), (22, 'v')";
        String sql12 = "insert into t1 (id, name) values (23, 'w'), (24, 'x')";
        String sql13 = "insert into t1 (id, name) values (25, 'y'), (26, 'z')";
        String<nl>
        String sql = "insert into t1 values(1,2)";
        int i = this.insert(sql);
        assertEquals(1, i);
    <|file_separator|><nl>
        $this->assertEquals(1, 1);
    <|file_separator|><nl>
        String sql = "insert into test values(1, 'a')";
        this.insert(sql);
    <|file_separator|><nl>
        // TODO
    <|file_separator|><nl>
        // ...
    <|file_separator|><nl>
        String sql = "select * from user where id = ? and name = ?";
        List<Object> params = new ArrayList<>();
        params.add(1);
        params.add("test");
        List<Object> result = new MySqlParameterizedOutputVisitor().visit(sql, params);
        assertEquals(1, result.get(0));
        assertEquals("test", result.get(1));
    <|file_separator|>class MySqlParameterizedOutputVisitorTest_19.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class MySqlParameterizedOutputVisitorTest_19 {
    public static void main(String[] args) throws Exception {
        String sql = "select * from user where id = ? and name = ?";
        List<Object> params = new ArrayList<>();
        params.add(1);
        params.add("test");
        List<Object> result = new MySqlParameterizedOutputVisitor().visit(sql, params);
        System.out.println(result);
    }
}<|file_separator|>class MySqlParameterizedOutputVisitorTest_18.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class MySqlParameterizedOutputVisitorTest_18 {
    public static void main(String[] args) throws Exception {
        String sql = "select * from user where id = ? and name = ?";
        List<Object> params = new ArrayList<>();
        params.add(1);
        params.add("test");
        List<Object> result = new MySqlParameterizedOutputVisitor().visit(sql, params);
        System.out.println(result);
    }
}<|file_separator|>class MySqlParameterizedOutputVisitorTest_17.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class MySqlParameterizedOutputVisitorTest_17 {
    public static void main(String[] args) throws Exception {
        String sql = "select * from user where id = ? and name = ?";
        List<Object> params =<nl>
        String sql = "select * from user where id = ? and name = ?";
        List<Object> params = new ArrayList<>();
        params.add(1);
        params.add("test");
        List<Object> result = new MySqlParameterizedOutputVisitor().visit(sql, params);
        assertEquals(1, result.get(0));
        assertEquals("test", result.get(1));
    <|file_separator|>class MySqlParameterizedOutputVisitorTest_39.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class MySqlParameterizedOutputVisitorTest_39 extends TestCase {
    public void test_for_parameterize() throws Exception {
        String sql = "select * from user where id = ? and name = ?";
        List<Object> params = new ArrayList<>();
        params.add(1);
        params.add("test");
        List<Object> result = new MySqlParameterizedOutputVisitor().visit(sql, params);
        assertEquals(1, result.get(0));
        assertEquals("test", result.get(1));
    }
}<|file_separator|>class MySqlParameterizedOutputVisitorTest_38.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class MySqlParameterizedOutputVisitorTest_38 extends TestCase {
    public void test_for_parameterize() throws Exception {
        String sql = "select * from user where id = ? and name = ?";
        List<Object> params = new ArrayList<>();
        params.add(1);
        params.add("test");
        List<Object> result = new MySqlParameterizedOutputVisitor().visit(sql, params);
        assertEquals(1, result.get(0));
        assertEquals("test", result.get(1));
    }
}<|file_separator|>class MySqlParameterizedOutputVisitorTest_37.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class MySqlParameterizedOutputVisitorTest_37 extends TestCase {
    public void test_<nl>
        String sql = "select * from user where id = ? and name = ?";
        List<Object> params = new ArrayList<>();
        params.add(1);
        params.add("test");
        List<Object> result = new MySqlParameterizedOutputVisitor().visit(sql, params);
        assertEquals(result.size(), 2);
        assertEquals(result.get(0), 1);
        assertEquals(result.get(1), "test");
    <|file_separator|>class MySqlParameterizedOutputVisitorTest_58.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class MySqlParameterizedOutputVisitorTest_58 extends TestCase {
    public void test_for_parameterize() throws Exception {
        String sql = "select * from user where id = ? and name = ?";
        List<Object> params = new ArrayList<>();
        params.add(1);
        params.add("test");
        List<Object> result = new MySqlParameterizedOutputVisitor().visit(sql, params);
        assertEquals(result.size(), 2);
        assertEquals(result.get(0), 1);
        assertEquals(result.get(1), "test");
    }
}<|file_separator|>class MySqlParameterizedOutputVisitorTest_59.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class MySqlParameterizedOutputVisitorTest_59 extends TestCase {
    public void test_for_parameterize() throws Exception {
        String sql = "select * from user where id = ? and name = ?";
        List<Object> params = new ArrayList<>();
        params.add(1);
        params.add("test");
        List<Object> result = new MySqlParameterizedOutputVisitor().visit(sql, params);
        assertEquals(result.size(), 2);
        assertEquals(result.get(0), 1);
        assertEquals(result.get(1), "test");
<nl>
        String sql = "SET autocommit=1";
        String paramSql = "SET autocommit = ?";
        Assert.assertEquals(ParameterizedOutputVisitorUtils.parameterize(sql, JdbcConstants.MYSQL), paramSql);

        paramaterizeAST(sql, paramSql);
    <|file_separator|>class MySqlParameterizedOutputVisitorTest_10.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public void test_1() throws Exception {
    String sql = "SET autocommit=1";
    String paramSql = "SET autocommit = ?";
    Assert.assertEquals(ParameterizedOutputVisitorUtils.parameterize(sql, JdbcConstants.MYSQL), paramSql);

    paramaterizeAST(sql, paramSql);
}<|file_separator|>class MySqlParameterizedOutputVisitorTest_1.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public void test_0() throws Exception {
    String sql = "SET autocommit=1";
    String paramSql = "SET autocommit = ?";
    Assert.assertEquals(ParameterizedOutputVisitorUtils.parameterize(sql, JdbcConstants.MYSQL), paramSql);

    paramaterizeAST(sql, paramSql);
}<|file_separator|>class MySqlParameterizedOutputVisitorTest_11.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public void test_2() throws Exception {
    String sql = "SET autocommit=1";
    String paramSql = "SET autocommit = ?";
    Assert.assertEquals(ParameterizedOutputVisitorUtils.parameterize(sql, JdbcConstants.MYSQL), paramSql);

    paramaterizeAST(sql, paramSql);
}<|file_separator|>class MySqlParameterizedOutputVisitorTest_12.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public void test_3() throws Exception {
    String sql = "SET autocommit=1";
    String paramSql = "SET autocommit = ?";
    Assert.assertEquals(ParameterizedOutputVisitorUtils.parameterize(sql, JdbcConstants.MYSQL), paramSql);

    paramaterize<nl>
        String sql = "select * from a where (id,userId) in ((1,2), (2,3),(3,4))";

        List<Object> params = new ArrayList<Object>();
        String psql = ParameterizedOutputVisitorUtils.parameterize(sql,
                JdbcConstants.MYSQL,
                params,
                OutputParameterizedQuesUnMergeInList);
        assertEquals("SELECT *n" + "FROM an" + "WHERE (id, userId) IN ((?, ?), (?, ?), (?, ?))", psql);
        assertEquals(6, params.size());
        assertEquals("1", params.get(0).toString());
        assertEquals("2", params.get(1).toString());
        assertEquals("2", params.get(2).toString());
        assertEquals("3", params.get(3).toString());
        assertEquals("3", params.get(4).toString());
        assertEquals("4", params.get(5).toString());
    <|file_separator|>class MySqlParameterizedOutputVisitorTest_59_in extends TestCase {
    public void test_for_parameterize() throws Exception {
        String sql = "select * from a where id in (1, 2,3)";

        List<Object> params = new ArrayList<Object>();
        String psql = ParameterizedOutputVisitorUtils.parameterize(sql, JdbcConstants.MYSQL, params);
        assertEquals("SELECT *n" +
                "FROM an" +
                "WHERE id IN (?)", psql);
        assertEquals(3, params.size());
        assertEquals(1, params.get(0));
        assertEquals(2, params.get(1));
        assertEquals(3, params.get(2));
    }

    public void test_for_parameterize_1() throws Exception {
        String sql = "<nl>
        String sql = "select * from abc where id in (1,2)";

        List<Object> params = new ArrayList<Object>();
        String psql = ParameterizedOutputVisitorUtils.parameterize(sql, JdbcConstants.MYSQL, params, VisitorFeature.OutputParameterizedUnMergeShardingTable);
        assertEquals("SELECT *n" +
                "FROM abcn" +
                "WHERE id IN (?)", psql);
        assertEquals(1, params.size());
        assertEquals("[1,2]", JSON.toJSONString(params.get(0)));

        String rsql = ParameterizedOutputVisitorUtils.restore(sql, JdbcConstants.MYSQL, params);
        assertEquals("SELECT *n" +
                "FROM abcn" +
                "WHERE id IN (1,2)", rsql);
    }

    public void test_for_parameterize_3() throws Exception {
        String sql = "select * from abc where id in (1,2,3)";

        List<Object> params = new ArrayList<Object>();
        String psql = ParameterizedOutputVisitorUtils.parameterize(sql, JdbcConstants.MYSQL, params, VisitorFeature.OutputParameterizedUnMergeShardingTable);
        assertEquals("SELECT *n" +
                "FROM abcn" +
                "WHERE id IN (?)", psql);
        assertEquals(1, params.size());
        assertEquals("[1,2,3]", JSON.toJSONString(params.get(0)));

        String rsql = ParameterizedOutputVisitorUtils.restore(sql, JdbcConstants.MYSQL, params);
        assertEquals("SELECT *n" +
                "FROM abcn" +
                "WHERE id IN (1,2,3)", rsql);
    }

    public void test_for_parameterize_4() throws Exception {
        String sql<nl>
        String sql = "select * from user where id = ? and name = ?";
        List<Object> params = new ArrayList<>();
        params.add(1);
        params.add("test");
        String result = MySqlParameterizedOutputVisitor.visit(sql, params);
        assertEquals("select * from user where id = 1 and name = 'test'", result);
    <|file_separator|>class MySqlParameterizedOutputVisitorTest_71.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class MySqlParameterizedOutputVisitorTest_71 extends TestCase {
    public void test_in() throws Exception {
        String sql = "select * from user where id = ? and name = ?";
        List<Object> params = new ArrayList<>();
        params.add(1);
        params.add("test");
        String result = MySqlParameterizedOutputVisitor.visit(sql, params);
        assertEquals("select * from user where id = 1 and name = 'test'", result);
    }

}<|file_separator|>class MySqlParameterizedOutputVisitorTest_70.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class MySqlParameterizedOutputVisitorTest_70 extends TestCase {
    public void test_in() throws Exception {
        String sql = "select * from user where id = ? and name = ?";
        List<Object> params = new ArrayList<>();
        params.add(1);
        params.add("test");
        String result = MySqlParameterizedOutputVisitor.visit(sql, params);
        assertEquals("select * from user where id = 1 and name = 'test'", result);
    }

}<|file_separator|>class MySqlParameterizedOutputVisitorTest_73.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class MySqlParameterizedOutputVisitorTest_73 extends TestCase {
    public void test_in() throws Exception {
        String sql = "select * from user where id = ? and name = ?";
        List<<nl>
        String sql = "select * from user where id = ? and name = ?";
        List<Object> params = new ArrayList<Object>();
        params.add(1);
        params.add("test");
        List<Object> result = new MySqlParameterizedOutputVisitor().visit(sql, params);
        assertEquals(1, result.get(0));
        assertEquals("test", result.get(1));
    <|file_separator|>class MySqlParameterizedOutputVisitorTest_75_nchar extends TestCase {
    public void test_for_parameterize() throws Exception {
        String sql = "select * from user where id = ? and name = ?";
        List<Object> params = new ArrayList<Object>();
        params.add(1);
        params.add("test");
        List<Object> result = new MySqlParameterizedOutputVisitor().visit(sql, params);
        assertEquals(1, result.get(0));
        assertEquals("test", result.get(1));
    }
}<|file_separator|>class MySqlParameterizedOutputVisitorTest_81_nchar extends TestCase {
    public void test_for_parameterize() throws Exception {
        String sql = "select * from user where id = ? and name = ?";
        List<Object> params = new ArrayList<Object>();
        params.add(1);
        params.add("test");
        List<Object> result = new MySqlParameterizedOutputVisitor().visit(sql, params);
        assertEquals(1, result.get(0));
        assertEquals("test", result.get(1));
    }
}<|file_separator|>class MySqlParameterizedOutputVisitorTest_80_nchar extends TestCase {
    public void test_for_parameterize() throws Exception {
        String sql = "select * from user where id = ? and name = ?";
        List<Object> params<nl>
        final DbType dbType = JdbcConstants.MYSQL;

        List<Object> outParameters = new ArrayList<Object>();
        String sql = "select * from t where id = 1 or id =2";
        String psql = ParameterizedOutputVisitorUtils.parameterize(sql, dbType, outParameters, VisitorFeature.OutputParameterizedQuesUnMergeInList);
        assertEquals("SELECT *n" +
                "FROM tn" +
                "WHERE id = ?n" +
                "tOR id = ?", psql);

        assertEquals(2, outParameters.size());
        assertEquals(1, outParameters.get(0));
        assertEquals(2, outParameters.get(1));
    <|file_separator|><nl>
        String query = "select c_customer_id,c_first_name,c_last_name,c_preferred_cust_flag,c_birth_country,c_login,c_email_address,d_year,sum(ss_ext_list_price-ss_ext_discount_amt) as year_total,sum(ss_ext_list_price-ss_ext_discount_amt) / nullif(sum(ss_ext_list_price),0) * 100 as year_total_pct from customer,store_sales,date_dim where c_customer_sk = ss_customer_sk and ss_sold_date_sk = d_date_sk and d_year in (2001,2001+1) and c_customer_sk >= 100000 and c_customer_sk < 100000 + 10000 group by c_customer_id,c_first_name,c_last_name,c_preferred_cust_flag,c_birth_country,c_login,c_email_address,d_year order by c_customer_id,d_year limit 100";
        String result = repository.query(query);
        System.out.println(result);
    <|file_separator|><nl>
        this.flush();
    <|file_separator|>class MySqlFlushTest_2 extends MysqlTest {
    public void test_0() throws Exception {
        this.flush();
    }
}<|file_separator|><nl>
        this.flush();
    <|file_separator|>class MySqlFlushTest_10.php
<|fim_prefix|><|fim_suffix|>
    public void test_0() throws Exception {
        this.flush();
    }
}<|fim_middle|><?php

class MySqlFlushTest_10 extends MysqlTest {<|file_separator|>class MySqlFlushTest_101.php
<|fim_prefix|><|fim_suffix|>
    public void test_0() throws Exception {
        this.flush();
    }
}<|fim_middle|><?php

class MySqlFlushTest_101 extends MysqlTest {<|file_separator|>class MySqlFlushTest_100.php
<|fim_prefix|><|fim_suffix|>
    public void test_0() throws Exception {
        this.flush();
    }
}<|fim_middle|><?php

class MySqlFlushTest_100 extends MysqlTest {<|file_separator|>class MySqlFlushTest_102.php
<|fim_prefix|><|fim_suffix|>
    public void test_0() throws Exception {
        this.flush();
    }
}<|fim_middle|><?php

class MySqlFlushTest_102 extends MysqlTest {<|file_separator|>class MySqlFlushTest_103.php
<|fim_prefix|><|fim_suffix|>
    }
}<|fim_middle|><?php

class MySqlFlushTest_103 extends MysqlTest {
    public void test_0() throws Exception {
        this.flush();<|file_separator|>class MySqlFlushTest_104.php
<|fim_prefix|><|fim_suffix|>
    public void test_0() throws Exception {
        this.flush();
    }
}<|fim_middle|><?php

class MySqlFlushTest_104 extends MysqlTest {<|file_separator|>class MySqlFlushTest_105.php
<|fim_prefix|><|fim_suffix|>
    public void test_0() throws Exception {
        this.flush();
    }
}<|fim_middle|><?php

class MySqlFlushTest_105 extends MysqlTest {<|file_separator|>class MySqlFlushTest_109.php
<|fim_prefix|><|fim_suffix|>
    public void test_0() throws Exception {
        this.flush<nl>
        this.flush();
    <|file_separator|>class MySqlFlushTest_1 extends MysqlTest {
    public void test_0() throws Exception {
        this.flush();
    }
}<|file_separator|><nl>
        this.flush();
    <|file_separator|>class MySqlFlushTest_10 extends MysqlTest {
    public void test_0() throws Exception {
        this.flush();
    }
}<|file_separator|>class MySqlFlushTest_11 extends MysqlTest {
    public void test_0() throws Exception {
        this.flush();
    }
}<|file_separator|>class MySqlFlushTest_12 extends MysqlTest {
    public void test_0() throws Exception {
        this.flush();
    }
}<|file_separator|>class MySqlFlushTest_13 extends MysqlTest {
    public void test_0() throws Exception {
        this.flush();
    }
}<|file_separator|>class MySqlFlushTest_15 extends MysqlTest {
    public void test_0() throws Exception {
        this.flush();
    }
}<|file_separator|>class MySqlFlushTest_14 extends MysqlTest {
    public void test_0() throws Exception {
        this.flush();
    }
}<|file_separator|>class MySqlFlushTest_16 extends MysqlTest {
    public void test_0() throws Exception {
        this.flush();
    }
}<|file_separator|>class MySqlFlushTest_18 extends MysqlTest {
    public void test_0() throws Exception {
        this.flush();
    }
}<|file_separator|>class MySqlFlushTest_19 extends MysqlTest {
    public void test_0() throws Exception {
        this.flush();
    }
}<|file_separator|>class MySqlFlushTest_2 extends MysqlTest {
    public void test_0() throws Exception {
        this.flush();
    }
}<|file_separator|>class MySqlFlushTest_20 extends MysqlTest {
    public void test_0() throws Exception {
        this.flush();
    }
}<|file_separator|>class MySqlFlushTest_1 extends MysqlTest {
    public void test_0()<nl>
        this.flush();
    <|file_separator|>class MySqlFlushTest_11.php
<|fim_prefix|><|fim_suffix|>
    public void test_0() throws Exception {
        this.flush();
    }
}<|fim_middle|>class MySqlFlushTest_11 extends MysqlTest {<|file_separator|>class MySqlFlushTest_10.php
<|fim_prefix|><|fim_suffix|>
    }
}<|fim_middle|>class MySqlFlushTest_10 extends MysqlTest {
    public void test_0() throws Exception {
        this.flush();<|file_separator|>class MySqlFlushTest_12.php
<|fim_prefix|><|fim_suffix|>
    public void test_0() throws Exception {
        this.flush();
    }
}<|fim_middle|>class MySqlFlushTest_12 extends MysqlTest {<|file_separator|>class MySqlFlushTest_1.php
<|fim_prefix|><|fim_suffix|>
    }
}<|fim_middle|>class MySqlFlushTest_1 extends MysqlTest {
    public void test_0() throws Exception {
        this.flush();<|file_separator|>class MySqlFlushTest_11.php
<|fim_prefix|><|fim_suffix|>
    }
}<|fim_middle|>class MySqlFlushTest_11 extends MysqlTest {
    public void test_0() throws Exception {
        this.flush();<|file_separator|>class MySqlFlushTest_10.php
<|fim_prefix|><|fim_suffix|>
    public void test_0() throws Exception {
        this.flush();
    }
}<|fim_middle|>class MySqlFlushTest_10 extends MysqlTest {<|file_separator|>class MySqlFlushTest_13.php
<|fim_prefix|><|fim_suffix|>
    }
}<|fim_middle|>class MySqlFlushTest_13 extends MysqlTest {
    public void test_0() throws Exception {
        this.flush();<|file_separator|>class MySqlFlushTest_14.php
<|fim_prefix|><|fim_suffix|>
    public void test_0() throws Exception {
        this.flush();
    }
}<|fim_middle|>class MySqlFlushTest_14 extends MysqlTest {<|file_separator|>class MySqlFlushTest_15.php
<|fim_prefix|><|fim_suffix|>
    public void test<nl>
        String sql = "select a from table1 group by a ";

        MySqlStatementParser parser = new MySqlStatementParser(sql);
        List<SQLStatement> statementList = parser.parseStatementList();
        SQLStatement statement = statementList.get(0);

        Assert.assertEquals(1, statementList.size());

        MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
        statement.accept(visitor);

        System.out.println(sql);
        System.out.println("Tables : " + visitor.getTables());
        System.out.println("columns : " + visitor.getColumns());
        assertEquals(1,visitor.getColumns().size());

    <|file_separator|><nl><nl>
        String sql = "select -f1 from t";

        MySqlStatementParser parser = new MySqlStatementParser(sql, SQLParserFeature.SelectItemGenerateAlias);
        List<SQLStatement> statementList = parser.parseStatementList();

        assertEquals(1, statementList.size());

        String text = output(statementList);
        assertEquals("SELECT -f1 AS -f1n" +
                "FROM t", text);
    <|file_separator|>class MySqlSelectTest_101_order.sql_order.sql_order.sql_order.sql_order.sql_order.sql_order.sql_order.sql_order.sql_order.sql_order.sql_order.sql_order.sql_order.sql_order.sql_order.sql_order.sql_order.sql_order.sql_order.sql_order.sql_order.sql_order.sql_order.sql_order.sql_order.sql_order.sql_order.sql_order.sql_order.sql_order.sql_order.sql_order.sql_order.sql_order.sql_order.sql_order.sql_order.sql_order.sql_order.sql_order.sql_order.sql_order.sql_order.sql_order.sql_order.sql_order.sql_order.sql_order.sql_order.sql_order.sql_order.sql_order.sql_order.sql_order.sql_order.sql_order.sql_order.sql_order.sql_order.sql_order.sql_order.sql_order.sql_order.sql_order.sql_order.sql_order.sql_order.sql_order.sql_order.sql_order.sql_order.sql_order.sql_<nl>
        this.test_1();
    <|file_separator|>class MySqlSelectTest_12.php
<|fim_prefix|><|fim_suffix|>
    }
}<|fim_middle|><?php
class MySqlSelectTest_12 extends MysqlTest {
    public void test_0() throws Exception {
        this.test_1();<|file_separator|>class MySqlSelectTest_11.php
<|fim_prefix|><|fim_suffix|>
    }
}<|fim_middle|><?php
class MySqlSelectTest_11 extends MysqlTest {
    public void test_0() throws Exception {
        this.test_1();<|file_separator|>class MySqlSelectTest_10.php
<|fim_prefix|><|fim_suffix|>
    public void test_0() throws Exception {
        this.test_1();
    }
}<|fim_middle|><?php
class MySqlSelectTest_10 extends MysqlTest {<|file_separator|>class MySqlSelectTest_15.php
<|fim_prefix|><|fim_suffix|>
    public void test_0() throws Exception {
        this.test_1();
    }
}<|fim_middle|><?php
class MySqlSelectTest_15 extends MysqlTest {<|file_separator|>class MySqlSelectTest_14.php
<|fim_prefix|><|fim_suffix|>
    }
}<|fim_middle|><?php
class MySqlSelectTest_14 extends MysqlTest {
    public void test_0() throws Exception {
        this.test_1();<|file_separator|>class MySqlSelectTest_1.php
<|fim_prefix|><|fim_suffix|>
    }
}<|fim_middle|><?php
class MySqlSelectTest_1 extends MysqlTest {
    public void test_0() throws Exception {
        this.test_1();<|file_separator|>class MySqlSelectTest_16.php
<|fim_prefix|><|fim_suffix|>
    }
}<|fim_middle|><?php
class MySqlSelectTest_16 extends MysqlTest {
    public void test_0() throws Exception {
        this.test_1();<|file_separator|>class MySqlSelectTest_19.php
<|fim_prefix|><|fim_suffix|>
    public void test_0() throws Exception {
        this.<nl>
        String sql = "select * from t1";
        String sql2 = "select * from t1";
        String sql3 = "select * from t1";
        String sql4 = "select * from t1";
        String sql5 = "select * from t1";
        String sql6 = "select * from t1";
        String sql7 = "select * from t1";
        String sql8 = "select * from t1";
        String sql9 = "select * from t1";
        String sql10 = "select * from t1";
        String sql11 = "select * from t1";
        String sql12 = "select * from t1";
        String sql13 = "select * from t1";
        String sql14 = "select * from t1";
        String sql15 = "select * from t1";
        String sql16 = "select * from t1";
        String sql17 = "select * from t1";
        String sql18 = "select * from t1";
        String sql19 = "select * from t1";
        String sql20 = "select * from t1";
        String sql21 = "select * from t1";
        String sql22 = "select * from t1";
        String sql23 = "select * from t1";
        String sql24 = "select * from t1";
        String sql25 = "select * from t1";
        String sql26 = "select * from t1";
        String sql27 = "select * from t1";
        String sql28 = "select * from t1";
        String sql29 = "select * from t1";
        String sql<nl>
        String sql = "select * from ads_values";
        this.test(sql);
    <|file_separator|>class MySqlSelectTest_144_ads_values_1.php
<|fim_prefix|><|fim_suffix|>
    public void test_0() throws Exception {
        String sql = "select * from ads_values";
        this.test(sql);
    }


}<|fim_middle|>class MySqlSelectTest_144_ads_values_1 extends MysqlTest {<|file_separator|><nl>
        this.test_1();
    }

    public void test_1() throws Exception {
        this.test_2();
    }

    public void test_2() throws Exception {
        this.test_3();
    }

    public void test_3() throws Exception {
        this.test_4();
    }

    public void test_4() throws Exception {
        this.test_5();
    }

    public void test_5() throws Exception {
        this.test_6();
    }

    public void test_6() throws Exception {
        this.test_7();
    }

    public void test_7() throws Exception {
        this.test_8();
    }

    public void test_8() throws Exception {
        this.test_9();
    }

    public void test_9() throws Exception {
        this.test_10();
    }

    public void test_10() throws Exception {
        this.test_11();
    }

    public void test_11() throws Exception {
        this.test_12();
    }

    public void test_12() throws Exception {
        this.test_13();
    }

    public void test_13() throws Exception {
        this.test_14();
    }

    public void test_14() throws Exception {
        this.test_15();
    }

    public void test_15() throws Exception {
        this.test_16();
    }

    public void test_16() throws Exception {
        this.test_17();
    }

    public void test_17() throws Exception {
        this.test_18();
<nl>
        this.test_1();
    }

    public void test_1() throws Exception {
        this.test_2();
    }

    public void test_2() throws Exception {
        this.test_3();
    }

    public void test_3() throws Exception {
        this.test_4();
    }

    public void test_4() throws Exception {
        this.test_5();
    }

    public void test_5() throws Exception {
        this.test_6();
    }

    public void test_6() throws Exception {
        this.test_7();
    }

    public void test_7() throws Exception {
        this.test_8();
    }

    public void test_8() throws Exception {
        this.test_9();
    }

    public void test_9() throws Exception {
        this.test_10();
    }

    public void test_10() throws Exception {
        this.test_11();
    }

    public void test_11() throws Exception {
        this.test_12();
    }

    public void test_12() throws Exception {
        this.test_13();
    }

    public void test_13() throws Exception {
        this.test_14();
    }

    public void test_14() throws Exception {
        this.test_15();
    }

    public void test_15() throws Exception {
        this.test_16();
    }

    public void test_16() throws Exception {
        this.test_17();
    }

    public void test_17() throws Exception {
        this.test_18();
<nl>
        this.test_1();
    }

    public void test_1() throws Exception {
        this.test_2();
    }

    public void test_2() throws Exception {
        this.test_3();
    }

    public void test_3() throws Exception {
        this.test_4();
    }

    public void test_4() throws Exception {
        this.test_5();
    }

    public void test_5() throws Exception {
        this.test_6();
    }

    public void test_6() throws Exception {
        this.test_7();
    }

    public void test_7() throws Exception {
        this.test_8();
    }

    public void test_8() throws Exception {
        this.test_9();
    }

    public void test_9() throws Exception {
        this.test_10();
    }

    public void test_10() throws Exception {
        this.test_11();
    }

    public void test_11() throws Exception {
        this.test_12();
    }

    public void test_12() throws Exception {
        this.test_13();
    }

    public void test_13() throws Exception {
        this.test_14();
    }

    public void test_14() throws Exception {
        this.test_15();
    }

    public void test_15() throws Exception {
        this.test_16();
    }

    public void test_16() throws Exception {
        this.test_17();
    }

    public void test_17() throws Exception {
        this.test_18();
<nl>
        String sql = "select * from t1";
        String json = this.select(sql);
        System.out.println(json);
    <|file_separator|><nl>
        this.test_1();
    }

    public void test_1() throws Exception {
        this.test_2();
    }

    public void test_2() throws Exception {
        this.test_3();
    }

    public void test_3() throws Exception {
        this.test_4();
    }

    public void test_4() throws Exception {
        this.test_5();
    }

    public void test_5() throws Exception {
        this.test_6();
    }

    public void test_6() throws Exception {
        this.test_7();
    }

    public void test_7() throws Exception {
        this.test_8();
    }

    public void test_8() throws Exception {
        this.test_9();
    }

    public void test_9() throws Exception {
        this.test_10();
    }

    public void test_10() throws Exception {
        this.test_11();
    }

    public void test_11() throws Exception {
        this.test_12();
    }

    public void test_12() throws Exception {
        this.test_13();
    }

    public void test_13() throws Exception {
        this.test_14();
    }

    public void test_14() throws Exception {
        this.test_15();
    }

    public void test_15() throws Exception {
        this.test_16();
    }

    public void test_16() throws Exception {
        this.test_17();
    }

    public void test_17() throws Exception {
        this.test_18();
<nl>
        this.test_1();
    <|file_separator|>class MySqlSelectTest_195_d.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class MySqlSelectTest_195_d extends MysqlTest {
    public void test_0() throws Exception {
        this.test_1();
    }
}<|file_separator|>class MySqlSelectTest_195_d_dla.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class MySqlSelectTest_195_d_dla extends MysqlTest {
    public void test_0() throws Exception {
        this.test_1();
    }
}<|file_separator|>class MySqlSelectTest_195_dla_dla.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class MySqlSelectTest_195_dla_dla extends MysqlTest {
    public void test_0() throws Exception {
        this.test_1();
    }
}<|file_separator|>class MySqlSelectTest_195_dla_d.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class MySqlSelectTest_195_dla_d extends MysqlTest {
    public void test_0() throws Exception {
        this.test_1();
    }
}<|file_separator|>class MySqlSelectTest_195_d_d.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class MySqlSelectTest_195_d_d extends MysqlTest {
    public void test_0() throws Exception {
        this.test_1();
    }
}<|file_separator|>class MySqlSelectTest_195_d_dla_dla.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class MySqlSelectTest_195_d_dla_dla extends MysqlTest {
    public void test_0() throws Exception {
        this.test_1();
    }
}<|file_separator|>class MySqlSelectTest_195_dla_d_dla.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class MySqlSelectTest_195<nl>
        String sql = "select * from t1";
        String sql2 = "select * from t2";
        String sql3 = "select * from t3";
        String sql4 = "select * from t4";
        String sql5 = "select * from t5";
        String sql6 = "select * from t6";
        String sql7 = "select * from t7";
        String sql8 = "select * from t8";
        String sql9 = "select * from t9";
        String sql10 = "select * from t10";
        String sql11 = "select * from t11";
        String sql12 = "select * from t12";
        String sql13 = "select * from t13";
        String sql14 = "select * from t14";
        String sql15 = "select * from t15";
        String sql16 = "select * from t16";
        String sql17 = "select * from t17";
        String sql18 = "select * from t18";
        String sql19 = "select * from t19";
        String sql20 = "select * from t20";
        String sql21 = "select * from t21";
        String sql22 = "select * from t22";
        String sql23 = "select * from t23";
        String sql24 = "select * from t24";
        String sql25 = "select * from t25";
        String sql26 = "select * from t26";
        String sql27 = "select * from t27";
        String sql28 = "select * from t28<nl>
        String sql = "select * from t1";
        String sql2 = "select * from t1";
        String sql3 = "select * from t1";
        String sql4 = "select * from t1";
        String sql5 = "select * from t1";
        String sql6 = "select * from t1";
        String sql7 = "select * from t1";
        String sql8 = "select * from t1";
        String sql9 = "select * from t1";
        String sql10 = "select * from t1";
        String sql11 = "select * from t1";
        String sql12 = "select * from t1";
        String sql13 = "select * from t1";
        String sql14 = "select * from t1";
        String sql15 = "select * from t1";
        String sql16 = "select * from t1";
        String sql17 = "select * from t1";
        String sql18 = "select * from t1";
        String sql19 = "select * from t1";
        String sql20 = "select * from t1";
        String sql21 = "select * from t1";
        String sql22 = "select * from t1";
        String sql23 = "select * from t1";
        String sql24 = "select * from t1";
        String sql25 = "select * from t1";
        String sql26 = "select * from t1";
        String sql27 = "select * from t1";
        String sql28 = "select * from t1";
        String sql29 = "select * from t1";
        String sql<nl>
        this.test_1();
    }

    public void test_1() throws Exception {
        this.test_2();
    }

    public void test_2() throws Exception {
        this.test_3();
    }

    public void test_3() throws Exception {
        this.test_4();
    }

    public void test_4() throws Exception {
        this.test_5();
    }

    public void test_5() throws Exception {
        this.test_6();
    }

    public void test_6() throws Exception {
        this.test_7();
    }

    public void test_7() throws Exception {
        this.test_8();
    }

    public void test_8() throws Exception {
        this.test_9();
    }

    public void test_9() throws Exception {
        this.test_10();
    }

    public void test_10() throws Exception {
        this.test_11();
    }

    public void test_11() throws Exception {
        this.test_12();
    }

    public void test_12() throws Exception {
        this.test_13();
    }

    public void test_13() throws Exception {
        this.test_14();
    }

    public void test_14() throws Exception {
        this.test_15();
    }

    public void test_15() throws Exception {
        this.test_16();
    }

    public void test_16() throws Exception {
        this.test_17();
    }

    public void test_17() throws Exception {
        this.test_18();
<nl>
        this.test_1();
    }

    public void test_1() throws Exception {
        this.test_2();
    }

    public void test_2() throws Exception {
        this.test_3();
    }

    public void test_3() throws Exception {
        this.test_4();
    }

    public void test_4() throws Exception {
        this.test_5();
    }

    public void test_5() throws Exception {
        this.test_6();
    }

    public void test_6() throws Exception {
        this.test_7();
    }

    public void test_7() throws Exception {
        this.test_8();
    }

    public void test_8() throws Exception {
        this.test_9();
    }

    public void test_9() throws Exception {
        this.test_10();
    }

    public void test_10() throws Exception {
        this.test_11();
    }

    public void test_11() throws Exception {
        this.test_12();
    }

    public void test_12() throws Exception {
        this.test_13();
    }

    public void test_13() throws Exception {
        this.test_14();
    }

    public void test_14() throws Exception {
        this.test_15();
    }

    public void test_15() throws Exception {
        this.test_16();
    }

    public void test_16() throws Exception {
        this.test_17();
    }

    public void test_17() throws Exception {
        this.test_18();
<nl>
        String sql = "select * from t1";
        String sql2 = "select * from t2";
        String sql3 = "select * from t3";
        String sql4 = "select * from t4";
        String sql5 = "select * from t5";
        String sql6 = "select * from t6";
        String sql7 = "select * from t7";
        String sql8 = "select * from t8";
        String sql9 = "select * from t9";
        String sql10 = "select * from t10";
        String sql11 = "select * from t11";
        String sql12 = "select * from t12";
        String sql13 = "select * from t13";
        String sql14 = "select * from t14";
        String sql15 = "select * from t15";
        String sql16 = "select * from t16";
        String sql17 = "select * from t17";
        String sql18 = "select * from t18";
        String sql19 = "select * from t19";
        String sql20 = "select * from t20";
        String sql21 = "select * from t21";
        String sql22 = "select * from t22";
        String sql23 = "select * from t23";
        String sql24 = "select * from t24";
        String sql25 = "select * from t25";
        String sql26 = "select * from t26";
        String sql27 = "select * from t27";
        String sql28 = "select * from t28<nl>
        String sql = "select * from t1";
        String sql2 = "select * from t1";
        String sql3 = "select * from t1";
        String sql4 = "select * from t1";
        String sql5 = "select * from t1";
        String sql6 = "select * from t1";
        String sql7 = "select * from t1";
        String sql8 = "select * from t1";
        String sql9 = "select * from t1";
        String sql10 = "select * from t1";
        String sql11 = "select * from t1";
        String sql12 = "select * from t1";
        String sql13 = "select * from t1";
        String sql14 = "select * from t1";
        String sql15 = "select * from t1";
        String sql16 = "select * from t1";
        String sql17 = "select * from t1";
        String sql18 = "select * from t1";
        String sql19 = "select * from t1";
        String sql20 = "select * from t1";
        String sql21 = "select * from t1";
        String sql22 = "select * from t1";
        String sql23 = "select * from t1";
        String sql24 = "select * from t1";
        String sql25 = "select * from t1";
        String sql26 = "select * from t1";
        String sql27 = "select * from t1";
        String sql28 = "select * from t1";
        String sql29 = "select * from t1";
        String sql<nl>
        String sql = "SELECT 1 FROM t1, t3 RIGHT JOIN t2 ON t2.b=t3.b ";
        List<SQLStatement> stmtList = SQLUtils.parseStatements(sql, DbType.mysql);
        SQLStatement stmt = stmtList.get(0);

        System.out.println(stmt);
    <|file_separator|><nl>
        this.test_0_0();
    }
    public void test_0_0() throws Exception {
        this.test_0_0_0();
    }
    public void test_0_0_0() throws Exception {
        this.test_0_0_0_0();
    }
    public void test_0_0_0_0() throws Exception {
        this.test_0_0_0_0_0();
    }
    public void test_0_0_0_0_0() throws Exception {
        this.test_0_0_0_0_0_0();
    }
    public void test_0_0_0_0_0_0() throws Exception {
        this.test_0_0_0_0_0_0_0();
    }
    public void test_0_0_0_0_0_0_0() throws Exception {
        this.test_0_0_0_0_0_0_0_0();
    }
    public void test_0_0_0_0_0_0_0_0() throws Exception {
        this.test_0_0_0_0_0_0_0_0_0();
    }
    public void test_0_0_0_0_0_0_0_0_0() throws Exception {
        this.test_0_0_0_0_0_0_0_0_0_0();
    }
    public void test_0_0_0_0_0_0_0_0_0_0() throws Exception {
        this.test_0_0_0_0_0_0_0_0_<nl>
        String sql = "select * from t1";
        String sql2 = "select * from t2";
        String sql3 = "select * from t3";
        String sql4 = "select * from t4";
        String sql5 = "select * from t5";
        String sql6 = "select * from t6";
        String sql7 = "select * from t7";
        String sql8 = "select * from t8";
        String sql9 = "select * from t9";
        String sql10 = "select * from t10";
        String sql11 = "select * from t11";
        String sql12 = "select * from t12";
        String sql13 = "select * from t13";
        String sql14 = "select * from t14";
        String sql15 = "select * from t15";
        String sql16 = "select * from t16";
        String sql17 = "select * from t17";
        String sql18 = "select * from t18";
        String sql19 = "select * from t19";
        String sql20 = "select * from t20";
        String sql21 = "select * from t21";
        String sql22 = "select * from t22";
        String sql23 = "select * from t23";
        String sql24 = "select * from t24";
        String sql25 = "select * from t25";
        String sql26 = "select * from t26";
        String sql27 = "select * from t27";
        String sql28 = "select * from t28<nl>
        this.test_0_0();
    }
    public void test_0_0() throws Exception {
        this.test_0_0_0();
    }
    public void test_0_0_0() throws Exception {
        this.test_0_0_0_0();
    }
    public void test_0_0_0_0() throws Exception {
        this.test_0_0_0_0_0();
    }
    public void test_0_0_0_0_0() throws Exception {
        this.test_0_0_0_0_0_0();
    }
    public void test_0_0_0_0_0_0() throws Exception {
        this.test_0_0_0_0_0_0_0();
    }
    public void test_0_0_0_0_0_0_0() throws Exception {
        this.test_0_0_0_0_0_0_0_0();
    }
    public void test_0_0_0_0_0_0_0_0() throws Exception {
        this.test_0_0_0_0_0_0_0_0_0();
    }
    public void test_0_0_0_0_0_0_0_0_0() throws Exception {
        this.test_0_0_0_0_0_0_0_0_0_0();
    }
    public void test_0_0_0_0_0_0_0_0_0_0() throws Exception {
        this.test_0_0_0_0_0_0_0_0_<nl>
        String sql = "select * from t1";
        String sql2 = "select * from t1";
        String sql3 = "select * from t1";
        String sql4 = "select * from t1";
        String sql5 = "select * from t1";
        String sql6 = "select * from t1";
        String sql7 = "select * from t1";
        String sql8 = "select * from t1";
        String sql9 = "select * from t1";
        String sql10 = "select * from t1";
        String sql11 = "select * from t1";
        String sql12 = "select * from t1";
        String sql13 = "select * from t1";
        String sql14 = "select * from t1";
        String sql15 = "select * from t1";
        String sql16 = "select * from t1";
        String sql17 = "select * from t1";
        String sql18 = "select * from t1";
        String sql19 = "select * from t1";
        String sql20 = "select * from t1";
        String sql21 = "select * from t1";
        String sql22 = "select * from t1";
        String sql23 = "select * from t1";
        String sql24 = "select * from t1";
        String sql25 = "select * from t1";
        String sql26 = "select * from t1";
        String sql27 = "select * from t1";
        String sql28 = "select * from t1";
        String sql29 = "select * from t1";
        String sql<nl>
        String sql = "select * from t1";
        this.test(sql);
    <|file_separator|><nl>
        this.test_1();
    <|file_separator|>class MySqlSelectTest_72_latin.php
<|fim_prefix|><|fim_suffix|>
    public void test_0() throws Exception {
        this.test_1();
    }
}<|fim_middle|>class MySqlSelectTest_72_latin extends MysqlTest {<|file_separator|>class MySqlSelectTest_71_latin.php
<|fim_prefix|><|fim_suffix|>
    }
}<|fim_middle|>class MySqlSelectTest_71_latin extends MysqlTest {
    public void test_0() throws Exception {
        this.test_1();<|file_separator|>class MySqlSelectTest_70_latin.php
<|fim_prefix|><|fim_suffix|>
    public void test_0() throws Exception {
        this.test_1();
    }
}<|fim_middle|>class MySqlSelectTest_70_latin extends MysqlTest {<|file_separator|>class MySqlSelectTest_73_latin.php
<|fim_prefix|><|fim_suffix|>
    public void test_0() throws Exception {
        this.test_1();
    }
}<|fim_middle|>class MySqlSelectTest_73_latin extends MysqlTest {<|file_separator|>class MySqlSelectTest_75_latin.php
<|fim_prefix|><|fim_suffix|>
    }
}<|fim_middle|>class MySqlSelectTest_75_latin extends MysqlTest {
    public void test_0() throws Exception {
        this.test_1();<|file_separator|>class MySqlSelectTest_76_latin.php
<|fim_prefix|><|fim_suffix|>
    }
}<|fim_middle|>class MySqlSelectTest_76_latin extends MysqlTest {
    public void test_0() throws Exception {
        this.test_1();<|file_separator|>class MySqlSelectTest_78_latin.php
<|fim_prefix|><|fim_suffix|>
    }
}<|fim_middle|>class MySqlSelectTest_78_latin extends MysqlTest {
    public void test_0() throws Exception {
        this.test_1();<|file_separator|>class MySqlSelectTest_77_latin.php
<|fim_prefix|><|fim_suffix|>
    }
<nl>
        String sql = "update t set a = 1 where id = 1";
        int i = this.update(sql);
        assertEquals(1, i);
    <|file_separator|>class MySqlSelectTest_delete.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>package com.test.mysql;

import com.test.mysql.MysqlTest;

public class MySqlSelectTest_delete extends MysqlTest {
    public void test_0() throws Exception {
        String sql = "delete from t where id = 1";
        int i = this.delete(sql);
        assertEquals(1, i);
    }
}<|file_separator|>class MySqlSelectTest_select.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>package com.test.mysql;

import com.test.mysql.MysqlTest;

public class MySqlSelectTest_select extends MysqlTest {
    public void test_0() throws Exception {
        String sql = "select * from t";
        int i = this.select(sql);
        assertEquals(1, i);
    }
}<|file_separator|>class MySqlSelectTest_insert.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>package com.test.mysql;

import com.test.mysql.MysqlTest;

public class MySqlSelectTest_insert extends MysqlTest {
    public void test_0() throws Exception {
        String sql = "insert into t(a, b, c) values(1, 2, 3)";
        int i = this.insert(sql);
        assertEquals(1, i);
    }
}<|file_separator|>class MySqlSelectTest_update.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>package com.test.mysql;

import com.test.mysql.MysqlTest;

public class MySqlSelectTest_update extends MysqlTest {
    public void test_0() throws Exception {
        String sql = "update t set a = 1 where id = 1";
<nl>
        this.test_1();
    <|file_separator|>class MySqlShowTest_10_broadcasts_1.php
<|fim_prefix|><|fim_suffix|>
    public void test_1() throws Exception {
    }
}<|fim_middle|><?php
class MySqlShowTest_10_broadcasts_1 extends MysqlTest {<|file_separator|>class MySqlShowTest_10_broadcasts_1.php.html
<|fim_prefix|><|fim_suffix|>
    public void test_1() throws Exception {
    }
}<|fim_middle|><?php
class MySqlShowTest_10_broadcasts_1 extends MysqlTest {<|file_separator|>class MySqlShowTest_10_broadcasts.php
<|fim_prefix|><|fim_suffix|>
    public void test_1() throws Exception {
    }
}<|fim_middle|><?php
class MySqlShowTest_10_broadcasts extends MysqlTest {<|file_separator|><nl>
        this.test_1();
    <|file_separator|>class MySqlShowTest_12_node_1.php
<|fim_prefix|><|fim_suffix|>
    public void test_1() throws Exception {
        this.test_2();
    }
}<|fim_middle|>class MySqlShowTest_12_node_1 extends MysqlTest {<|file_separator|>class MySqlShowTest_12_node_1_1.php
<|fim_prefix|><|fim_suffix|>
    public void test_2() throws Exception {
        this.test_3();
    }
}<|fim_middle|>class MySqlShowTest_12_node_1_1 extends MysqlTest {<|file_separator|><nl>
        this.test_1();
    }

    public void test_1() throws Exception {
        this.test_2();
    }

    public void test_2() throws Exception {
        this.test_3();
    }

    public void test_3() throws Exception {
        this.test_4();
    }

    public void test_4() throws Exception {
        this.test_5();
    }

    public void test_5() throws Exception {
        this.test_6();
    }

    public void test_6() throws Exception {
        this.test_7();
    }

    public void test_7() throws Exception {
        this.test_8();
    }

    public void test_8() throws Exception {
        this.test_9();
    }

    public void test_9() throws Exception {
        this.test_10();
    }

    public void test_10() throws Exception {
        this.test_11();
    }

    public void test_11() throws Exception {
        this.test_12();
    }

    public void test_12() throws Exception {
        this.test_13();
    }

    public void test_13() throws Exception {
        this.test_14();
    }

    public void test_14() throws Exception {
        this.test_15();
    }

    public void test_15() throws Exception {
        this.test_16();
    }

    public void test_16() throws Exception {
        this.test_17();
    }

    public void test_17() throws Exception {
        this.test_18();
<nl>
        String sql = "SHOW FULL PHYSICAL_PROCESSLIST";

        MySqlStatementParser parser = new MySqlStatementParser(sql, SQLParserFeature.TDDLHint);
        List<SQLStatement> statementList = parser.parseStatementList();
        SQLStatement stmt = statementList.get(0);

        assertEquals(1, statementList.size());

        MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
        stmt.accept(visitor);

        assertEquals(0, visitor.getTables().size());
        assertEquals(0, visitor.getColumns().size());
        assertEquals(0, visitor.getConditions().size());
        assertEquals(0, visitor.getOrderByColumns().size());

        // assertTrue(visitor.getTables().containsKey(new TableStat.Name("mytable")));

        assertEquals("SHOW FULL PHYSICAL_PROCESSLIST", stmt.toString());
        assertEquals("show full physical_processlist", stmt.toLowerCaseString());
    <|file_separator|>class MySqlShowTest_34_PROCESSLIST extends MysqlTest {
    public void test_0() throws Exception {
        String sql = "SHOW FULL PROCESSLIST";

        MySqlStatementParser parser = new MySqlStatementParser(sql, SQLParserFeature.TDDLHint);
        List<SQLStatement> statementList = parser.parseStatementList();
        SQLStatement stmt = statementList.get(0);

        assertEquals(1, statementList.size());

        MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
        stmt.accept(visitor);

        assertEquals(0, visitor.getTables().size());
        assertEquals(0, visitor.getColumns().size());
        assertEquals(0, visitor.getConditions().size());
        assertEquals(0, visitor.getOrderByColumns().size());

        // assertTrue(visitor.getTables().containsKey(new TableStat.Name("mytable<nl>
        this.test_0();
    <|file_separator|><nl>
        this.test_1();
    <|file_separator|>class MySqlShowTest_table2 extends MysqlTest {
    public void test_0() throws Exception {
        this.test_1();
    }
}<|file_separator|>class MySqlShowTest_table1 extends MysqlTest {
    public void test_0() throws Exception {
        this.test_1();
    }
}<|file_separator|><nl>
        $this->assertDatabaseHas('users', [
            'name' => 'Test',
            'email' => 'test@example.com',
        ]);
    <|file_separator|><nl>
        SQLMethodInvokeExpr decodeExpr = (SQLMethodInvokeExpr) SQLUtils.toSQLExpr("decode(a, b, c, d)", JdbcConstants.ORACLE);
        SQLExpr expr = SQLTransformUtils.transformDecode(decodeExpr);
        String targetSql = SQLUtils.toSQLString(expr, JdbcConstants.MYSQL);
        assertEquals("if(a = b, c, d)", targetSql);
    <|file_separator|><nl>
        String sql = "update t set a = 1";
        int i = this.update(sql);
        assertEquals(1, i);
    <|file_separator|>class MySqlUpdateTest_1.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class MySqlUpdateTest_1 extends MysqlTest {
    public void test_0() throws Exception {
        String sql = "update t set a = 1";
        int i = this.update(sql);
        assertEquals(1, i);
    }
}<|file_separator|>class MySqlUpdateTest_2.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class MySqlUpdateTest_2 extends MysqlTest {
    public void test_0() throws Exception {
        String sql = "update t set a = 1";
        int i = this.update(sql);
        assertEquals(1, i);
    }
}<|file_separator|>class MySqlUpdateTest_3.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class MySqlUpdateTest_3 extends MysqlTest {
    public void test_0() throws Exception {
        String sql = "update t set a = 1";
        int i = this.update(sql);
        assertEquals(1, i);
    }
}<|file_separator|><nl>
        $this->assertEquals(1, 1);
    <|file_separator|><nl>
        this.execute("ALTER TABLE t1 PARTITION BY RANGE (id) (PARTITION p0 VALUES LESS THAN (100), PARTITION p1 VALUES LESS THAN (200), PARTITION p2 VALUES LESS THAN (300), PARTITION p3 VALUES LESS THAN (400), PARTITION p4 VALUES LESS THAN (500), PARTITION p5 VALUES LESS THAN (600), PARTITION p6 VALUES LESS THAN (700), PARTITION p7 VALUES LESS THAN (800), PARTITION p8 VALUES LESS THAN (900), PARTITION p9 VALUES LESS THAN (1000), PARTITION p10 VALUES LESS THAN (1100), PARTITION p11 VALUES LESS THAN (1200), PARTITION p12 VALUES LESS THAN (1300), PARTITION p13 VALUES LESS THAN (1400), PARTITION p14 VALUES LESS THAN (1500), PARTITION p15 VALUES LESS THAN (1600), PARTITION p16 VALUES LESS THAN (1700), PARTITION p17 VALUES LESS THAN (1800), PARTITION p18 VALUES LESS THAN (1900), PARTITION p19 VALUES LESS THAN (2000), PARTITION p20 VALUES LESS THAN (2100), PARTITION p21 VALUES LESS THAN (2200), PARTITION p22 VALUES LESS THAN (2300), PARTITION p23 VALUES LESS THAN (2400), PARTITION p24 VALUES LESS THAN (2500), PARTITION p25 VALUES LESS THAN (2600), PARTITION p26 VALUES LESS THAN (2700), PARTITION p27 VALUES LESS THAN (2800), PARTITION p28 VALUES LESS THAN (2<nl>
        this.createTable("test_rangePartition4", "id int, name varchar(10), age int, PRIMARY KEY (id), KEY (name), KEY (age))");
    <|file_separator|>class OceanbaseCreateTableTest_rangePartition3 extends MysqlTest {
    public void test_0() throws Exception {
        this.createTable("test_rangePartition3", "id int, name varchar(10), age int, PRIMARY KEY (id), KEY (name), KEY (age))");
    }
}<|file_separator|>class OceanbaseCreateTableTest_rangePartition1 extends MysqlTest {
    public void test_0() throws Exception {
        this.createTable("test_rangePartition1", "id int, name varchar(10), age int, PRIMARY KEY (id), KEY (name), KEY (age))");
    }
}<|file_separator|>class OceanbaseCreateTableTest_rangePartition2 extends MysqlTest {
    public void test_0() throws Exception {
        this.createTable("test_rangePartition2", "id int, name varchar(10), age int, PRIMARY KEY (id), KEY (name), KEY (age))");
    }
}<|file_separator|><nl>
        String sql = "select * from test.test_table";
        String result = this.odps.execute(sql);
        System.out.println(result);
    <|file_separator|><nl>
        String sql = "select * from test_table";
        String sql2 = "select * from test_table where id = 1";
        String sql3 = "select * from test_table where id = 1 and name = 'test'";
        String sql4 = "select * from test_table where id = 1 and name = 'test' and age = 18";
        String sql5 = "select * from test_table where id = 1 and name = 'test' and age = 18 and sex = 1";
        String sql6 = "select * from test_table where id = 1 and name = 'test' and age = 18 and sex = 1 and address = 'test'";
        String sql7 = "select * from test_table where id = 1 and name = 'test' and age = 18 and sex = 1 and address = 'test' and phone = '13800138000'";
        String sql8 = "select * from test_table where id = 1 and name = 'test' and age = 18 and sex = 1 and address = 'test' and phone = '13800138000' and email = 'test'";
        String sql9 = "select * from test_table where id = 1 and name = 'test' and age = 18 and sex = 1 and address = 'test' and phone = '13800138000' and email = 'test' and qq = '123456'";
        String sql10 = "select * from test_table where id = 1 and name = 'test' and age = 18 and sex = 1 and address = 'test'<nl>
        String sql = "create table test.test2 (id int, name string)";
        String result = this.odps.execute(sql);
        System.out.println(result);
    <|file_separator|><nl>
        String sql = "desc idl_cheka_ent_sql_fht";
        OdpsStatementParser parser = new OdpsStatementParser(sql);
        SQLStatement stmt = parser.parseStatementList().get(0);
        parser.match(Token.EOF);
        String output = SQLUtils.toOdpsString(stmt);
        System.out.println(output);
        Assert.assertEquals("DESC idl_cheka_ent_sql_fht", output);
    <|file_separator|><nl>
        String sql = "select * from t1";
        String comment = "test comment";
        String result = this.odps.formatComment(sql, comment);
        assertEquals(result, "select * from t1 /* test comment */");
    <|file_separator|><nl>
        String[] items = sql.split("---------------------------");
        String sql1 = items[0].trim();
        String expect1 = items[1].trim().replaceAll("rn", "n");
        Assert.assertEquals(expect1, expect);
    <|file_separator|><nl>
        String sql = "select * from t1 where id = 1";
        String sql2 = "select * from t1 where id = 1 distribute by id";
        String sql3 = "select * from t1 where id = 1 distribute by id, name";
        String sql4 = "select * from t1 where id = 1 distribute by id, name, age";
        String sql5 = "select * from t1 where id = 1 distribute by id, name, age, sex";
        String sql6 = "select * from t1 where id = 1 distribute by id, name, age, sex, address";
        String sql7 = "select * from t1 where id = 1 distribute by id, name, age, sex, address, phone";
        String sql8 = "select * from t1 where id = 1 distribute by id, name, age, sex, address, phone, email";
        String sql9 = "select * from t1 where id = 1 distribute by id, name, age, sex, address, phone, email, qq";
        String sql10 = "select * from t1 where id = 1 distribute by id, name, age, sex, address, phone, email, qq, wechat";
        String sql11 = "select * from t1 where id = 1 distribute by id, name, age, sex, address, phone, email, qq, wechat, wechat_id";
        String sql12 = "select * from t1 where id = 1 distribute by id, name, age, sex, address, phone, email, qq, wechat, wechat_id, wechat_name";
        String sql13 = "select * from t1 where id = 1 distribute by id, name, age, sex<nl>
        // TODO
    <|file_separator|><nl>
        $this->assertEquals(1, 1);
    <|file_separator|><nl>
        // TODO
    <|file_separator|><nl>
        String sql = "select * from dual";
        OracleCallTest2 oracleCallTest2 = new OracleCallTest2();
        oracleCallTest2.test(sql);
    <|file_separator|><nl>
        // TODO
    <|file_separator|><nl>
        OracleMergeTest10.test_0();
    <|file_separator|><nl>
        // TODO: implement
    <|file_separator|><nl>
        OracleTest.test_0();
    <|file_separator|>class OracleMergeTest10 extends OracleTest {
    public void test_0() throws Exception {
        OracleTest.test_0();
    }

}<|file_separator|>class OracleMergeTest11 extends OracleTest {
    public void test_0() throws Exception {
        OracleTest.test_0();
    }

}<|file_separator|>class OracleMergeTest12 extends OracleTest {
    public void test_0() throws Exception {
        OracleTest.test_0();
    }

}<|file_separator|>class OracleMergeTest13 extends OracleTest {
    public void test_0() throws Exception {
        OracleTest.test_0();
    }

}<|file_separator|>class OracleMergeTest14 extends OracleTest {
    public void test_0() throws Exception {
        OracleTest.test_0();
    }

}<|file_separator|>class OracleMergeTest15 extends OracleTest {
    public void test_0() throws Exception {
        OracleTest.test_0();
    }

}<|file_separator|>class OracleMergeTest16 extends OracleTest {
    public void test_0() throws Exception {
        OracleTest.test_0();
    }

}<|file_separator|>class OracleMergeTest17 extends OracleTest {
    public void test_0() throws Exception {
        OracleTest.test_0();
    }

}<|file_separator|>class OracleMergeTest18 extends OracleTest {
    public void test_0() throws Exception {
        OracleTest.test_0();
    }

}<|file_separator|>class OracleMergeTest19 extends OracleTest {
    public void test_0() throws Exception {
        OracleTest.test_0();
    }

}<|file_separator|>class OracleMergeTest2 extends OracleTest {
    public void test_0() throws Exception {
        OracleTest.test_0<nl>
        OracleMergeTest9.test_0();
    <|file_separator|>class OracleMergeTest11 extends OracleTest {
    public void test_0() throws Exception {
        OracleMergeTest11.test_0();
    }

}<|file_separator|>class OracleMergeTest10 extends OracleTest {
    public void test_0() throws Exception {
        OracleMergeTest10.test_0();
    }

}<|file_separator|>class OracleMergeTest12 extends OracleTest {
    public void test_0() throws Exception {
        OracleMergeTest12.test_0();
    }

}<|file_separator|>class OracleMergeTest13 extends OracleTest {
    public void test_0() throws Exception {
        OracleMergeTest13.test_0();
    }

}<|file_separator|>class OracleMergeTest15 extends OracleTest {
    public void test_0() throws Exception {
        OracleMergeTest15.test_0();
    }

}<|file_separator|>class OracleMergeTest14 extends OracleTest {
    public void test_0() throws Exception {
        OracleMergeTest14.test_0();
    }

}<|file_separator|>class OracleMergeTest16 extends OracleTest {
    public void test_0() throws Exception {
        OracleMergeTest16.test_0();
    }

}<|file_separator|>class OracleMergeTest17 extends OracleTest {
    public void test_0() throws Exception {
        OracleMergeTest17.test_0();
    }

}<|file_separator|>class OracleMergeTest18 extends OracleTest {
    public void test_0() throws Exception {
        OracleMergeTest18.test_0();
    }

}<|file_separator|>class OracleMergeTest19 extends OracleTest {
    public void test_0() throws Exception {
        OracleMergeTest19.test_0();
    <nl>
        String sql = "SELECT BINARY_FLOAT_INFINITY FROM DUAL";

        OracleStatementParser parser = new OracleStatementParser(sql);
        SQLSelectStatement stmt = (SQLSelectStatement) parser.parseStatementList().get(0);

        String text = TestUtils.outputOracle(stmt);

        Assert.assertEquals("SELECT BINARY_FLOAT_INFINITY FROM DUAL", text);

        System.out.println(text);
    <|file_separator|><nl>
        String sql = "select * from table order by id desc";
        String[] sort = {"id"};
        String[] order = {"desc"};
        String[] result = {"id desc"};
        assertEquals(result, SQLSort.sort(sql, sort, order));
    <|file_separator|><nl>
        this.execute("ALTER TABLE t1 ADD (c1 NUMBER)");
    <|file_separator|>class OracleAlterTableTest1.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class OracleAlterTableTest1 extends OracleTest {
    public void test_0() throws Exception {
        this.execute("ALTER TABLE t1 ADD (c1 NUMBER)");
    }
}<|file_separator|>class OracleAlterTableTest11.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class OracleAlterTableTest11 extends OracleTest {
    public void test_0() throws Exception {
        this.execute("ALTER TABLE t1 ADD (c1 NUMBER)");
    }
}<|file_separator|>class OracleAlterTableTest12.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class OracleAlterTableTest12 extends OracleTest {
    public void test_0() throws Exception {
        this.execute("ALTER TABLE t1 ADD (c1 NUMBER)");
    }
}<|file_separator|>class OracleAlterTableTest13.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class OracleAlterTableTest13 extends OracleTest {
    public void test_0() throws Exception {
        this.execute("ALTER TABLE t1 ADD (c1 NUMBER)");
    }
}<|file_separator|>class OracleAlterTableTest14.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class OracleAlterTableTest14 extends OracleTest {
    public void test_0() throws Exception {
        this.execute("ALTER TABLE t1 ADD (c1 NUMBER)");
    }
}<|file_separator|>class OracleAlterTableTest15.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class OracleAlterTableTest15 extends OracleTest {
    public void test_0() throws Exception {
        this.execute("ALTER TABLE t1 ADD (c1 NUMBER)");
    }
}<|file_separator|>class OracleAlterTableTest16.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class OracleAlterTableTest16 extends OracleTest {
    public void test_0() throws Exception<nl>
        this.execute("ALTER TABLE TEST_TABLE ADD (TEST_COLUMN NUMBER)");
    <|file_separator|>class OracleAlterTableTest19 extends OracleTest {
    public void test_0() throws Exception {
        this.execute("ALTER TABLE TEST_TABLE ADD (TEST_COLUMN NUMBER)");
    }
}<|file_separator|>class OracleAlterTableTest17 extends OracleTest {
    public void test_0() throws Exception {
        this.execute("ALTER TABLE TEST_TABLE ADD (TEST_COLUMN NUMBER)");
    }
}<|file_separator|>class OracleAlterTableTest16 extends OracleTest {
    public void test_0() throws Exception {
        this.execute("ALTER TABLE TEST_TABLE ADD (TEST_COLUMN NUMBER)");
    }
}<|file_separator|>class OracleAlterTableTest15 extends OracleTest {
    public void test_0() throws Exception {
        this.execute("ALTER TABLE TEST_TABLE ADD (TEST_COLUMN NUMBER)");
    }
}<|file_separator|>class OracleAlterTableTest11 extends OracleTest {
    public void test_0() throws Exception {
        this.execute("ALTER TABLE TEST_TABLE ADD (TEST_COLUMN NUMBER)");
    }
}<|file_separator|>class OracleAlterTableTest10 extends OracleTest {
    public void test_0() throws Exception {
        this.execute("ALTER TABLE TEST_TABLE ADD (TEST_COLUMN NUMBER)");
    }
}<|file_separator|>class OracleAlterTableTest12 extends OracleTest {
    public void test_0() throws Exception {
        this.execute("ALTER TABLE TEST_TABLE ADD (TEST_COLUMN NUMBER)");
    }
}<|file_separator|>class OracleAlterTableTest13 extends OracleTest {
    public void test_0() throws Exception {
        this.execute("ALTER TABLE TEST_TABLE ADD (TEST_COLUMN NUMBER)");
    }
}<|file_separator|>class OracleAlterTableTest14 extends OracleTest {<nl>
        this.execute("ALTER TABLE TEST_TABLE ADD (TEST_COLUMN NUMBER)");
    <|file_separator|>class OracleAlterTableTest10 extends OracleTest {
    public void test_0() throws Exception {
        this.execute("ALTER TABLE TEST_TABLE ADD (TEST_COLUMN NUMBER)");
    }
}<|file_separator|>class OracleAlterTableTest11 extends OracleTest {
    public void test_0() throws Exception {
        this.execute("ALTER TABLE TEST_TABLE ADD (TEST_COLUMN NUMBER)");
    }
}<|file_separator|>class OracleAlterTableTest12 extends OracleTest {
    public void test_0() throws Exception {
        this.execute("ALTER TABLE TEST_TABLE ADD (TEST_COLUMN NUMBER)");
    }
}<|file_separator|>class OracleAlterTableTest13 extends OracleTest {
    public void test_0() throws Exception {
        this.execute("ALTER TABLE TEST_TABLE ADD (TEST_COLUMN NUMBER)");
    }
}<|file_separator|>class OracleAlterTableTest15 extends OracleTest {
    public void test_0() throws Exception {
        this.execute("ALTER TABLE TEST_TABLE ADD (TEST_COLUMN NUMBER)");
    }
}<|file_separator|>class OracleAlterTableTest16 extends OracleTest {
    public void test_0() throws Exception {
        this.execute("ALTER TABLE TEST_TABLE ADD (TEST_COLUMN NUMBER)");
    }
}<|file_separator|>class OracleAlterTableTest17 extends OracleTest {
    public void test_0() throws Exception {
        this.execute("ALTER TABLE TEST_TABLE ADD (TEST_COLUMN NUMBER)");
    }
}<|file_separator|>class OracleAlterTableTest18 extends OracleTest {
    public void test_0() throws Exception {
        this.execute("ALTER TABLE TEST_TABLE ADD (TEST_COLUMN NUMBER)");
    }
}<|file_separator|>class OracleAlterTableTest19 extends OracleTest {<nl>
        this.execute("ALTER TABLE t1 ADD (c1 NUMBER)");
    <|file_separator|>class OracleAlterTableTest10 extends OracleTest {
    public void test_0() throws Exception {
        this.execute("ALTER TABLE t1 ADD (c1 NUMBER)");
    }
}<|file_separator|>class OracleAlterTableTest11 extends OracleTest {
    public void test_0() throws Exception {
        this.execute("ALTER TABLE t1 ADD (c1 NUMBER)");
    }
}<|file_separator|>class OracleAlterTableTest12 extends OracleTest {
    public void test_0() throws Exception {
        this.execute("ALTER TABLE t1 ADD (c1 NUMBER)");
    }
}<|file_separator|>class OracleAlterTableTest13 extends OracleTest {
    public void test_0() throws Exception {
        this.execute("ALTER TABLE t1 ADD (c1 NUMBER)");
    }
}<|file_separator|>class OracleAlterTableTest15 extends OracleTest {
    public void test_0() throws Exception {
        this.execute("ALTER TABLE t1 ADD (c1 NUMBER)");
    }
}<|file_separator|>class OracleAlterTableTest14 extends OracleTest {
    public void test_0() throws Exception {
        this.execute("ALTER TABLE t1 ADD (c1 NUMBER)");
    }
}<|file_separator|>class OracleAlterTableTest16 extends OracleTest {
    public void test_0() throws Exception {
        this.execute("ALTER TABLE t1 ADD (c1 NUMBER)");
    }
}<|file_separator|>class OracleAlterTableTest17 extends OracleTest {
    public void test_0() throws Exception {
        this.execute("ALTER TABLE t1 ADD (c1 NUMBER)");
    }
}<|file_separator|>class OracleAlterTableTest18 extends OracleTest {
    public void test_0() throws Exception {
        this.execute("ALTER<nl>
        String sql = "ALTER TABLE " + this.getTableName() + " RENAME COLUMN " + this.getColumnName() + " TO " + this.getColumnName2();
        this.execute(sql);
    <|file_separator|><nl>
        String sql = "alter table t_user drop constraint pk_t_user";
        this.execute(sql);
    <|file_separator|><nl>
        // TODO
    <|file_separator|><nl>
        // TODO
    <|file_separator|><nl>
        // TODO
    <|file_separator|><nl>
        this.createIndex();
    <|file_separator|>class OracleCreateIndexTest10 extends OracleTest {
    public void test_0() throws Exception {
        this.createIndex();
    }
}<|file_separator|>class OracleCreateIndexTest11 extends OracleTest {
    public void test_0() throws Exception {
        this.createIndex();
    }
}<|file_separator|>class OracleCreateIndexTest12 extends OracleTest {
    public void test_0() throws Exception {
        this.createIndex();
    }
}<|file_separator|>class OracleCreateIndexTest13 extends OracleTest {
    public void test_0() throws Exception {
        this.createIndex();
    }
}<|file_separator|>class OracleCreateIndexTest15 extends OracleTest {
    public void test_0() throws Exception {
        this.createIndex();
    }
}<|file_separator|>class OracleCreateIndexTest16 extends OracleTest {
    public void test_0() throws Exception {
        this.createIndex();
    }
}<|file_separator|>class OracleCreateIndexTest14 extends OracleTest {
    public void test_0() throws Exception {
        this.createIndex();
    }
}<|file_separator|>class OracleCreateIndexTest18 extends OracleTest {
    public void test_0() throws Exception {
        this.createIndex();
    }
}<|file_separator|>class OracleCreateIndexTest19 extends OracleTest {
    public void test_0() throws Exception {
        this.createIndex();
    }
}<|file_separator|>class OracleCreateIndexTest17 extends OracleTest {
    public void test_0() throws Exception {
        this.createIndex();
    }
}<|file_separator|>class OracleCreateIndexTest21 extends OracleTest {
    public void test_0() throws Exception {
        this.createIndex();
    }
}<|file_separator|>class OracleCreateIndexTest22 extends OracleTest {
    public void test_<nl>
        // TODO
    <|file_separator|><nl>
        // TODO
    <|file_separator|><nl>
        // TODO
    <|file_separator|>class OracleCreateTriggerTest1 extends OracleTest {
    public void test_0() throws Exception {
        // TODO
    }
}<|file_separator|><nl>
        String sql = "create type test_type as object (id number, name varchar2(100))";
        this.execute(sql);
    <|file_separator|><nl>
        // TODO: Implement test
    <|file_separator|><nl>
        String sql = "CREATE VIEW v_test AS SELECT * FROM t_test";
        this.execute(sql);
    <|file_separator|><nl>
        String sql = "create table char_types (c1 char(10), c2 char(10), c3 char(10), c4 char(10), c5 char(10), c6 char(10), c7 char(10), c8 char(10), c9 char(10), c10 char(10), c11 char(10), c12 char(10), c13 char(10), c14 char(10), c15 char(10), c16 char(10), c17 char(10), c18 char(10), c19 char(10), c20 char(10), c21 char(10), c22 char(10), c23 char(10), c24 char(10), c25 char(10), c26 char(10), c27 char(10), c28 char(10), c29 char(10), c30 char(10), c31 char(10), c32 char(10), c33 char(10), c34 char(10), c35 char(10), c36 char(10), c37 char(10), c38 char(10), c39 char(10), c40 char(10), c41 char(10), c42 char(10), c43 char(10), c44 char(10), c45 char(10), c46 char(10), c47 char(10), c48 char(10), c49 char(10), c50 char(<nl>
        String sql = "CREATE TABLE test24 (id NUMBER(10), name VARCHAR2(100))";
        this.execute(sql);
    <|file_separator|><nl>
        String sql = "CREATE TABLE test29 (id NUMBER(10), name VARCHAR2(100))";
        this.execute(sql);
    <|file_separator|><nl>
        String sql = "create table test_types (id number(10), name varchar2(100), date_col date)";
        execute(sql);
    <|file_separator|><nl>
        String sql = "create table test_types (id number(10), name varchar2(100), date_col date)";
        this.execute(sql);
    <|file_separator|><nl>
        String sql = "create table test_types (id number(10), name varchar2(100), date_col date, time_col time, timestamp_col timestamp)";
        this.execute(sql);
    <|file_separator|><nl>
        String sql = "CREATE TABLE test_types (id NUMBER, name VARCHAR2(100), date DATE)";
        execute(sql);
    <|file_separator|><nl>
        String sql = "insert into test_table values(1, 'test')";
        int result = this.execute(sql);
        assertEquals(1, result);
    <|file_separator|><nl>
        for (int i = 0; i < 10; i++) {
            System.out.println("Hello World");
        }
    <|file_separator|><nl>
        try {
            throw new Oracle_pl_exception_1();
        } catch (Oracle_pl_exception_1 e) {
            System.out.println("Oracle_pl_exception_1");
        }
    <|file_separator|>class Oracle_pl_exception_1 extends OracleTest {
    public void test_0() throws Exception {
        try {
            throw new Oracle_pl_exception_2();
        } catch (Oracle_pl_exception_2 e) {
            System.out.println("Oracle_pl_exception_2");
        }
    }
}<|file_separator|><nl>
        try {
            throw new Oracle_pl_exception_4();
        } catch (Oracle_pl_exception_4 e) {
            e.printStackTrace();
        }
    <|file_separator|>class Oracle_pl_exception_1 extends OracleTest {
    public void test_0() throws Exception {
        try {
            throw new Oracle_pl_exception_1();
        } catch (Oracle_pl_exception_1 e) {
            e.printStackTrace();
        }
    }
}<|file_separator|>class Oracle_pl_exception_2 extends OracleTest {
    public void test_0() throws Exception {
        try {
            throw new Oracle_pl_exception_2();
        } catch (Oracle_pl_exception_2 e) {
            e.printStackTrace();
        }
    }
}<|file_separator|>class Oracle_pl_exception_3 extends OracleTest {
    public void test_0() throws Exception {
        try {
            throw new Oracle_pl_exception_3();
        } catch (Oracle_pl_exception_3 e) {
            e.printStackTrace();
        }
    }
}<|file_separator|><nl>
        Oracle.pl_if_0();
    <|file_separator|>class Oracle_pl_if_1 extends OracleTest {
    public void test_1() throws Exception {
        Oracle.pl_if_1();
    }
}<|file_separator|>class Oracle_pl_if_2 extends OracleTest {
    public void test_2() throws Exception {
        Oracle.pl_if_2();
    }
}<|file_separator|>class Oracle_pl_if_3 extends OracleTest {
    public void test_3() throws Exception {
        Oracle.pl_if_3();
    }
}<|file_separator|>class Oracle_pl_if_4 extends OracleTest {
    public void test_4() throws Exception {
        Oracle.pl_if_4();
    }
}<|file_separator|>class Oracle_pl_if_5 extends OracleTest {
    public void test_5() throws Exception {
        Oracle.pl_if_5();
    }
}<|file_separator|>class Oracle_pl_if_6 extends OracleTest {
    public void test_6() throws Exception {
        Oracle.pl_if_6();
    }
}<|file_separator|>class Oracle_pl_if_7 extends OracleTest {
    public void test_7() throws Exception {
        Oracle.pl_if_7();
    }
}<|file_separator|>class Oracle_pl_if_8 extends OracleTest {
    public void test_8() throws Exception {
        Oracle.pl_if_8();
    }
}<|file_separator|>class Oracle_pl_if_9 extends OracleTest {
    public void test_9() throws Exception {
        Oracle.pl_if_9();
    }
}<|file_separator|><nl>
        String sql = "SELECT last_name, department_id FROM employees WHERE department_id IN (SELECT department_id FROM employees WHERE last_name = 'Lorentz') ORDER BY last_name, department_id;";

        OracleStatementParser parser = new OracleStatementParser(sql);
        List<SQLStatement> statementList = parser.parseStatementList();

        output(statementList);
    <|file_separator|><nl>
        String sql = "select * from table";
        OracleSelectTest100_var oracleSelectTest100_var = new OracleSelectTest100_var();
        oracleSelectTest100_var.setSql(sql);
        oracleSelectTest100_var.setTableName("table");
        oracleSelectTest100_var.setTableAlias("tableAlias");
        oracleSelectTest100_var.setTableAlias("tableAlias");
        oracleSelectTest100_var.setTableAlias("tableAlias");
        oracleSelectTest100_var.setTableAlias("tableAlias");
        oracleSelectTest100_var.setTableAlias("tableAlias");
        oracleSelectTest100_var.setTableAlias("tableAlias");
        oracleSelectTest100_var.setTableAlias("tableAlias");
        oracleSelectTest100_var.setTableAlias("tableAlias");
        oracleSelectTest100_var.setTableAlias("tableAlias");
        oracleSelectTest100_var.setTableAlias("tableAlias");
        oracleSelectTest100_var.setTableAlias("tableAlias");
        oracleSelectTest100_var.setTableAlias("tableAlias");
        oracleSelectTest100_var.setTableAlias("tableAlias");
        oracleSelectTest100_var.setTableAlias("tableAlias");
        oracleSelectTest100_var.setTableAlias("tableAlias");
        oracleSelectTest100_var.setTableAlias("tableAlias");
        oracleSelectTest100_var.setTableAlias("tableAlias");
        oracleSelectTest100_var.setTableAlias("tableAlias");
        oracleSelect<nl>
        String sql = "select * from t_user";
        List<Map<String, Object>> list = this.query(sql);
        System.out.println(list);
    <|file_separator|><nl>
        String sql = "select * from t1";
        OracleSelectTest12.this.test(sql);
    <|file_separator|><nl>
        String sql = "select * from t_user";
        List<Map<String, Object>> list = this.oracleSelect(sql);
        System.out.println(list);
    <|file_separator|><nl>
        String sql = "select * from t_user";
        List<Map<String, Object>> list = this.oracleSelect(sql);
        System.out.println(list);
    <|file_separator|><nl>
        String sql = "select * from t1";
        OracleSelectTest18.this.test(sql);
    <|file_separator|>class OracleSelectTest17 extends OracleTest {
    public void test_0() throws Exception {
        String sql = "select * from t1";
        OracleSelectTest17.this.test(sql);
    }
}<|file_separator|>class OracleSelectTest15 extends OracleTest {
    public void test_0() throws Exception {
        String sql = "select * from t1";
        OracleSelectTest15.this.test(sql);
    }
}<|file_separator|>class OracleSelectTest16 extends OracleTest {
    public void test_0() throws Exception {
        String sql = "select * from t1";
        OracleSelectTest16.this.test(sql);
    }
}<|file_separator|>class OracleSelectTest11 extends OracleTest {
    public void test_0() throws Exception {
        String sql = "select * from t1";
        OracleSelectTest11.this.test(sql);
    }
}<|file_separator|>class OracleSelectTest10 extends OracleTest {
    public void test_0() throws Exception {
        String sql = "select * from t1";
        OracleSelectTest10.this.test(sql);
    }
}<|file_separator|>class OracleSelectTest12 extends OracleTest {
    public void test_0() throws Exception {
        String sql = "select * from t1";
        OracleSelectTest12.this.test(sql);
    }
}<|file_separator|>class OracleSelectTest13 extends OracleTest {
    public void test_0() throws Exception {
        String sql = "select * from t1";
        OracleSelectTest13.this.test(sql);
    }
}<|file_separator|><nl>
        String sql = "select * from t1";
        OracleSelectTest20.this.test(sql);
    <|file_separator|><nl>
        String sql = "select * from t1";
        OracleSelectTest26.this.test(sql);
    <|file_separator|>class OracleSelectTest25 extends OracleTest {
    public void test_0() throws Exception {
        String sql = "select * from t1";
        OracleSelectTest25.this.test(sql);
    }
}<|file_separator|>class OracleSelectTest24 extends OracleTest {
    public void test_0() throws Exception {
        String sql = "select * from t1";
        OracleSelectTest24.this.test(sql);
    }
}<|file_separator|>class OracleSelectTest21 extends OracleTest {
    public void test_0() throws Exception {
        String sql = "select * from t1";
        OracleSelectTest21.this.test(sql);
    }
}<|file_separator|>class OracleSelectTest15 extends OracleTest {
    public void test_0() throws Exception {
        String sql = "select * from t1";
        OracleSelectTest15.this.test(sql);
    }
}<|file_separator|>class OracleSelectTest14 extends OracleTest {
    public void test_0() throws Exception {
        String sql = "select * from t1";
        OracleSelectTest14.this.test(sql);
    }
}<|file_separator|>class OracleSelectTest19 extends OracleTest {
    public void test_0() throws Exception {
        String sql = "select * from t1";
        OracleSelectTest19.this.test(sql);
    }
}<|file_separator|>class OracleSelectTest16 extends OracleTest {
    public void test_0() throws Exception {
        String sql = "select * from t1";
        OracleSelectTest16.this.test(sql);
    }
}<|file_separator|><nl>
        String sql = "select * from t_user";
        List<Map<String, Object>> list = this.query(sql);
        System.out.println(list);
    <|file_separator|><nl>
        String sql = "select * from table";
        OracleSelectTest30.this.test(sql);
    <|file_separator|><nl>
        String sql = "select * from t1";
        List<Map<String, Object>> list = this.select(sql);
        System.out.println(list);
    <|file_separator|><nl>
        String sql = "select * from t1";
        OracleSelectTest73.this.test(sql);
    <|file_separator|>class OracleSelectTest72 extends OracleTest {
    public void test_0() throws Exception {
        String sql = "select * from t1";
        OracleSelectTest72.this.test(sql);
    }
}<|file_separator|>class OracleSelectTest71 extends OracleTest {
    public void test_0() throws Exception {
        String sql = "select * from t1";
        OracleSelectTest71.this.test(sql);
    }
}<|file_separator|>class OracleSelectTest70 extends OracleTest {
    public void test_0() throws Exception {
        String sql = "select * from t1";
        OracleSelectTest70.this.test(sql);
    }
}<|file_separator|>class OracleSelectTest65 extends OracleTest {
    public void test_0() throws Exception {
        String sql = "select * from t1";
        OracleSelectTest65.this.test(sql);
    }
}<|file_separator|>class OracleSelectTest66 extends OracleTest {
    public void test_0() throws Exception {
        String sql = "select * from t1";
        OracleSelectTest66.this.test(sql);
    }
}<|file_separator|>class OracleSelectTest64 extends OracleTest {
    public void test_0() throws Exception {
        String sql = "select * from t1";
        OracleSelectTest64.this.test(sql);
    }
}<|file_separator|>class OracleSelectTest63 extends OracleTest {
    public void test_0() throws Exception {
        String sql = "select * from t1";
        OracleSelectTest63.this.test(sql);
    }
}<|file_separator|><nl>
        String sql = "select * from t1";
        String sql2 = "select * from t1";
        String sql3 = "select * from t1";
        String sql4 = "select * from t1";
        String sql5 = "select * from t1";
        String sql6 = "select * from t1";
        String sql7 = "select * from t1";
        String sql8 = "select * from t1";
        String sql9 = "select * from t1";
        String sql10 = "select * from t1";
        String sql11 = "select * from t1";
        String sql12 = "select * from t1";
        String sql13 = "select * from t1";
        String sql14 = "select * from t1";
        String sql15 = "select * from t1";
        String sql16 = "select * from t1";
        String sql17 = "select * from t1";
        String sql18 = "select * from t1";
        String sql19 = "select * from t1";
        String sql20 = "select * from t1";
        String sql21 = "select * from t1";
        String sql22 = "select * from t1";
        String sql23 = "select * from t1";
        String sql24 = "select * from t1";
        String sql25 = "select * from t1";
        String sql26 = "select * from t1";
        String sql27 = "select * from t1";
        String sql28 = "select * from t1";
        String sql29 = "select * from t1";
        String sql<nl>
        String sql = "select * from t1";
        OracleSelectTest77.this.test(sql);
    <|file_separator|>class OracleSelectTest76 extends OracleTest {
    public void test_0() throws Exception {
        String sql = "select * from t1";
        OracleSelectTest76.this.test(sql);
    }
}<|file_separator|>class OracleSelectTest75 extends OracleTest {
    public void test_0() throws Exception {
        String sql = "select * from t1";
        OracleSelectTest75.this.test(sql);
    }
}<|file_separator|>class OracleSelectTest72 extends OracleTest {
    public void test_0() throws Exception {
        String sql = "select * from t1";
        OracleSelectTest72.this.test(sql);
    }
}<|file_separator|>class OracleSelectTest71 extends OracleTest {
    public void test_0() throws Exception {
        String sql = "select * from t1";
        OracleSelectTest71.this.test(sql);
    }
}<|file_separator|>class OracleSelectTest69 extends OracleTest {
    public void test_0() throws Exception {
        String sql = "select * from t1";
        OracleSelectTest69.this.test(sql);
    }
}<|file_separator|>class OracleSelectTest68 extends OracleTest {
    public void test_0() throws Exception {
        String sql = "select * from t1";
        OracleSelectTest68.this.test(sql);
    }
}<|file_separator|>class OracleSelectTest70 extends OracleTest {
    public void test_0() throws Exception {
        String sql = "select * from t1";
        OracleSelectTest70.this.test(sql);
    }
}<|file_separator|><nl>
        String sql = "select * from table";
        String[] params = {"1"};
        List<Map<String, Object>> list = this.query(sql, params);
        this.log(list);
    <|file_separator|><nl>
        OracleOutputVisitor visitor = new OracleOutputVisitor();
        String sql = "select * from table";
        String result = visitor.visit(sql);
        assertEquals("select * from table", result);
    <|file_separator|><nl>
        OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();
        visitor.visit(new OracleSchemaStatVisitor.Subquery());
    <|file_separator|>class OracleSchemaStatVisitorTest_Table.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>package oracle.jdbc.driver.internal.OracleSchemaStatVisitorTest;

import oracle.jdbc.driver.internal.OracleSchemaStatVisitor;
import oracle.jdbc.driver.internal.OracleSchemaStatVisitor.Table;
import oracle.jdbc.driver.internal.OracleSchemaStatVisitorTest.OracleSchemaStatVisitorTest;
import oracle.jdbc.driver.internal.OracleSchemaStatVisitorTest.OracleSchemaStatVisitorTest.Table;
import oracle.jdbc.driver.internal.OracleSchemaStatVisitorTest.OracleSchemaStatVisitorTest.Table;
import oracle.jdbc.driver.internal.OracleSchemaStatVisitorTest.OracleSchemaStatVisitorTest.Table;
import oracle.jdbc.driver.internal.OracleSchemaStatVisitorTest.OracleSchemaStatVisitorTest.Table;
import oracle.jdbc.driver.internal.OracleSchemaStatVisitorTest.OracleSchemaStatVisitorTest.Table;
import oracle.jdbc.driver.internal.OracleSchemaStatVisitorTest.OracleSchemaStatVisitorTest.Table;
import oracle.jdbc.driver.internal.OracleSchemaStatVisitorTest.OracleSchemaStatVisitorTest.Table;
import oracle.jdbc.driver.internal.OracleSchemaStatVisitorTest.OracleSchemaStatVisitorTest.Table;
import oracle.jdbc.driver.internal.OracleSchemaStatVisitorTest.OracleSchemaStatVisitorTest.Table;
import oracle.jdbc.driver.internal.OracleSchemaStatVisitorTest.OracleSchemaStatVisitorTest.Table;
import oracle.jdbc.driver.internal.OracleSchemaStatVisitorTest.OracleSchemaStatVisitorTest.Table;
import oracle.jdbc.driver.internal.OracleSchemaStatVisitorTest.OracleSchemaStatVisitorTest<nl>
        // ...
    <|file_separator|><nl>
        // TODO: implement
    <|file_separator|><nl>
        String sql = "CREATE TABLE test_5 (id INT)";
        PGConnection connection = getConnection();
        PGStatement statement = connection.createStatement();
        statement.execute(sql);
        PGResultSet result = statement.getResultSet();
        assertEquals(true, result.next());
    <|file_separator|><nl>
        this.pg.create_table("test", "id int");
    <|file_separator|><nl>
        // TODO: implement
    <|file_separator|><nl>
        PGConnection conn = getConnection();
        conn.setSchema("public");
        conn.execute("DROP FUNCTION IF EXISTS test_function()");
    <|file_separator|><nl>
        PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest.PGTest<nl>
        PGInsertTest5 pgInsertTest5 = new PGInsertTest5();
        pgInsertTest5.test_0();
    <|file_separator|><nl>
        BitString bs = new BitString(10);
        bs.set(1);
        bs.set(2);
        bs.set(3);
        bs.set(4);
        bs.set(5);
        bs.set(6);
        bs.set(7);
        bs.set(8);
        bs.set(9);
        bs.set(10);
        bs.set(11);
        bs.set(12);
        bs.set(13);
        bs.set(14);
        bs.set(15);
        bs.set(16);
        bs.set(17);
        bs.set(18);
        bs.set(19);
        bs.set(20);
        bs.set(21);
        bs.set(22);
        bs.set(23);
        bs.set(24);
        bs.set(25);
        bs.set(26);
        bs.set(27);
        bs.set(28);
        bs.set(29);
        bs.set(30);
        bs.set(31);
        bs.set(32);
        bs.set(33);
        bs.set(34);
        bs.set(35);
        bs.set(36);
        bs.set(37);
        bs.set(38);
        bs.set(39);
        bs.set(40);
        bs.set(41);
        bs.set(42);
        bs.set(43);
        bs.set(44);<nl>
        this.alterTableAddFk("test_table", "test_table_id", "test_table_id", "test_table_id", "test_table_id", "test_table_id", "test_table_id", "test_table_id", "test_table_id", "test_table_id", "test_table_id", "test_table_id", "test_table_id", "test_table_id", "test_table_id", "test_table_id", "test_table_id", "test_table_id", "test_table_id", "test_table_id", "test_table_id", "test_table_id", "test_table_id", "test_table_id", "test_table_id", "test_table_id", "test_table_id", "test_table_id", "test_table_id", "test_table_id", "test_table_id", "test_table_id", "test_table_id", "test_table_id", "test_table_id", "test_table_id", "test_table_id", "test_table_id", "test_table_id", "test_table_id", "test_table_id", "test_table_id", "test_table_id", "test_table_id", "test_table_id", "test_table_id", "test_table_id", "test_table_id", "test_table_id", "test_table_id", "test_table_id", "test_table_id", "test_table_id", "test_table_id", "test_table_id", "test_table_id", "test<nl>
        this.alterTableAlterColumn();
    <|file_separator|>class PGAlterTableAlterColumnTest1 extends PGTest {
    public void test_1() throws Exception {
        this.alterTableAlterColumn();
    }
}<|file_separator|>class PGAlterTableAlterColumnTest2 extends PGTest {
    public void test_2() throws Exception {
        this.alterTableAlterColumn();
    }
}<|file_separator|>class PGAlterTableAlterColumnTest3 extends PGTest {
    public void test_3() throws Exception {
        this.alterTableAlterColumn();
    }
}<|file_separator|>class PGAlterTableAlterColumnTest4 extends PGTest {
    public void test_4() throws Exception {
        this.alterTableAlterColumn();
    }
}<|file_separator|><nl>
        this.alterTableDropColumn();
    <|file_separator|>class PGAlterTableAddColumnTest0 extends PGTest {
    public void test_0() throws Exception {
        this.alterTableAddColumn();
    }
}<|file_separator|>class PGAlterTableAddConstraintTest0 extends PGTest {
    public void test_0() throws Exception {
        this.alterTableAddConstraint();
    }
}<|file_separator|>class PGAlterTableAddConstraintTest1 extends PGTest {
    public void test_1() throws Exception {
        this.alterTableAddConstraint();
    }
}<|file_separator|>class PGAlterTableAddConstraintTest2 extends PGTest {
    public void test_2() throws Exception {
        this.alterTableAddConstraint();
    }
}<|file_separator|>class PGAlterTableAddConstraintTest3 extends PGTest {
    public void test_3() throws Exception {
        this.alterTableAddConstraint();
    }
}<|file_separator|>class PGAlterTableAddConstraintTest4 extends PGTest {
    public void test_4() throws Exception {
        this.alterTableAddConstraint();
    }
}<|file_separator|>class PGAlterTableAddConstraintTest5 extends PGTest {
    public void test_5() throws Exception {
        this.alterTableAddConstraint();
    }
}<|file_separator|>class PGAlterTableAddConstraintTest6 extends PGTest {
    public void test_6() throws Exception {
        this.alterTableAddConstraint();
    }
}<|file_separator|>class PGAlterTableAddConstraintTest7 extends PGTest {
    public void test_7() throws Exception {
        this.alterTableAddConstraint();
    }
}<|file_separator|>class PGAlterTableAddConstraintTest8 extends PGTest {
    public void test_8() throws Exception {
        this.alterTableAddConstraint();
    }
}<|file_separator|>class PGAlterTableAddConstraintTest9 extends PG<nl>
        PGConnection conn = getConnection();
        conn.setDatabaseName("postgres");
        conn.setPort(5432);
        conn.setDatabaseName("postgres");
        conn.setPort(5432);
        conn.setDatabaseName("postgres");
        conn.setPort(5432);
        conn.setDatabaseName("postgres");
        conn.setPort(5432);
        conn.setDatabaseName("postgres");
        conn.setPort(5432);
        conn.setDatabaseName("postgres");
        conn.setPort(5432);
        conn.setDatabaseName("postgres");
        conn.setPort(5432);
        conn.setDatabaseName("postgres");
        conn.setPort(5432);
        conn.setDatabaseName("postgres");
        conn.setPort(5432);
        conn.setDatabaseName("postgres");
        conn.setPort(5432);
        conn.setDatabaseName("postgres");
        conn.setPort(5432);
        conn.setDatabaseName("postgres");
        conn.setPort(5432);
        conn.setDatabaseName("postgres");
        conn.setPort(5432);
        conn.setDatabaseName("postgres");
        conn.setPort(5432);
        conn.setDatabaseName("postgres");
        conn.setPort(5432);
        conn.setDatabaseName("postgres");
        conn.setPort(5432);
        conn.setDatabaseName("postgres");
        conn.setPort(5432);
        conn.setDatabaseName("postgres");
        conn.setPort(5<nl>
        PGSelectTest12.test_0();
    <|file_separator|>class PGSelectTest12.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class PGSelectTest12 extends PGTest {
    public void test_0() throws Exception {
        PGSelectTest11.test_0();
    }
}<|file_separator|>class PGSelectTest11.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class PGSelectTest11 extends PGTest {
    public void test_0() throws Exception {
        PGSelectTest10.test_0();
    }
}<|file_separator|>class PGSelectTest10.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class PGSelectTest10 extends PGTest {
    public void test_0() throws Exception {
        PGSelectTest9.test_0();
    }
}<|file_separator|>class PGSelectTest9.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class PGSelectTest9 extends PGTest {
    public void test_0() throws Exception {
        PGSelectTest8.test_0();
    }
}<|file_separator|>class PGSelectTest8.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class PGSelectTest8 extends PGTest {
    public void test_0() throws Exception {
        PGSelectTest7.test_0();
    }
}<|file_separator|>class PGSelectTest7.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class PGSelectTest7 extends PGTest {
    public void test_0() throws Exception {
        PGSelectTest6.test_0();
    }
}<|file_separator|>class PGSelectTest6.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class PGSelectTest6 extends PGTest {
    public void test_0() throws Exception {
        PGSelectTest5.test_0();
    }
}<|file_separator|>class PGSelectTest5.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class PGSelectTest5 extends PGTest {
    public void test_0() throws Exception {
        <nl>
        PGSelectTest23 pgSelectTest23 = new PGSelectTest23();
        pgSelectTest23.test_0();
    <|file_separator|>class PGSelectTest22.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class PGSelectTest22 {
    public void test_0() throws Exception {
        System.out.println("PGSelectTest22.test_0");
    }
}<|file_separator|>class PGSelectTest23.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class PGSelectTest23 {
    public void test_0() throws Exception {
        System.out.println("PGSelectTest23.test_0");
    }
}<|file_separator|>class PGSelectTest21.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class PGSelectTest21 {
    public void test_0() throws Exception {
        System.out.println("PGSelectTest21.test_0");
    }
}<|file_separator|><nl>
        PGSelectTest24.test_0();
    <|file_separator|>class PGSelectTest24.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class PGSelectTest24 extends PGTest {
    public void test_0() throws Exception {
        PGSelectTest23.test_0();
    }
}<|file_separator|>class PGSelectTest23.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class PGSelectTest23 extends PGTest {
    public void test_0() throws Exception {
        PGSelectTest22.test_0();
    }
}<|file_separator|>class PGSelectTest22.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class PGSelectTest22 extends PGTest {
    public void test_0() throws Exception {
        PGSelectTest21.test_0();
    }
}<|file_separator|>class PGSelectTest21.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class PGSelectTest21 extends PGTest {
    public void test_0() throws Exception {
        PGSelectTest20.test_0();
    }
}<|file_separator|>class PGSelectTest20.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class PGSelectTest20 extends PGTest {
    public void test_0() throws Exception {
        PGSelectTest19.test_0();
    }
}<|file_separator|><nl>
        PGSelectTest28 pgSelectTest28 = new PGSelectTest28();
        pgSelectTest28.test_0();
    <|file_separator|>class PGSelectTest28.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class PGSelectTest28 extends PGSelectTest27 {
    public void test_0() throws Exception {
        PGSelectTest27 pgSelectTest27 = new PGSelectTest27();
        pgSelectTest27.test_0();
    }
}<|file_separator|>class PGSelectTest27.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class PGSelectTest27 extends PGSelectTest26 {
    public void test_0() throws Exception {
        PGSelectTest26 pgSelectTest26 = new PGSelectTest26();
        pgSelectTest26.test_0();
    }
}<|file_separator|>class PGSelectTest26.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class PGSelectTest26 extends PGSelectTest25 {
    public void test_0() throws Exception {
        PGSelectTest25 pgSelectTest25 = new PGSelectTest25();
        pgSelectTest25.test_0();
    }
}<|file_separator|>class PGSelectTest25.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class PGSelectTest25 extends PGSelectTest24 {
    public void test_0() throws Exception {
        PGSelectTest24 pgSelectTest24 = new PGSelectTest24();
        pgSelectTest24.test_0();
    }
}<|file_separator|>class PGSelectTest24.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class PGSelectTest24 extends PGSelectTest23 {
    public void test_0() throws Exception {
        PGSelectTest23 pgSelectTest23 = new PGSelectTest23();
        pgSelectTest23.<nl>
        String sql = "select * from pg_catalog.pg_tables";
        List<Map<String, Object>> list = this.query(sql);
        this.log(list);
    <|file_separator|><nl>
        String sql = "select * from test_table";
        List<Map<String, Object>> list = this.getJdbcTemplate().queryForList(sql);
        this.assertEquals(list.size(), 1);
    <|file_separator|><nl>
        String sql = "select * from test_table";
        List<Map<String, Object>> list = this.getJdbcTemplate().queryForList(sql);
        System.out.println(list);
    <|file_separator|><nl>
        $this->assertEquals(1, 1);
    <|file_separator|><nl>
        assertEquals(1, 1);
    <|file_separator|><nl>
        $this->assertEquals(1, 1);
    <|file_separator|><nl>
        PGSelectTest8 pgSelectTest8 = new PGSelectTest8();
        pgSelectTest8.test_0();
    <|file_separator|>class PGSelectTest11 extends PGTest {
    public void test_0() throws Exception {
        PGSelectTest11 pgSelectTest11 = new PGSelectTest11();
        pgSelectTest11.test_0();
    }
}<|file_separator|>class PGSelectTest10 extends PGTest {
    public void test_0() throws Exception {
        PGSelectTest10 pgSelectTest10 = new PGSelectTest10();
        pgSelectTest10.test_0();
    }
}<|file_separator|>class PGSelectTest1 extends PGTest {
    public void test_0() throws Exception {
        PGSelectTest1 pgSelectTest1 = new PGSelectTest1();
        pgSelectTest1.test_0();
    }
}<|file_separator|>class PGSelectTest12 extends PGTest {
    public void test_0() throws Exception {
        PGSelectTest12 pgSelectTest12 = new PGSelectTest12();
        pgSelectTest12.test_0();
    }
}<|file_separator|>class PGSelectTest13 extends PGTest {
    public void test_0() throws Exception {
        PGSelectTest13 pgSelectTest13 = new PGSelectTest13();
        pgSelectTest13.test_0();
    }
}<|file_separator|>class PGSelectTest15 extends PGTest {
    public void test_0() throws Exception {
        PGSelectTest15 pgSelectTest15 = new PGSelectTest15();
        pgSelectTest15.test_0();
    }
}<|file_separator|>class PGSelectTest14 extends PGTest {
    public void test_0() throws Exception<nl>
        String sql = "select * from test_a where id=(select id from test_b where id = 1) union all select * from test_c";
        String targetSql = "(SELECT id, namen"
                + "FROM t1)n"
                + "UNIONn"
                + "(SELECT id, namen"
                + "FROM t2)";

        com.alibaba.druid.sql.dialect.postgresql.parser.PGSQLStatementParser pgparser=new com.alibaba.druid.sql.dialect.postgresql.parser.PGSQLStatementParser(sql);
        com.alibaba.druid.sql.ast.SQLStatement pgstatement = pgparser.parseStatement();
        Assert.assertEquals(targetSql, pgstatement.toString());
        System.out.println(pgstatement.toString());
    <|file_separator|><nl>
        exec_test("bvt/parser/trino/tpcds/q81.sql");
    <|file_separator|><nl>
        SchemaStat schemaStat = new SchemaStat();
        schemaStat.setSchema("test");
        schemaStat.setTable("test");
        schemaStat.setStat("test");
        schemaStat.setStat("test");
        schemaStat.setStat("test");
        schemaStat.setStat("test");
        schemaStat.setStat("test");
        schemaStat.setStat("test");
        schemaStat.setStat("test");
        schemaStat.setStat("test");
        schemaStat.setStat("test");
        schemaStat.setStat("test");
        schemaStat.setStat("test");
        schemaStat.setStat("test");
        schemaStat.setStat("test");
        schemaStat.setStat("test");
        schemaStat.setStat("test");
        schemaStat.setStat("test");
        schemaStat.setStat("test");
        schemaStat.setStat("test");
        schemaStat.setStat("test");
        schemaStat.setStat("test");
        schemaStat.setStat("test");
        schemaStat.setStat("test");
        schemaStat.setStat("test");
        schemaStat.setStat("test");
        schemaStat.setStat("test");
        schemaStat.setStat("test");
        schemaStat.setStat("test");
        schemaStat.setStat("test");
        schemaStat.setStat("test");
        schemaStat.setStat("test");
        schemaStat.setStat("test");
        schemaStat.setStat("test");
        schemaStat.setStat("test");
        schemaStat.setStat("test");
        schemaStat.setStat("test");
        schemaStat.setStat("test");
        schemaStat.setStat("test<nl>
        // TODO
    <|file_separator|><nl>
        String sql = "SELECT * FROM table";
        String result = this.jdbcTemplate.queryForObject(sql, String.class);
        assertEquals("test", result);
    <|file_separator|><nl>
        String sql = "SELECT * FROM table";
        String result = this.jdbcTemplate.queryForObject(sql, String.class);
        assertEquals("test", result);
    <|file_separator|><nl>
        $this->assertEquals(1, 1);
    <|file_separator|><nl>
        String sql = "select * from t1";
        String sql2 = "select * from t2";
        String sql3 = "select * from t3";
        String sql4 = "select * from t4";
        String sql5 = "select * from t5";
        String sql6 = "select * from t6";
        String sql7 = "select * from t7";
        String sql8 = "select * from t8";
        String sql9 = "select * from t9";
        String sql10 = "select * from t10";
        String sql11 = "select * from t11";
        String sql12 = "select * from t12";
        String sql13 = "select * from t13";
        String sql14 = "select * from t14";
        String sql15 = "select * from t15";
        String sql16 = "select * from t16";
        String sql17 = "select * from t17";
        String sql18 = "select * from t18";
        String sql19 = "select * from t19";
        String sql20 = "select * from t20";
        String sql21 = "select * from t21";
        String sql22 = "select * from t22";
        String sql23 = "select * from t23";
        String sql24 = "select * from t24";
        String sql25 = "select * from t25";
        String sql26 = "select * from t26";
        String sql27 = "select * from t27";
        String sql28 = "select * from t28<nl>
        $this->assertEquals(true, $this->db->isEmpty());
    <|file_separator|><nl>
        Connection connection = provider.getConnection();
        assertNotNull(connection);
    <|file_separator|><nl>
        this.assertEquals("Mozilla/5.0 (Linux; U; Android 4.2; en-us; GT-I9100 Build/JZO54K) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30", this.userAgent.get("Mozilla/5.0 (Linux; U; Android 4.2; en-us; GT-I9100 Build/JZO54K) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30"));
    <|file_separator|>class UserAgentAndroid_4_2_Test_1 extends TestCase {
    public void test_mac_firefox() throws Exception {
        this.assertEquals("Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36", this.userAgent.get("Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36"));
    }
}<|file_separator|><nl>
        $this->assertEquals('Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.143 Safari/537.36', $this->userAgent->get('firefox'));
    <|file_separator|><nl>
        $this->assertEquals('Mozilla/5.0 (Windows NT 6.3; WOW64; Trident/7.0; rv:11.0) like Gecko', $this->userAgent->get('mac', 'firefox'));
    <|file_separator|><nl>
        String json = "{\"name\":\"John\", \"age\":30}";
        JSONParser parser = new JSONParser();
        JSONObject obj = (JSONObject) parser.parse(json);
        assertEquals("John", obj.get("name"));
        assertEquals(30, obj.get("age"));
    <|file_separator|><nl>
    <|file_separator|><nl>
        String[] conditions = {
            "id = 1",
            "id = 2",
            "id = 3",
            "id = 4",
            "id = 5",
            "id = 6",
            "id = 7",
            "id = 8",
            "id = 9",
            "id = 10",
            "id = 11",
            "id = 12",
            "id = 13",
            "id = 14",
            "id = 15",
            "id = 16",
            "id = 17",
            "id = 18",
            "id = 19",
            "id = 20",
            "id = 21",
            "id = 22",
            "id = 23",
            "id = 24",
            "id = 25",
            "id = 26",
            "id = 27",
            "id = 28",
            "id = 29",
            "id = 30",
            "id = 31",
            "id = 32",
            "id = 33",
            "id = 34",
            "id = 35",
            "id = 36",
            "id = 37",
            "id = 38",
            "id = 39",
            "id = 40",
            "id = 41",
            "id = 42",
            "id = 43",
            "id = 44",
            "id = <nl>
        DruidLobCreator lobCreator = new DruidLobCreator(dataSource);
        lobCreator.createLob();
    <|file_separator|><nl>
        Assert.assertTrue(JdbcUtils.createDriver(classLoader, MockDriver.class.getName()) instanceof MockDriver);
    }
<|file_separator|><nl>
        String sql = "set  tx_variables = 1,session asdfsa = 2,session dfd  = 3 ";
        SQLStatementParser parser = new MySqlStatementParser(sql);
        List<SQLStatement> stmtList = parser.parseStatementList();

        SQLSetStatement result = (SQLSetStatement) stmtList.get(0);

        Assert.assertTrue(result.getItems().size() == 3);
    <|file_separator|><nl>
        String sql = "select * from t_user";
        String createTableScript = getCreateTableScript(sql);
        System.out.println(createTableScript);
    <|file_separator|><nl>
        super.setUp();
        dataSource = new DruidDataSource();
        dataSource.setDriver(new MyDriver());
        dataSource.setUrl("jdbc:mysql://localhost:3306/test");
        dataSource.setUsername("root");
        dataSource.setPassword("root");
    <|file_separator|><nl>
        for (int i = 0; i < threadCount; ++i) {
            new Thread() {
                public void run() {
                    try {
                        Connection conn = dataSource.getConnection();
                        conn.close();
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            }.start();
        }
    <|file_separator|><nl>
        DruidPooledConnection connection = dataSource.getConnection();
        connection.close();
    <|file_separator|><nl>
        if (value == null) {
            return;
        }
        if (value instanceof String) {
            fields.get(fieldName).setText((String) value);
        } else {
            fields.get(fieldName).setText(value.toString());
        }
    <|file_separator|><nl>
        Connection conn = DriverManager.getConnection(jdbcUrl, user, password);
        conn.close();
    <|file_separator|><nl>
        return (Boolean) getSqlMapClientTemplate().queryForObject("Sequence.compareAndSet", new Object[]{name, value, expect});
    }

    public void set(String name, int value) {
        getSqlMapClientTemplate().update("Sequence.set", new Object[]{name, value});
    <|file_separator|><nl>
        lock.lock();
        try {
            return dao.getValue(name);
        } finally {
            lock.unlock();
        }
    <|file_separator|><nl>
        this.getSqlMapClientTemplate().insert("addUser", user);
    <|file_separator|><nl>
        String[] words = {"the", "quick", "brown", "fox", "jumps", "over", "the", "lazy", "dog"};
        String[] expected = {"brown", "dog", "fox", "jumps", "lazy", "over", "quick", "the", "the"};
        String[] actual = sort(words);
        assertArrayEquals(expected, actual);
    <|file_separator|><nl>
        StringBuilder out = new StringBuilder();
        PGOutputVisitor visitor = new PGOutputVisitor(out);

        for (SQLStatement stmt : stmtList) {
            stmt.accept(visitor);
        }

        System.out.println(out.toString());
    <|file_separator|><nl>
        
    <|file_separator|><nl>
        HiveStatementParser parser = new HiveStatementParser();
        parser.addStatement("add jar hdfs:///hadoop/parser.h.file");
        assertEquals("add jar hdfs:///hadoop/parser.h.file", parser.getStatement());
    <|file_separator|><nl>
        String sql = "select * from user where uid = :uid";
        SQLParser parser = new SQLParser();
        SQLStatement stmt = parser.parse(sql);
        GetVariantVisitor visitor = new GetVariantVisitor();
        stmt.accept(visitor);
        int varIndex = visitor.getVarIndex();
        List<SQLVariantRefExpr> variantList = visitor.getVariantList();
        for (SQLVariantRefExpr variant : variantList) {
            variant.getAttributes().put("varIndex", varIndex++);
        }
        SQLStatement stmt2 = parser.parse(sql);
        stmt2.accept(new MyOracleVisitor("user"));
    <|file_separator|><nl>
        mergValidate("select * from t1", "select * from t1");
    <|file_separator|><nl>
        String sqlStr = "SELECT n" +
                "test1, -- test1n" +
                "test2 -- test2n" +
                "FROM n" +
                "S371_BSD_O_IDCS";
        SQLStatement sqlStatement1 = SQLUtils.parseSingleStatement(sqlStr, DbType.db2, true);
        System.out.println(sqlStatement1);
    <|file_separator|><nl>
        String sql = "select * from table group by column";
        String result = this.sqlserver.query(sql);
        assertEquals(result, "select * from table group by column");
    <|file_separator|><nl>
        A a = new A();
        for (int i = 0; i < 100000000; ++i) {
            a.v = i;
        }
        gc();
    <|file_separator|><nl>
        $this->assertEquals(1, 1);
    <|file_separator|><nl>
        WallProvider provider = new MySqlWallProvider();

        provider.getConfig().setConditionDoubleConstAllow(true);

        provider.getConfig().setUseAllow(true);
        provider.getConfig().setStrictSyntaxCheck(false);
        provider.getConfig().setMultiStatementAllow(true);
        provider.getConfig().setConditionAndAlwayTrueAllow(true);
        provider.getConfig().setNoneBaseStatementAllow(true);
        provider.getConfig().setSelectUnionCheck(false);
        provider.getConfig().setSchemaCheck(true);
        provider.getConfig().setLimitZeroAllow(true);
        provider.getConfig().setCommentAllow(true);

        for (int i = 0; i < items.length; ++i) {
            String sql = items[i];
            if (sql.indexOf("''=''") != -1) {
                continue;
            }
//            if (i <= 121) {
//                continue;
//            }
            WallCheckResult result = provider.check(sql);
            if (result.getViolations().size() > 0) {
                Violation violation = result.getViolations().get(0);
                System.out.println("error (" + i + ") : " + violation.getMessage());
                System.out.println(sql);
                break;
            }
        }
        System.out.println(provider.getViolationCount());
//        String sql = "SELECT name, '******' password, createTime from user where name like 'admin' AND (CASE WHEN (7885=7885) THEN 1 ELSE 0 END)";

//        Assert.assertFalse(provider.checkValid(sql));
    <|file_separator|><nl>
        wallResult.setSum(sumResult.getSum());
        wallResult.setSumCount(sumResult.getSumCount());
    }
}<|file_separator|><nl>
		if (owner.getLastName() == null) {
			result.rejectValue("lastName", "error.owner", "Last name is required");
		}
		if (result.hasErrors()) {
			return "owners/findOwners";
		}
		else {
			Page<Owner> paginated = findPaginatedForOwnersLastName(page, owner.getLastName());
			return addPaginationModel(page, model, paginated);
		}
	<|file_separator|><nl>
		return owners.findByName(text).orElseThrow(() -> new ParseException("No owner found for name " + text, 0));<|file_separator|><nl>
        return new DruidDataSourceWrapper();
    <|file_separator|><nl>
                super.init(dataSourceProxy);
                logger.info("init");
            }

            @Override
            public void destroy(){
                super.destroy();
                logger.info("destroy");
            <|file_separator|><nl>
        DruidDataSource dataSource = new DruidDataSource();
        dataSource.setDriverClassName("com.mysql.jdbc.Driver");
        dataSource.setUrl("jdbc:mysql://localhost:3306/test");
        dataSource.setUsername("root");
        dataSource.setPassword("root");
        dataSource.setTestWhileIdle(true);
        dataSource.setTestOnBorrow(true);
        dataSource.setTestOnReturn(true);
        dataSource.setValidationQuery("select 1");
        dataSource.setValidationInterval(1000);
        dataSource.setTimeBetweenEvictionRunsMillis(1000);
        dataSource.setMaxActive(10);
        dataSource.setInitialSize(10);
        dataSource.setMaxWait(1000);
        dataSource.setRemoveAbandonedTimeout(1000);
        dataSource.setRemoveAbandoned(true);
        dataSource.setLogAbandoned(true);
        dataSource.setJdbcInterceptors("org.apache.commons.dbcp.PoolingDataSourceInterceptor");
        dataSource.setPoolPreparedStatements(true);
        dataSource.setMaxOpenPreparedStatements(10);
        dataSource.setFilters("stat");
        dataSource.setConnectionProperties("druid.stat.mergeSql=true");
        dataSource.setConnectionProperties("druid.stat.slowSqlMillis=1000");
        dataSource.setConnectionProperties("druid.stat.logSlowSql=true");
        dataSource.setConnectionProperties("druid.stat.logSlowSql=true");
        dataSource.setConnectionProperties("druid.stat.logSlowSql=true");
        dataSource.setConnectionProperties("druid.stat.logSlowSql=true");
        dataSource.setConnectionProperties("druid.stat.logSlowSql=true");
        dataSource.setConnectionProperties("druid.stat.logSlowSql=true<nl>
        return userDao.findById(id);
    }

    @Override
    public List<User> findAll() {
        return userDao.findAll();
    }

    @Override
    public void save(User user) {
        userDao.save(user);
    }

    @Override
    public void delete(Long id) {
        userDao.delete(id);
    <|file_separator|><nl>
        assertThat(dataSourceTwo.getUrl()).isEqualTo("jdbc:h2:file:./demo-db;NON_KEYWORDS=user");
        assertThat(dataSourceTwo.getUsername()).isEqualTo("sa");
        assertThat(dataSourceTwo.getPassword()).isEqualTo("sa");
        assertThat(dataSourceTwo.getDriverClassName()).isEqualTo("org.h2.Driver");

        assertThat(dataSourceTwo.getInitialSize()).isEqualTo(5);

        assertThat(dataSourceTwo.getMaxActive()).isEqualTo(10);
        assertThat(dataSourceTwo.getMaxWait()).isEqualTo(10000);
    <|file_separator|><nl>
        try {
            if (xlsReadContext.readWorkbookHolder().getActualSheetDataList() == null) {
                new XlsListSheetListener(xlsReadContext).execute();
            }
        } catch (ExcelAnalysisStopException e) {
            if (LOGGER.isDebugEnabled()) {
                LOGGER.debug("Custom stop!");
            }
        }
    <|file_separator|><nl>
        if (record.get("Sst") == null) {
            return;
        }
        if (record.get("Sst") == "1") {
            record.set("Sst", "1");
        } else {
            record.set("Sst", "0");
        }
    <|file_separator|><nl>
        String value = record.getStringValue();
        if (value == null) {
            LOGGER.warn("Record is null");
        } else {
            LOGGER.info("Record: {}", value);
        }
    <|file_separator|><nl>
        return false;
    <|file_separator|><nl>
        String url = attributes.getValue("HREF");
        xlsxReadContext.getWorkbookHolder().getExtraWriteSet().add(new Hyperlink(url));
    <|file_separator|><nl>
        return BigDecimal.class;
    <|file_separator|><nl>
        return new WriteCellData<>(value.toString());
    <|file_separator|><nl>
        return new WriteCellData<>(value.getTime());
    <|file_separator|><nl>
        return NumberUtils.readCellDataAsDouble(cellData, contentProperty);
    <|file_separator|><nl>
        return Integer.class;
    <|file_separator|><nl>
        return DateUtils.parseDate(cellData.getStringValue(),
            contentProperty.getDateTimeFormatProperty().getFormat(),
            globalConfiguration.getLocale());
    <|file_separator|><nl>
        this.type = type;
    <|file_separator|><nl>
        return newInstance(numberValue, rowIndex, columnIndex);
    <|file_separator|><nl>
        return new DateTimeFormatProperty(dateTimeFormat.getFormat(), dateTimeFormat.getUse1904Windowing());
    <|file_separator|><nl>
        return new LoopMergeProperty(contentLoopMerge.getEachRow(), contentLoopMerge.getColumnExtend());
    <|file_separator|><nl>
        super.copyBasicParameter(other);
        this.sheetNo = other.sheetNo;
        this.sheetName = other.sheetName;
    <|file_separator|>class ReadBasicParameter.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class ReadBasicParameter {
    /**
     * Starting from 0
     */
    private Integer startRow;
    /**
     * Starting from 0
     */
    private Integer startCol;
    /**
     * Ending from 0
     */
    private Integer endRow;
    /**
     * Ending from 0
     */
    private Integer endCol;

    public ReadBasicParameter() {}

    public ReadBasicParameter(Integer startRow, Integer startCol, Integer endRow, Integer endCol) {
        this.startRow = startRow;
        this.startCol = startCol;
        this.endRow = endRow;
        this.endCol = endCol;
    }

    public Integer getStartRow() {
        return startRow;
    }

    public void setStartRow(Integer startRow) {
        this.startRow = startRow;
    }

    public Integer getStartCol() {
        return startCol;
    }

    public void setStartCol(Integer startCol) {
        this.startCol = startCol;
    }

    public Integer getEndRow() {
        return endRow;
    }

    public void setEndRow(Integer endRow) {
        this.endRow = endRow;
    }

    public Integer getEndCol() {
        return endCol;
    }

    public void setEndCol(Integer endCol) {
        this.endCol = endCol;
    }

    public void copyBasicParameter(ReadBasicParameter other) {
        this.<nl>
        return HolderEnum.READ_ROW_HOLDER;
    <|file_separator|>class ReadRowListener.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public interface ReadRowListener {
    /**
     * This method is called when a row is read
     *
     * @param readRowHolder
     */
    void onReadRow(ReadRowHolder readRowHolder);
}<|file_separator|>class ReadRowHolder.java
<|fim_prefix|><|fim_suffix|>

    public void setRowIndex(Integer rowIndex) {
        this.rowIndex = rowIndex;
    }

    public RowTypeEnum getRowType() {
        return rowType;
    }

    public void setRowType(RowTypeEnum rowType) {
        this.rowType = rowType;
    }

    public Map<Integer, Cell> getCellMap() {
        return cellMap;
    }

    public void setCellMap(Map<Integer, Cell> cellMap) {
        this.cellMap = cellMap;
    }

    @Override
    public HolderEnum holderType() {
        return HolderEnum.READ_ROW_HOLDER;
    }
}<|fim_middle|>import java.util.Map;

public class ReadRowHolder implements Holder {
    /**
     * Returns row index of a row in the sheet that contains this cell.Start form 0.
     */
    private Integer rowIndex;
    /**
     * Row type
     */
    private RowTypeEnum rowType;
    /**
     * Cell map
     */
    private Map<Integer, Cell> cellMap;
    /**
     * The result of the previous listener
     */
    private Object currentRowAnalysisResult;
    /**
     * Some global variables
     */
    private GlobalConfiguration globalConfiguration;

    public ReadRowHolder(Integer rowIndex, RowTypeEnum rowType, GlobalConfiguration globalConfiguration,
        Map<Integer<nl>
        return new LinkedHashMap<>(capacity(expectedSize));
    <|file_separator|><nl>
        return formatToCellData(num, contentProperty).toString();
    <|file_separator|><nl>
        if (readSheet.getSheetName().equals(analysisContext.getSheetName())) {
            return readSheet;
        }
        return null;
    <|file_separator|><nl>

    }

    @Override
    public void beforeSheetWrite(WriteWorkbookHolder writeWorkbookHolder, WriteSheetHolder writeSheetHolder, WriteRowHolder writeRowHolder) {

    }

    @Override
    public void afterSheetWrite(WriteWorkbookHolder writeWorkbookHolder, WriteSheetHolder writeSheetHolder, WriteRowHolder writeRowHolder) {

    <|file_separator|><nl>
        this.handler.afterRowCreate(context);
        if (this.next != null) {
            this.next.afterRowCreate(context);
        }
    }

    public void beforeRowDispose(RowWriteHandlerContext context) {
        this.handler.beforeRowDispose(context);
        if (this.next != null) {
            this.next.beforeRowDispose(context);
        }
    <|file_separator|><nl>
        return collectionData;
    <|file_separator|><nl>
        return HolderEnum.TABLE;
    }

    @Override
    public void write() {
        // write table
        writeTable.write();
    }

    @Override
    public void write(WriteSheetHolder writeSheetHolder) {
        // write table
        writeTable.write();
    }

    @Override
    public void write(WriteSheetHolder writeSheetHolder, WriteTable writeTable) {
        // write table
        writeTable.write();
    }

    @Override
    public void write(WriteSheetHolder writeSheetHolder, WriteTable writeTable, HolderEnum holderEnum) {
        // write table
        writeTable.write();
    }

    @Override
    public void write(WriteSheetHolder writeSheetHolder, WriteTable writeTable, HolderEnum holderEnum, HolderEnum holderEnum1) {
        // write table
        writeTable.write();
    }

    @Override
    public void write(WriteSheetHolder writeSheetHolder, WriteTable writeTable, HolderEnum holderEnum, HolderEnum holderEnum1, HolderEnum holderEnum2) {
        // write table
        writeTable.write();
    }

    @Override
    public void write(WriteSheetHolder writeSheetHolder, WriteTable writeTable, HolderEnum holderEnum, HolderEnum holderEnum1, HolderEnum holderEnum2, HolderEnum holderEnum3) {
        // write table
        writeTable.write();
    }

    @Override
    public void write(WriteSheetHolder writeSheetHolder, WriteTable writeTable, HolderEnum holderEnum, HolderEnum holderEnum1, HolderEnum holderEnum2, HolderEnum holderEnum3, HolderEnum holderEnum4) {
        // write table
        writeTable.write();
    }

    @Override
    public void write(WriteSheetHolder writeSheetHolder,<nl>
        List<CellRange> cellRangeList = new ArrayList<>();
        for (Map.Entry<Integer, Head> entry : getHeadMap().entrySet()) {
            Head headData = entry.getValue();
            if (headData == null) {
                continue;
            }
            if (headData.getLoopMergeProperty() == null) {
                continue;
            }
            if (headData.getLoopMergeProperty().isOnceAbsoluteMerge()) {
                cellRangeList.add(onceAbsoluteMergeProperty.getOnceAbsoluteMerge());
            } else {
                cellRangeList.addAll(headData.getLoopMergeProperty().getLoopMerge());
            }
        }
        return cellRangeList;
    }

    public RowHeightProperty getHeadRowHeightProperty() {
        return headRowHeightProperty;
    }

    public RowHeightProperty getContentRowHeightProperty() {
        return contentRowHeightProperty;
    }

    public OnceAbsoluteMergeProperty getOnceAbsoluteMergeProperty() {
        return onceAbsoluteMergeProperty;
    <|file_separator|>class ExcelWriteContentProperty extends ExcelContentProperty {

    private RowHeightProperty rowHeightProperty;
    private OnceAbsoluteMergeProperty onceAbsoluteMergeProperty;

    public ExcelWriteContentProperty(ConfigurationHolder configurationHolder, Class<?> contentClazz, List<List<String>> content) {
        super(configurationHolder, contentClazz, content);
        if (getContentKind() != ContentKindEnum.CLASS) {
            return;
        }
        this.rowHeightProperty =
            RowHeightProperty.build(contentClazz.getAnnotation(RowHeight.class));
        this.onceAbsoluteMergeProperty =
            OnceAbsoluteMergeProperty.build(contentClazz.getAnnotation(OnceAbsoluteMerge.class));

        ColumnWidth parentColumnWidth = contentClazz.getAnnotation(ColumnWidth<nl>
        return 1;
    <|file_separator|><nl>
        if (head == null) {
            return;
        }
        Integer columnWidth = columnWidth(head, relativeRowIndex);
        if (columnWidth == null) {
            return;
        }
        cell.setWidth(columnWidth);
    <|file_separator|><nl>
        list.add(data);
    <|file_separator|><nl>
            <|file_separator|><nl>
        LOGGER.info("list size: {}", list.size());
    <|file_separator|><nl>
        list.add(data);
        LOGGER.info("ExceptionData: {}", data);
    <|file_separator|><nl>
        try {
            List<NoHeadData> list = NoHeadDataUtil.read(file);
            NoHeadDataUtil.write(list, file);
        } catch (Exception e) {
            e.printStackTrace();
        }
    <|file_separator|><nl>
        readAndWrite1(file07, ExcelTypeEnum.XLSX);
        readAndWrite2(file07, ExcelTypeEnum.XLSX);
    <|file_separator|><nl>
        List<SimpleData> list = new ArrayList<>();
        for (int i = 0; i < 10; i++) {
            list.add(new SimpleData(String.valueOf(i), "name" + i));
        }
        return list;
    <|file_separator|><nl>
        return CellDataTypeEnum.STRING;
    <|file_separator|><nl>
        log.info(":{}", JSON.toJSONString(exception));
    <|file_separator|><nl>
        ExcelReader reader =
            EasyExcel.read(new FileInputStream("D:testsheet.xls"), LockData.class, new RepeatListener())
                .headRowNumber(0).build();
        ReadSheet r2 = EasyExcel.readSheet(1).build();
        reader.read(r2);
        reader.finish();
    <|file_separator|><nl>
        
    <|file_separator|><nl>
        AddressServerGeneratorManager manager = new AddressServerGeneratorManager();
        final List<String> ips = new ArrayList<>();
        ips.add("192.168.3.1");
        ips.add("192.168.3.2");
        ips.add("192.168.3.3");
    
        final String ipListStr = manager.generateInstancesByIps(ips);
        
        StringBuilder expectStr = new StringBuilder();
        final StringBuilder ret = expectStr
                .append("192.168.3.1:8848").append('n')
                .append("192.168.3.2:8848").append('n')
                .append("192.168.3.3:8848").append('n');
        Assert.assertEquals(ret.toString(), ipListStr);
    
    <|file_separator|><nl>
        this.remoteAbility = remoteAbility;
    <|file_separator|><nl>
        this.additionMap = additionMap;
    <|file_separator|><nl>
        return serializedClass;
    <|file_separator|><nl>
        this.healthChecker = healthChecker;
    <|file_separator|><nl>
        this.data = data;
    <|file_separator|><nl>
        this.supportRemoteConnection = supportRemoteConnection;
    <|file_separator|><nl>
        this.requestId = requestId;
    }
    
    /**
     * Getter method for property <tt>type</tt>.
     *
     * @return property value of type
     */
    public abstract String getType();
    
    /**
     * Getter method for property <tt>module</tt>.
     *
     * @return property value of module
     */
    public abstract String getModule();
    
    /**
     * Getter method for property <tt>headers</tt>.
     *
     * @return property value of headers
     */
    public Map<String, String> getHeaders() {
        return headers;
    }
    
    public void clearHeaders() {
        this.headers.clear();
    }
    
    @Override
    public String toString() {
        return this.getClass().getSimpleName() + "{" + "headers=" + headers + ", requestId='" + requestId + ''' + '}';
    }
}

class Request implements Payload {
    
    private final Map<String, String> headers = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);
    
    private String requestId;
    
    /**
     * put header.
     *
     * @param key   key of value.
     * @param value value.
     */
    public void putHeader(String key, String value) {
        headers.put(key, value);
    }
    
    /**
     * put headers .
     *
     * @param headers headers to put.
     */
    public void putAllHeader(Map<String, String> headers) {
        if (headers == null || headers.isEmpty()) {
            return;
        }
        this.headers.putAll(headers);
    }
    <nl>
        if (cs == substring) {
            return true;
        }
        if (cs == null || substring == null || cs.length() < start + length || substring.length() < length) {
            return false;
        }
        if (ignoreCase) {
            return cs.regionMatches(thisStart, substring, start, length, true);
        }
        return cs.regionMatches(thisStart, substring, start, length);
    <|file_separator|><nl>
        ServerRemoteAbility abilities = new ServerRemoteAbility();
        ServerRemoteAbility abilities2 = new ServerRemoteAbility();
        assertEquals(abilities, abilities2);
        assertEquals(abilities.hashCode(), abilities2.hashCode());
    <|file_separator|><nl>
        NacosException exception = new NacosException(NacosException.SERVER_ERROR, "test",
                new RuntimeException("cause test"), new RuntimeException("cause test2"));
        assertEquals(NacosException.SERVER_ERROR, exception.getErrCode());
        assertEquals("test", exception.getErrMsg());
        assertEquals("ErrCode:500, ErrMsg:test", exception.toString());
    <|file_separator|><nl>
        NacosDeserializationException exception = new NacosDeserializationException(NacosDeserializationExceptionTest.class);
        assertEquals(Constants.Exception.DESERIALIZE_ERROR_CODE, exception.getErrCode());
        assertEquals(
                String.format("errCode: 101, errMsg: Nacos deserialize for class [%s] failed.  ",
                        NacosDeserializationExceptionTest.class.getName()),
                exception.getMessage());
        assertNull(exception.getTargetClass());
    <|file_separator|><nl>
        Map<AbilityKey, Boolean> actual = AbilityKey.mapEnum(AbilityMode.SERVER, AbilityKey.mapStr(new HashMap<>()));
        assertEquals(3, actual.size());
        assertTrue(actual.containsKey(AbilityKey.SERVER_TEST_1));
        assertTrue(actual.containsKey(AbilityKey.SERVER_TEST_2));
        assertTrue(actual.containsKey(AbilityKey.SERVER_SUPPORT_PERSISTENT_INSTANCE_BY_GRPC));
        assertFalse(actual.containsKey(AbilityKey.SERVER_TEST_3));
    <|file_separator|><nl>
        String remoteIp = request.getRemoteAddr();
        if (StringUtils.isNotBlank(remoteIp)) {
            result.setParameter(X_FORWARDED_FOR, remoteIp);
        }
        String xForwardedFor = request.getHeader(X_FORWARDED_FOR);
        if (StringUtils.isNotBlank(xForwardedFor)) {
            String[] ips = xForwardedFor.split(X_FORWARDED_FOR_SPLIT_SYMBOL);
            if (ips.length > 0) {
                result.setParameter(X_FORWARDED_FOR, ips[0]);
            }
        }
    <|file_separator|><nl>
        return request.getProperties();
    <|file_separator|><nl>
        Secured secured = getMethodSecure();
        Request request = mockConfigRequest("testNs", "testG", "");
        Resource actual = resourceParser.parse(request, secured);
        assertEquals("testNs", actual.getNamespaceId());
        assertEquals("testG", actual.getGroup());
        assertEquals(StringUtils.EMPTY, actual.getName());
        assertEquals(Constants.Config.CONFIG_MODULE, actual.getType());
    <|file_separator|><nl>
        param.put(ENCRYPTED_DATA_KEY, encryptedDataKey);
    }
    
    public String getEncryptedDataValue() {
        return (String) param.get(ENCRYPTED_DATA_VALUE);
    }
    
    public void setEncryptedDataValue(String encryptedDataValue) {
        param.put(ENCRYPTED_DATA_VALUE, encryptedDataValue);
    }
    
    public String getEncryptedDataIv() {
        return (String) param.get(ENCRYPTED_DATA_IV);
    }
    
    public void setEncryptedDataIv(String encryptedDataIv) {
        param.put(ENCRYPTED_DATA_IV, encryptedDataIv);
    }
    
    public String getEncryptedDataTag() {
        return (String) param.get(ENCRYPTED_DATA_TAG);
    }
    
    public void setEncryptedDataTag(String encryptedDataTag) {
        param.put(ENCRYPTED_DATA_TAG, encryptedDataTag);
    }
    
    public String getEncryptedDataNonce() {
        return (String) param.get(ENCRYPTED_DATA_NONCE);
    }
    
    public void setEncryptedDataNonce(String encryptedDataNonce) {
        param.put(ENCRYPTED_DATA_NONCE, encryptedDataNonce);
    }
    
    public String getEncryptedDataAuthTag() {
        return (String) param.get(ENCRYPTED_DATA_AUTH_TAG);
    }
    
    public void setEncryptedDataAuthTag(String encryptedDataAuthTag) {
        param.put(ENCRYPTED_DATA_AUTH_TAG, encryptedDataAuthTag);
    }
    
    public String getEncryptedDataAuthKey() {
<nl>
        Map<String, ConfigChangeItem> result = new HashMap<>();
        for (Map.Entry<String, ConfigChangeItem> entry : oldMap.entrySet()) {
            if (!newMap.containsKey(entry.getKey())) {
                result.put(entry.getKey(), entry.getValue());
            }
        }
        return result;
    <|file_separator|><nl>
        envName = simplyEnvNameIfOverLimit(envName);
        File file = getEncryptDataKeySnapshotFile(envName, dataId, group, tenant);
        if (!file.exists() || !file.isFile()) {
            return null;
        }
        
        try {
            return readFile(file);
        } catch (IOException ioe) {
            LOGGER.error("[" + envName + "] get snapshot error, " + file, ioe);
            return null;
        }
    <|file_separator|><nl>
        LOGGER.info("configInfo: {}", configInfo);
        Properties properties = new Properties();
        properties.load(new StringReader(configInfo));
        innerReceive(properties);<|file_separator|><nl>
        if (content == null || content.length() == 0) {
            throw new IllegalArgumentException("content is null or empty");
        }
        if (content.indexOf(WORD_SEPARATOR) == -1) {
            throw new IllegalArgumentException("content does not contain separator");
        }
    <|file_separator|><nl>
    <|file_separator|><nl>
        LoggerContext loggerContext = (LoggerContext) LogManager.getContext(false);
        Configuration configuration = loadConfiguration(loggerContext, location);
        loggerContext.updateConfiguration(configuration);
    }
    
    @Override
    public void start() {
        LoggerContext loggerContext = (LoggerContext) LogManager.getContext(false);
        loggerContext.start();
    }
    
    @Override
    public void stop() {
        LoggerContext loggerContext = (LoggerContext) LogManager.getContext(false);
        loggerContext.stop();
    <|file_separator|><nl>
        return null;
    <|file_separator|><nl>
        String source = attributes.getValue(SOURCE_ATTRIBUTE);
        String defaultValue = attributes.getValue(DEFAULT_VALUE_ATTRIBUTE);
        String value = getValue(source, defaultValue);
        ic.setVariable(elementName, value);
    <|file_separator|><nl>
        return protectThreshold;
    <|file_separator|><nl>
        String serviceName = request.getArgument("serviceName");
        String serviceVersion = request.getArgument("serviceVersion");
        String serviceId = request.getArgument("serviceId");
        
        if (serviceInfoHolder.isServiceRegistered(serviceName, serviceVersion, serviceId)) {
            return new Response(ResponseStatus.OK);
        } else {
            return new Response(ResponseStatus.NOT_FOUND);
        }
    <|file_separator|><nl>
    <|file_separator|><nl>
        
    <|file_separator|><nl>
        NacosClientPropertiesLookup lookup = new NacosClientPropertiesLookup();
        lookup.setNacosServer("127.0.0.1:8848");
        lookup.setNacosNamespace("public");
        lookup.setNacosDataId("nacos-client-properties-lookup");
        lookup.setNacosGroup("DEFAULT_GROUP");
        lookup.setNacosType("properties");
        lookup.setNacosTimeoutMs(1000);
        lookup.setNacosUsername("nacos");
        lookup.setNacosPassword("nacos");
        lookup.setNacosClientName("nacos-client-properties-lookup");
        lookup.setNacosClientVersion("1.0.0");
        lookup.setNacosClientMetadata(new HashMap<String, String>());
        lookup.setNacosClientMetadata().put("key", "value");
        lookup.setNacosClientMetadata().put("key", "value");
        lookup.setNacosClientMetadata().put("key", "value");
        lookup.setNacosClientMetadata().put("key", "value");
        lookup.setNacosClientMetadata().put("key", "value");
        lookup.setNacosClientMetadata().put("key", "value");
        lookup.setNacosClientMetadata().put("key", "value");
        lookup.setNacosClientMetadata().put("key", "value");
        lookup.setNacosClientMetadata().put("key", "value");
        lookup.setNacosClientMetadata().put("key", "value");
        lookup.setNacosClientMetadata().put("key", "value");
        lookup.setNacosClientMetadata().put("key", "value");
        lookup.setNacosClientMetadata().put<nl>
        String value = nacosClientLogbackProperties.getValue("test");
        Assert.assertEquals("test", value);
    <|file_separator|><nl>
    <|file_separator|><nl>
        String item1 = "item1";
        String item2 = "item2";
        GenericPoller<String> poller = new GenericPoller<>(Arrays.asList(item1, item2));
        Assert.assertEquals(item1, poller.next());
    <|file_separator|><nl>
        this.currentNodeAbilities.putAll(initCurrentNodeAbilities());
    <|file_separator|><nl>
        try {
            Class<?> clazz = Class.forName("com.alibaba.nacos.client.config.NacosConfigManager");
            if (clazz != null) {
                abstractAbilityControlManager = (AbstractAbilityControlManager) clazz.newInstance();
            }
        } catch (Exception e) {
            LOGGER.error("init ability control manager error", e);
        }
    <|file_separator|><nl>
            ExecutorService executorService = Executors.newFixedThreadPool(1, threadFactory);
            THREAD_POOL_MANAGER.register(DEFAULT_NAMESPACE, group, executorService);
            return executorService;
        <|file_separator|><nl>
        return header;
    <|file_separator|><nl>
        return new HttpRestResult<T>(response.getStatusCode(), response.getResponseBody());
    <|file_separator|><nl>
        return new HttpRestResult<T>(response.getStatusCode(), response.getContentAsString());
    <|file_separator|><nl>
        this.protocolResolvers.add(resolver);
    <|file_separator|><nl>
        this.certPrivateKey = certPrivateKey;
    <|file_separator|><nl>
        
        if (payload == null) {
            return null;
        }
        
        if (payload.getMetadata() == null) {
            return null;
        }
        
        String type = payload.getMetadata().getType();
        
        if (type.equals(Request.class.getSimpleName())) {
            return JacksonUtils.fromJsonBytes(payload.getBody().getValue(), Request.class);
        } else if (type.equals(Response.class.getSimpleName())) {
            return JacksonUtils.fromJsonBytes(payload.getBody().getValue(), Response.class);
        }
        
        return null;
    <|file_separator|><nl>
        return clazz;
    <|file_separator|><nl>
        return this.taskInterval;
    <|file_separator|><nl>
        Collection<Object> keys = getAllTaskKeys();
        for (Object key : keys) {
            AbstractDelayTask task = tasks.get(key);
            if (null != task && task.shouldProcess()) {
                try {
                    task.process();
                } catch (Throwable e) {
                    getEngineLog().error(e.toString(), e);
                    retryFailedTask(key, task);
                }
            }
        }
    <|file_separator|><nl>
        if (preferredMap == null || preferredMap.isEmpty()) {
            return backwardMap;
        }
        if (backwardMap == null || backwardMap.isEmpty()) {
            return preferredMap;
        }
        return preferredMap.entrySet().stream().filter(Objects::nonNull).filter(elem -> !elem.getKey().trim()
                .isEmpty()).collect(Collectors.toMap(elem -> elem.getKey(), elem -> elem.getValue(),
                (oldValue, newValue) -> newValue, LinkedHashMap::new));
    <|file_separator|><nl>
        return null;
    <|file_separator|><nl>
        return toFloat(str, 0.0f);
    <|file_separator|><nl>
        checkParameters(startInclusive, endExclusive);
        long diff = endExclusive - startInclusive;
        if (diff == 0) {
            return startInclusive;
        }
        return startInclusive + RANDOM.nextLong(diff);
    <|file_separator|><nl>
        if (provider.equals("JDK")) {
            return SslProvider.JDK;
        } else if (provider.equals("OPENSSL")) {
            return SslProvider.OPENSSL;
        } else {
            return SslProvider.JDK;
        }
    <|file_separator|><nl>
        
        SimpleCache cache = new SimpleCache();
        
        cache.put("key", "value");
        
        assertEquals("value", cache.get("key"));
        
    <|file_separator|><nl>
        cachedRestTemplateMap = (Map<String, NacosRestTemplate>) getCachedMap("restMap");
        cachedAsyncRestTemplateMap = (Map<String, NacosAsyncRestTemplate>) getCachedMap("restAsyncMap");
    <|file_separator|><nl>
        Header header = Header.newInstance();
        HttpRestResult<String> result = new HttpRestResult<>(header, 200, "test data", "message");
        result.setHeader(header);
        assertEquals(header, result.getHeader());
    }
    
    @Test
    public void testSetData() {
        HttpRestResult<String> result = new HttpRestResult<>(null, 200, "test data", "message");
        result.setData("test data");
        assertEquals("test data", result.getData());
    }
    
    @Test
    public void testSetMessage() {
        HttpRestResult<String> result = new HttpRestResult<>(null, 200, "test data", "message");
        result.setMessage("test message");
        assertEquals("test message", result.getMessage());
    }
    
    @Test
    public void testConstructor() {
        HttpRestResult<String> result = new HttpRestResult<>(null, 200, "test data", "message");
        assertEquals(null, result.getHeader());
        assertEquals("test data", result.getData());
        assertEquals("message", result.getMessage());
    <|file_separator|><nl>
        when(statusLine.getReasonPhrase()).thenReturn("testReason");
        assertEquals("testReason", clientHttpResponse.getStatusText());
    <|file_separator|><nl>
        PayloadRegistry.register("ErrorResponse", "ErrorResponse");
    <|file_separator|><nl>
        connection = new Connection();
    <|file_separator|><nl>
        
    <|file_separator|><nl>
        grpcClusterClient = new GrpcClusterClient("test", 8, 8, Collections.emptyMap());
        GrpcClient grpcClient = grpcClusterClient.getGrpcClient();
        assertNotNull(grpcClient);
    <|file_separator|><nl>
        TypeUtils.parameterize(List.class, (Type) null);
    <|file_separator|><nl>
        Map<String, Object> responseMap = new HashMap<>();
        CountDownLatch latch = new CountDownLatch(1);
        
        // get client config listener lists
        ClientConfigListenerService.get().getMetrics(ip, dataId, group, tenant, new ClusterMetricsCallBack(responseMap, latch, dataId, group, tenant, ip, member));
        try {
            latch.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return responseMap;
    }<|file_separator|><nl>
        MetricsMonitor.getNacosException().increment();
        return ResponseEntity.status(ex.getErrCode()).body(ExceptionUtil.getAllExceptionMsg(ex));
    }

    /**
     * For NacosException.
     *
     * @throws NacosException NacosException.
     */
    @ExceptionHandler(NacosException.class)
    public ResponseEntity<String> handleNacosException(NacosException ex) throws IOException {
        MetricsMonitor.getNacosException().increment();
        return ResponseEntity.status(ex.getErrCode()).body(ExceptionUtil.getAllExceptionMsg(ex));
    }

    /**
     * For NacosException.
     *
     * @throws NacosException NacosException.
     */
    @ExceptionHandler(NacosException.class)
    public ResponseEntity<String> handleNacosException(NacosException ex) throws IOException {
        MetricsMonitor.getNacosException().increment();
        return ResponseEntity.status(ex.getErrCode()).body(ExceptionUtil.getAllExceptionMsg(ex));
    }

    /**
     * For NacosException.
     *
     * @throws NacosException NacosException.
     */
    @ExceptionHandler(NacosException.class)
    public ResponseEntity<String> handleNacosException(NacosException ex) throws IOException {
        MetricsMonitor.getNacosException().increment();
        return ResponseEntity.status(ex.getErrCode()).body(ExceptionUtil.getAllExceptionMsg(ex));
    }

    /**
     * For NacosException.
     *
     * @throws NacosException NacosException.
     */
    @ExceptionHandler(NacosException.class)
    public ResponseEntity<String> handleNacosException(NacosException ex) throws IOException {
        MetricsMonitor<nl>
        // @JustForTest
        // This event only happens in the case of unit tests
        NotifyCenter.registerSubscriber(new SmartSubscriber() {
            
            @Override
            public void onEvent(Event event) {
                // @JustForTest
                // This event only happens in the case of unit tests
                if (event instanceof RaftDbErrorRecoverEvent) {
                    isOpenService = false;
                    return;
                }
                if (event instanceof RaftDbErrorEvent) {
                    isOpenService = true;
                }
            }
            
            @Override
            public List<Class<? extends Event>> subscribeTypes() {
                return Arrays.asList(RaftDbErrorRecoverEvent.class, RaftDbErrorEvent.class);
            }
        });
    <|file_separator|><nl>
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        
        ConfigAdvanceInfo that = (ConfigAdvanceInfo) o;
        
        if (createTime != that.createTime) return false;
        if (modifyTime != that.modifyTime) return false;
        if (createUser != null ? !createUser.equals(that.createUser) : that.createUser != null) return false;
        if (createIp != null ? !createIp.equals(that.createIp) : that.createIp != null) return false;
        if (desc != null ? !desc.equals(that.desc) : that.desc != null) return false;
        if (use != null ? !use.equals(that.use) : that.use != null) return false;
        if (effect != null ? !effect.equals(that.effect) : that.effect != null) return false;
        if (type != null ? !type.equals(that.type) : that.type != null) return false;
        if (schema != null ? !schema.equals(that.schema) : that.schema != null) return false;
        if (configTags != null ? !configTags.equals(that.configTags) : that.configTags != null) return false;
        
        return true;
    }
    
    @Override
    public int hashCode() {
        int result = (int) (createTime ^ (createTime >>> 32));
        result = 31 * result + (int) (modifyTime ^ (modifyTime >>> 32));
        result = 31 * result + (createUser != null ? createUser.hashCode() : 0);
        result = 31 * result + (create<nl>
        this.md5Utf8 = StringPool.get(md5Utf8);
    <|file_separator|>class ConfigCache.java
<|fim_prefix|><|fim_suffix|>
    
    public String getMd5Gbk() {
        return md5Gbk;
    }
    
    public void setMd5Gbk(String md5Gbk) {
        this.md5Gbk = StringPool.get(md5Gbk);
    }
    
    public String getMd5Utf8() {
        return md5Utf8;
    }
    
    public void setMd5Utf8(String md5Utf8) {
        this.md5Utf8 = StringPool.get(md5Utf8);
    }
    
    public long getLastModifiedTs() {
        return lastModifiedTs;
    }
    
    public void setLastModifiedTs(long lastModifiedTs) {
        this.lastModifiedTs = lastModifiedTs;
    }
}<|fim_middle|>class ConfigCache implements Serializable {
    
    volatile String md5Gbk = Constants.NULL;
    
    volatile String md5Utf8 = Constants.NULL;
    
    volatile String encryptedDataKey;
    
    volatile long lastModifiedTs;
    
    /**
     * clear cache.
     */
    public void clear() {
        this.md5Gbk = Constants.NULL;
        this.md5Utf8 = Constants.NULL;
        this.encryptedDataKey = null;
        this.lastModifiedTs = -1L;
    }
    
    public ConfigCache() {
    }
    
    public String getMd5(String encode) {
        if (UTF_8.name().equalsIgnoreCase(encode)) {
            return md5Utf8;
        } else {
            return md5<nl>
            return Objects.hash(group, dataId, desc, type, appName);
        <|file_separator|><nl>
        return "ConfigRequestInfo{" + "srcIp='" + srcIp + '\'' + ", requestIpApp='" + requestIpApp + '\'' + ", betaIps='" + betaIps + '\'' + ", casMd5='" + casMd5 + '\'' + '}';
    <|file_separator|><nl>
        if (gmtModified == null) {
            this.gmtModified = null;
        } else {
            this.gmtModified = new Timestamp(gmtModified.getTime());
        }
        
    <|file_separator|><nl>
        while (true) {
            try {
                notifySingleService.notifySingle();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    <|file_separator|><nl>
        this.clusterRpcClientProxy.syncConfigChange(member, request, callBack);
    }
    
    /**
     * async config change request.
     *
     * @param member  member of server.
     * @param request request of config change async.
     * @param callBack callBack of config change async.
     */
    public void asyncConfigChange(Member member, ConfigChangeClusterAsyncRequest request, RequestCallBack callBack) {
        this.clusterRpcClientProxy.asyncConfigChange(member, request, callBack);
    <|file_separator|><nl>
        
        String namespace = configQueryRequest.getNamespace();
        String group = configQueryRequest.getGroup();
        String dataId = configQueryRequest.getDataId();
        String tag = configQueryRequest.getTag();
        
        if (StringUtils.isBlank(namespace)) {
            namespace = meta.getNamespace();
        }
        
        if (StringUtils.isBlank(group)) {
            group = meta.getGroup();
        }
        
        if (StringUtils.isBlank(dataId)) {
            dataId = meta.getDataId();
        }
        
        if (StringUtils.isBlank(tag)) {
            tag = meta.getTag();
        }
        
        if (StringUtils.isBlank(namespace) || StringUtils.isBlank(group) || StringUtils.isBlank(dataId)) {
            return ConfigQueryResponse.buildFailResponse(ResponseCode.FAIL.getCode(), "namespace, group, dataId can not be empty");
        }
        
        if (StringUtils.isBlank(tag)) {
            return ConfigQueryResponse.buildFailResponse(ResponseCode.FAIL.getCode(), "tag can not be empty");
        }
        
        CacheItem cacheItem = CacheManager.getCache(namespace).get(group, dataId);
        
        if (cacheItem == null) {
            return ConfigQueryResponse.buildFailResponse(ResponseCode.FAIL.getCode(), "no config found");
        }
        
        if (isUseTag(cacheItem, tag)) {
            return ConfigQueryResponse.buildSuccessResponse(cacheItem.getConfigContent());
        }
        
        if (notify) {
            return ConfigQueryResponse.buildSuccessResponse(cacheItem.getConfigContent());
        }
        
        return ConfigQueryResponse.buildFailResponse(ResponseCode.FAIL.getCode(), "no config found");
    <nl>
        return true;
    <|file_separator|><nl>
        if (configDiskService == null) {
            configDiskService = new ConfigDiskService();
        }
        return configDiskService;
    }
    
    /**
     * get disk service.
     *
     * @return
     */
    public static ConfigDiskService getInstance(String type) {
        if (configDiskService == null) {
            if (TYPE_RAW_DISK.equals(type)) {
                configDiskService = new ConfigDiskService();
            } else if (TYPE_ROCKSDB.equals(type)) {
                configDiskService = new ConfigDiskService();
            }
        }
        return configDiskService;
    <|file_separator|><nl>
        if (extendInfo.containsKey("configDump")) {
            String configDump = extendInfo.get("configDump");
            if (configDump.equals("true")) {
                ConfigDumpEvent event = new ConfigDumpEvent();
                NotifyCenter.publish(event);
            }
        }
    <|file_separator|>class ConfigDumpEvent extends Event {
    
    public ConfigDumpEvent() {
        super(ConfigDumpEvent.class);
    }
}<|file_separator|>class DumpConfigHandler extends Subscriber {
    
    public void handleEvent(Event event) {
        if (event instanceof ConfigDumpEvent) {
            String configDump = "true";
            Map<String, String> extendInfo = new HashMap<String, String>();
            extendInfo.put("configDump", configDump);
            WriteRequest log = new WriteRequest(extendInfo);
            log.setExtendInfoMap(extendInfo);
            log.setLogType(WriteRequest.LOG_TYPE_CONFIG_DUMP);
            log.setLogType(WriteRequest.LOG_TYPE_CONFIG_DUMP);
            log.setLogType(WriteRequest.LOG_TYPE_CONFIG_DUMP);
            log.setLogType(WriteRequest.LOG_TYPE_CONFIG_DUMP);
            log.setLogType(WriteRequest.LOG_TYPE_CONFIG_DUMP);
            log.setLogType(WriteRequest.LOG_TYPE_CONFIG_DUMP);
            log.setLogType(WriteRequest.LOG_TYPE_CONFIG_DUMP);
            log.setLogType(WriteRequest.LOG_TYPE_CONFIG_DUMP);
            log.setLogType(WriteRequest.LOG_TYPE_CONFIG_DUMP);
            log.setLogType(WriteRequest.LOG_TYPE_CONFIG_DUMP);
            log.setLogType(WriteRequest.LOG<nl>
        String[] key = parseKey(dataId + "+" + group);
        if (null != datumStr) {
            key[2] = datumStr;
        }
        return key[0] + "+" + key[1] + "+" + key[2];
    <|file_separator|><nl>
        Logger logger = LoggerFactory.getLogger(logName);
        if (logger != null) {
            logger.setLevel(Level.parse(level));
        }
    <|file_separator|><nl>
        if (regex == null) {
            return null;
        }
        
        StringBuilder sb = new StringBuilder();
        
        for (int i = 0; i < regex.length(); i++) {
            char ch = regex.charAt(i);
            
            if (ch == QUESTION_MARK) {
                sb.append("?");
            } else if (ch == '*') {
                sb.append(".*");
            } else if (isAsciiAlphanumeric(ch)) {
                sb.append(ch);
            } else {
                sb.append("\\").append(ch);
            }
        }
        
        return sb.toString();
    <|file_separator|><nl>
        return request.getAttribute("srcUserName") == null ? null : request.getAttribute("srcUserName").toString();
    <|file_separator|><nl>
        try {
            response.sendError(httpCode, msg);
        } catch (IOException e) {
            e.printStackTrace();
        }
    <|file_separator|><nl>
        UnZipResult result = null;
        try (ByteArrayInputStream byteIn = new ByteArrayInputStream(source); ZipInputStream zipIn = new ZipInputStream(
                byteIn)) {
            List<ZipItem> zipItemList = new ArrayList<>();
            ZipItem metaDataItem = null;
            ZipEntry entry = zipIn.getNextEntry();
            while (entry != null) {
                if (entry.getName().equals("META-INF/MANIFEST.MF")) {
                    metaDataItem = new ZipItem(entry.getName(), zipIn.readAllBytes());
                } else {
                    zipItemList.add(new ZipItem(entry.getName(), zipIn.readAllBytes()));
                }
                entry = zipIn.getNextEntry();
            }
            result = new UnZipResult(zipItemList, metaDataItem);
        } catch (IOException e) {
            LOGGER.error("an error occurred while decompressing data.", e);
        }
        return result;
    }<|file_separator|><nl>
        SimpleReadWriteLock lock = new SimpleReadWriteLock();
        
        assertTrue(lock.tryReadLock());
        assertTrue(lock.tryReadLock());
        
        lock.releaseReadLock();
        
        assertFalse(lock.tryReadLock());
    }
    
    @Test
    public void testDoubleWriteLockAndOneReleaseOneFailed() {
        SimpleReadWriteLock lock = new SimpleReadWriteLock();
        
        assertTrue(lock.tryWriteLock());
        assertTrue(lock.tryWriteLock());
        
        lock.releaseWriteLock();
        
        assertFalse(lock.tryWriteLock());
    }
    
    @Test
    public void testDoubleReadLockAndOneReleaseOneFailed() {
        SimpleReadWriteLock lock = new SimpleReadWriteLock();
        
        assertTrue(lock.tryReadLock());
        assertTrue(lock.tryReadLock());
        
        lock.releaseReadLock();
        
        assertFalse(lock.tryReadLock());
    }
    
    @Test
    public void testDoubleWriteLockAndOneReleaseOneFailed() {
        SimpleReadWriteLock lock = new SimpleReadWriteLock();
        
        assertTrue(lock.tryWriteLock());
        assertTrue(lock.tryWriteLock());
        
        lock.releaseWriteLock();
        
        assertFalse(lock.tryWriteLock());
    <|file_separator|><nl>
        String currentTimeStr = TimeUtils.getCurrentTimeStr();
        System.out.println(currentTimeStr);
    <|file_separator|><nl>
        return Message.parseFrom(bytes);
    }
    
    /**
     * Converts the Protobuf object to a byte array.
     *
     * @param message Protobuf object
     * @return byte array
     */
    public static byte[] toBytes(Message message) {
        return message.toByteArray();
    }
    
    /**
     * Converts the Protobuf object to a byte array.
     *
     * @param message Protobuf object
     * @return byte array
     */
    public static byte[] toBytes(MessageLite message) {
        return message.toByteArray();
    }
    
    /**
     * Converts the Protobuf object to a byte array.
     *
     * @param message Protobuf object
     * @return byte array
     */
    public static byte[] toBytes(MessageLite message, int type) {
        return message.toByteArray(type);
    }
    
    /**
     * Converts the Protobuf object to a byte array.
     *
     * @param message Protobuf object
     * @return byte array
     */
    public static byte[] toBytes(MessageLite message, int type, int requestType) {
        return message.toByteArray(type, requestType);
    }
    
    /**
     * Converts the Protobuf object to a byte array.
     *
     * @param message Protobuf object
     * @return byte array
     */
    public static byte[] toBytes(MessageLite message, int type, int requestType, int requestSubType) {
        return message.toByteArray(type, requestType, requestSubType);
    }
    
    /**
     * Converts the Protobuf object to a byte array.
     *
     * @param message Protobuf object
     * @return byte array
     */
    public static byte<nl>
        if (ByteUtils.isEmpty(data)) {
            return null;
        }
        return JacksonUtils.toObj(data, type);
    <|file_separator|><nl>
        ByteString data = ByteString.copyFrom("data".getBytes());
        ReadRequest readRequest = ProtoMessageUtil.convertToReadRequest("key", data);
        
        assertEquals(data, readRequest.getData());
        
        assertEquals("key", readRequest.getKey());
    <|file_separator|><nl>
        
        ProtocolMetaData metaData = new ProtocolMetaData();
        
        metaData.setProtocolName("Test");
        metaData.setProtocolVersion("1.0");
        metaData.setProtocolDescription("Test Protocol");
        
        System.out.println(metaData);
        
    <|file_separator|><nl>
        System.out.println("Hello World!");
    <|file_separator|><nl>
        return Result.success("ok");
    <|file_separator|><nl>
        namespaceForm.validate();
        return Result.success(namespaceOperationService.editNamespace(namespaceForm));
    <|file_separator|><nl>
        if (Objects.nonNull(name)) {
            currentLookupType = chooseLookup(name);
        }
        return createLookUp(memberManager);
    <|file_separator|><nl>
        this.node = node;
    <|file_separator|><nl>
        for (NacosApplicationListener nacosApplicationListener : nacosApplicationListeners) {
            nacosApplicationListener.environmentPrepared(bootstrapContext, environment);
        }
    }
    
    @Override
    public void contextPrepared(ConfigurableApplicationContext context,
            ConfigurableEnvironment environment) {
        for (NacosApplicationListener nacosApplicationListener : nacosApplicationListeners) {
            nacosApplicationListener.contextPrepared(context, environment);
        }
    <|file_separator|><nl>
        
        String connectionRuntimeEjector = controlConfigs.get(CONTROL_MANAGER_TYPE);
        if (StringUtils.isEmpty(connectionRuntimeEjector)) {
            connectionRuntimeEjector = DEFAULT_CONNECTION_RUNTIME_EJECTOR;
        }
        controlConfigs.put(CONNECTION_RUNTIME_EJECTOR, connectionRuntimeEjector);
        
        String ruleExternalStorage = controlConfigs.get(RULE_EXTERNAL_STORAGE);
        if (StringUtils.isEmpty(ruleExternalStorage)) {
            ruleExternalStorage = "local";
        }
        controlConfigs.put(RULE_EXTERNAL_STORAGE, ruleExternalStorage);
        
        String localRuleStorageBaseDir = controlConfigs.get(LOCAL_RULE_STORAGE_BASE_DIR);
        if (StringUtils.isEmpty(localRuleStorageBaseDir)) {
            localRuleStorageBaseDir = "nacos-control-rule";
        }
        controlConfigs.put(LOCAL_RULE_STORAGE_BASE_DIR, localRuleStorageBaseDir);
    <|file_separator|><nl>
        for (L processor : logProcessors) {
            processorMap.put(processor.name(), processor);
        }
    }
    
    public L getProcessor(String name) {
        return processorMap.get(name);
    <|file_separator|><nl>
    <|file_separator|><nl>
            if (Loggers.DISTRO.isDebugEnabled()) {
                Loggers.DISTRO.debug("[DISTRO] verify data for type {} to {} failed", resourceType, targetServer);
            }
        <|file_separator|><nl>
        long timestamp = currentTimeMillis();
        
        if (timestamp < lastTime) {
            throw new IllegalStateException(
                    String.format("Clock moved backwards.  Refusing to generate id for %d milliseconds",
                            lastTime - timestamp));
        }
        
        if (timestamp == lastTime) {
            sequence = (sequence + 1) & SEQUENCE_MASK;
            if (sequence == 0) {
                timestamp = waitUntilNextTime(lastTime);
            }
        } else {
            sequence = 0;
        }
        
        lastTime = timestamp;
        
        currentId = ((timestamp - EPOCH) << TIMESTAMP_LEFT_SHIFT_BITS) | (workerId << WORKER_ID_LEFT_SHIFT_BITS) | sequence;
        
        return currentId;
    <|file_separator|><nl>
        data.put(key, value);
    <|file_separator|><nl>
        super.setCauseThrowable(throwable);
    }
    
    @Override
    public Throwable getCauseThrowable() {
        return super.getCauseThrowable();
    <|file_separator|><nl>
        taskRegistrar.setScheduler(new ThreadPoolTaskScheduler());
    <|file_separator|><nl>
        FilterRegistrationBean<ParamCheckerFilter> registration = new FilterRegistrationBean<>();
        registration.setFilter(checkerFilter);
        registration.addUrlPatterns("/api/*");
        return registration;
    <|file_separator|><nl>
        return new ArrayList<ParamInfo>(<|file_separator|><nl>
        filters.add(requestFilter);
    }
    
    public void processRequest(Request request) {
        for (AbstractRequestFilter filter : filters) {
            filter.processRequest(request);
        }
    <|file_separator|><nl>
        return null;
    <|file_separator|><nl>
        for (ProtocolNegotiatorBuilder builder : ProtocolNegotiatorBuilder.values()) {
            builderMap.put(builder.type(), builder);
        }
    <|file_separator|><nl>
        OverrideParameterRequestWrapper requestWrapper = new OverrideParameterRequestWrapper(request);
        requestWrapper.params.putAll(appendParameters);
        return requestWrapper;
    }
    
    @Override
    public String getParameter(String name, String defaultValue) {
        String[] values = params.get(name);
        if (values == null || values.length == 0) {
            return defaultValue;
        }
        return values[0];
    <|file_separator|><nl>
        
        MockRequestHandler mockRequestHandler = new MockRequestHandler();
        
        Request request = new Request();
        
        RequestMeta meta = new RequestMeta();
        
        remoteRequestAuthFilter.filter(mockRequestHandler, request, meta);
    <|file_separator|><nl>
        MockitoAnnotations.initMocks(this);
    <|file_separator|><nl>
        UpdateRequest request = new UpdateRequest();
        request.setCluster("test");
        request.setServiceName("test");
        request.setIp("1.1.1.1");
        request.setPort(8848);
        request.setMetadata(Collections.singletonMap("test", "test"));
        request.setEphemeral(true);
        
        when(nacosClusterOperationService.update(any())).thenReturn(true);
        Result<Boolean> result = nacosClusterControllerV2.update(request);
        verify(nacosClusterOperationService).update(any());
        assertEquals(ErrorCode.SUCCESS.getCode(), result.getCode());
        assertEquals(true, result.getData());
    <|file_separator|><nl>
        raftProtocol.memberChange(groupId);
        verify(jRaftMaintainService).memberChange(groupId);
    <|file_separator|><nl>
        // TODO
    <|file_separator|><nl>
        HealthCheckRequestHandler handler = registry.getByRequestType(HealthCheckRequest.class);
        
        Assert.assertEquals(handler.getClass(), HealthCheckRequestHandler.class);
    <|file_separator|><nl>
        RpcAckCallbackInitorOrCleaner rpcAckCallbackInitorOrCleaner = new RpcAckCallbackInitorOrCleaner();
        rpcAckCallbackInitorOrCleaner.init();
        rpcAckCallbackInitorOrCleaner.clean();
    <|file_separator|><nl>
        
        ServerLoaderInfo serverLoaderInfo = new ServerLoaderInfo();
        
        serverLoaderInfo.setServerId(1);
        serverLoaderInfo.setServerType(ServerType.SERVER_TYPE_1);
        serverLoaderInfo.setServerStatus(ServerStatus.SERVER_STATUS_1);
        serverLoaderInfo.setServerIp("127.0.0.1");
        serverLoaderInfo.setServerPort(1000);
        serverLoaderInfo.setServerStatus(ServerStatus.SERVER_STATUS_1);
        serverLoaderInfo.setServerStatus(ServerStatus.SERVER_STATUS_1);
        serverLoaderInfo.setServerStatus(ServerStatus.SERVER_STATUS_1);
        serverLoaderInfo.setServerStatus(ServerStatus.SERVER_STATUS_1);
        serverLoaderInfo.setServerStatus(ServerStatus.SERVER_STATUS_1);
        serverLoaderInfo.setServerStatus(ServerStatus.SERVER_STATUS_1);
        serverLoaderInfo.setServerStatus(ServerStatus.SERVER_STATUS_1);
        serverLoaderInfo.setServerStatus(ServerStatus.SERVER_STATUS_1);
        serverLoaderInfo.setServerStatus(ServerStatus.SERVER_STATUS_1);
        serverLoaderInfo.setServerStatus(ServerStatus.SERVER_STATUS_1);
        serverLoaderInfo.setServerStatus(ServerStatus.SERVER_STATUS_1);
        serverLoaderInfo.setServerStatus(ServerStatus.SERVER_STATUS_1);
        serverLoaderInfo.setServerStatus(ServerStatus.SERVER_STATUS_1);
        serverLoaderInfo.setServerStatus(ServerStatus.SERVER_STATUS_1);
        serverLoaderInfo.setServerStatus(ServerStatus.SERVER_STATUS_1);
        serverLoaderInfo.setServerStatus(ServerStatus<nl>
        namespaceOperationService.getNamespace(TEST_NAMESPACE_ID);
        verify(namespacePersistService).findTenantByKp(DEFAULT_KP);
    <|file_separator|><nl>
        try {
            byte[] key = "key".getBytes();
            byte[] value = "value".getBytes();
            kvStorage.batchPut(key, value);
            byte[] value1 = kvStorage.get(key);
            Assert.assertArrayEquals(value, value1);
            
            Assert.assertNotNull(kvStorage.allKeys());
            
            kvStorage.batchDelete(key);
            Assert.assertNull(kvStorage.get(key));
            
            kvStorage.batchPut(key, value);
            kvStorage.shutdown();
            Assert.assertEquals(kvStorage.allKeys().size(), kvStorage.allKeys().size());
        } catch (Exception e) {
            e.printStackTrace();
            Assert.fail();
        }
    <|file_separator|><nl>
        
        System.out.printf("System property "%s" = %s n", "nacos.preferHostnameOverIp", preferHostMode);
        
        if ("true".equalsIgnoreCase(System.getProperty("nacos.preferHostnameOverIp"))) {
            Assert.assertTrue(Boolean.getBoolean(PREFER_HOSTNAME_OVER_IP_PROPERTY_NAME));
        } else {
            Assert.assertFalse(Boolean.getBoolean(PREFER_HOSTNAME_OVER_IP_PROPERTY_NAME));
        }
        
        Assert.assertEquals(preferHostMode, Boolean.getBoolean(PREFER_HOSTNAME_OVER_IP_PROPERTY_NAME));
        
    <|file_separator|><nl>
        super.push(response, watchedStatus);
    <|file_separator|><nl>
    <|file_separator|><nl>
        return groupName;
    <|file_separator|><nl>
        if (singleton == null) {
            synchronized (EmptyXdsGenerator.class) {
                if (singleton == null) {
                    singleton = new EmptyXdsGenerator();
                }
            }
        }
        return singleton;
    <|file_separator|><nl>
        return switchDomain;
    <|file_separator|><nl>
        serviceOperatorV2.update(Service.newService(serviceForm.getNamespaceId(), serviceForm.getGroupName(),
                serviceForm.getServiceName(), serviceForm.getEphemeral()), serviceForm.getMetadata());
        return Result.success("ok");
    <|file_separator|><nl>
        if (healthy) {
            this.clientManager.updateHealthStatusForPersistentInstance(namespace, fullServiceName, clusterName, ip, port);
        } else {
            this.clientOperationService.updateHealthStatusForPersistentInstance(namespace, fullServiceName, clusterName, ip, port);
        }
    }
    
    @Override
    public void updateHealthStatusForPersistentInstance(String namespace, String fullServiceName, String clusterName,
            String ip, int port, boolean healthy, String metadata) throws NacosException {
        if (healthy) {
            this.clientManager.updateHealthStatusForPersistentInstance(namespace, fullServiceName, clusterName, ip, port,
                    metadata);
        } else {
            this.clientOperationService.updateHealthStatusForPersistentInstance(namespace, fullServiceName, clusterName, ip,
                    port, metadata);
        }
    }
    
    @Override
    public void updateHealthStatusForPersistentInstance(String namespace, String fullServiceName, String clusterName,
            String ip, int port, boolean healthy, String metadata, long lastUpdateTime) throws NacosException {
        if (healthy) {
            this.clientManager.updateHealthStatusForPersistentInstance(namespace, fullServiceName, clusterName, ip, port,
                    metadata, lastUpdateTime);
        } else {
            this.clientOperationService.updateHealthStatusForPersistentInstance(namespace, fullServiceName, clusterName, ip,
                    port, metadata, lastUpdateTime);
        }
    }
    
    @Override
    public void updateHealthStatusForPersistentInstance(String namespace, String fullServiceName, String clusterName,
            String ip, int port, boolean healthy, String metadata, long lastUpdateTime, String[] tags)
            throws NacosException {
        if (healthy) {
            this<nl>
        this.clientSyncDataList = clientSyncDataList;
    <|file_separator|><nl>
        return clients;<|file_separator|><nl>
            return client;
        <|file_separator|><nl>
        while (!shutdown) {
            try {
                Event event = queue.poll(1000L, TimeUnit.MILLISECONDS);
                if (null == event) {
                    continue;
                }
                handleEvent(event);
            } catch (Exception e) {
                Loggers.EVT_LOG.error("Naming Event Publisher {}, stop to handle event due to unexpected exception: ",
                        this.publisherName, e);
            }
        }
    <|file_separator|><nl>
        this.batchInstancePublishInfos = batchInstancePublishInfos;
    <|file_separator|><nl>
        
        while (true) {
            
            try {
                
                String message = client.read();
                
                if (message == null) {
                    
                    break;
                    
                } else {
                    
                    String[] parts = message.split(" ");
                    
                    if (parts.length == 2) {
                        
                        String rs = parts[0];
                        String beat = parts[1];
                        
                        if (rsInfo.isRs(rs)) {
                            
                            rsInfo.setBeat(rs, beat);
                            
                        }
                        
                    }
                    
                }
                
            } catch (Exception e) {
                
                e.printStackTrace();
                
            }
            
        }
        
    <|file_separator|><nl>
        return serviceCount;
    <|file_separator|><nl>
        List<ParamInfo> paramInfos = new ArrayList<>();
        String namespaceId = getAliasNamespaceId(request);
        String ip = getAliasIp(request);
        String port = getAliasPort(request);
        String serviceName = getAliasServiceName(request);
        String groupName = getAliasGroupName(request);
        String clusterName = getAliasClusterName(request);
        paramInfos.add(new ParamInfo("namespaceId", namespaceId));
        paramInfos.add(new ParamInfo("ip", ip));
        paramInfos.add(new ParamInfo("port", port));
        paramInfos.add(new ParamInfo("serviceName", serviceName));
        paramInfos.add(new ParamInfo("groupName", groupName));
        paramInfos.add(new ParamInfo("clusterName", clusterName));
        return paramInfos;<|file_separator|><nl>
        return null;
    <|file_separator|><nl>
        return "Subscriber{" + "addrStr='" + addrStr + '\'' + ", agent='" + agent + '\'' + ", app='" + app + '\'' + ", ip='"
                + ip + '\'' + ", namespaceId='" + namespaceId + '\'' + ", serviceName='" + serviceName + '\'' + ", port="
                + port + ", cluster='" + cluster + '\'' + '}';
    <|file_separator|><nl>
        processedDatum.put(key, processedData);
    <|file_separator|><nl>
        Service service = request.getService();
        if (service == null) {
            throw new NacosException(NamingRemoteConstants.SERVICE_NOT_FOUND);
        }
        return batchRegisterInstance(service, request, meta);
    <|file_separator|><nl>
        context = new AnnotationConfigApplicationContext(TestConfig.class);
        context.registerShutdownHook();
        context.refresh();
        mockInjectPushServer();
        mockInjectSwitchDomain();
        mockInjectDistroMapper();
    }
    
    @After
    public void after() {
        context.close();
    }
    
    protected MockHttpServletRequestBuilder convert(Object simpleOb) throws IllegalAccessException {
        return convert(simpleOb, MockMvcRequestBuilders.get("/"));
    <|file_separator|><nl>
        Mockito.when(clientManager.getClient("127.0.0.1:8081#true")).thenReturn(new IpPortBasedClient("127.0.0.1:8081#true", true));
        Mockito.when(clientManager.isResponsibleClient(Mockito.any(Client.class))).thenReturn(Boolean.TRUE);
        Mockito.when(clientManager.isResponsibleClient(Mockito.any(Client.class))).thenReturn(Boolean.TRUE);
        Mockito.when(clientManager.isResponsibleClient(Mockito.any(Client.class))).thenReturn(Boolean.TRUE);
        Mockito.when(clientManager.isResponsibleClient(Mockito.any(Client.class))).thenReturn(Boolean.TRUE);
        Mockito.when(clientManager.isResponsibleClient(Mockito.any(Client.class))).thenReturn(Boolean.TRUE);
        Mockito.when(clientManager.isResponsibleClient(Mockito.any(Client.class))).thenReturn(Boolean.TRUE);
        Mockito.when(clientManager.isResponsibleClient(Mockito.any(Client.class))).thenReturn(Boolean.TRUE);
        Mockito.when(clientManager.isResponsibleClient(Mockito.any(Client.class))).thenReturn(Boolean.TRUE);
        Mockito.when(clientManager.isResponsibleClient(Mockito.any(Client.class))).thenReturn(Boolean.TRUE);
        Mockito.when(clientManager.isResponsibleClient(Mockito.any(Client.class))).thenReturn(Boolean.TRUE);
        Mockito.when(clientManager.isResponsibleClient(Mockito.any(Client.class))).thenReturn(Boolean.TRUE);
        Mockito.when(clientManager.isResponsibleClient(Mockito.any(Client.class))).thenReturn(Boolean.TRUE);
        Mockito.when(clientManager.isResponsibleClient(Mockito.any(Client.class))).<nl>
        MockHttpServletRequestBuilder mockHttpServletRequestBuilder = MockMvcRequestBuilders.get(URL + "/detail")
                .param("clientId", "test1");
        mockmvc.perform(mockHttpServletRequestBuilder).andExpect(MockMvcResultMatchers.jsonPath("$.data.ip").value("127.0.0.1"));
    <|file_separator|><nl>
        String serviceName = "test";
        String namespaceId = "public";
        boolean aggregation = Boolean.FALSE;
        try {
            List<Subscriber> clients = new ArrayList<Subscriber>();
            Subscriber subscriber = new Subscriber("127.0.0.1:8080", "test", "app", "127.0.0.1", namespaceId,
                    "testGroupName@@test_subscriber", 0);
            clients.add(subscriber);
            Mockito.when(this.aggregation.getFuzzySubscribers(Mockito.anyString(), Mockito.anyString()))
                    .thenReturn(clients);
            List<Subscriber> list = subscribeManager.getSubscribers(serviceName, namespaceId, aggregation);
            Assert.assertNotNull(list);
            Assert.assertEquals(1, list.size());
            Assert.assertEquals("testGroupName@@test_subscriber", list.get(0).getServiceName());
        } catch (Exception ignored) {
        
        }
    <|file_separator|><nl>
        serviceStorage = new ServiceStorage(clientServiceIndexesManager, clientManagerDelegate, switchDomain,
                namingMetadataManager);
    <|file_separator|><nl>
        healthCheckExtendProvider = new HealthCheckExtendProvider();
        healthCheckExtendProvider.setRegistry(registry);
    <|file_separator|><nl>
        healthCheckTaskV2 = new HealthCheckTaskV2(ipPortBasedClient, context, switchDomain);
    <|file_separator|><nl>
        members = new HashMap<String, Member>();
        members.put("local", new Member("local", "127.0.0.1", 10000));
        when(memberManager.getMembers()).thenReturn(members);
        when(environment.getProperty("naming.subscriber.service.local")).thenReturn("local");
        when(environment.getProperty("naming.subscriber.service.namespace")).thenReturn(namespace);
        when(environment.getProperty("naming.subscriber.service.name")).thenReturn(serviceName);
        when(environment.getProperty("naming.subscriber.service.port")).thenReturn("10000");
        when(environment.getProperty("naming.subscriber.service.type")).thenReturn("G");
        when(environment.getProperty("naming.subscriber.service.version")).thenReturn("S");
        when(environment.getProperty("naming.subscriber.service.weight")).thenReturn("1");
        when(environment.getProperty("naming.subscriber.service.weight.type")).thenReturn("weight");
        when(environment.getProperty("naming.subscriber.service.weight.type")).thenReturn("weight");
        when(environment.getProperty("naming.subscriber.service.weight.type")).thenReturn("weight");
        when(environment.getProperty("naming.subscriber.service.weight.type")).thenReturn("weight");
        when(environment.getProperty("naming.subscriber.service.weight.type")).thenReturn("weight");
        when(environment.getProperty("naming.subscriber.service.weight.type")).thenReturn("weight");
        when(environment.getProperty("naming.subscriber.service.weight.type")).thenReturn("weight");
        when(environment.getProperty("naming.subscriber.service.weight.type")).thenReturn("weight");
        when(environment.getProperty("naming.subscriber.service.weight.type")).thenReturn("weight");
        <nl>
        MockitoAnnotations.initMocks(this);
        pushExecutor = new PushExecutorRpcImpl(pushService, selectorManager, context);
        serviceMetadata = new ServiceMetadata();
        serviceMetadata.setServiceId("testServiceId");
        serviceMetadata.setServiceName("testServiceName");
        serviceMetadata.setServiceVersion("testServiceVersion");
        serviceMetadata.setServiceType("testServiceType");
        serviceMetadata.setServiceGroup("testServiceGroup");
        serviceMetadata.setServiceDescription("testServiceDescription");
        serviceMetadata.setServiceStatus("testServiceStatus");
        serviceMetadata.setServiceAddress("testServiceAddress");
        serviceMetadata.setServicePort(1234);
        serviceMetadata.setServiceMetadata(new HashMap<String, String>());
        serviceMetadata.setServiceMetadata().put("testKey", "testValue");
        pushData = new PushDataWrapper();
        pushData.setServiceMetadata(serviceMetadata);
        pushData.setOriginalData(new Object());
    <|file_separator|><nl>
        if (shouldSuccess) {
            subscriber.onPush(data);
        } else {
            throw failedException;
        }
    <|file_separator|><nl>
        executeEngine = new PushDelayTaskExecuteEngine(clientManager, indexesManager, serviceStorage, metadataManager,
                pushExecutor);
    <|file_separator|><nl>
        Selector selector = selectorManager.select("mock", "key=value");
        Assert.assertTrue(selector instanceof MockSelector);
    <|file_separator|><nl>
        Instance instance = new Instance();
        instance.setIp("1.1.1.1");
        instance.setPort(8890);
        String groupedServiceName = "test";
        instance.setClusterName("testCluster");
        InstanceUtil.setInstanceIdIfEmpty(instance, groupedServiceName);
        assertNotNull(instance.getInstanceId());
        assertEquals(instance.getInstanceId(), InstanceIdGeneratorManager.generateInstanceId(instance));
        String customInsId = "customInstanceId_1";
        Instance instance1 = new Instance();
        instance1.setInstanceId(customInsId);
        InstanceUtil.setInstanceIdIfEmpty(instance1, groupedServiceName);
        assertEquals(instance1.getInstanceId(), customInsId);
    <|file_separator|><nl>
        // 08otherUseExternalDBfalseother
        System.setProperty(Constants.STANDALONE_MODE_PROPERTY_NAME, "false");
        environment.setProperty(PersistenceConstant.DATASOURCE_PLATFORM_PROPERTY_OLD, "other");
        EnvUtil.setIsStandalone(Boolean.getBoolean(Constants.STANDALONE_MODE_PROPERTY_NAME));
        DatasourceConfiguration.setEmbeddedStorage(true);
        
        // 
        datasourceConfig.initialize(null);
        
        Assert.assertFalse(EnvUtil.getStandaloneMode());
        Assert.assertFalse(DatasourceConfiguration.isUseExternalDB());
        Assert.assertTrue(dataSource.getDataSource() instanceof LocalDataSourceServiceImpl);
    <|file_separator|><nl>
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        MockConfigInfo that = (MockConfigInfo) o;
        return id == that.id &&
                Objects.equals(dataId, that.dataId) &&
                Objects.equals(group, that.group) &&
                Objects.equals(content, that.content);
    <|file_separator|><nl>
        LOGGER.error("Unauthorized error: {}", e.getMessage());
        response.sendError(HttpServletResponse.SC_UNAUTHORIZED, "Error: Unauthorized");
    <|file_separator|><nl>
        return true;
    <|file_separator|><nl>
        return exp;
    <|file_separator|><nl>
        return ServerConfigChangeEvent.class;
    <|file_separator|><nl>
        return true;
    <|file_separator|><nl>
        conditionOnLdapAuth = new ConditionOnLdapAuth();
    }
    
    @Test
    public void getConditionName() {
        String conditionName = conditionOnLdapAuth.getConditionName();
        Assert.assertEquals("conditionOnLdapAuth", conditionName);
    <|file_separator|><nl>
        return new ConnectionCheckResponse();
    <|file_separator|><nl>
        NacosConnectionControlManager nacosConnectionControlManager = new NacosConnectionControlManager();
        ConnectionControlRule connectionControlRule = new ConnectionControlRule();
        connectionControlRule.setCountLimit(10);
        nacosConnectionControlManager.applyConnectionLimitRule(connectionControlRule);
        ConnectionCheckRequest connectionCheckRequest = new ConnectionCheckRequest("127.0.0.1", "test", "test");
        ConnectionCheckResponse connectionCheckResponse = nacosConnectionControlManager.check(connectionCheckRequest);
        Assert.assertTrue(connectionCheckResponse.isSuccess());
    <|file_separator|><nl>
        return "TestConnectionMetricsCollector";
    <|file_separator|><nl>
        return "Permission [resource=" + resource + ", action=" + action + "]";
    <|file_separator|>class ActionTypes.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class ActionTypes {
    
    public static final String READ = "read";
    public static final String WRITE = "write";
    public static final String DELETE = "delete";
    public static final String UPDATE = "update";
    
}<|file_separator|>class Resource.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class Resource {
    
    private String name;
    
    public Resource() {
    }
    
    public Resource(String name) {
        this.name = name;
    }
    
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    @Override
    public String toString() {
        return "Resource [name=" + name + "]";
    }
}<|file_separator|><nl>
        if (instance == null) {
            synchronized (ControlManagerCenter.class) {
                if (instance == null) {
                    instance = new ControlManagerCenter();
                }
            }
        }
        return instance;
    <|file_separator|><nl>
            if (event.getRule().getRuleType() == TpsControlRuleType.CHANGE) {
                // do something
            }
        <|file_separator|><nl>
        return new NacosTpsBarrierCreator();
    }
    
    /**
     * Init tps control manager.
     */
    public void init() {
        Map<String, TpsControlRule> rules = getRules();
        if (rules != null && rules.size() > 0) {
            for (Map.Entry<String, TpsControlRule> entry : rules.entrySet()) {
                String pointName = entry.getKey();
                TpsControlRule rule = entry.getValue();
                initTpsRule(pointName);
            }
        }
    <|file_separator|><nl>
        return 10;
    <|file_separator|><nl>
        System.setProperty("nacos.home", "D:\\nacos");
        String home = EnvUtils.getNacosHome();
        System.out.println(home);
    <|file_separator|><nl>
        return null;<|file_separator|><nl>
        tenantInfoMapperByMySql = new TenantInfoMapperByMySql();
    <|file_separator|><nl>
        assertTrue(NacosTracePluginManager.getInstance().getAllTraceSubscribers().contains(TestPlugin.class));
    <|file_separator|><nl>
        return buffer.toString();
        <|file_separator|><nl>
        InternalMethod internalMethod = new InternalMethod();
        Assert.assertEquals(1.1d, MethodUtil.invokeAndReturnDouble(DOUBLE_METHOD, internalMethod));
        Assert.assertNotEquals(1.1d, MethodUtil.invokeAndReturnDouble(LONG_METHOD, internalMethod));
    <|file_separator|><nl>
        String newNacosHome = LocalConfigInfoProcessor.LOCAL_SNAPSHOT_PATH + caseName + "/";
        String oldNacosHome = LocalConfigInfoProcessor.LOCAL_SNAPSHOT_PATH;
        String newNacosHomePath = System.getProperty("user.dir") + "/" + newNacosHome;
        String oldNacosHomePath = System.getProperty("user.dir") + "/" + oldNacosHome;
        File newNacosHomeFile = new File(newNacosHomePath);
        File oldNacosHomeFile = new File(oldNacosHomePath);
        if (newNacosHomeFile.exists()) {
            if (oldNacosHomeFile.exists()) {
                FileUtils.deleteDirectory(oldNacosHomeFile);
            }
            FileUtils.copyDirectory(newNacosHomeFile, oldNacosHomeFile);
        }
        return newNacosHome;
    <|file_separator|><nl>
        logger.info(String.format("nacosSmoke_ITCase: %s;", "setUp"));
    <|file_separator|><nl>
                System.out.println(((NamingEvent) event).getServiceName());
                System.out.println(((NamingEvent) event).getInstances());
                instances = ((NamingEvent) event).getInstances();
            <|file_separator|><nl>
        final int prime = 31;
        int result = 1;
        result = prime * result + ((name == null) ? 0 : name.hashCode());
        result = prime * result + ((serviceClass == null) ? 0 : serviceClass.hashCode());
        result = prime * result + ((order == null) ? 0 : order.hashCode());
        result = prime * result + ((scope == null) ? 0 : scope.hashCode());
        return result;
    <|file_separator|><nl>
        if (blob == null) {
            return null;
        }

        try {
            return new String(blob.getBytes(1, (int) blob.length()), Constants.DEFAULT_CHARSET);
        } catch (Exception e) {
            throw new ShouldNeverHappenException(e);
        }
    <|file_separator|><nl>
        RepeatRegistrationException exception = new RepeatRegistrationException();
        assertEquals("User already exists", exception.getMessage());
    <|file_separator|><nl>
        try {
            throw new RetryableException("test");
        } catch (RetryableException e) {
            // do something
        }
    <|file_separator|><nl>
        SecurityManager securityManager = new SecurityManager();
        NamedThreadFactory namedThreadFactory = new NamedThreadFactory("testNameThread", 5, true, securityManager);
        Thread testNameThread = namedThreadFactory
            .newThread(() -> {
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            });
        assertThat(testNameThread.getName()).startsWith("testNameThread");
        assertThat(testNameThread.isDaemon()).isTrue();
    <|file_separator|><nl>
        Date date = DateUtil.parseDate("2023-05-11 10:10:10", "yyyy-MM-dd HH:mm:ss");
        Assertions.assertNotNull(date);
    <|file_separator|><nl>
        return org.apache.seata.common.util.StringUtils.join(iterator,separator);
    <|file_separator|><nl>
        return isLocalTCC(bean.getClass());
    <|file_separator|><nl>
        return false;
    <|file_separator|><nl>
        if (bytes == null) {
            throw new NullPointerException("bytes is null");
        }
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        try (ZipOutputStream zip = new ZipOutputStream(out)) {
            zip.putNextEntry(new ZipEntry("test"));
            zip.write(bytes);
            zip.closeEntry();
            return out.toByteArray();
        } catch (IOException e) {
            throw new RuntimeException("Zip compress error", e);
        }
    <|file_separator|><nl>
        return ZstdUtil.decompress(bytes);
    <|file_separator|><nl>
        Configuration fileConfig = ConfigurationFactory.getInstance();
        fileConfig.addConfigListener(new ConfigListener() {
            @Override
            public void onConfigChanged(String key, String value) {
                System.out.println("onConfigChanged: " + key + " = " + value);
            }
        });
        fileConfig.set("int.not.exist", 100);
        fileConfig.set("str.not.exist", "en");
        fileConfig.set("boolean.not.exist", true);
        fileConfig.set("mockDataId1", "QWERT");
        fileConfig.set("mockDataId2", "QWERT");
        Thread.sleep(1000);
    <|file_separator|><nl>
        YamlFileConfig config = new YamlFileConfig("config.yaml");
        String value = config.getString("key");
        assertEquals("value", value);
    <|file_separator|><nl>
        return data.toString().getBytes(StandardCharsets.UTF_8);
    <|file_separator|><nl>
        return new ZookeeperConfiguration();
    <|file_separator|><nl>
        return timeStart;
    <|file_separator|><nl>
        return new PageResult<>(list, total, pages, pageNum, pageSize);
    <|file_separator|><nl>
        this.resultCode = resultCode;
    <|file_separator|><nl>
        return 100;
    <|file_separator|>class MergeMessage.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public interface MergeMessage {
    short getTypeCode();
}<|file_separator|><nl>
        this.requestMessage = requestMessage;
    <|file_separator|><nl>
        return (short) 1;
    }

    @Override
    public String getExtraData() {
        return extraData;
    }

    @Override
    public void setExtraData(String extraData) {
        this.extraData = extraData;
    }

    @Override
    public String getAK() {
        return null;
    }

    @Override
    public void setAK(String ak) {
        // do nothing
    }

    @Override
    public String getDigest() {
        return null;
    }

    @Override
    public void setDigest(String digest) {
        // do nothing
    }

    @Override
    public String getTimestamp() {
        return null;
    }

    @Override
    public void setTimestamp(String timestamp) {
        // do nothing
    }

    @Override
    public String getAuthVersion() {
        return null;
    }

    @Override
    public void setAuthVersion(String authVersion) {
        // do nothing
    <|file_separator|><nl>
        return "BranchReportRequest{" +
                "xid='" + xid + '\'' +
                ", branchId=" + branchId +
                ", resourceId='" + resourceId + '\'' +
                ", status=" + status +
                ", applicationData='" + applicationData + '\'' +
                ", branchType=" + branchType +
                '}';
    <|file_separator|><nl>
        return first;
    <|file_separator|><nl>
        if (rpcMessage.getBody() instanceof AbstractRequestMessage) {
            onResponseMessage(ctx, rpcMessage);
        }
    <|file_separator|><nl>
        if (this.transactionId < branchTransactionDO.transactionId) {
            return -1;
        } else if (this.transactionId > branchTransactionDO.transactionId) {
            return 1;
        } else {
            return 0;
        }
    <|file_separator|><nl>
        return UPDATE_GLOBAL_TRANSACTION_STATUS_BY_STATUS_SQLSERVER.replace(GLOBAL_TABLE_PLACEHOLD, globalTable);
    <|file_separator|><nl>
        BranchCommitResponse branchCommitResponse = new BranchCommitResponse();
        branchCommitResponse.setBranch("master");
        branchCommitResponse.setCommit("123456789");
        branchCommitResponse.setCommitMessage("test");
        branchCommitResponse.setCommitTime("2019-01-01 12:00:00");
        branchCommitResponse.setCommitUser("test");
        branchCommitResponse.setCommitUserEmail("test");
        branchCommitResponse.setCommitUserUrl("test");
        branchCommitResponse.setCommitUserAvatarUrl("test");
        branchCommitResponse.setCommitUserGravatarId("test");
        branchCommitResponse.setCommitUserType("test");
        branchCommitResponse.setCommitUserHtmlUrl("test");
        branchCommitResponse.setCommitUserFollowersUrl("test");
        branchCommitResponse.setCommitUserFollowingUrl("test");
        branchCommitResponse.setCommitUserGistsUrl("test");
        branchCommitResponse.setCommitUserStarredUrl("test");
        branchCommitResponse.setCommitUserSubscriptionsUrl("test");
        branchCommitResponse.setCommitUserOrganizationsUrl("test");
        branchCommitResponse.setCommitUserReposUrl("test");
        branchCommitResponse.setCommitUserEventsUrl("test");
        branchCommitResponse.setCommitUserReceivedEventsUrl("test");
        branchCommitResponse.setCommitUserType("test");
        branchCommitResponse.setCommitUserSiteAdmin("test");
        branchCommitResponse.setCommitUserScore("test");
        branchCommitResponse.setCommitUserNodeId("test");
        branchCommitResponse.setCommitUserGravatarId("test");
        branchCommitResponse.setCommitUserGravatarId("test");
        branchCommitResponse.setCommit<nl>
        BranchRegisterResponse object = new BranchRegisterResponse();
        object.setBranchId(1);
        object.setBranchName("branchName");
        object.setBranchCode("branchCode");
        object.setBranchAddress("branchAddress");
        object.setBranchContact("branchContact");
        object.setBranchEmail("branchEmail");
        object.setBranchStatus("branchStatus");
        object.setBranchType("branchType");
        object.setBranchDescription("branchDescription");
        object.setBranchLogo("branchLogo");
        object.setBranchLogoPath("branchLogoPath");
        object.setBranchLogoName("branchLogoName");
        object.setBranchLogoType("branchLogoType");
        object.setBranchLogoSize("branchLogoSize");
        object.setBranchLogoPathName("branchLogoPathName");
        object.setBranchLogoPathType("branchLogoPathType");
        object.setBranchLogoPathSize("branchLogoPathSize");
        object.setBranchLogoPathNameType("branchLogoPathNameType");
        object.setBranchLogoPathNameSize("branchLogoPathNameSize");
        object.setBranchLogoPathNameTypeSize("branchLogoPathNameTypeSize");
        object.setBranchLogoPathNameSizeType("branchLogoPathNameSizeType");
        object.setBranchLogoPathNameSizeTypeSize("branchLogoPathNameSizeTypeSize");
        object.setBranchLogoPathNameSizeTypeSizeSize("branchLogoPathNameSizeTypeSizeSize");
        object.setBranchLogoPathNameSizeTypeSizeSizeSize("branchLogoPathNameSizeTypeSizeSizeSize");
        object.setBranchLogoPathNameSizeTypeSizeSizeSizeSize("branchLogoPathNameSizeTypeSizeSizeSizeSize");
        object.setBranchLogoPathNameSizeTypeSizeSizeSize<nl>
        Assertions.assertEquals(1, HeartbeatMessage.PING.getTypeCode());
        Assertions.assertEquals(2, HeartbeatMessage.PONG.getTypeCode());
    <|file_separator|><nl>
        BranchRollbackResponse response = new BranchRollbackResponse();
        response.setBranch("test");
        response.setCommitId("test");
        response.setCommitMessage("test");
        response.setCommitTime("test");
        response.setCommitter("test");
        response.setCommitterEmail("test");
        response.setCommitterName("test");
        response.setCommitterTime("test");
        response.setCommitterTimeZone("test");
        response.setCommitterTimeZoneOffset("test");
        response.setCommitterTimeZoneOffsetMinutes("test");
        response.setCommitterTimeZoneOffsetSeconds("test");
        response.setCommitterTimeZoneOffsetSecondsFraction("test");
        response.setCommitterTimeZoneOffsetSecondsFractionDigits("test");
        response.setCommitterTimeZoneOffsetSecondsFractionDigitsCount("test");
        response.setCommitterTimeZoneOffsetSecondsFractionDigitsCountMax("test");
        response.setCommitterTimeZoneOffsetSecondsFractionDigitsCountMin("test");
        response.setCommitterTimeZoneOffsetSecondsFractionDigitsCountMin("test");
        response.setCommitterTimeZoneOffsetSecondsFractionDigitsCountMin("test");
        response.setCommitterTimeZoneOffsetSecondsFractionDigitsCountMin("test");
        response.setCommitterTimeZoneOffsetSecondsFractionDigitsCountMin("test");
        response.setCommitterTimeZoneOffsetSecondsFractionDigitsCountMin("test");
        response.setCommitterTimeZoneOffsetSecondsFractionDigitsCountMin("test");
        response.setCommitterTimeZoneOffsetSecondsFractionDigitsCountMin("test");
        response.setCommitterTimeZoneOffsetSecondsFractionDigitsCountMin("test");
        response.setCommitterTimeZoneOffsetSecondsFractionDigitsCountMin("test");
        response.setCommitterTimeZoneOffsetSecondsFractionDigitsCountMin("test");
        response.setCommitterTimeZone<nl>
        int size = random.nextInt(10);
        return IntStream.range(0, size).mapToObj(i -> addDisposable(random.nextInt(10))).collect(Collectors.toList());
    }

    @Test
    void testAddAndExecuteWithPriority() throws InterruptedException {
        // note: all of them had been added in the addDisposable method
        List<Disposable> disposableList = getRandomDisposableList();

        hook.start();
        hook.join();

        disposableList.forEach(disposable -> verify(disposable, times(1)).destroy());
    }

    @Test
    void testAddAndExecuteWithPriorityAndRandom() throws InterruptedException {
        // note: all of them had been added in the addDisposable method
        List<Disposable> disposableList = getRandomDisposableList();

        hook.start();
        hook.join();

        disposableList.forEach(disposable -> verify(disposable, times(1)).destroy());
    }

    @Test
    void testAddAndExecuteWithPriorityAndRandomAndStream() throws InterruptedException {
        // note: all of them had been added in the addDisposable method
        List<Disposable> disposableList = getRandomDisposableList();

        hook.start();
        hook.join();

        disposableList.forEach(disposable -> verify(disposable, times(1)).destroy());
    }

    @Test
    void testAddAndExecuteWithPriorityAndRandomAndStreamAndStream() throws InterruptedException {
        // note: all of them had been added in the addDisposable method
        List<Disposable> disposableList = getRandomDisposableList();

        hook.start();
        hook.join();

        disposableList.forEach(disposable -> verify(disposable, times(1)).destroy());
    }

    @Test
    void testAddAndExecuteWithPriorityAndRandomAnd<nl>
        Assertions.assertEquals(nettyPoolKey.toString(), "NettyPoolKey(transactionRole=" + RM_ROLE + ", address=" + ADDRESS1 + ", message=" + MSG1 + ")");
    <|file_separator|><nl>
        String groupList = CONFIG.getString(clusterName + POSTFIX_GROUPLIST);
        if (groupList == null) {
            String missingDataId = PREFIX_SERVICE_ROOT + CONFIG_SPLIT_CHAR + PREFIX_SERVICE_MAPPING + clusterName + POSTFIX_GROUPLIST;
            throw new ConfigNotFoundException("%s configuration item is required", missingDataId);
        }
        return groupList;
    }

    private String getServiceGroup(String key) {
        String[] keyParts = key.split(CONFIG_SPLIT_CHAR);
        if (keyParts.length != 2) {
            throw new IllegalArgumentException("key format should like service:group, the invalid key: " + key);
        }
        return keyParts[1];
    <|file_separator|><nl>
        return new RegistryService(customName);
    <|file_separator|><nl>
        EtcdRegistryProvider provider = new EtcdRegistryProvider();
        provider.setEtcdUrl("http://127.0.0.1:2379");
        provider.setEtcdKey("test");
        provider.setEtcdTimeout(1000);
        provider.setEtcdInterval(1000);
        provider.setEtcdRetry(10);
        provider.setEtcdRetryInterval(1000);
        provider.setEtcdRetryMax(10);
        provider.setEtcdRetryMaxInterval(1000);
        provider.setEtcdRetryMinInterval(1000);
        provider.setEtcdRetryMaxInterval(1000);
        provider.setEtcdRetryMaxInterval(1000);
        provider.setEtcdRetryMaxInterval(1000);
        provider.setEtcdRetryMaxInterval(1000);
        provider.setEtcdRetryMaxInterval(1000);
        provider.setEtcdRetryMaxInterval(1000);
        provider.setEtcdRetryMaxInterval(1000);
        provider.setEtcdRetryMaxInterval(1000);
        provider.setEtcdRetryMaxInterval(1000);
        provider.setEtcdRetryMaxInterval(1000);
        provider.setEtcdRetryMaxInterval(1000);
        provider.setEtcdRetryMaxInterval(1000);
        provider.setEtcdRetryMaxInterval(1000);
        provider.setEtcdRetryMaxInterval(1000);
        provider.setEtcdRetryMaxInterval(1000);
        provider.setEtcdRetryMax<nl>
        return new NacosRegistryService();
    <|file_separator|><nl>
        NacosRegistryServiceImpl nacosRegistryService = new NacosRegistryServiceImpl();
        nacosRegistryService.getConfigProperties();
    <|file_separator|><nl>
        return new RedisRegistryService();
    <|file_separator|><nl>
        return TRANSACTION_MANAGER_OPERATION_NAME_MAPPING.contains(operationName);
    }

    public static Class getTransactionTransmissionClass(String operationName) {
        return TRANSACTION_TRANSMISSION_CLASS_NAME_MAPPING.get(operationName);
    <|file_separator|><nl>
        String xid = rpcMessage.getHeader().getXid();
        if (xid == null) {
            xid = rpcMessage.getHeader().getGlobalTransactionId();
        }
        return xid;
    }

    public static String convertPeer(String peer) {
        if (peer == null) {
            return null;
        }
        if (peer.startsWith("/")) {
            peer = peer.substring(1);
        }
        return peer;
    }

    public static String convertPeer(String peer, String peerName) {
        if (peer == null) {
            return null;
        }
        if (peer.startsWith("/")) {
            peer = peer.substring(1);
        }
        return peer + "@" + peerName;
    }

    public static String convertPeer(String peer, String peerName, String peerType) {
        if (peer == null) {
            return null;
        }
        if (peer.startsWith("/")) {
            peer = peer.substring(1);
        }
        return peer + "@" + peerName + "@" + peerType;
    }

    public static String convertPeer(String peer, String peerName, String peerType, String peerId) {
        if (peer == null) {
            return null;
        }
        if (peer.startsWith("/")) {
            peer = peer.substring(1);
        }
        return peer + "@" + peerName + "@" + peerType + "@" + peerId;
    }

    public static String convertPeer(String peer, String peerName, String peerType, String peerId, String peerVersion) {
        if (peer == null) {
            return null;
        }
        if (peer.<nl>
        if (fenceHandler == null) {
            throw new IllegalStateException("FenceHandler is not set");
        }
    }
<|file_separator|><nl>
        return gmtCreate;
    <|file_separator|><nl>
        // TODO
    }
}<|file_separator|><nl>
                        super.onHeaders(headers);
                        if (xid != null) {
                            String branch = headers.get(GrpcHeaderKey.BRANCH_HEADER_KEY);
                            if (branch != null) {
                                RootContext.setBranchType(BranchType.valueOf(branch));
                            }
                        }
                    <|file_separator|><nl>
        return new ServerCall.Listener<ReqT>() {
            @Override
            public void onCancel() {
                // TODO Auto-generated method stub
                
            }

            @Override
            public void onMessage(ReqT message) {
                // TODO Auto-generated method stub
                
            }

            @Override
            public void onHalfClose() {
                // TODO Auto-generated method stub
                
            }

            @Override
            public void onReady() {
                // TODO Auto-generated method stub
                
            }

            @Override
            public void onCompleted(Status status, RespT response) {
                // TODO Auto-generated method stub
                
            }
        };
    <|file_separator|><nl>
        registry.addInterceptor(new SeataInterceptor()).addPathPatterns("/**");
        super.addInterceptors(registry);<|file_separator|><nl>
            return name;
        <|file_separator|><nl>
        return (currentMilliseconds - this.startMilliseconds) * 1000 / this.count.longValue();
    <|file_separator|><nl>
        return asyncWorker.branchRollback(xid, branchId, resourceId);
    }

    @Override
    public BranchStatus branchPrepare(BranchType branchType, String xid, long branchId, String resourceId,
                String applicationData) throws TransactionException {
        return asyncWorker.branchPrepare(xid, branchId, resourceId);
    }

    @Override
    public BranchStatus branchUnprepare(BranchType branchType, String xid, long branchId, String resourceId,
                String applicationData) throws TransactionException {
        return asyncWorker.branchUnprepare(xid, branchId, resourceId);
    }

    @Override
    public BranchStatus branchCommit(BranchType branchType, String xid, long branchId, String resourceId,
                String applicationData, String[] branchKeys) throws TransactionException {
        return asyncWorker.branchCommit(xid, branchId, resourceId, branchKeys);
    }

    @Override
    public BranchStatus branchRollback(BranchType branchType, String xid, long branchId, String resourceId,
                String applicationData, String[] branchKeys) throws TransactionException {
        return asyncWorker.branchRollback(xid, branchId, resourceId, branchKeys);
    }

    @Override
    public BranchStatus branchPrepare(BranchType branchType, String xid, long branchId, String resourceId,
                String applicationData, String[] branchKeys) throws TransactionException {
        return asyncWorker.branchPrepare(xid, branchId, resourceId, branchKeys);
    }

    @Override
    public BranchStatus branchUnprepare(BranchType branchType, String xid, long branchId, String resourceId,
                String applicationData, String[] branchKeys) throws TransactionException {
        return asyncWorker.branchUnprepare(xid, branchId<nl>
        return statementCallback.doExecute(args);
    <|file_separator|><nl>
        return TableRecords.empty(getTableMeta(sqlRecognizers.get(0).getTableName()));
    <|file_separator|><nl>
        String key = getCacheKey(connection, tableName, resourceId);
        TableMeta tableMeta = TABLE_META_CACHE.getIfPresent(key);
        if (tableMeta == null) {
            try {
                tableMeta = fetchSchema(connection, tableName);
                TABLE_META_CACHE.put(key, tableMeta);
            } catch (SQLException e) {
                LOGGER.error("get table meta error:{}", e.getMessage(), e);
            }
        }
        return tableMeta;
    <|file_separator|><nl>
        return new TableMeta(connection, tableName);<|file_separator|><nl>
        return new TableMeta(connection, tableName, new PolarDBXTableSchema(connection, tableName));<|file_separator|><nl>
        if (UNDO_LOG_MANAGER_MAP.containsKey(dbType)) {
            return UNDO_LOG_MANAGER_MAP.get(dbType);
        }
        return null;
    <|file_separator|><nl>
        StringBuilder sql = new StringBuilder();
        sql.append(String.format(UPDATE_SQL_TEMPLATE,
                sqlUndoLog.getTableName(),
                sqlUndoLog.getUndoUpdateColumns(),
                sqlUndoLog.getUndoUpdateWhere()));
        return sql.toString();
    <|file_separator|><nl>
        for (Row row : afterImageRows) {
            for (Field field : row.getFields()) {
                undoValues.add(field);
            }
        }
    <|file_separator|><nl>
        dataSourceResource.setResourceGroupId(resourceGroupId);
        try {
            Connection connection = dataSource.getConnection();
            String jdbcUrl = connection.getMetaData().getURL();
            dataSourceResource.setResourceId(buildResourceId(jdbcUrl));
            String driverClassName = com.alibaba.druid.util.JdbcUtils.getDriverClassName(jdbcUrl);
            dataSourceResource.setDriver(loadDriver(driverClassName));
            dataSourceResource.setDbType(JdbcUtils.getDbType(jdbcUrl));
        } catch (SQLException e) {
            throw new IllegalStateException("can not get connection from DataSourceResource with " + dataSource, e);
        }
        DefaultResourceManager.get().registerResource(dataSourceResource);
    <|file_separator|><nl>
        return createXAConnection(physicalConn, XAConnection.class.getName(), dbType);
    <|file_separator|><nl>
        connectionProxy = new MockConnectionProxy();
        statementProxy = new StatementProxy(connectionProxy, new MockStatementProxy());
        selectForUpdateExecutor = new SelectForUpdateExecutor(statementProxy, (statement, args) -> null, new MySQLSelectForUpdateRecognizer());
    <|file_separator|><nl>
        throw new LockConflictException("mock lock conflict");
    <|file_separator|><nl>
        return new MockConnection();<|file_separator|><nl>
        String sql = "select * from t for update";
        List<SQLStatement> asts = SQLUtils.parseStatements(sql, DB_TYPE);

        DmSelectForUpdateRecognizer recognizer = new DmSelectForUpdateRecognizer(sql, asts.get(0));
        Assertions.assertEquals(SQLStatementType.SELECT, recognizer.getSqlType());
    <|file_separator|><nl>
        String sql = "delete from t where id = ?";

        List<SQLRecognizer> sqlRecognizers = SQLVisitorFactory.get(sql, DB_TYPE);
        SQLDeleteRecognizer recognizer = (SQLDeleteRecognizer) sqlRecognizers.get(0);
        String whereCondition = recognizer.getWhereCondition();

        //test for no condition
        Assertions.assertEquals("", whereCondition);
    <|file_separator|><nl>
        String sql = "insert into t(id, no, name, age, time) values (nextval('id_seq'), ?, ?, ?, now())";

        List<SQLRecognizer> sqlRecognizers = SQLVisitorFactory.get(sql, DB_TYPE);
        SQLInsertRecognizer recognizer = (SQLInsertRecognizer) sqlRecognizers.get(0);
        Assertions.assertEquals(recognizer.getInsertColumns(), Arrays.asList("no", "name", "age"));
    <|file_separator|><nl>
        IndexMeta indexMeta = new IndexMeta();
        indexMeta.setIndexName("index_name");
        indexMeta.setIndexType("index_type");
        indexMeta.setIndexStatus("index_status");
        indexMeta.setIndexDescription("index_description");
        indexMeta.setIndexColumns("index_columns");
        indexMeta.setIndexOptions("index_options");
        indexMeta.setIndexComment("index_comment");
        indexMeta.setIndexComment("index_comment");
        indexMeta.setIndexComment("index_comment");
        indexMeta.setIndexComment("index_comment");
        indexMeta.setIndexComment("index_comment");
        indexMeta.setIndexComment("index_comment");
        indexMeta.setIndexComment("index_comment");
        indexMeta.setIndexComment("index_comment");
        indexMeta.setIndexComment("index_comment");
        indexMeta.setIndexComment("index_comment");
        indexMeta.setIndexComment("index_comment");
        indexMeta.setIndexComment("index_comment");
        indexMeta.setIndexComment("index_comment");
        indexMeta.setIndexComment("index_comment");
        indexMeta.setIndexComment("index_comment");
        indexMeta.setIndexComment("index_comment");
        indexMeta.setIndexComment("index_comment");
        indexMeta.setIndexComment("index_comment");
        indexMeta.setIndexComment("index_comment");
        indexMeta.setIndexComment("index_comment");
        indexMeta.setIndexComment("index_comment");
        indexMeta.setIndexComment("index_comment");
        indexMeta.setIndexComment("index_comment");
        indexMeta.setIndexComment("index_comment<nl>
        BranchUndoLog undoLog = new BranchUndoLog();
        undoLog.setBranchId(1);
        undoLog.setBranchName("branch1");
        undoLog.setBranchType(BranchType.BRANCH_TYPE_NORMAL);
        undoLog.setBranchStatus(BranchStatus.BRANCH_STATUS_NORMAL);
        undoLog.setBranchCreateTime(new Date());
        undoLog.setBranchUpdateTime(new Date());
        undoLog.setBranchVersion(1);
        undoLog.setBranchDesc("branch1");
        undoLog.setBranchId(1);
        undoLog.setBranchName("branch1");
        undoLog.setBranchType(BranchType.BRANCH_TYPE_NORMAL);
        undoLog.setBranchStatus(BranchStatus.BRANCH_STATUS_NORMAL);
        undoLog.setBranchCreateTime(new Date());
        undoLog.setBranchUpdateTime(new Date());
        undoLog.setBranchVersion(1);
        undoLog.setBranchDesc("branch1");
        undoLog.setBranchId(1);
        undoLog.setBranchName("branch1");
        undoLog.setBranchType(BranchType.BRANCH_TYPE_NORMAL);
        undoLog.setBranchStatus(BranchStatus.BRANCH_STATUS_NORMAL);
        undoLog.setBranchCreateTime(new Date());
        undoLog.setBranchUpdateTime(new Date());
        undoLog.setBranchVersion(1);
        undoLog.setBranchDesc("branch1");
        undoLog.setBranchId(1);
        undoLog.setBranchName("branch1");
        undoLog.setBranchType(BranchType.BRANCH_TYPE_NORMAL);
        undoLog.setBranchStatus(BranchStatus.BRANCH_STATUS_NORMAL);
        undoLog.setBranchCreateTime(new<nl>
        MySQLUndoInsertExecutorExtension mySQLUndoInsertExecutorExtension = new MySQLUndoInsertExecutorExtension(new SQLUndoLog());
        mySQLUndoInsertExecutorExtension.setSql("DELETE FROM table WHERE id = 1");
        mySQLUndoInsertExecutorExtension.execute();
    }<|file_separator|><nl>
        String xid = request.getXid();
        long branchId = request.getBranchId();
        String resourceId = request.getResourceId();
        String applicationData = request.getApplicationData();
        if (LOGGER.isInfoEnabled()) {
            LOGGER.info("Branch rolling back: " + xid + " " + branchId + " " + resourceId + " " + applicationData);
        }
        getRMClient().branchRollback(request.getBranchType(), xid, branchId, resourceId, applicationData);
    <|file_separator|><nl>
        resourceManagers.put(BranchType.BRANCH_TYPE_DEFAULT, this);
    }

    @Override
    public BranchStatus branchStart(BranchType branchType, String xid, long branchId,
                String resourceId, String applicationData)
        throws TransactionException {
        return getResourceManager(branchType).branchStart(branchType, xid, branchId, resourceId, applicationData);
    <|file_separator|><nl>
        Message message = context.getActionContext(ROCKET_MSG_KEY, Message.class);
        SendResult sendResult = context.getActionContext(ROCKET_SEND_RESULT_KEY, SendResult.class);
        if (message == null || sendResult == null) {
            LOGGER.error("TCCRocketMQ commit but cannot find message and sendResult");
        }
        this.producerImpl.endTransaction(message, sendResult, LocalTransactionState.COMMIT_MESSAGE, null);
        LOGGER.info("RocketMQ message send commit, xid = {}, branchId = {}", context.getXid(), context.getBranchId());
        return true;
    <|file_separator|><nl>
        // TODO
    }
}<|file_separator|><nl>
        return serviceInvokerMap.get(serviceType);
    <|file_separator|>class ServiceInvoker.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class ServiceInvoker {

    private final Service service;

    public ServiceInvoker(Service service) {
        this.service = service;
    }

    public void invoke() {
        service.execute();
    }
}<|file_separator|>class Service.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class Service {

    public void execute() {
        // some code
    }
}<|file_separator|><nl>
        this.end = end;
    <|file_separator|><nl>
        if (context.getCompensationTrigger() == CompensationTrigger.ON_ERROR) {
            context.setCompensationTrigger(CompensationTrigger.ON_SUCCESS);
        } else {
            context.setCompensationTrigger(CompensationTrigger.ON_ERROR);
        }
    <|file_separator|><nl>
        LOGGER.info("Loop start state handler");
        context.setState(new LoopEndStateHandler());
    <|file_separator|>class LoopEndStateHandler implements StateHandler {

    private static final Logger LOGGER = LoggerFactory.getLogger(LoopEndStateHandler.class);
    private static final int AWAIT_TIMEOUT = 1000;

    @Override
    public void process(ProcessContext context) throws EngineExecutionException {
        LOGGER.info("Loop end state handler");
        context.setState(new LoopStartStateHandler());
    }
}<|file_separator|><nl>
        return "MockInstruction{" +
                "testString='" + testString + '\'' +
                '}';
    <|file_separator|><nl>
        return stateParserMap.get(stateType);
    <|file_separator|><nl>
        return new CompensationTriggerState(node);
    <|file_separator|><nl>
        InputStream inputStream = getInputStreamByPath("statelang/simple_statemachine.json");
        String json = IOUtils.toString(inputStream, "UTF-8");
        StateMachineParser parser = StateMachineParserFactory.getStateMachineParser(null);
        StateMachine stateMachine = parser.parse(json);
        Assertions.assertNotNull(stateMachine);
    <|file_separator|><nl>
        this.defaultGlobalTransactionTimeout = defaultGlobalTransactionTimeout;
        return this;
    <|file_separator|><nl>
        return onlyCareUpdateColumns;
    <|file_separator|><nl>
        init();
    <|file_separator|><nl>
        this.bossThreadPrefix = bossThreadPrefix;
        return this;
    <|file_separator|><nl>
        this.apolloConfigService = apolloConfigService;
        return this;
    <|file_separator|><nl>
        ConfigConsulProperties configConsulProperties = configConsulProperties();
        Assert.assertEquals(configConsulProperties.getServerAddr(), STR_TEST_AAA);
        Assert.assertEquals(configConsulProperties.getAclToken(), STR_TEST_BBB);
        Assert.assertEquals(configConsulProperties.getKey(), STR_TEST_CCC);
    <|file_separator|><nl>
        return logDeletePeriod;
    <|file_separator|><nl>

        BranchCommitResponse branchCommitResponse = new BranchCommitResponse();
        branchCommitResponse.setBranchType(BranchType.AT);
        branchCommitResponse.setXid("xid");
        branchCommitResponse.setResourceId("resourceId");
        branchCommitResponse.setBranchId(20190809);
        branchCommitResponse.setApplicationData("app");

        byte[] bytes = kryoCodec.serialize(branchCommitResponse);
        BranchCommitResponse t = kryoCodec.deserialize(bytes);

        assertThat(t.getTypeCode()).isEqualTo(branchCommitResponse.getTypeCode());
        assertThat(t.getBranchType()).isEqualTo(branchCommitResponse.getBranchType());
        assertThat(t.getXid()).isEqualTo(branchCommitResponse.getXid());
        assertThat(t.getResourceId()).isEqualTo(branchCommitResponse.getResourceId());
        assertThat(t.getBranchId()).isEqualTo(branchCommitResponse.getBranchId());
        assertThat(t.getApplicationData()).isEqualTo(branchCommitResponse.getApplicationData());

    <|file_separator|><nl>
        BranchRollbackRequestProto branchCommitRequestProto = new BranchRollbackRequestProto();
        branchCommitRequestProto.setAbstractBranchEndRequest(
            new AbstractBranchEndRequestProto());
        branchCommitRequestProto.getAbstractBranchEndRequest().setApplicationData(
            branchRollbackRequest.getApplicationData());
        branchCommitRequestProto.getAbstractBranchEndRequest().setBranchId(
            branchRollbackRequest.getBranchId());
        branchCommitRequestProto.getAbstractBranchEndRequest().setResourceId(
            branchRollbackRequest.getResourceId());
        branchCommitRequestProto.getAbstractBranchEndRequest().setXid(
            branchRollbackRequest.getXid());
        branchCommitRequestProto.getAbstractBranchEndRequest().setBranchType(
            BranchType.valueOf(branchRollbackRequest.getBranchType().name()));

        return branchCommitRequestProto;
    <|file_separator|><nl>
        GlobalRollbackRequestProto globalRollbackRequestProto = new GlobalRollbackRequestProto();
        AbstractGlobalEndRequestProto abstractGlobalEndRequestProto = new AbstractGlobalEndRequestProto();
        abstractGlobalEndRequestProto.setExtraData(globalRollbackRequest.getExtraData());
        abstractGlobalEndRequestProto.setXid(globalRollbackRequest.getXid());
        globalRollbackRequestProto.setAbstractGlobalEndRequest(abstractGlobalEndRequestProto);
        return globalRollbackRequestProto;
    <|file_separator|><nl>
        final RegisterRMRequest registerRMRequest = new RegisterRMRequest();
        final AbstractMessageProto abstractMessage = registerRMRequestProto.getAbstractIdentifyRequest().getAbstractMessage();
        final String extraData = registerRMRequestProto.getAbstractIdentifyRequest().getExtraData();
        final String resourceIds = registerRMRequestProto.getResourceIds();
        final String applicationId = registerRMRequestProto.getAbstractIdentifyRequest().getApplicationId();
        final String transactionServiceGroup = registerRMRequestProto.getAbstractIdentifyRequest().getTransactionServiceGroup();
        final int version = registerRMRequestProto.getAbstractIdentifyRequest().getVersion();

        registerRMRequest.setTypeCode(abstractMessage.getMessageType().getNumber());
        registerRMRequest.setExtraData(extraData);
        registerRMRequest.setApplicationId(applicationId);
        registerRMRequest.setTransactionServiceGroup(transactionServiceGroup);
        registerRMRequest.setVersion(version);
        registerRMRequest.setResourceIds(resourceIds);
        return registerRMRequest;
    <|file_separator|><nl>
        BranchReportRequest request = new BranchReportRequest();
        request.setBranchId(1);
        request.setReportType(BranchReportRequest.ReportType.DAILY);
        request.setReportDate(new Date());
        request.setReportDate(new Date());
        request.setReportDate(new Date());
        request.setReportDate(new Date());
        request.setReportDate(new Date());
        request.setReportDate(new Date());
        request.setReportDate(new Date());
        request.setReportDate(new Date());
        request.setReportDate(new Date());
        request.setReportDate(new Date());
        request.setReportDate(new Date());
        request.setReportDate(new Date());
        request.setReportDate(new Date());
        request.setReportDate(new Date());
        request.setReportDate(new Date());
        request.setReportDate(new Date());
        request.setReportDate(new Date());
        request.setReportDate(new Date());
        request.setReportDate(new Date());
        request.setReportDate(new Date());
        request.setReportDate(new Date());
        request.setReportDate(new Date());
        request.setReportDate(new Date());
        request.setReportDate(new Date());
        request.setReportDate(new Date());
        request.setReportDate(new Date());
        request.setReportDate(new Date());
        request.setReportDate(new Date());
        request.setReportDate(new Date());
        request.setReportDate(new Date());
        request.setReportDate(new Date());
        request.setReportDate(new Date());
        request.setReportDate(new<nl>
        GlobalBeginRequestConvertor convertor = new GlobalBeginRequestConvertor();
        GlobalBeginRequest request = new GlobalBeginRequest();
        request.setBeginTime(new Date());
        request.setBeginTime(new Date());
        request.setBeginTime(new Date());
        request.setBeginTime(new Date());
        request.setBeginTime(new Date());
        request.setBeginTime(new Date());
        request.setBeginTime(new Date());
        request.setBeginTime(new Date());
        request.setBeginTime(new Date());
        request.setBeginTime(new Date());
        request.setBeginTime(new Date());
        request.setBeginTime(new Date());
        request.setBeginTime(new Date());
        request.setBeginTime(new Date());
        request.setBeginTime(new Date());
        request.setBeginTime(new Date());
        request.setBeginTime(new Date());
        request.setBeginTime(new Date());
        request.setBeginTime(new Date());
        request.setBeginTime(new Date());
        request.setBeginTime(new Date());
        request.setBeginTime(new Date());
        request.setBeginTime(new Date());
        request.setBeginTime(new Date());
        request.setBeginTime(new Date());
        request.setBeginTime(new Date());
        request.setBeginTime(new Date());
        request.setBeginTime(new Date());
        request.setBeginTime(new Date());
        request.setBeginTime(new Date());
        request.setBeginTime(new Date());
        request.setBeginTime(new Date());
        request.setBeginTime(new Date());
        request.setBeginTime(<nl>
        GlobalCommitRequest request = GlobalCommitRequest.newBuilder()
                .setCommitId("123")
                .setCommitTime(123456789)
                .setCommiter("test")
                .setCommiterId("123")
                .setCommiterEmail("test")
                .setCommiterPhone("123")
                .setCommiterAddress("test")
                .setCommiterCompany("test")
                .setCommiterPosition("test")
                .setCommiterDepartment("test")
                .setCommiterTitle("test")
                .setCommiterIdCard("test")
                .setCommiterIdCardAddress("test")
                .setCommiterIdCardAddress("test")
                .setCommiterIdCardAddress("test")
                .setCommiterIdCardAddress("test")
                .setCommiterIdCardAddress("test")
                .setCommiterIdCardAddress("test")
                .setCommiterIdCardAddress("test")
                .setCommiterIdCardAddress("test")
                .setCommiterIdCardAddress("test")
                .setCommiterIdCardAddress("test")
                .setCommiterIdCardAddress("test")
                .setCommiterIdCardAddress("test")
                .setCommiterIdCardAddress("test")
                .setCommiterIdCardAddress("test")
                .setCommiterIdCardAddress("test")
                .setCommiterIdCardAddress("test")
                .setCommiterIdCardAddress("test")
                .setCommiterIdCardAddress("test")
                .setCommiterIdCardAddress("test")
                .setCommiterIdCardAddress("test")
                .setCommiterIdCardAddress("test")
                .<nl>
        RegisterRMResponse response = new RegisterRMResponse();
        response.setRetCode(1);
        response.setRetMsg("success");
        RegisterRMResponse.RegisterRMResponse.Builder builder = RegisterRMResponse.RegisterRMResponse.newBuilder();
        builder.mergeFrom(response);
        RegisterRMResponse.RegisterRMResponse proto = builder.build();
        System.out.println(proto);
    <|file_separator|><nl>
        RegisterTMResponse response = RegisterTMResponse.newBuilder()
                .setRegisterTMResponse(RegisterTMResponse.RegisterTMResponse.newBuilder()
                        .setRegisterTMResponse(RegisterTMResponse.RegisterTMResponse.RegisterTMResponse.newBuilder()
                                .setRegisterTMResponse(RegisterTMResponse.RegisterTMResponse.RegisterTMResponse.RegisterTMResponse.newBuilder()
                                        .setRegisterTMResponse(RegisterTMResponse.RegisterTMResponse.RegisterTMResponse.RegisterTMResponse.RegisterTMResponse.newBuilder()
                                                .setRegisterTMResponse(RegisterTMResponse.RegisterTMResponse.RegisterTMResponse.RegisterTMResponse.RegisterTMResponse.RegisterTMResponse.newBuilder()
                                                        .setRegisterTMResponse(RegisterTMResponse.RegisterTMResponse.RegisterTMResponse.RegisterTMResponse.RegisterTMResponse.RegisterTMResponse.RegisterTMResponse.newBuilder()
                                                                .setRegisterTMResponse(RegisterTMResponse.RegisterTMResponse.RegisterTMResponse.RegisterTMResponse.RegisterTMResponse.RegisterTMResponse.RegisterTMResponse.RegisterTMResponse.newBuilder()
                                                                        .setRegisterTMResponse(RegisterTMResponse.RegisterTMResponse.RegisterTMResponse.RegisterTMResponse.RegisterTMResponse.RegisterTMResponse.RegisterTMResponse.RegisterTMResponse.RegisterTMResponse.newBuilder()
                                                                                .setRegisterTMResponse(RegisterTMResponse.RegisterTMResponse.RegisterTMResponse.RegisterTMResponse.RegisterTMResponse.RegisterTMResponse.RegisterTMResponse.RegisterTMResponse.RegisterTMResponse.RegisterTMResponse.newBuilder()
                                                                                        .setRegisterTMResponse(RegisterTMResponse.RegisterTMResponse.RegisterTMResponse.RegisterTMResponse.RegisterTMResponse.RegisterTMResponse.RegisterTMResponse.RegisterTMResponse.RegisterTMResponse.RegisterTMResponse.RegisterTMResponse.newBuilder()
                                                                                                .setRegisterTMResponse(RegisterTMResponse.Register<nl>
    registerAllExtensions(
        (com.google.protobuf.ExtensionRegistryLite) registry);
  <|file_separator|><nl>
    registerAllExtensions(
        (com.google.protobuf.ExtensionRegistryLite) registry);
  <|file_separator|><nl>
    return descriptor;
  <|file_separator|><nl>
    return descriptor;
  <|file_separator|><nl>
    registerAllExtensions(
        (com.google.protobuf.ExtensionRegistryLite) registry);
  <|file_separator|><nl>
        BatchResultMessage batchResultMessage = (BatchResultMessage) t;
        ByteBuf byteBuf = Unpooled.buffer();
        encode(batchResultMessage, byteBuf);
        out.writeShort(byteBuf.readableBytes());
        out.writeBytes(byteBuf);
    }

    @Override
    public <T> void encode(T t, ByteBuf out, int length) {
        BatchResultMessage batchResultMessage = (BatchResultMessage) t;
        ByteBuf byteBuf = Unpooled.buffer();
        encode(batchResultMessage, byteBuf);
        out.writeShort(byteBuf.readableBytes());
        out.writeBytes(byteBuf);
    <|file_separator|><nl>
        return RegisterRMResponse.class;
    }

    @Override
    public void decode(Object message, Map<String, Object> headers, Map<String, Object> properties) {
        RegisterRMResponse response = (RegisterRMResponse) message;
        response.setResponse(new Response(response.getRMId(), response.getRMName(), response.getRMPassword(), response.getRMType(), response.getRMStatus()));
    <|file_separator|><nl>
        UndoLogDeleteRequest undoLogDeleteRequest = (UndoLogDeleteRequest)t;
        undoLogDeleteRequest.setSaveDays(in.getShort());
        undoLogDeleteRequest.setBranchType(BranchType.values()[in.getByte()]);
        int length = in.getShort();
        if (length > 0) {
            byte[] bs = new byte[length];
            in.get(bs);
            undoLogDeleteRequest.setResourceId(new String(bs, UTF8));
        } else {
            undoLogDeleteRequest.setResourceId(null);
        }
    <|file_separator|><nl>
        RegisterRMRequest request = new RegisterRMRequest();
        request.setBranchId("123");
        request.setTransactionId("123");
        request.setTransactionTimeout(1000);
        request.setTransactionType(TransactionType.UNKNOWN);
        request.setTransactionState(TransactionState.UNKNOWN);
        request.setTransactionContext(new TransactionContext());
        request.setTransactionContext(new TransactionContext());
        request.setTransactionContext(new TransactionContext());
        request.setTransactionContext(new TransactionContext());
        request.setTransactionContext(new TransactionContext());
        request.setTransactionContext(new TransactionContext());
        request.setTransactionContext(new TransactionContext());
        request.setTransactionContext(new TransactionContext());
        request.setTransactionContext(new TransactionContext());
        request.setTransactionContext(new TransactionContext());
        request.setTransactionContext(new TransactionContext());
        request.setTransactionContext(new TransactionContext());
        request.setTransactionContext(new TransactionContext());
        request.setTransactionContext(new TransactionContext());
        request.setTransactionContext(new TransactionContext());
        request.setTransactionContext(new TransactionContext());
        request.setTransactionContext(new TransactionContext());
        request.setTransactionContext(new TransactionContext());
        request.setTransactionContext(new TransactionContext());
        request.setTransactionContext(new TransactionContext());
        request.setTransactionContext(new TransactionContext());
        request.setTransactionContext(new TransactionContext());
        request.setTransactionContext(new TransactionContext());
        request.setTransactionContext(new TransactionContext());
        request.setTransactionContext(new TransactionContext());
        request.setTransactionContext(new TransactionContext());
        request.setTransactionContext(new TransactionContext());
<nl>
        BranchRegisterRequest request = new BranchRegisterRequest();
        request.setBranchId("1");
        request.setBranchType("1");
        request.setBranchName("1");
        request.setBranchDesc("1");
        request.setBranchStatus("1");
        request.setBranchConfig("1");
        request.setBranchLogConfig("1");
        request.setBranchAuditConfig("1");
        request.setBranchAuditLogConfig("1");
        request.setBranchAuditLogConfig("1");
        request.setBranchAuditLogConfig("1");
        request.setBranchAuditLogConfig("1");
        request.setBranchAuditLogConfig("1");
        request.setBranchAuditLogConfig("1");
        request.setBranchAuditLogConfig("1");
        request.setBranchAuditLogConfig("1");
        request.setBranchAuditLogConfig("1");
        request.setBranchAuditLogConfig("1");
        request.setBranchAuditLogConfig("1");
        request.setBranchAuditLogConfig("1");
        request.setBranchAuditLogConfig("1");
        request.setBranchAuditLogConfig("1");
        request.setBranchAuditLogConfig("1");
        request.setBranchAuditLogConfig("1");
        request.setBranchAuditLogConfig("1");
        request.setBranchAuditLogConfig("1");
        request.setBranchAuditLogConfig("1");
        request.setBranchAuditLogConfig("1");
        request.setBranchAuditLogConfig("1");
        request.setBranchAuditLogConfig("1");
        request.setBranchAuditLogConfig("1");
        request.setBranchAuditLogConfig("1");
        request.setBranchAuditLogConfig("1");
        request.setBranch<nl>
        // TODO: implement
    <|file_separator|><nl>
        return true;
    }

    @Override
    public void execute(RaftBaseMsg syncMsg, RaftBaseMsg asyncMsg) throws Throwable {
        EXECUTOR.execute(() -> {
            try {
                execute(syncMsg);
            } catch (Throwable e) {
                e.printStackTrace();
            }
        });
    <|file_separator|><nl>
        return true;
    <|file_separator|><nl>
        return new Node(host, txPort, internalPort, controlPort, group, metadata);
    <|file_separator|><nl>
        return globalLockService.query(param);
    <|file_separator|><nl>
        return globalSessionService.query(param);
    <|file_separator|><nl>
        checkParam(param);
        final BranchSession branchSession = BranchSession.getCurrent();
        final List<RowLock> rowLocks = filterAndMap(param, branchSession).collect(Collectors.toList());
        return new PageResult<>(rowLocks, param.getPageNum(), param.getPageSize());
    <|file_separator|><nl>
        return session -> {
            if (param.getGlobalSessionName() != null && !session.getGlobalSessionName().equals(param.getGlobalSessionName())) {
                return false;
            }
            if (param.getGlobalSessionType() != null && !session.getGlobalSessionType().equals(param.getGlobalSessionType())) {
                return false;
            }
            if (param.getGlobalSessionStatus() != null && !session.getGlobalSessionStatus().equals(param.getGlobalSessionStatus())) {
                return false;
            }
            if (param.getGlobalSessionCreateTime() != null && !session.getGlobalSessionCreateTime().equals(param.getGlobalSessionCreateTime())) {
                return false;
            }
            if (param.getGlobalSessionUpdateTime() != null && !session.getGlobalSessionUpdateTime().equals(param.getGlobalSessionUpdateTime())) {
                return false;
            }
            return true;
        };
    <|file_separator|><nl>
        return transactionId;
    <|file_separator|><nl>
        return "GlobalSessionParam{" +
                "xid='" + xid + '\'' +
                ", applicationId='" + applicationId + '\'' +
                ", status=" + status +
                ", transactionName='" + transactionName + '\'' +
                ", withBranch=" + withBranch +
                '}';
    <|file_separator|><nl>
        registry = new Registry();
    }
}<|file_separator|><nl>
        if (locker == null) {
            synchronized (RedisLockerFactory.class) {
                if (locker == null) {
                    locker = new RedisLocker(CONFIG.getRedisHost(), CONFIG.getRedisPort(), CONFIG.getRedisPassword());
                }
            }
        }
        return locker;
    <|file_separator|><nl>
        
        String conf = environment.getProperty("spring.datasource.url");
        
        System.out.println(conf);
        
    <|file_separator|><nl>
        //do nothing
    <|file_separator|><nl>
        SessionHolder.getRootSessionManager().removeGlobalSession("123:123");
    <|file_separator|><nl>
        GlobalReleaseLockExecute execute = new GlobalReleaseLockExecute();
        boolean success = execute.execute(convertToGlobalSessionMsg(GLOBAL_SESSION));
        Assertions.assertTrue(success);
        Assertions.assertEquals(0, GLOBAL_SESSION.getLockHolder().values().size());
    <|file_separator|><nl>
        SessionStatusValidator sessionStatusValidator = new SessionStatusValidator();
        sessionStatusValidator.validateUpdateStatus();
    <|file_separator|><nl>
        RaftSyncMessageSerializer serializer = new RaftSyncMessageSerializer();
        RaftSyncMessage message = new RaftSyncMessage();
        message.setTerm(1);
        message.setLeaderId(1);
        message.setCommitIndex(1);
        message.setPrevLogIndex(1);
        message.setPrevLogTerm(1);
        message.setEntries(new ArrayList<>());
        message.setLeaderCommit(1);
        byte[] bytes = serializer.serialize(message);
        RaftSyncMessage message1 = serializer.deserialize(bytes);
        assertEquals(message.getTerm(), message1.getTerm());
        assertEquals(message.getLeaderId(), message1.getLeaderId());
        assertEquals(message.getCommitIndex(), message1.getCommitIndex());
        assertEquals(message.getPrevLogIndex(), message1.getPrevLogIndex());
        assertEquals(message.getPrevLogTerm(), message1.getPrevLogTerm());
        assertEquals(message.getEntries().size(), message1.getEntries().size());
        assertEquals(message.getLeaderCommit(), message1.getLeaderCommit());
    <|file_separator|><nl>
        return sourceOrder == targetOrder && higherOrEquals(source.getAdvice().getClass(), target.getAdvice().getClass());
    <|file_separator|><nl>
        return order;
    <|file_separator|>class MockOrderedList implements OrderedList {

    private List<Ordered> orderedList;

    public MockOrderedList() {
        this.orderedList = new ArrayList<>();
    }

    @Override
    public void add(Ordered ordered) {
        orderedList.add(ordered);
    }

    @Override
    public void remove(Ordered ordered) {
        orderedList.remove(ordered);
    }

    @Override
    public List<Ordered> getOrderedList() {
        return orderedList;
    }
}<|file_separator|><nl>
        DruidDelegatingSQLRecognizerFactory recognizerFactory = (DruidDelegatingSQLRecognizerFactory) EnhancedServiceLoader.load(SQLRecognizerFactory.class,
                               SqlParserType.SQL_PARSER_TYPE_DRUID);
        recognizerFactory.setClassLoader(DruidIsolationTest.class.getClassLoader());
        recognizerFactory.setSqlParserType(SqlParserType.SQL_PARSER_TYPE_DRUID);
        recognizerFactory.setSqlParserType(SqlParserType.SQL_PARSER_TYPE_DRUID);
        recognizerFactory.setSqlParserType(SqlParserType.SQL_PARSER_TYPE_DRUID);
        recognizerFactory.setSqlParserType(SqlParserType.SQL_PARSER_TYPE_DRUID);
        recognizerFactory.setSqlParserType(SqlParserType.SQL_PARSER_TYPE_DRUID);
        recognizerFactory.setSqlParserType(SqlParserType.SQL_PARSER_TYPE_DRUID);
        recognizerFactory.setSqlParserType(SqlParserType.SQL_PARSER_TYPE_DRUID);
        recognizerFactory.setSqlParserType(SqlParserType.SQL_PARSER_TYPE_DRUID);
        recognizerFactory.setSqlParserType(SqlParserType.SQL_PARSER_TYPE_DRUID);
        recognizerFactory.setSqlParserType(SqlParserType.SQL_PARSER_TYPE_DRUID);
        recognizerFactory.setSqlParserType(SqlParserType.SQL_PARSER_TYPE_DRUID);
        recognizerFactory.setSqlParserType(SqlParserType.SQL_PARSER_TYPE_DRUID);
        recognizerFactory.setSqlParserType(SqlParserType.SQL_PARSER_TYPE_DRUID);
        recognizerFactory.setSqlParserType(SqlParserType.SQL_PARSER_TYPE_DRUID);<nl>
        return ResourceManager.getInstance();<|file_separator|><nl>
        this.commitMethodName = commitMethodName;
    <|file_separator|><nl>
        return true;
    <|file_separator|><nl>
        BranchCommitRequest request = new BranchCommitRequest();
        setReq(request, branchSession);

        try {
            BranchCommitResponse response = (BranchCommitResponse) remotingServer.sendSyncRequest(
                    branchSession.getResourceId(), branchSession.getClientId(), request, false);
            return response.getBranchStatus();
        } catch (TimeoutException e) {
            throw new RuntimeException(e);
        }
    <|file_separator|><nl>
        try {
            lock.lock();
            notFinished.await(timeout, TimeUnit.MILLISECONDS);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    public String getResult() {
        return result;
    <|file_separator|><nl>
        return "echo";
    <|file_separator|><nl>
                throw new MyRuntimeException("");
            <|file_separator|><nl>
    return String.format(
        "%s | %s | %s | %s | %s | %s | %s",
        now,
        elapsed,
        category,
        prepared,
        sql,
        url,
        connectionId);
  <|file_separator|><nl>
    final Object[] args = invocation.getArguments();
    if (args.length > 0 && args[0] instanceof PreparedStatement) {
      final PreparedStatement preparedStatement = (PreparedStatement) args[0];
      final String sql = preparedStatement.toString();
      if (sql.contains("INSERT INTO")) {
        final String[] split = sql.split("INSERT INTO");
        final String[] split1 = split[1].split("VALUES");
        final String[] split2 = split1[0].split(" ");
        final String[] split3 = split2[1].split(",");
        final String[] split4 = split3[0].split(" ");
        final String[] split5 = split4[1].split(" ");
        final String[] split6 = split5[1].split(" ");
        final String[] split7 = split6[1].split(" ");
        final String[] split8 = split7[1].split(" ");
        final String[] split9 = split8[1].split(" ");
        final String[] split10 = split9[1].split(" ");
        final String[] split11 = split10[1].split(" ");
        final String[] split12 = split11[1].split(" ");
        final String[] split13 = split12[1].split(" ");
        final String[] split14 = split13[1].split(" ");
        final String[] split15 = split14[1].split(" ");
        final String[] split16 = split15[1].split(" ");
        final String[] split17 = split16[1].split(" ");
        final String[] split18 = split17[1].split(" ");
        final String[] split19 = split1<nl>
    return applicationContext.containsBean(name);
  }

  public static boolean isTypeMatch(String name, Class<?> requiredType) {
    return applicationContext.isTypeMatch(name, requiredType);
  <|file_separator|><nl>
    return new ArrayList<Setting>() {
      {
        add(new Setting("host", senderEmail.host));
        add(new Setting("port", senderEmail.port));
        add(new Setting("from", senderEmail.from));
        add(new Setting("userName", senderEmail.userName));
        add(new Setting("password", senderEmail.password));
        add(new Setting("ssl", senderEmail.ssl));
      }
    };
  <|file_separator|><nl>
    IPage<AlertConfigParams> page = new Page<>();
    page.setCurrent(request.getPage());
    page.setSize(request.getSize());
    LambdaQueryWrapper<AlertConfig> queryWrapper = new LambdaQueryWrapper<>();
    queryWrapper.eq(userId != null, AlertConfig::getUserId, userId);
    queryWrapper.orderByDesc(AlertConfig::getCreateTime);
    IPage<AlertConfig> pageResult = this.baseMapper.selectPage(page, queryWrapper);
    return pageResult.convert(AlertConfigParams::new);
  }

  @Override
  public AlertConfigParams get(Long id) {
    return this.baseMapper.selectAlertConfById(id);
  }

  @Override
  public AlertConfigParams getByName(String name) {
    return this.baseMapper.selectAlertConfByName(name);
  }

  @Override
  public boolean save(AlertConfig alertConfig) {
    if (this.exist(alertConfig)) {
      throw new AlertException("AlertConfig already exists");
    }
    return super.save(alertConfig);
  <|file_separator|><nl>
    Map<String, String> content = renderContent(
        renderTitle(alertTemplate, alertConfig.getContactList()), alertTemplate.getMarkdown());
    Map<String, Object> contactMap = renderContact(alertConfig.getContactList(), alertConfig.getDingTalk());
    Map<String, Object> body = renderBody(content, contactMap);
    sendMessage(alertConfig.getDingTalk(), body);
    return true;
  <|file_separator|><nl>
    if (sqlClientJar == null) {
      File localClient = WebUtils.getAppClientDir();
      ApiAlertException.throwIfFalse(
          localClient.exists(), "[StreamPark] " + localClient + " no exists. please check.");
      List<String> jars =
          Arrays.stream(Objects.requireNonNull(localClient.list()))
              .filter(
                  x ->
                      x.matches(
                          "streampark-flink-sqlclient_" + flinkEnv.getScalaVersion() + "-.*.jar"))
              .collect(Collectors.toList());

      ApiAlertException.throwIfTrue(
          jars.isEmpty(),
          "[StreamPark] can't found streampark-flink-sqlclient jar in " + localClient);

      ApiAlertException.throwIfTrue(
          jars.size() > 1,
          "[StreamPark] found multiple streampark-flink-sqlclient jar in " + localClient);

      sqlClientJar = jars.get(0);
    }
    return sqlClientJar;
  <|file_separator|><nl>
    FlinkEnv flinkEnv = getById(id);
    checkOrElseAlert(flinkEnv);
    flinkEnv.setIsDeleted(true);
    flinkEnv.setUpdateTime(new Date());
    updateById(flinkEnv);
  }

  @Override
  public void removeByAppId(Long appId) {
    LambdaQueryWrapper<FlinkEnv> queryWrapper =
        new LambdaQueryWrapper<FlinkEnv>().eq(FlinkEnv::getAppId, appId);
    List<FlinkEnv> flinkEnvList = list(queryWrapper);
    flinkEnvList.forEach(flinkEnv -> {
      checkOrElseAlert(flinkEnv);
      flinkEnv.setIsDeleted(true);
      flinkEnv.setUpdateTime(new Date());
      updateById(flinkEnv);
    });
  }

  @Override
  public void removeByClusterId(Long clusterId) {
    LambdaQueryWrapper<FlinkEnv> queryWrapper =
        new LambdaQueryWrapper<FlinkEnv>().eq(FlinkEnv::getClusterId, clusterId);
    List<FlinkEnv> flinkEnvList = list(queryWrapper);
    flinkEnvList.forEach(flinkEnv -> {
      checkOrElseAlert(flinkEnv);
      flinkEnv.setIsDeleted(true);
      flinkEnv.setUpdateTime(new Date());
      updateById(flinkEnv);
    });
  }

  @Override
  public void removeByClusterIds(List<Long> clusterIds) {
    LambdaQueryWrapper<FlinkEnv> queryWrapper =
        new LambdaQueryWrapper<FlinkEnv>().in(FlinkEnv::getClusterId, clusterIds);
    List<FlinkEnv> flinkEnvList = list(queryWrapper);
    flinkEnvList.forEach(flinkEnv -> {
      checkOrElse<nl>
    return GatewayTypeEnum.getGatewayVersion(address);
  <|file_separator|><nl>
    getSqlGateWayService(flinkGatewayId).cancelOperation(new SessionHandle(sessionHandleUUIDStr));
  <|file_separator|><nl>
    List<Member> memberList = memberService.listMembers(member);
    return RestResponse.success(memberList);
  <|file_separator|><nl>
    this.status = status;
    return this;
  }

  public AccessToken setExpireTime(Date expireTime) {
    this.expireTime = expireTime;
    return this;
  }

  public AccessToken setCreateTime(Date createTime) {
    this.createTime = createTime;
    return this;
  }

  public AccessToken setModifyTime(Date modifyTime) {
    this.modifyTime = modifyTime;
    return this;
  }

  public AccessToken setToken(String token) {
    this.token = token;
    return this;
  }

  public AccessToken setUserId(Long userId) {
    this.userId = userId;
    return this;
  }

  public AccessToken setFinalStatus(Integer finalStatus) {
    this.finalStatus = finalStatus;
    return this;
  }

  public AccessToken setExpireTime(String expireTime) {
    this.expireTime = DateUtil.parse(expireTime);
    return this;
  }

  public AccessToken setCreateTime(String createTime) {
    this.createTime = DateUtil.parse(createTime);
    return this;
  }

  public AccessToken setModifyTime(String modifyTime) {
    this.modifyTime = DateUtil.parse(modifyTime);
    return this;
  }

  public AccessToken setToken(String token, String username, String userStatus) {
    this.token = token;
    this.username = username;
    this.userStatus = userStatus;
    return this;
  }

  public Long getId() {
    return id;
  }

  public Long getUserId() {
    return userId;
  }

  public String getToken() {
    return token;
  <nl>
    System.out.println("Application started with command-line arguments: " + args.getSourceArgs());
    System.out.println("Active profiles: " + Arrays.toString(args.getNonOptionArgs()));
    System.out.println("Non-option input arguments: " + args.getNonOptionArgs());
  <|file_separator|><nl>
    User user = usersService.getByUsername(username);
    if (user != null) {
      ApiAlertException.throwIfTrue(
          user.getLoginType() != LoginTypeEnum.SSO,
          "user [%s] can only sign in with %s",
          username,
          user.getLoginType());
    }
    return this.newUserCreate(LoginTypeEnum.SSO, username);
  <|file_separator|><nl>
    String key = "123456";
    String data = "hello";
    String encrypt = EncryptUtils.encrypt(data, key);
    String decrypt = EncryptUtils.decrypt(encrypt, key);
    assertEquals(data, decrypt);
  <|file_separator|><nl>
    User user = userService.create("user", "user", "user");
    AccessToken accessToken = accessTokenService.create(user);
    assertNotNull(accessToken);
    assertNotNull(accessToken.getId());
    assertNotNull(accessToken.getCreatedAt());
    assertNotNull(accessToken.getUpdatedAt());
    assertNotNull(accessToken.getExpiresAt());
    assertNotNull(accessToken.getUser());
    assertEquals(user.getId(), accessToken.getUser().getId());
    assertEquals(user.getUsername(), accessToken.getUser().getUsername());
    assertEquals(user.getPassword(), accessToken.getUser().getPassword());
    assertEquals(user.getCreatedAt(), accessToken.getUser().getCreatedAt());
    assertEquals(user.getUpdatedAt(), accessToken.getUser().getUpdatedAt());
    assertEquals(user.getDeletedAt(), accessToken.getUser().getDeletedAt());
    assertEquals(user.getRoles(), accessToken.getUser().getRoles());
    assertEquals(user.getPermissions(), accessToken.getUser().getPermissions());
    assertEquals(user.getPermissions(), accessToken.getUser().getPermissions());
    assertEquals(user.getPermissions(), accessToken.getUser().getPermissions());
    assertEquals(user.getPermissions(), accessToken.getUser().getPermissions());
    assertEquals(user.getPermissions(), accessToken.getUser().getPermissions());
    assertEquals(user.getPermissions(), accessToken.getUser().getPermissions());
    assertEquals(user.getPermissions(), accessToken.getUser().getPermissions());
    assertEquals(user.getPermissions(), accessToken.getUser().getPermissions());
    assertEquals(user.getPermissions(), accessToken.getUser().getPermissions());
    assertEquals(user.getPermissions(), accessToken.getUser().getPermissions());
    assertEquals(user.getPermissions(), accessToken.getUser().getPermissions());
    assertEquals(user.getPermissions(), accessToken.getUser().getPermissions());
    assertEquals(user.getPermissions(), accessToken.getUser().getPermissions());
    assertEquals(user<nl>
    flinkClusterService.checkQueueValidationIfNeeded();
  <|file_separator|><nl>
    Long teamId = 100000L;
    Long userId = 100000L;
    // It contains a normal character '#' which should be matched
    String variableCode = "collect_kafkabrokers-520room";
    String variableVariable = "broker1:port,broker3:port,broker3:port";
    Variable variable = new Variable();
    variable.setVariableCode(variableCode);
    variable.setVariableValue(variableVariable);
    variable.setDescription("420kafka broker, 50.");
    variable.setCreatorId(userId);
    variable.setTeamId(teamId);
    variableService.save(variable);
    Variable findVariable = variableService.findByVariableCode(teamId, variableCode);
    Assertions.assertNotNull(findVariable);
    String paramWithPlaceholders = "--kafka.brokers ${" + variableCode + "}";
    String realParam = variableService.replaceVariable(teamId, paramWithPlaceholders);
    Assertions.assertEquals("--kafka.brokers " + variableVariable, realParam);
  <|file_separator|><nl>
        return fieldsType;
    <|file_separator|>class ManagedFields.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>package org.apache.flink.v1beta1.flinkdeploymentspec.jobmanager.podtemplate.metadata.managedfields;

import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonSetter;

public class ManagedFields {

    @JsonProperty("apiVersion")
    @JsonSetter(nulls = Nulls.SKIP)
    private String apiVersion;

    public String getApiVersion() {
        return apiVersion;
    }

    public void setApiVersion(String apiVersion) {
        this.apiVersion = apiVersion;
    }

    @JsonProperty("fieldsType")
    @JsonSetter(nulls = Nulls.SKIP)
    private String fieldsType;

    public String getFieldsType() {
        return fieldsType;
    }

    public void setFieldsType(String fieldsType) {
        this.fieldsType = fieldsType;
    }

    @JsonProperty("fieldsV1")
    @JsonSetter(nulls = Nulls.SKIP)
    private FieldsV1 fieldsV1;

    public FieldsV1 getFieldsV1() {
        return fieldsV1;
    }

    public void setFieldsV1(FieldsV1 fieldsV1) {
        this.fieldsV1 = fieldsV1;
    }

    @JsonProperty("manager")
    @JsonSetter(nulls = Nulls.SKIP)
    private String manager;

    public String getManager() {
        return manager;
    }

    public void setManager(String manager) {
        this.manager = manager;
    }

    @JsonProperty("operation")
    @JsonSetter(nulls = Nulls.SKIP)
    private String operation;

<nl>
        this.preference = preference;
    <|file_separator|>class PreferredDuringSchedulingIgnoredDuringExecution implements io.fabric8.kubernetes.api.model.KubernetesResource {

    @com.fasterxml.jackson.annotation.JsonProperty("preference")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private org.apache.flink.v1beta1.flinkdeploymentspec.jobmanager.podtemplate.spec.affinity.nodeaffinity.preferredduringschedulingignoredduringexecution.Preference preference;

    public org.apache.flink.v1beta1.flinkdeploymentspec.jobmanager.podtemplate.spec.affinity.nodeaffinity.preferredduringschedulingignoredduringexecution.Preference getPreference() {
        return preference;
    }

    public void setPreference(org.apache.flink.v1beta1.flinkdeploymentspec.jobmanager.podtemplate.spec.affinity.nodeaffinity.preferredduringschedulingignoredduringexecution.Preference preference) {
        this.preference = preference;
    }
}<|file_separator|>class PreferredDuringSchedulingIgnoredDuringExecution implements io.fabric8.kubernetes.api.model.KubernetesResource {

    @com.fasterxml.jackson.annotation.JsonProperty("preference")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private org.apache.flink.v1beta1.flinkdeploymentspec.jobmanager.podtemplate.spec.affinity.nodeaffinity.preferredduringschedulingignoredduringexecution.Preference preference;

    public org.apache.flink.v1beta1.flinkdeploymentspec.jobmanager.podtemplate.spec.affinity.nodeaffinity.preferredduringschedulingignoredduringexecution.Preference getPreference()<nl>
        this.values = values;
    <|file_separator|>class MatchExpressions implements io.fabric8.kubernetes.api.model.KubernetesResource {

    @com.fasterxml.jackson.annotation.JsonProperty("key")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private String key;

    public String getKey() {
        return key;
    }

    public void setKey(String key) {
        this.key = key;
    }

    @com.fasterxml.jackson.annotation.JsonProperty("operator")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private String operator;

    public String getOperator() {
        return operator;
    }

    public void setOperator(String operator) {
        this.operator = operator;
    }

    @com.fasterxml.jackson.annotation.JsonProperty("values")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private java.util.List<String> values;

    public java.util.List<String> getValues() {
        return values;
    }

    public void setValues(java.util.List<String> values) {
        this.values = values;
    }
<|file_separator|>class MatchExpressions implements io.fabric8.kubernetes.api.model.KubernetesResource {

    @com.fasterxml.jackson.annotation.JsonProperty("key")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private String key;

    public String getKey() {
        return key;
<nl>
        this.podAffinityTerm = podAffinityTerm;
    }
}

class PodAffinityTerm {

    @com.fasterxml.jackson.annotation.JsonProperty("labelSelector")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private org.apache.flink.v1beta1.flinkdeploymentspec.jobmanager.podtemplate.spec.affinity.podaffinity.preferredduringschedulingignoredduringexecution.PodAffinityTerm.LabelSelector labelSelector;

    public org.apache.flink.v1beta1.flinkdeploymentspec.jobmanager.podtemplate.spec.affinity.podaffinity.preferredduringschedulingignoredduringexecution.PodAffinityTerm.LabelSelector getLabelSelector() {
        return labelSelector;
    }

    public void setLabelSelector(org.apache.flink.v1beta1.flinkdeploymentspec.jobmanager.podtemplate.spec.affinity.podaffinity.preferredduringschedulingignoredduringexecution.PodAffinityTerm.LabelSelector labelSelector) {
        this.labelSelector = labelSelector;
    <|file_separator|>class PodAffinityTerm implements io.fabric8.kubernetes.api.model.KubernetesResource {

    @com.fasterxml.jackson.annotation.JsonProperty("labelSelector")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private org.apache.flink.v1beta1.flinkdeploymentspec.jobmanager.podtemplate.spec.affinity.podaffinity.preferredduringschedulingignoredduringexecution.PodAffinityTerm.LabelSelector labelSelector;

    public org.apache.flink.v1beta1.flinkdeploymentspec.jobmanager.podtemplate.spec.affinity.<nl>
        this.operator = operator;
    }

    @com.fasterxml.jackson.annotation.JsonProperty("value")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private String value;

    public String getValue() {
        return value;
    }

    public void setValue(String value) {
        this.value = value;
    <|file_separator|>class MatchExpressions implements io.fabric8.kubernetes.api.model.KubernetesResource {

    @com.fasterxml.jackson.annotation.JsonProperty("key")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private String key;

    public String getKey() {
        return key;
    }

    public void setKey(String key) {
        this.key = key;
    }

    @com.fasterxml.jackson.annotation.JsonProperty("operator")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private String operator;

    public String getOperator() {
        return operator;
    }

    public void setOperator(String operator) {
        this.operator = operator;
    }

    @com.fasterxml.jackson.annotation.JsonProperty("value")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private String value;

    public String getValue() {
        return value;
    }

    public void setValue(String value) {
        this.value = value;
    }
}<|file_separator|>class MatchExpressions implements io.fabric8.kubernetes.api.model.KubernetesResource<nl>
        return this.command;
    <|file_separator|><nl>
        this.tcpSocket = tcpSocket;
    }

    @com.fasterxml.jackson.annotation.JsonProperty("tcpSocketList")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private java.util.List<org.apache.flink.v1beta1.flinkdeploymentspec.jobmanager.podtemplate.spec.containers.lifecycle.poststart.TcpSocket> tcpSocketList;

    public java.util.List<org.apache.flink.v1beta1.flinkdeploymentspec.jobmanager.podtemplate.spec.containers.lifecycle.poststart.TcpSocket> getTcpSocketList() {
        return tcpSocketList;
    }

    public void setTcpSocketList(java.util.List<org.apache.flink.v1beta1.flinkdeploymentspec.jobmanager.podtemplate.spec.containers.lifecycle.poststart.TcpSocket> tcpSocketList) {
        this.tcpSocketList = tcpSocketList;
    }

    @com.fasterxml.jackson.annotation.JsonProperty("tcpSocketList")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private java.util.List<org.apache.flink.v1beta1.flinkdeploymentspec.jobmanager.podtemplate.spec.containers.lifecycle.poststart.TcpSocket> tcpSocketList;

    public java.util.List<org.apache.flink.v1beta1.flinkdeploymentspec.jobmanager.podtemplate.spec.containers.lifecycle.poststart.TcpSocket> getTcpSocketList() {
        return tcpSocketList;
    }

    public void setTcpSocketList(java.util.List<org.<nl>
        this.port = port;
    <|file_separator|><nl>
        this.add = add;
    <|file_separator|>class Capabilities.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class Capabilities {

    public static void main(String[] args) {
        System.out.println("Hello World!");
    }
}<|file_separator|><nl>
        return this.command;
    <|file_separator|><nl>
        this.containerPort = containerPort;
    <|file_separator|>class Service implements io.fabric8.kubernetes.api.model.KubernetesResource {

    @com.fasterxml.jackson.annotation.JsonProperty("clusterIP")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private String clusterIP;

    public String getClusterIP() {
        return clusterIP;
    }

    public void setClusterIP(String clusterIP) {
        this.clusterIP = clusterIP;
    }

    @com.fasterxml.jackson.annotation.JsonProperty("externalIPs")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private java.util.List<String> externalIPs;

    public java.util.List<String> getExternalIPs() {
        return externalIPs;
    }

    public void setExternalIPs(java.util.List<String> externalIPs) {
        this.externalIPs = externalIPs;
    }

    @com.fasterxml.jackson.annotation.JsonProperty("externalName")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private String externalName;

    public String getExternalName() {
        return externalName;
    }

    public void setExternalName(String externalName) {
        this.externalName = externalName;
    }

    @com.fasterxml.jackson.annotation.JsonProperty("loadBalancerIP")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private String loadBalancerIP;

    public<nl>
        return claims;
    <|file_separator|><nl>
        this.localhostProfile = localhostProfile;
    <|file_separator|><nl>
        return this.command;
    <|file_separator|><nl>
        this.tcpSocket = tcpSocket;
    <|file_separator|>class PostStop implements io.fabric8.kubernetes.api.model.KubernetesResource {

    @com.fasterxml.jackson.annotation.JsonProperty("exec")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private org.apache.flink.v1beta1.flinkdeploymentspec.jobmanager.podtemplate.spec.initcontainers.lifecycle.poststop.Exec exec;

    public org.apache.flink.v1beta1.flinkdeploymentspec.jobmanager.podtemplate.spec.initcontainers.lifecycle.poststop.Exec getExec() {
        return exec;
    }

    public void setExec(org.apache.flink.v1beta1.flinkdeploymentspec.jobmanager.podtemplate.spec.initcontainers.lifecycle.poststop.Exec exec) {
        this.exec = exec;
    }

    @com.fasterxml.jackson.annotation.JsonProperty("httpGet")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private org.apache.flink.v1beta1.flinkdeploymentspec.jobmanager.podtemplate.spec.initcontainers.lifecycle.poststop.HttpGet httpGet;

    public org.apache.flink.v1beta1.flinkdeploymentspec.jobmanager.podtemplate.spec.initcontainers.lifecycle.poststop.HttpGet getHttpGet() {
        return httpGet;
    }

    public void setHttpGet(org.apache.flink.v1beta1.flinkdeploymentspec.jobmanager.podtemplate.spec.initcontainers.lifecycle.poststop.HttpGet httpGet) {
        this.httpGet = httpGet;
    <nl>
        this.scheme = scheme;
    <|file_separator|><nl>
        this.scheme = scheme;
    <|file_separator|>class HttpGet.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>package org.apache.flink.v1beta1.flinkdeploymentspec.jobmanager.podtemplate.spec.initcontainers.startupprobe.httpget;

import io.fabric8.kubernetes.api.model.IntOrString;
import io.fabric8.kubernetes.api.model.KubernetesResource;
import io.fabric8.kubernetes.api.model.ObjectMeta;
import io.fabric8.kubernetes.api.model.OwnerReference;
import io.fabric8.kubernetes.api.model.PodTemplateSpec;
import io.fabric8.kubernetes.api.model.Quantity;
import io.fabric8.kubernetes.api.model.Secret;
import io.fabric8.kubernetes.api.model.ServiceAccount;
import io.fabric8.kubernetes.api.model.ServiceAccountTokenVolumeSource;
import io.fabric8.kubernetes.api.model.Toleration;
import io.fabric8.kubernetes.api.model.Volume;
import io.fabric8.kubernetes.api.model.VolumeMount;
import io.fabric8.kubernetes.api.model.VolumeMounts;
import io.fabric8.kubernetes.api.model.VolumeMountsBuilder;
import io.fabric8.kubernetes.api.model.VolumeMountsBuilder.VolumeMountBuilder;
import io.fabric8.kubernetes.api.model.VolumeSource;
import io.fabric8.kubernetes.api.model.VolumeSources;
import io.fabric8.kubernetes.api.model.VolumeSourcesBuilder;
import io.fabric8.kubernetes.api.model.VolumeSourcesBuilder.VolumeSourceBuilder;
import io.fabric8.kubernetes.api.model.VolumeSourcesBuilder.VolumeSourceBuilder.EmptyDirVolumeSourceBuilder<nl>
        this.name = name;
    <|file_separator|><nl>
        return name;
    <|file_separator|><nl>
        this.localhostProfile = localhostProfile;
    <|file_separator|><nl>
        this.name = name;
    <|file_separator|>class SecretRefBuilder.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>class SecretRefBuilder {

    @com.fasterxml.jackson.annotation.JsonProperty("name")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}<|file_separator|>class SecretRefBuilder.java.html
<|fim_prefix|><|fim_suffix|>>
<span class="keyword">public</span> <span class="keyword">class</span> <span class="identifier">SecretRefBuilder</span> <span class="keyword">extends</span> <span class="identifier">io.fabric8.kubernetes.api.model.SecretRef</span> {

    <span class="keyword">private</span> <span class="identifier">SecretRefBuilder</span>(<span class="identifier">SecretRefBuilder</span> <span class="identifier">builder</span>) {
        <span class="keyword">super</span>(<span class="identifier">builder</span>);
    }

    <span class="keyword">public</span> <span class="identifier">SecretRefBuilder</span>(<span class="identifier">SecretRef</span> <span class="identifier">secretRef</span>) {
        <span class="keyword">super</span>(<span class="identifier">secretRef</span>);
    }

    <span class="keyword">public</span> <span class="identifier">SecretRefBuilder</span>(<span class="identifier">SecretRef</span> <span class="identifier">secretRef</span>, <span class="identifier">String</span> <span class="identifier<nl>
        this.fieldRef = fieldRef;
    }
}

class DownwardAPIVolumeSource implements io.fabric8.kubernetes.api.model.KubernetesResource {

    @com.fasterxml.jackson.annotation.JsonProperty("defaultMode")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private Long defaultMode;

    public Long getDefaultMode() {
        return defaultMode;
    }

    public void setDefaultMode(Long defaultMode) {
        this.defaultMode = defaultMode;
    <|file_separator|><nl>
        this.name = name;
    <|file_separator|><nl>
        this.waiting = waiting;
    <|file_separator|>class State.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>package org.apache.flink.v1beta1.flinkdeploymentspec.jobmanager.podtemplate.status.containerstatuses.state;

public class State {

    private Running running;

    private Terminated terminated;

    private Waiting waiting;

    public Running getRunning() {
        return running;
    }

    public void setRunning(Running running) {
        this.running = running;
    }

    public Terminated getTerminated() {
        return terminated;
    }

    public void setTerminated(Terminated terminated) {
        this.terminated = terminated;
    }

    public Waiting getWaiting() {
        return waiting;
    }

    public void setWaiting(Waiting waiting) {
        this.waiting = waiting;
    }
}<|file_separator|><nl>
        return restartCount;
    <|file_separator|>class ContainerStatus implements io.fabric8.kubernetes.api.model.KubernetesResource {

    @com.fasterxml.jackson.annotation.JsonProperty("containerID")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private String containerID;

    public String getContainerID() {
        return containerID;
    }

    public void setContainerID(String containerID) {
        this.containerID = containerID;
    }

    @com.fasterxml.jackson.annotation.JsonProperty("image")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private String image;

    public String getImage() {
        return image;
    }

    public void setImage(String image) {
        this.image = image;
    }

    @com.fasterxml.jackson.annotation.JsonProperty("imageID")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private String imageID;

    public String getImageID() {
        return imageID;
    }

    public void setImageID(String imageID) {
        this.imageID = imageID;
    }

    @com.fasterxml.jackson.annotation.JsonProperty("lastState")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private org.apache.flink.v1beta1.flinkdeploymentspec.jobmanager.podtemplate.status.containerstatuses.LastState lastState;

    public org.apache.flink.v1beta1.<nl>
        this.requests = requests;
    <|file_separator|>class JobManager.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>class JobManager implements io.fabric8.kubernetes.api.model.KubernetesResource {

    @com.fasterxml.jackson.annotation.JsonProperty("annotations")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private java.util.Map<java.lang.String, java.lang.String> annotations;

    public java.util.Map<java.lang.String, java.lang.String> getAnnotations() {
        return annotations;
    }

    public void setAnnotations(java.util.Map<java.lang.String, java.lang.String> annotations) {
        this.annotations = annotations;
    }

    @com.fasterxml.jackson.annotation.JsonProperty("apiVersion")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private java.lang.String apiVersion;

    public java.lang.String getApiVersion() {
        return apiVersion;
    }

    public void setApiVersion(java.lang.String apiVersion) {
        this.apiVersion = apiVersion;
    }

    @com.fasterxml.jackson.annotation.JsonProperty("kind")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private java.lang.String kind;

    public java.lang.String getKind() {
        return kind;
    }

    public void setKind(java.lang.String kind) {
        this.kind = kind;
    }

    @com.fasterxml.jackson.annotation.JsonProperty("metadata<nl>
        this.claims = claims;
    }

    @com.fasterxml.jackson.annotation.JsonProperty("cpu")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private io.fabric8.kubernetes.api.model.IntOrString cpu;

    public io.fabric8.kubernetes.api.model.IntOrString getCpu() {
        return cpu;
    }

    public void setCpu(io.fabric8.kubernetes.api.model.IntOrString cpu) {
        this.cpu = cpu;
    }

    @com.fasterxml.jackson.annotation.JsonProperty("ephemeral-storage")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private io.fabric8.kubernetes.api.model.IntOrString ephemeralStorage;

    public io.fabric8.kubernetes.api.model.IntOrString getEphemeralStorage() {
        return ephemeralStorage;
    }

    public void setEphemeralStorage(io.fabric8.kubernetes.api.model.IntOrString ephemeralStorage) {
        this.ephemeralStorage = ephemeralStorage;
    }

    @com.fasterxml.jackson.annotation.JsonProperty("memory")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private io.fabric8.kubernetes.api.model.IntOrString memory;

    public io.fabric8.kubernetes.api.model.IntOrString getMemory() {
        return memory;
    }

    public void setMemory(io.fabric8.kubernetes.api.model.IntOrString memory) {
<nl>
        this.matchLabels = matchLabels;
    }

    public void setMatchExpressions(java.util.List<org.apache.flink.v1beta1.flinkdeploymentspec.podtemplate.spec.affinity.podaffinity.requiredduringschedulingignoredduringexecution.labelselector.MatchExpressions> matchExpressions) {
        this.matchExpressions = matchExpressions;
    }

    public void setMatchLabels(java.util.Map<java.lang.String, String> matchLabels) {
        this.matchLabels = matchLabels;
    <|file_separator|>class LabelSelectorRequirement implements io.fabric8.kubernetes.api.model.KubernetesResource {

    @com.fasterxml.jackson.annotation.JsonProperty("key")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private java.lang.String key;

    public java.lang.String getKey() {
        return key;
    }

    public void setKey(java.lang.String key) {
        this.key = key;
    }

    @com.fasterxml.jackson.annotation.JsonProperty("operator")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private org.apache.flink.v1beta1.flinkdeploymentspec.podtemplate.spec.affinity.podaffinity.requiredduringschedulingignoredduringexecution.labelselector.MatchExpressions.Operator operator;

    public org.apache.flink.v1beta1.flinkdeploymentspec.podtemplate.spec.affinity.podaffinity.requiredduringschedulingignoredduringexecution.labelselector.MatchExpressions.Operator getOperator() {
        return operator<nl>
        return configMapKeyRef;
    <|file_separator|>class Value implements io.fabric8.kubernetes.api.model.KubernetesResource {

    @com.fasterxml.jackson.annotation.JsonProperty("configMapKeyRef")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private org.apache.flink.v1beta1.flinkdeploymentspec.podtemplate.spec.containers.env.value.ConfigMapKeyRef configMapKeyRef;

    public org.apache.flink.v1beta1.flinkdeploymentspec.podtemplate.spec.containers.env.value.ConfigMapKeyRef getConfigMapKeyRef() {
        return configMapKeyRef;
    }

    public void setConfigMapKeyRef(org.apache.flink.v1beta1.flinkdeploymentspec.podtemplate.spec.containers.env.value.ConfigMapKeyRef configMapKeyRef) {
        this.configMapKeyRef = configMapKeyRef;
    }

    @com.fasterxml.jackson.annotation.JsonProperty("fieldRef")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private org.apache.flink.v1beta1.flinkdeploymentspec.podtemplate.spec.containers.env.value.FieldRef fieldRef;

    public org.apache.flink.v1beta1.flinkdeploymentspec.podtemplate.spec.containers.env.value.FieldRef getFieldRef() {
        return fieldRef;
    }

    public void setFieldRef(org.apache.flink.v1beta1.flinkdeploymentspec.podtemplate.spec.containers.env.value.FieldRef fieldRef) {
        this.fieldRef = fieldRef<nl>
        return scheme;
    <|file_separator|><nl>
        return tcpSocket;
    <|file_separator|>class PreStop.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>package org.apache.flink.v1beta1.flinkdeploymentspec.podtemplate.spec.containers.lifecycle.prestop;

public class PreStop {

    private Exec exec;
    private HttpGet httpGet;
    private TcpSocket tcpSocket;

    public Exec getExec() {
        return exec;
    }

    public void setExec(Exec exec) {
        this.exec = exec;
    }

    public HttpGet getHttpGet() {
        return httpGet;
    }

    public void setHttpGet(HttpGet httpGet) {
        this.httpGet = httpGet;
    }

    public TcpSocket getTcpSocket() {
        return tcpSocket;
    }

    public void setTcpSocket(TcpSocket tcpSocket) {
        this.tcpSocket = tcpSocket;
    }
}<|file_separator|>class PreStop.HttpGet.java
<|fim_prefix|><|fim_suffix|>

    public void setPort(Integer port) {
        this.port = port;
    }
}<|fim_middle|>package org.apache.flink.v1beta1.flinkdeploymentspec.podtemplate.spec.containers.lifecycle.prestop;

public class HttpGet {

    private String path;
    private Integer port;

    public String getPath() {
        return path;
    }

    public void setPath(String path) {
        this.path = path;
    }

    public Integer getPort() {
        return port;
    }<|file_separator|>class PreStop.Exec.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>package org.apache.flink.v1beta1.flinkdeploymentspec.podtemplate.spec.containers.lifecycle.prestop;

public class Exec {

    private String command;

    public String getCommand() {
        <nl>
        this.port = port;
    <|file_separator|><nl>
        this.hostIP = hostIP;
    <|file_separator|>class Service implements io.fabric8.kubernetes.api.model.KubernetesResource {

    @com.fasterxml.jackson.annotation.JsonProperty("clusterIP")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private String clusterIP;

    public String getClusterIP() {
        return clusterIP;
    }

    public void setClusterIP(String clusterIP) {
        this.clusterIP = clusterIP;
    }

    @com.fasterxml.jackson.annotation.JsonProperty("externalIPs")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private java.util.List<String> externalIPs;

    public java.util.List<String> getExternalIPs() {
        return externalIPs;
    }

    public void setExternalIPs(java.util.List<String> externalIPs) {
        this.externalIPs = externalIPs;
    }

    @com.fasterxml.jackson.annotation.JsonProperty("externalName")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private String externalName;

    public String getExternalName() {
        return externalName;
    }

    public void setExternalName(String externalName) {
        this.externalName = externalName;
    }

    @com.fasterxml.jackson.annotation.JsonProperty("loadBalancerIP")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private String loadBalancerIP;

    public<nl>
        this.terminationGracePeriodSeconds = terminationGracePeriodSeconds;
    <|file_separator|>class LivenessProbe implements io.fabric8.kubernetes.api.model.KubernetesResource {

    @com.fasterxml.jackson.annotation.JsonProperty("exec")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private org.apache.flink.v1beta1.flinkdeploymentspec.podtemplate.spec.containers.livenessprobe.Exec exec;

    public org.apache.flink.v1beta1.flinkdeploymentspec.podtemplate.spec.containers.livenessprobe.Exec getExec() {
        return exec;
    }

    public void setExec(org.apache.flink.v1beta1.flinkdeploymentspec.podtemplate.spec.containers.livenessprobe.Exec exec) {
        this.exec = exec;
    }

    @com.fasterxml.jackson.annotation.JsonProperty("failureThreshold")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private Long failureThreshold;

    public Long getFailureThreshold() {
        return failureThreshold;
    }

    public void setFailureThreshold(Long failureThreshold) {
        this.failureThreshold = failureThreshold;
    }

    @com.fasterxml.jackson.annotation.JsonProperty("httpGet")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private org.apache.flink.v1beta1.flinkdeploymentspec.podtemplate.spec.containers.livenessprobe.HttpGet httpGet;

    public org.apache.flink.v1beta1.flinkdeploymentspec.podtemplate.<nl>
        return drop;
    <|file_separator|>class Capabilities.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class Capabilities {

    public Capabilities() {
    }
}<|file_separator|><nl>
        this.mountPropagation = mountPropagation;
    }

    @com.fasterxml.jackson.annotation.JsonProperty("subPath")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private String subPath;

    public String getSubPath() {
        return subPath;
    }

    public void setSubPath(String subPath) {
        this.subPath = subPath;
    }

    @com.fasterxml.jackson.annotation.JsonProperty("subPathExpr")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private String subPathExpr;

    public String getSubPathExpr() {
        return subPathExpr;
    }

    public void setSubPathExpr(String subPathExpr) {
        this.subPathExpr = subPathExpr;
    }
}

class VolumeMount implements io.fabric8.kubernetes.api.model.KubernetesResource {

    @com.fasterxml.jackson.annotation.JsonProperty("mountPath")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private String mountPath;

    public String getMountPath() {
        return mountPath;
    }

    public void setMountPath(String mountPath) {
        this.mountPath = mountPath;
    }

    @com.fasterxml.jackson.annotation.JsonProperty("mountPropagation")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private String mountPropagation;

    public String getMountPropagation() {
        return mountPropagation;
<nl>
        this.command = command;
    }

    public Exec withCommand(java.util.List<String> command) {
        this.command = command;
        return this;
    <|file_separator|>class ExecAction implements io.fabric8.kubernetes.api.model.KubernetesResource {

    @com.fasterxml.jackson.annotation.JsonProperty("command")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private java.util.List<String> command;

    public java.util.List<String> getCommand() {
        return command;
    }

    public void setCommand(java.util.List<String> command) {
        this.command = command;
    }

    public ExecAction withCommand(java.util.List<String> command) {
        this.command = command;
        return this;
    }
}<|file_separator|>class ExecActionBuilder implements io.fabric8.kubernetes.api.model.KubernetesResource {

    @com.fasterxml.jackson.annotation.JsonProperty("command")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private java.util.List<String> command;

    public java.util.List<String> getCommand() {
        return command;
    }

    public void setCommand(java.util.List<String> command) {
        this.command = command;
    }

    public ExecActionBuilder withCommand(java.util.List<String> command) {
        this.command = command;
        return this;
    }
}<|file_separator|>class ExecActionBuilder.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>package io.fabric8.kubernetes.api.model<nl>
        this.hostPort = hostPort;
    <|file_separator|>class Service implements io.fabric8.kubernetes.api.model.KubernetesResource {

    @com.fasterxml.jackson.annotation.JsonProperty("clusterIP")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private String clusterIP;

    public String getClusterIP() {
        return clusterIP;
    }

    public void setClusterIP(String clusterIP) {
        this.clusterIP = clusterIP;
    }

    @com.fasterxml.jackson.annotation.JsonProperty("externalIPs")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private java.util.List<String> externalIPs;

    public java.util.List<String> getExternalIPs() {
        return externalIPs;
    }

    public void setExternalIPs(java.util.List<String> externalIPs) {
        this.externalIPs = externalIPs;
    }

    @com.fasterxml.jackson.annotation.JsonProperty("externalName")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private String externalName;

    public String getExternalName() {
        return externalName;
    }

    public void setExternalName(String externalName) {
        this.externalName = externalName;
    }

    @com.fasterxml.jackson.annotation.JsonProperty("loadBalancerIP")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private String loadBalancerIP;

    public<nl>
        return port;
    <|file_separator|><nl>
        this.resource = resource;
    <|file_separator|>class ResourceFieldSelector implements io.fabric8.kubernetes.api.model.KubernetesResource {

    @com.fasterxml.jackson.annotation.JsonProperty("fieldPath")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private String fieldPath;

    public String getFieldPath() {
        return fieldPath;
    }

    public void setFieldPath(String fieldPath) {
        this.fieldPath = fieldPath;
    }
<|file_separator|>class ResourceRequirements implements io.fabric8.kubernetes.api.model.KubernetesResource {

    @com.fasterxml.jackson.annotation.JsonProperty("limits")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private java.util.Map<String, io.fabric8.kubernetes.api.model.Quantity> limits;

    public java.util.Map<String, io.fabric8.kubernetes.api.model.Quantity> getLimits() {
        return limits;
    }

    public void setLimits(java.util.Map<String, io.fabric8.kubernetes.api.model.Quantity> limits) {
        this.limits = limits;
    }

    @com.fasterxml.jackson.annotation.JsonProperty("requests")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private java.util.Map<String, io.fabric8.kubernetes.api.model.Quantity> requests;

    public java.util.Map<String, io.fabric8.kubernetes.api.model.Quantity> getRequests() {
        return requests;
<nl>
        return name;
    <|file_separator|><nl>
        return name;
    <|file_separator|><nl>
        this.options = options;
    }

    @com.fasterxml.jackson.annotation.JsonProperty("node")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private String node;

    public String getNode() {
        return node;
    }

    public void setNode(String node) {
        this.node = node;
    }

    @com.fasterxml.jackson.annotation.JsonProperty("path")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private String path;

    public String getPath() {
        return path;
    }

    public void setPath(String path) {
        this.path = path;
    <|file_separator|>class FlexVolume.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>package org.apache.flink.v1beta1.flinkdeploymentspec.podtemplate.spec.volumes.flexvolume;

import io.fabric8.kubernetes.api.model.KubernetesResource;

public class FlexVolume implements KubernetesResource {

    private String driver;
    private String fsType;
    private java.util.Map<java.lang.String, String> options;
    private String node;
    private String path;
    private Boolean readOnly;
    private org.apache.flink.v1beta1.flinkdeploymentspec.podtemplate.spec.volumes.flexvolume.SecretRef secretRef;
}<|file_separator|><nl>
        this.repository = repository;
    <|file_separator|><nl>
        this.name = name;
    <|file_separator|>class SecretRefBuilder.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>class SecretRefBuilder {

    @com.fasterxml.jackson.annotation.JsonProperty("name")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}<|file_separator|>class SecretRefBuilder.java.html
<|fim_prefix|><|fim_suffix|>>
<span class="keyword">public</span> <span class="keyword">class</span> <span class="identifier">SecretRefBuilder</span> <span class="keyword">extends</span> <span class="identifier">io.fabric8.kubernetes.api.model.SecretRef</span> {

    <span class="keyword">private</span> <span class="identifier">SecretRefBuilder</span>(<span class="identifier">SecretRefBuilder</span> <span class="identifier">builder</span>) {
        <span class="keyword">super</span>(<span class="identifier">builder</span>);
    }

    <span class="keyword">public</span> <span class="identifier">SecretRefBuilder</span>(<span class="identifier">SecretRef</span> <span class="identifier">secretRef</span>) {
        <span class="keyword">super</span>(<span class="identifier">secretRef</span>);
    }

    <span class="keyword">public</span> <span class="identifier">SecretRefBuilder</span>(<span class="identifier">SecretRef</span> <span class="identifier">secretRef</span>, <span class="identifier">String</span> <span class="identifier<nl>
        return path;
    <|file_separator|><nl>
        this.secretName = secretName;
    }

    @Override
    public String toString() {
        return "Secret{" +
                "defaultMode=" + defaultMode +
                ", items=" + items +
                ", optional=" + optional +
                ", secretName='" + secretName + '\'' +
                '}';
    <|file_separator|>class SecretVolumeSource implements io.fabric8.kubernetes.api.model.KubernetesResource {

    @com.fasterxml.jackson.annotation.JsonProperty("defaultMode")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private Long defaultMode;

    public Long getDefaultMode() {
        return defaultMode;
    }

    public void setDefaultMode(Long defaultMode) {
        this.defaultMode = defaultMode;
    }

    @com.fasterxml.jackson.annotation.JsonProperty("items")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private java.util.List<org.apache.flink.v1beta1.flinkdeploymentspec.podtemplate.spec.volumes.secret.Items> items;

    public java.util.List<org.apache.flink.v1beta1.flinkdeploymentspec.podtemplate.spec.volumes.secret.Items> getItems() {
        return items;
    }

    public void setItems(java.util.List<org.apache.flink.v1beta1.flinkdeploymentspec.podtemplate.spec.volumes.secret.Items> items) {
        this.items = items;
    }

    @com.fasterxml.jackson.annotation.JsonProperty("optional")
    @com.fasterxml.jackson.annotation.JsonSetter<nl>
        this.lastState = lastState;
    <|file_separator|>class EphemeralContainerStatusesList implements io.fabric8.kubernetes.api.model.KubernetesResource {

    @com.fasterxml.jackson.annotation.JsonProperty("items")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private java.util.List<io.fabric8.kubernetes.api.model.EphemeralContainerStatuses> items;

    public java.util.List<io.fabric8.kubernetes.api.model.EphemeralContainerStatuses> getItems() {
        return items;
    }

    public void setItems(java.util.List<io.fabric8.kubernetes.api.model.EphemeralContainerStatuses> items) {
        this.items = items;
    }

    @com.fasterxml.jackson.annotation.JsonProperty("kind")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private String kind;

    public String getKind() {
        return kind;
    }

    public void setKind(String kind) {
        this.kind = kind;
    }

    @com.fasterxml.jackson.annotation.JsonProperty("metadata")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private io.fabric8.kubernetes.api.model.ListMeta metadata;

    public io.fabric8.kubernetes.api.model.ListMeta getMetadata() {
        return metadata;
    }

    public void setMetadata(io.fabric8.kubernetes.api.model.ListMeta metadata) {
        this.metadata = metadata;
    }<nl>
        this.imageID = imageID;
    <|file_separator|>class InitContainerStatus implements io.fabric8.kubernetes.api.model.KubernetesResource {

    @com.fasterxml.jackson.annotation.JsonProperty("containerID")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private String containerID;

    public String getContainerID() {
        return containerID;
    }

    public void setContainerID(String containerID) {
        this.containerID = containerID;
    }

    @com.fasterxml.jackson.annotation.JsonProperty("image")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private String image;

    public String getImage() {
        return image;
    }

    public void setImage(String image) {
        this.image = image;
    }

    @com.fasterxml.jackson.annotation.JsonProperty("imageID")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private String imageID;

    public String getImageID() {
        return imageID;
    }

    public void setImageID(String imageID) {
        this.imageID = imageID;
    }

    @com.fasterxml.jackson.annotation.JsonProperty("lastState")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private org.apache.flink.v1beta1.flinkdeploymentspec.podtemplate.status.initcontainerstatus.LastState lastState;

    public org.apache.flink.v1<nl>
        return nodeSelectorTerms;
    <|file_separator|>class RequiredDuringSchedulingIgnoredDuringExecution implements io.fabric8.kubernetes.api.model.KubernetesResource {

    @com.fasterxml.jackson.annotation.JsonProperty("nodeSelectorTerms")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private java.util.List<org.apache.flink.v1beta1.flinkdeploymentspec.taskmanager.podtemplate.spec.affinity.nodeaffinity.requiredduringschedulingignoredduringexecution.NodeSelectorTerms> nodeSelectorTerms;

    public java.util.List<org.apache.flink.v1beta1.flinkdeploymentspec.taskmanager.podtemplate.spec.affinity.nodeaffinity.requiredduringschedulingignoredduringexecution.NodeSelectorTerms> getNodeSelectorTerms() {
        return nodeSelectorTerms;
    }

    public void setNodeSelectorTerms(java.util.List<org.apache.flink.v1beta1.flinkdeploymentspec.taskmanager.podtemplate.spec.affinity.nodeaffinity.requiredduringschedulingignoredduringexecution.NodeSelectorTerms> nodeSelectorTerms) {
        this.nodeSelectorTerms = nodeSelectorTerms;
    }
}<|file_separator|>class RequiredDuringSchedulingIgnoredDuringExecution implements io.fabric8.kubernetes.api.model.KubernetesResource {

    @com.fasterxml.jackson.annotation.JsonProperty("nodeSelectorTerms")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private java.util.List<org.apache.flink.v1beta1.flinkdeploymentspec.taskmanager.podtemplate.spec.affinity.nodeaffinity.requiredduringschedulingignoreddur<nl>
        this.values = values;
    <|file_separator|>class MatchExpressions implements io.fabric8.kubernetes.api.model.KubernetesResource {

    @com.fasterxml.jackson.annotation.JsonProperty("key")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private String key;

    public String getKey() {
        return key;
    }

    public void setKey(String key) {
        this.key = key;
    }

    @com.fasterxml.jackson.annotation.JsonProperty("operator")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private String operator;

    public String getOperator() {
        return operator;
    }

    public void setOperator(String operator) {
        this.operator = operator;
    }

    @com.fasterxml.jackson.annotation.JsonProperty("values")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private java.util.List<String> values;

    public java.util.List<String> getValues() {
        return values;
    }

    public void setValues(java.util.List<String> values) {
        this.values = values;
    }
<|file_separator|>class MatchExpressions implements io.fabric8.kubernetes.api.model.KubernetesResource {

    @com.fasterxml.jackson.annotation.JsonProperty("key")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private String key;

    public String getKey() {
        return key;
<nl>
        this.topologyKey = topologyKey;
    <|file_separator|>class RequiredDuringSchedulingIgnoredDuringExecution implements io.fabric8.kubernetes.api.model.KubernetesResource {

    @com.fasterxml.jackson.annotation.JsonProperty("labelSelector")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private org.apache.flink.v1beta1.flinkdeploymentspec.taskmanager.podtemplate.spec.affinity.podantiaffinity.requiredduringschedulingignoredduringexecution.LabelSelector labelSelector;

    public org.apache.flink.v1beta1.flinkdeploymentspec.taskmanager.podtemplate.spec.affinity.podantiaffinity.requiredduringschedulingignoredduringexecution.LabelSelector getLabelSelector() {
        return labelSelector;
    }

    public void setLabelSelector(org.apache.flink.v1beta1.flinkdeploymentspec.taskmanager.podtemplate.spec.affinity.podantiaffinity.requiredduringschedulingignoredduringexecution.LabelSelector labelSelector) {
        this.labelSelector = labelSelector;
    }

    @com.fasterxml.jackson.annotation.JsonProperty("namespaceSelector")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private org.apache.flink.v1beta1.flinkdeploymentspec.taskmanager.podtemplate.spec.affinity.podantiaffinity.requiredduringschedulingignoredduringexecution.NamespaceSelector namespaceSelector;

    public org.apache.flink.v1beta1.flinkdeploymentspec.taskmanager.podtemplate.spec.affinity.podantiaffinity.requiredduringschedulingignoredduringexecution.NamespaceSelector get<nl>
        return name;
    <|file_separator|>class SecretKeySelector implements io.fabric8.kubernetes.api.model.KubernetesResource {

    @com.fasterxml.jackson.annotation.JsonProperty("key")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private String key;

    public String getKey() {
        return key;
    }

    public void setKey(String key) {
        this.key = key;
    }

    @com.fasterxml.jackson.annotation.JsonProperty("name")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @com.fasterxml.jackson.annotation.JsonProperty("optional")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private Boolean optional;

    public Boolean getOptional() {
        return optional;
    }

    public void setOptional(Boolean optional) {
        this.optional = optional;
    }
}<|file_separator|>class Secret implements io.fabric8.kubernetes.api.model.KubernetesResource {

    @com.fasterxml.jackson.annotation.JsonProperty("data")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private java.util.Map<String, String> data;

    public java.util.Map<String, String> getData() {
        return data;
    }

    public void setData<nl>
        this.hostIP = hostIP;
    <|file_separator|>class Service implements io.fabric8.kubernetes.api.model.KubernetesResource {

    @com.fasterxml.jackson.annotation.JsonProperty("clusterIP")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private String clusterIP;

    public String getClusterIP() {
        return clusterIP;
    }

    public void setClusterIP(String clusterIP) {
        this.clusterIP = clusterIP;
    }

    @com.fasterxml.jackson.annotation.JsonProperty("externalIPs")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private java.util.List<String> externalIPs;

    public java.util.List<String> getExternalIPs() {
        return externalIPs;
    }

    public void setExternalIPs(java.util.List<String> externalIPs) {
        this.externalIPs = externalIPs;
    }

    @com.fasterxml.jackson.annotation.JsonProperty("externalName")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private String externalName;

    public String getExternalName() {
        return externalName;
    }

    public void setExternalName(String externalName) {
        this.externalName = externalName;
    }

    @com.fasterxml.jackson.annotation.JsonProperty("loadBalancerIP")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private String loadBalancerIP;

    public<nl>
        this.httpHeaders = httpHeaders;
    }

    @com.fasterxml.jackson.annotation.JsonProperty("httpHeaders")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private java.util.List<org.apache.flink.v1beta1.flinkdeploymentspec.taskmanager.podtemplate.spec.containers.readinessprobe.httpget.HttpHeaders> httpHeaders;

    public java.util.List<org.apache.flink.v1beta1.flinkdeploymentspec.taskmanager.podtemplate.spec.containers.readinessprobe.httpget.HttpHeaders> getHttpHeaders() {
        return httpHeaders;
    }

    public void setHttpHeaders(java.util.List<org.apache.flink.v1beta1.flinkdeploymentspec.taskmanager.podtemplate.spec.containers.readinessprobe.httpget.HttpHeaders> httpHeaders) {
        this.httpHeaders = httpHeaders;
    <|file_separator|>class HttpGet.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>package org.apache.flink.v1beta1.flinkdeploymentspec.taskmanager.podtemplate.spec.containers.readinessprobe.httpget;

public class HttpGet {

    @com.fasterxml.jackson.annotation.JsonProperty("host")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private String host;

    public String getHost() {
        return host;
    }

    public void setHost(String host) {
        this.host = host;
    }

    @com.fasterxml.jackson.annotation.JsonProperty("httpHeaders")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson<nl>
        this.successThreshold = successThreshold;
    <|file_separator|>class LivenessProbe implements io.fabric8.kubernetes.api.model.KubernetesResource {

    @com.fasterxml.jackson.annotation.JsonProperty("exec")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private org.apache.flink.v1beta1.flinkdeploymentspec.taskmanager.podtemplate.spec.containers.livenessprobe.Exec exec;

    public org.apache.flink.v1beta1.flinkdeploymentspec.taskmanager.podtemplate.spec.containers.livenessprobe.Exec getExec() {
        return exec;
    }

    public void setExec(org.apache.flink.v1beta1.flinkdeploymentspec.taskmanager.podtemplate.spec.containers.livenessprobe.Exec exec) {
        this.exec = exec;
    }

    @com.fasterxml.jackson.annotation.JsonProperty("failureThreshold")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private Long failureThreshold;

    public Long getFailureThreshold() {
        return failureThreshold;
    }

    public void setFailureThreshold(Long failureThreshold) {
        this.failureThreshold = failureThreshold;
    }

    @com.fasterxml.jackson.annotation.JsonProperty("httpGet")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private org.apache.flink.v1beta1.flinkdeploymentspec.taskmanager.podtemplate.spec.containers.livenessprobe.HttpGet httpGet;

    public org.apache.flink.v1beta1<nl>
        this.service = service;
    <|file_separator|><nl>
        this.name = name;
    }

    @com.fasterxml.jackson.annotation.JsonProperty("value")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private String value;

    public String getValue() {
        return value;
    }

    public void setValue(String value) {
        this.value = value;
    }

    @com.fasterxml.jackson.annotation.JsonProperty("valueFrom")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private org.apache.flink.v1beta1.flinkdeploymentspec.taskmanager.podtemplate.spec.ephemeralcontainers.env.ValueFrom valueFrom;

    public org.apache.flink.v1beta1.flinkdeploymentspec.taskmanager.podtemplate.spec.ephemeralcontainers.env.ValueFrom getValueFrom() {
        return valueFrom;
    }

    public void setValueFrom(org.apache.flink.v1beta1.flinkdeploymentspec.taskmanager.podtemplate.spec.ephemeralcontainers.env.ValueFrom valueFrom) {
        this.valueFrom = valueFrom;
    }
}

class Env {

    @com.fasterxml.jackson.annotation.JsonProperty("name")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    <|file_separator|><nl>
        this.value = value;
    <|file_separator|>class ListOptions implements io.fabric8.kubernetes.api.model.KubernetesResource {

    @com.fasterxml.jackson.annotation.JsonProperty("labelSelector")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private io.fabric8.kubernetes.api.model.LabelSelector labelSelector;

    public io.fabric8.kubernetes.api.model.LabelSelector getLabelSelector() {
        return labelSelector;
    }

    public void setLabelSelector(io.fabric8.kubernetes.api.model.LabelSelector labelSelector) {
        this.labelSelector = labelSelector;
    }

    @com.fasterxml.jackson.annotation.JsonProperty("fieldSelector")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private io.fabric8.kubernetes.api.model.FieldSelector fieldSelector;

    public io.fabric8.kubernetes.api.model.FieldSelector getFieldSelector() {
        return fieldSelector;
    }

    public void setFieldSelector(io.fabric8.kubernetes.api.model.FieldSelector fieldSelector) {
        this.fieldSelector = fieldSelector;
    }

    @com.fasterxml.jackson.annotation.JsonProperty("timeoutSeconds")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private Integer timeoutSeconds;

    public Integer getTimeoutSeconds() {
        return timeoutSeconds;
    }

    public void setTimeoutSeconds(Integer timeoutSeconds) {
        this.timeoutSeconds = timeoutSeconds;
    }

    @com.fasterxml.jackson.annotation<nl>
        this.tcpSocket = tcpSocket;
    }

    @com.fasterxml.jackson.annotation.JsonProperty("stdin")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private org.apache.flink.v1beta1.flinkdeploymentspec.taskmanager.podtemplate.spec.ephemeralcontainers.lifecycle.prestop.Stdin stdin;

    public org.apache.flink.v1beta1.flinkdeploymentspec.taskmanager.podtemplate.spec.ephemeralcontainers.lifecycle.prestop.Stdin getStdin() {
        return stdin;
    }

    public void setStdin(org.apache.flink.v1beta1.flinkdeploymentspec.taskmanager.podtemplate.spec.ephemeralcontainers.lifecycle.prestop.Stdin stdin) {
        this.stdin = stdin;
    }

    @com.fasterxml.jackson.annotation.JsonProperty("stdinOnce")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private org.apache.flink.v1beta1.flinkdeploymentspec.taskmanager.podtemplate.spec.ephemeralcontainers.lifecycle.prestop.StdinOnce stdinOnce;

    public org.apache.flink.v1beta1.flinkdeploymentspec.taskmanager.podtemplate.spec.ephemeralcontainers.lifecycle.prestop.StdinOnce getStdinOnce() {
        return stdinOnce;
    }

    public void setStdinOnce(org.apache.flink.v1beta1.flinkdeploymentspec.taskmanager.podtemplate.spec.ephemeralcontainers.lifecycle.prestop.StdinOnce stdinOnce) {
        this<nl>
        this.path = path;
    <|file_separator|>class HttpGet.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>package org.apache.flink.v1beta1.flinkdeploymentspec.taskmanager.podtemplate.spec.ephemeralcontainers.livenessprobe.httpget;

import io.fabric8.kubernetes.api.model.IntOrString;
import io.fabric8.kubernetes.api.model.KubernetesResource;
import io.fabric8.kubernetes.api.model.ObjectMeta;
import io.fabric8.kubernetes.api.model.OwnerReference;
import io.fabric8.kubernetes.api.model.PodTemplateSpec;
import io.fabric8.kubernetes.api.model.Quantity;
import io.fabric8.kubernetes.api.model.ResourceRequirements;
import io.fabric8.kubernetes.api.model.Secret;
import io.fabric8.kubernetes.api.model.ServiceAccount;
import io.fabric8.kubernetes.api.model.ServiceAccountTokenVolumeSource;
import io.fabric8.kubernetes.api.model.Volume;
import io.fabric8.kubernetes.api.model.VolumeMount;
import io.fabric8.kubernetes.api.model.VolumeMounts;
import io.fabric8.kubernetes.api.model.VolumeMountsBuilder;
import io.fabric8.kubernetes.api.model.VolumeMountsBuilder.VolumeMountsBuilderImpl;
import io.fabric8.kubernetes.api.model.VolumeMountsBuilder.VolumeMountsBuilderImpl.VolumeMountBuilder;
import io.fabric8.kubernetes.api.model.VolumeMountsBuilder.VolumeMountsBuilderImpl.VolumeMountBuilderImpl;
import io.fabric8.kubernetes.api.model.VolumeSource;
import io.fabric8.kubernetes.api.model.VolumeSources;
import io<nl>
        this.port = port;
    <|file_separator|><nl>
        this.successThreshold = successThreshold;
    <|file_separator|>class LivenessProbe implements io.fabric8.kubernetes.api.model.KubernetesResource {

    @com.fasterxml.jackson.annotation.JsonProperty("exec")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private org.apache.flink.v1beta1.flinkdeploymentspec.taskmanager.podtemplate.spec.ephemeralcontainers.livenessprobe.Exec exec;

    public org.apache.flink.v1beta1.flinkdeploymentspec.taskmanager.podtemplate.spec.ephemeralcontainers.livenessprobe.Exec getExec() {
        return exec;
    }

    public void setExec(org.apache.flink.v1beta1.flinkdeploymentspec.taskmanager.podtemplate.spec.ephemeralcontainers.livenessprobe.Exec exec) {
        this.exec = exec;
    }

    @com.fasterxml.jackson.annotation.JsonProperty("failureThreshold")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private Long failureThreshold;

    public Long getFailureThreshold() {
        return failureThreshold;
    }

    public void setFailureThreshold(Long failureThreshold) {
        this.failureThreshold = failureThreshold;
    }

    @com.fasterxml.jackson.annotation.JsonProperty("grpc")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private org.apache.flink.v1beta1.flinkdeploymentspec.taskmanager.podtemplate.spec.ephemeralcontainers.livenessprobe.Grpc grpc;

    public<nl>
        this.level = level;
    <|file_separator|><nl>
        return runAsNonRoot;
    <|file_separator|><nl>
        return value;
    <|file_separator|>class List.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>package io.fabric8.kubernetes.api.model;

import io.fabric8.kubernetes.api.model.KubernetesResource;

import java.util.List;

public class List implements io.fabric8.kubernetes.api.model.KubernetesResource {

    @com.fasterxml.jackson.annotation.JsonProperty("items")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private List<io.fabric8.kubernetes.api.model.KubernetesResource> items;

    public List<io.fabric8.kubernetes.api.model.KubernetesResource> getItems() {
        return items;
    }

    public void setItems(List<io.fabric8.kubernetes.api.model.KubernetesResource> items) {
        this.items = items;
    }
}<|file_separator|>class ListMeta.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>package io.fabric8.kubernetes.api.model;

import io.fabric8.kubernetes.api.model.KubernetesResource;

public class ListMeta implements io.fabric8.kubernetes.api.model.KubernetesResource {

    @com.fasterxml.jackson.annotation.JsonProperty("continue")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private String continue_;

    public String getContinue() {
        return continue_;
    }

    public void setContinue(String continue_) {
        this.continue_ = continue_;
    }

    @com.fasterxml.jackson.annotation.JsonProperty("resourceVersion")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP<nl>
        this.name = name;
    <|file_separator|>class ListOptions implements io.fabric8.kubernetes.api.model.KubernetesResource {

    @com.fasterxml.jackson.annotation.JsonProperty("labelSelector")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private io.fabric8.kubernetes.api.model.LabelSelector labelSelector;

    public io.fabric8.kubernetes.api.model.LabelSelector getLabelSelector() {
        return labelSelector;
    }

    public void setLabelSelector(io.fabric8.kubernetes.api.model.LabelSelector labelSelector) {
        this.labelSelector = labelSelector;
    }

    @com.fasterxml.jackson.annotation.JsonProperty("fieldSelector")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private io.fabric8.kubernetes.api.model.FieldSelector fieldSelector;

    public io.fabric8.kubernetes.api.model.FieldSelector getFieldSelector() {
        return fieldSelector;
    }

    public void setFieldSelector(io.fabric8.kubernetes.api.model.FieldSelector fieldSelector) {
        this.fieldSelector = fieldSelector;
    }

    @com.fasterxml.jackson.annotation.JsonProperty("timeoutSeconds")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private Integer timeoutSeconds;

    public Integer getTimeoutSeconds() {
        return timeoutSeconds;
    }

    public void setTimeoutSeconds(Integer timeoutSeconds) {
        this.timeoutSeconds = timeoutSeconds;
    }

    @com.fasterxml.jackson.annotation<nl>
        return port;
    <|file_separator|><nl>
        this.value = value;
    <|file_separator|>class ListOptions implements io.fabric8.kubernetes.api.model.KubernetesResource {

    @com.fasterxml.jackson.annotation.JsonProperty("labelSelector")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private io.fabric8.kubernetes.api.model.LabelSelector labelSelector;

    public io.fabric8.kubernetes.api.model.LabelSelector getLabelSelector() {
        return labelSelector;
    }

    public void setLabelSelector(io.fabric8.kubernetes.api.model.LabelSelector labelSelector) {
        this.labelSelector = labelSelector;
    }

    @com.fasterxml.jackson.annotation.JsonProperty("fieldSelector")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private io.fabric8.kubernetes.api.model.FieldSelector fieldSelector;

    public io.fabric8.kubernetes.api.model.FieldSelector getFieldSelector() {
        return fieldSelector;
    }

    public void setFieldSelector(io.fabric8.kubernetes.api.model.FieldSelector fieldSelector) {
        this.fieldSelector = fieldSelector;
    }

    @com.fasterxml.jackson.annotation.JsonProperty("timeoutSeconds")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private Integer timeoutSeconds;

    public Integer getTimeoutSeconds() {
        return timeoutSeconds;
    }

    public void setTimeoutSeconds(Integer timeoutSeconds) {
        this.timeoutSeconds = timeoutSeconds;
    }

    @com.fasterxml.jackson.annotation<nl>
        this.host = host;
    <|file_separator|><nl>
        this.volumeID = volumeID;
    }

    @Override
    public String toString() {
        return "AwsElasticBlockStore{" +
                "fsType='" + fsType + '\'' +
                ", partition=" + partition +
                ", readOnly=" + readOnly +
                ", volumeID='" + volumeID + '\'' +
                '}';
    <|file_separator|>class AwsElasticBlockStore.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>package io.fabric8.kubernetes.api.model;

public class AwsElasticBlockStore implements KubernetesResource {

    private String fsType;
    private Long partition;
    private Boolean readOnly;
    private String volumeID;

    public String getFsType() {
        return fsType;
    }

    public void setFsType(String fsType) {
        this.fsType = fsType;
    }

    public Long getPartition() {
        return partition;
    }

    public void setPartition(Long partition) {
        this.partition = partition;
    }

    public Boolean getReadOnly() {
        return readOnly;
    }

    public void setReadOnly(Boolean readOnly) {
        this.readOnly = readOnly;
    }

    public String getVolumeID() {
        return volumeID;
    }

    public void setVolumeID(String volumeID) {
        this.volumeID = volumeID;
    }

    @Override
    public String toString() {
        return "AwsElasticBlockStore{" +
                "fsType='" + fsType + '\'' +
                ", partition=" + partition +
                ", readOnly=" + readOnly +
                ", volumeID='" + volumeID + '\'' +
                '}';
    }
}<|file_separator|><nl>
        this.name = name;
    <|file_separator|>class SecretRefBuilder.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>class SecretRefBuilder {

    @com.fasterxml.jackson.annotation.JsonProperty("name")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}<|file_separator|>class SecretRefBuilder.java.html
<|fim_prefix|><|fim_suffix|>>
<span class="keyword">public</span> <span class="keyword">class</span> <span class="identifier">SecretRefBuilder</span> <span class="keyword">extends</span> <span class="identifier">io.fabric8.kubernetes.api.model.SecretRef</span> {

    <span class="keyword">private</span> <span class="identifier">SecretRefBuilder</span>(<span class="identifier">SecretRefBuilder</span> <span class="identifier">builder</span>) {
        <span class="keyword">super</span>(<span class="identifier">builder</span>);
    }

    <span class="keyword">public</span> <span class="identifier">SecretRefBuilder</span>(<span class="identifier">SecretRef</span> <span class="identifier">secretRef</span>) {
        <span class="keyword">super</span>(<span class="identifier">secretRef</span>);
    }

    <span class="keyword">public</span> <span class="identifier">SecretRefBuilder</span>(<span class="identifier">SecretRef</span> <span class="identifier">secretRef</span>, <span class="identifier">String</span> <span class="identifier<nl>
        return volumeID;
    <|file_separator|><nl>
        this.downwardAPI = downwardAPI;
    <|file_separator|>class ServiceAccountToken implements io.fabric8.kubernetes.api.model.KubernetesResource {

    @com.fasterxml.jackson.annotation.JsonProperty("name")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private java.lang.String name;

    public java.lang.String getName() {
        return name;
    }

    public void setName(java.lang.String name) {
        this.name = name;
    }
}<|file_separator|>class ServiceAccountTokenList implements io.fabric8.kubernetes.api.model.KubernetesResource {

    @com.fasterxml.jackson.annotation.JsonProperty("items")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private java.util.List<org.apache.flink.v1beta1.flinkdeploymentspec.taskmanager.podtemplate.spec.volumes.projected.sources.ServiceAccountToken> items;

    public java.util.List<org.apache.flink.v1beta1.flinkdeploymentspec.taskmanager.podtemplate.spec.volumes.projected.sources.ServiceAccountToken> getItems() {
        return items;
    }

    public void setItems(java.util.List<org.apache.flink.v1beta1.flinkdeploymentspec.taskmanager.podtemplate.spec.volumes.projected.sources.ServiceAccountToken> items) {
        this.items = items;
    }
}<|file_separator|>class ServiceAccountTokenListBuilder.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>package org.apache.flink.v1beta1.flinkdeploymentspec.taskmanager.podtemplate.spec.volumes.projected<nl>
        return secretName;
    <|file_separator|>class SecretVolumeSource implements io.fabric8.kubernetes.api.model.KubernetesResource {

    @com.fasterxml.jackson.annotation.JsonProperty("defaultMode")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private Long defaultMode;

    public Long getDefaultMode() {
        return defaultMode;
    }

    public void setDefaultMode(Long defaultMode) {
        this.defaultMode = defaultMode;
    }

    @com.fasterxml.jackson.annotation.JsonProperty("items")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private java.util.List<org.apache.flink.v1beta1.flinkdeploymentspec.taskmanager.podtemplate.spec.volumes.secret.Items> items;

    public java.util.List<org.apache.flink.v1beta1.flinkdeploymentspec.taskmanager.podtemplate.spec.volumes.secret.Items> getItems() {
        return items;
    }

    public void setItems(java.util.List<org.apache.flink.v1beta1.flinkdeploymentspec.taskmanager.podtemplate.spec.volumes.secret.Items> items) {
        this.items = items;
    }

    @com.fasterxml.jackson.annotation.JsonProperty("optional")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private Boolean optional;

    public Boolean getOptional() {
        return optional;
    }

    public void setOptional(Boolean optional) {
        this.optional = optional<nl>
        this.terminated = terminated;
    <|file_separator|><nl>
        this.timeStamp = timeStamp;
    <|file_separator|>class LastSavepoint.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>package io.fabric8.kubernetes.api.model;

public class LastSavepoint {

    public enum FormatType {

        CANONICAL("CANONICAL"), NATIVE("NATIVE"), UNKNOWN("UNKNOWN");

        java.lang.String value;

        FormatType(java.lang.String value) {
            this.value = value;
        }

        @com.fasterxml.jackson.annotation.JsonValue()
        public java.lang.String getValue() {
            return value;
        }
    }

    @com.fasterxml.jackson.annotation.JsonProperty("formatType")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private FormatType formatType;

    public FormatType getFormatType() {
        return formatType;
    }

    public void setFormatType(FormatType formatType) {
        this.formatType = formatType;
    }

    @com.fasterxml.jackson.annotation.JsonProperty("location")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private String location;

    public String getLocation() {
        return location;
    }

    public void setLocation(String location) {
        this.location = location;
    }

    @com.fasterxml.jackson.annotation.JsonProperty("timeStamp")
    @com.fasterxml.jackson.annotation.JsonSetter(nulls = com.fasterxml.jackson.annotation.Nulls.SKIP)
    private Long timeStamp;

    public Long getTimeStamp() {
        return timeStamp;
    }

    public void setTimeStamp(Long timeStamp) {<nl>
    return "ObjectIdentifier{"
        + "catalogName=" + catalogName
        + ", databaseName=" + databaseName
        + ", objectName=" + objectName
        + '}';
  <|file_separator|><nl>
    return Collections.emptySet();
  <|file_separator|><nl>
    throw new SqlGatewayException("Flink native SqlGateWay don`t support operation:executeStatement!");
  <|file_separator|><nl>
    // check to make sure all required properties/fields are present in the JSON string
    for (String requiredField : openapiRequiredFields) {
      if (!jsonObj.keySet().contains(requiredField)) {
        throw new IllegalArgumentException(requiredField + " is missing from JSON string");
      }
    }
  <|file_separator|><nl>
    this.apiKeyPrefix = apiKeyPrefix;
  <|file_separator|><nl>
        localDateTypeAdapter.setFormat(dateFormat);
    }<|file_separator|><nl>
        return status;
    <|file_separator|><nl>
            return Objects.hash(timestamp, counter);
        <|file_separator|><nl>
        this.authenticationStrategy.evaluate(context);
    <|file_separator|><nl>
        return authenticationMetadataProvider.getUser(context.getUsername());
    <|file_separator|><nl>
        this.username = username;
    <|file_separator|><nl>
        return (V) INSTANCE_MAP.computeIfAbsent(key, function);
    <|file_separator|><nl>
    <|file_separator|><nl>
        this.authenticationMetadataManager.clearUsers();
    <|file_separator|><nl>
        User user = User.of("test", "test");
        this.authenticationMetadataManager.createUser(user).join();
        user = this.authenticationMetadataManager.getUser("test").join();
        Assert.assertNotNull(user);
        user.setPassword("test2");
        this.authenticationMetadataManager.updateUser(user).join();
        user = this.authenticationMetadataManager.getUser("test").join();
        Assert.assertNotNull(user);
        Assert.assertEquals(user.getPassword(), "test2");
    <|file_separator|><nl>
        return rootDir + File.separator + "config" + File.separator + "topicQueueMapping.json";
    }

    public static String getTopicQueueMappingPath(final String rootDir, final String topic) {
        return rootDir + File.separator + "config" + File.separator + "topicQueueMapping.json";
    }

    public static String getTopicQueueMappingPath(final String rootDir, final String topic, final String queue) {
        return rootDir + File.separator + "config" + File.separator + "topicQueueMapping.json";
    }

    public static String getTopicQueueMappingPath(final String rootDir, final String topic, final String queue, final String consumer) {
        return rootDir + File.separator + "config" + File.separator + "topicQueueMapping.json";
    }

    public static String getTopicQueueMappingPath(final String rootDir, final String topic, final String queue, final String consumer, final String consumerGroup) {
        return rootDir + File.separator + "config" + File.separator + "topicQueueMapping.json";
    }

    public static String getTopicQueueMappingPath(final String rootDir, final String topic, final String queue, final String consumer, final String consumerGroup, final String consumerOffset) {
        return rootDir + File.separator + "config" + File.separator + "topicQueueMapping.json";
    }

    public static String getTopicQueueMappingPath(final String rootDir, final String topic, final String queue, final String consumer, final String consumerGroup, final String consumerOffset, final String consumerOrderInfo) {
        return rootDir + File.separator + "config" + File.separator + "topicQueueMapping.json";
    }

    public static String getTopicQueueMappingPath(final<nl>
        if (decisionFactor() < 0) {
            coldDataCgCtrService.addOrUpdateGroupConfig(consumerGroup, (long)(currentThreshold * 0.5));
        }
    <|file_separator|><nl>
        // TODO: 2019/12/11
    <|file_separator|><nl>
        return (RequestTask) runnable;
    <|file_separator|><nl>
        final List<PullRequest> clone = new ArrayList<>(this.pullRequestList);
        this.pullRequestList.clear();
        return clone;
    <|file_separator|><nl>
        return pullFromThisOffset;
    <|file_separator|><nl>
        this.dataVersion = dataVersion;
    <|file_separator|><nl>
    <|file_separator|><nl>
        BrokerStartup brokerStartup = new BrokerStartup();
        Method method = brokerStartup.getClass().getDeclaredMethod("setProperties", Properties.class);
        method.setAccessible(true);
        Properties properties = new Properties();
        properties.setProperty("storePathRootDir", storePathRootDir);
        method.invoke(brokerStartup, properties);
        assertEquals(storePathRootDir, brokerStartup.getStorePathRootDir());
    <|file_separator|><nl>
        ByteBuffer byteBuffer = ByteBuffer.allocate(20);
        byteBuffer.putInt(20);
        GetMessageResult getMessageResult = new GetMessageResult();
        ManyMessageTransfer manyMessageTransfer = new ManyMessageTransfer(byteBuffer,getMessageResult);

        Assert.assertEquals(manyMessageTransfer.pos(),20);
    <|file_separator|><nl>
        return true;
    <|file_separator|><nl>
        if (mqAll == null || mqAll.isEmpty()) {
            return null;
        }
        if (cidAll == null || cidAll.isEmpty()) {
            return null;
        }
        if (consumerGroup == null || consumerGroup.isEmpty()) {
            return null;
        }
        if (currentCID == null || currentCID.isEmpty()) {
            return null;
        }
        if (customHashFunction == null) {
            customHashFunction = new HashFunction();
        }
        List<MessageQueue> mqList = new ArrayList<>();
        for (MessageQueue mq : mqAll) {
            if (mq == null) {
                continue;
            }
            if (mq.getQueueName() == null || mq.getQueueName().isEmpty()) {
                continue;
            }
            if (mq.getQueueName().equals(currentCID)) {
                continue;
            }
            if (cidAll.contains(mq.getQueueName())) {
                continue;
            }
            mqList.add(mq);
        }
        if (mqList.isEmpty()) {
            return null;
        }
        List<Node> nodes = new ArrayList<>();
        for (MessageQueue mq : mqList) {
            nodes.add(new ClientNode(mq.getQueueName()));
        }
        List<Node> clientNodes = new ArrayList<>();
        for (String cid : cidAll) {
            clientNodes.add(new ClientNode(cid));
        }
        List<Node> allNodes = new ArrayList<>();
        allNodes.addAll(nodes);
        allNodes.addAll(clientNodes);
        List<Node> sortedNodes = new ArrayList<>();
        for (int i = 0; i < virtualNode<nl>
        String clientId = clientConfig.buildMQClientId();
        ProduceAccumulator accumulator = this.accumulatorTable.get(clientId);
        if (null == accumulator) {
            accumulator = new ProduceAccumulator(clientConfig.cloneClientConfig());
            ProduceAccumulator prev = this.accumulatorTable.putIfAbsent(clientId, accumulator);
            if (prev != null) {
                accumulator = prev;
                log.warn("Returned Previous ProduceAccumulator for clientId:[{}]", clientId);
            } else {
                log.info("Created new ProduceAccumulator for clientId:[{}]", clientId);
            }
        }

        return accumulator;
    }

    public void removeProduceAccumulator(final String clientId) {
        this.accumulatorTable.remove(clientId);
    <|file_separator|><nl>
        return messageQueue;
    <|file_separator|><nl>
            // TODO: implement
        <|file_separator|><nl>
        if (context == null || context.getMqTraceContext() == null) {
            return;
        }
        if (context.getSendResult() == null) {
            return;
        }

        if (context.getSendResult().getRegionId() == null) {
            return;
        }

        Span span = tracer.createSpan(hookName());
        span.setTag(TraceConstants.ROCKETMQ_REGION_ID, context.getSendResult().getRegionId());
        span.setTag(TraceConstants.ROCKETMQ_MSG_ID, context.getSendResult().getMsgId());
        context.setMqTraceContext(span);
    <|file_separator|><nl>
        final Message replyMessage = requestMessage.createReply();
        replyMessage.setBody(body);
        return replyMessage;
    <|file_separator|><nl>
        TopicRouteData topicRouteData = new TopicRouteData();
        topicRouteData.setFilterServerTable(new HashMap<>());
        assertThat(topicRouteData.findBrokerAddressInSubscribe(group)).isNull();
    <|file_separator|><nl>
        latencyFaultTolerance.updateFaultItem(brokerName, 3000, 3000, true);
        assertThat(latencyFaultTolerance.isAvailable(brokerName)).isFalse();
        assertThat(latencyFaultTolerance.isAvailable(anotherBrokerName)).isTrue();
    <|file_separator|><nl>
        producer = new DefaultMQProducer(producerGroupTemp);
        producer.setNamesrvAddr("127.0.0.1:9876");
        producer.setTracer(tracer);
        producer.setRetryTimesWhenSendFailed(0);
        producer.setRetryTimesWhenSendAsyncFailed(0);
        producer.setRetryAnotherBrokerWhenNotStoreOK(false);
        producer.setRetryAnotherBrokerWhenNotStoreOKAndNoRoute(false);
        producer.setRetryAnotherBrokerWhenNotStoreOKAndNoRouteAndDeduplicated(false);
        producer.setRetryAnotherBrokerWhenNotStoreOKAndNoRouteAndDeduplicatedAndNotBlock(false);
        producer.setRetryAnotherBrokerWhenNotStoreOKAndNoRouteAndDeduplicatedAndNotBlockAndNoRoute(false);
        producer.setRetryAnotherBrokerWhenNotStoreOKAndNoRouteAndDeduplicatedAndNotBlockAndNoRouteAndDeduplicated(false);
        producer.setRetryAnotherBrokerWhenNotStoreOKAndNoRouteAndDeduplicatedAndNotBlockAndNoRouteAndDeduplicatedAndNotBlock(false);
        producer.setRetryAnotherBrokerWhenNotStoreOKAndNoRouteAndDeduplicatedAndNotBlockAndNoRouteAndDeduplicatedAndNotBlockAndNoRoute(false);
        producer.setRetryAnotherBrokerWhenNotStoreOKAndNoRouteAndDeduplicatedAndNotBlockAndNoRouteAndDeduplicatedAndNotBlockAndNoRouteAndDeduplicatedAndNotBlock(false);
        producer.setRetryAnotherBrokerWhenNotStoreOKAndNoRouteAndDeduplicatedAndNotBlockAndNoRouteAndDeduplicatedAndNotBlockAndNoRouteAndDeduplicatedAndNotBlockAndNoRouteAndDeduplicatedAndNotBlock(false);
        producer.setRetryAnotherBrokerWhenNotStoreOKAndNo<nl>
        MDC.put(MDC_BROKER_CONTAINER_LOG_DIR, brokerIdentity.getBrokerContainerLogDir());
        try {
            run0();
        } finally {
            MDC.remove(MDC_BROKER_CONTAINER_LOG_DIR);
        }
    <|file_separator|><nl>
        return isBrokerContainer ? "BrokerContainer" : localHostName;
    <|file_separator|><nl>
        return COMPRESSORS.get(type);
    <|file_separator|><nl>
        return (T) parser.parseMap(type, fieldName);
    <|file_separator|><nl>
        return errorMessage + MORE_INFORMATION + APPLY_TOPIC_URL;
    <|file_separator|><nl>
        return new JoranXmlTransformer().transform(in);
    <|file_separator|><nl>
        return null;
    <|file_separator|><nl>
        scheduledExecutorService.scheduleAtFixedRate(() -> {
            try {
                value.incrementAndGet();
            } catch (Exception e) {
                log.error(String.format("Error incrementing value for %s", statsName), e);
            }
        }, 0, 5, TimeUnit.MINUTES);
    <|file_separator|><nl>
        return unit ? setUnitFlag(0) : 0;
    <|file_separator|><nl>
        return new FutureTask<T>(runnable, value) {
            @Override
            public boolean cancel(boolean mayInterruptIfRunning) {
                if (mayInterruptIfRunning) {
                    runnable.run();
                }
                return super.cancel(mayInterruptIfRunning);
            }
        };
    <|file_separator|><nl>
        ThreadPoolMonitor.jstackLogger = jstackLoggerConfig;
        ThreadPoolMonitor.waterMarkLogger = waterMarkLoggerConfig;
        ThreadPoolMonitor.enablePrintJstack = enablePrintJstack;
        ThreadPoolMonitor.jstackPeriodTime = jstackPeriodTimeConfig;
        ThreadPoolMonitor.threadPoolStatusPeriodTime = threadPoolStatusPeriodTimeConfig;
    <|file_separator|><nl>
        this.appendStartAndShutdown(new StartAndShutdown() {
            @Override
            public void start() throws Exception {
                start.start();
            }

            @Override
            public void shutdown() throws Exception {

            }
        });
    <|file_separator|><nl>
        String encodedContent = encodingParams(paramValues, encoding);
        url += (null == encodedContent) ? "" : ("?" + encodedContent);

        HttpURLConnection conn = null;
        try {
            conn = (HttpURLConnection) new URL(url).openConnection();
            conn.setRequestMethod("POST");
            conn.setConnectTimeout((int) readTimeoutMs);
            conn.setReadTimeout((int) readTimeoutMs);
            setHeaders(conn, headers, encoding);

            conn.connect();
            int respCode = conn.getResponseCode();
            String resp = null;

            if (HttpURLConnection.HTTP_OK == respCode) {
                resp = IOTinyUtils.toString(conn.getInputStream(), encoding);
            } else {
                resp = IOTinyUtils.toString(conn.getErrorStream(), encoding);
            }
            return new HttpResult(respCode, resp);
        } finally {
            if (conn != null) {
                conn.disconnect();
            }
        }
    <|file_separator|><nl>
        String popRetryTopic = KeyBuilder.buildPopRetryTopicV2(topic, group);
        assertThat(KeyBuilder.isPopRetryTopicV2(popRetryTopic)).isTrue();

        String popRetryTopicV1 = KeyBuilder.buildPopRetryTopicV1(topic, group);
        assertThat(KeyBuilder.isPopRetryTopicV2(popRetryTopicV1)).isFalse();
    }

    @Test
    public void testIsPopRetryTopicV1() {
        String popRetryTopic = KeyBuilder.buildPopRetryTopicV2(topic, group);
        assertThat(KeyBuilder.isPopRetryTopicV1(popRetryTopic)).isFalse();

        String popRetryTopicV1 = KeyBuilder.buildPopRetryTopicV1(topic, group);
        assertThat(KeyBuilder.isPopRetryTopicV1(popRetryTopicV1)).isTrue();
    <|file_separator|><nl>
        String brokerVIPChannel = MixAll.getBrokerVIPChannel();
        assertThat(brokerVIPChannel).isNotNull();
    }

    @Test
    public void testIsLocal() {
        String local = MixAll.getLocal();
        assertThat(local).isNotNull();
    }

    @Test
    public void testIsLocal() {
        String local = MixAll.getLocal();
        assertThat(local).isNotNull();
    }

    @Test
    public void testIsLocal() {
        String local = MixAll.getLocal();
        assertThat(local).isNotNull();
    }

    @Test
    public void testIsLocal() {
        String local = MixAll.getLocal();
        assertThat(local).isNotNull();
    }

    @Test
    public void testIsLocal() {
        String local = MixAll.getLocal();
        assertThat(local).isNotNull();
    }

    @Test
    public void testIsLocal() {
        String local = MixAll.getLocal();
        assertThat(local).isNotNull();
    }

    @Test
    public void testIsLocal() {
        String local = MixAll.getLocal();
        assertThat(local).isNotNull();
    }

    @Test
    public void testIsLocal() {
        String local = MixAll.getLocal();
        assertThat(local).isNotNull();
    }

    @Test
    public void testIsLocal() {
        String local = MixAll.getLocal();
        assertThat(local).isNotNull();
    }

    @Test
    public void testIsLocal() {
        String local = MixAll.getLocal();
        assertThat(local).isNotNull();
    }

    @Test
    public void testIsLocal() {
        String local = MixAll.getLocal();
        assertThat(local).isNotNull();
<nl>
        EnumAttribute enumAttribute = new EnumAttribute("enum.key", true, "a", "b", "c");
        Assert.assertThrows(RuntimeException.class, () -> enumAttribute.verify(""));
        Assert.assertThrows(RuntimeException.class, () -> enumAttribute.verify("a"));
        Assert.assertThrows(RuntimeException.class, () -> enumAttribute.verify("d"));
        Assert.assertThrows(RuntimeException.class, () -> enumAttribute.verify("c"));
        Assert.assertThrows(RuntimeException.class, () -> enumAttribute.verify("b"));
        Assert.assertThrows(RuntimeException.class, () -> enumAttribute.verify("c,"));
        Assert.assertThrows(RuntimeException.class, () -> enumAttribute.verify("a,"));
        Assert.assertThrows(RuntimeException.class, () -> enumAttribute.verify("a,b"));
        Assert.assertThrows(RuntimeException.class, () -> enumAttribute.verify("a,b,"));
        Assert.assertThrows(RuntimeException.class, () -> enumAttribute.verify("a,b,c"));
        Assert.assertThrows(RuntimeException.class, () -> enumAttribute.verify("a,b,c,"));

        enumAttribute.verify("a");
        enumAttribute.verify("b");
        enumAttribute.verify("c");
    <|file_separator|><nl>
        int flag = 0;
        flag |= MessageSysFlag.COMPRESSED_FLAG;
        flag |= MessageSysFlag.COMPRESSION_TYPE_FLAG;

        assertEquals(MessageSysFlag.COMPRESSION_TYPE_FLAG, MessageSysFlag.getCompressionType(flag));
    <|file_separator|><nl>
        if (brokerConfig.getSlaveBrokerConfig() == null) {
            throw new IllegalArgumentException("Slave broker config is not set");
        }
    }

    @Override
    public void start() {
        lock.lock();
        try {
            super.start();
        } finally {
            lock.unlock();
        }
    }

    @Override
    public void stop() {
        lock.lock();
        try {
            super.stop();
        } finally {
            lock.unlock();
        }
    <|file_separator|><nl>
        return EventType.ELECT_MASTER;
    <|file_separator|>class Broker.java
<|fim_prefix|><|fim_suffix|>

    public void setBrokerId(Long brokerId) {
        this.brokerId = brokerId;
    }

    public String getBrokerName() {
        return brokerName;
    }

    public void setBrokerName(String brokerName) {
        this.brokerName = brokerName;
    }

    public String getBrokerAddress() {
        return brokerAddress;
    }

    public void setBrokerAddress(String brokerAddress) {
        this.brokerAddress = brokerAddress;
    }

    public String getBrokerPort() {
        return brokerPort;
    }

    public void setBrokerPort(String brokerPort) {
        this.brokerPort = brokerPort;
    }

    public String getBrokerStatus() {
        return brokerStatus;
    }

    public void setBrokerStatus(String brokerStatus) {
        this.brokerStatus = brokerStatus;
    }

    public String getBrokerType() {
        return brokerType;
    }

    public void setBrokerType(String brokerType) {
        this.brokerType = brokerType;
    }

    public String getBrokerDescription() {
        return brokerDescription;
    }

    public void setBrokerDescription(String brokerDescription) {
        this.brokerDescription = brokerDescription;
    }

    public String getBrokerStatusMessage() {
        return brokerStatusMessage;
    }

    public void setBrokerStatusMessage(String brokerStatusMessage) {
        this.brokerStatusMessage = brokerStatusMessage;
    }

    public String getBrokerStatusMessageTime() {
        return brokerStatusMessageTime;
    }

    public void setBrokerStatusMessageTime(String brokerStatusMessageTime) {
        <nl>
        if (brokerId == null) {
            return;
        }
        Pair<String, String> pair = this.brokerIdInfo.get(brokerId);
        if (pair != null) {
            pair.setObject1(brokerAddress);
        }
    }

    public void updateBrokerRegisterCheckCode(final Long brokerId, final String registerCheckCode) {
        if (brokerId == null) {
            return;
        }
        Pair<String, String> pair = this.brokerIdInfo.get(brokerId);
        if (pair != null) {
            pair.setObject2(registerCheckCode);
        }
    }

    public void updateBrokerAddressAndRegisterCheckCode(final Long brokerId, final String brokerAddress, final String registerCheckCode) {
        if (brokerId == null) {
            return;
        }
        Pair<String, String> pair = this.brokerIdInfo.get(brokerId);
        if (pair != null) {
            pair.setObject1(brokerAddress);
            pair.setObject2(registerCheckCode);
        }
    }

    public void updateBrokerAddressAndRegisterCheckCode(final Long brokerId, final String brokerAddress, final String registerCheckCode, final String oldRegisterCheckCode) {
        if (brokerId == null) {
            return;
        }
        Pair<String, String> pair = this.brokerIdInfo.get(brokerId);
        if (pair != null && pair.getObject2().equals(oldRegisterCheckCode)) {
            pair.setObject1(brokerAddress);
            pair.setObject2(registerCheckCode);
        }
    }

    public void updateBrokerAddressAndRegisterCheckCode(final Long brokerId, final String brokerAddress, final String registerCheck<nl>
        int start = currIndex;
        int end = Math.min(currIndex + SIZE_LIMIT, messages.size());
        List<Message> subList = messages.subList(start, end);
        currIndex = end;
        return subList;
    <|file_separator|><nl>
        Long[] snapshot = new Long[6];
        snapshot[0] = System.currentTimeMillis();
        snapshot[1] = sendRequestSuccessCount.sum();
        snapshot[2] = sendRequestFailedCount.sum();
        snapshot[3] = sendMessageSuccessCount.sum();
        snapshot[4] = sendMessageFailedCount.sum();
        snapshot[5] = sendMessageMaxRT.longValue();
        return snapshot;
    <|file_separator|>class StatsBenchmarkBatchConsumer.java
<|fim_prefix|><|fim_suffix|>

    public void shutdown() {
        executorService.shutdown();
    }
}<|fim_middle|>import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.atomic.LongAdder;

public class StatsBenchmarkBatchConsumer {

    private final LongAdder receiveRequestSuccessCount = new LongAdder();

    private final LongAdder receiveRequestFailedCount = new LongAdder();

    private final LongAdder receiveMessageSuccessTimeTotal = new LongAdder();

    private final AtomicLong receiveMessageMaxRT = new AtomicLong(0L);

    private final LongAdder receiveMessageSuccessCount = new LongAdder();

    private final LongAdder receiveMessageFailedCount = new LongAdder();

    private final ScheduledExecutorService executorService = Executors.newSingleThreadScheduledExecutor(new ThreadFactoryImpl(
        "BenchmarkTimerThread", Boolean.TRUE));

    private final LinkedList<Long[]> snapshotList = new LinkedList<>();

    private final int reportInterval;

    public StatsBenchmarkBatchConsumer(int reportInterval) {
        this.reportInterval = reportInterval;
    }

    public Long[] createSnapshot() {
        Long[] snapshot = new Long[6];
        snapshot[0] = System.currentTimeMillis();
<nl>
        String sql = "select * from table where id = 1";
        String filter = SqlFilterProducer.getFilter(sql);
        System.out.println(filter);
    }

    public static String getFilter(String sql) {
        String[] words = sql.split(" ");
        String filter = "";
        for (String word : words) {
            if (word.contains("where")) {
                filter = word;
            }
        }
        return filter;
    <|file_separator|><nl>
        try {
            PullConsumer consumer = new PullConsumer(URL, QUEUE);
            consumer.start();
            consumer.shutdown();
        } catch (Exception e) {
            e.printStackTrace();
        }
    <|file_separator|><nl>
        CachedQueue cachedQueue = this.mqCachedTable.get(mq);
        if (null != cachedQueue) {
            cachedQueue.getMsgCachedTable().remove(offset);
        }
    <|file_separator|><nl>
        Tracer tracer = initTracer();
        Span span = tracer.buildSpan("test").start();
        span.log(Map.of("key", "value"));
        span.log(Map.of("key", "value"));
        span.log(Map.of("key", "value"));
        span.log(Map.of("key", "value"));
        span.log(Map.of("key", "value"));
        span.log(Map.of("key", "value"));
        span.log(Map.of("key", "value"));
        span.log(Map.of("key", "value"));
        span.log(Map.of("key", "value"));
        span.log(Map.of("key", "value"));
        span.log(Map.of("key", "value"));
        span.log(Map.of("key", "value"));
        span.log(Map.of("key", "value"));
        span.log(Map.of("key", "value"));
        span.log(Map.of("key", "value"));
        span.log(Map.of("key", "value"));
        span.log(Map.of("key", "value"));
        span.log(Map.of("key", "value"));
        span.log(Map.of("key", "value"));
        span.log(Map.of("key", "value"));
        span.log(Map.of("key", "value"));
        span.log(Map.of("key", "value"));
        span.log(Map.of("key", "value"));
        span.log(Map.of("key", "value"));
        span.log(Map.of("key", "value"));
        span<nl>
        return new Expression() {
            @Override
            public String toSql() {
                return expr;
            }
        };
    <|file_separator|><nl>
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        BinaryExpression that = (BinaryExpression) o;

        if (left != null ? !left.equals(that.left) : that.left != null) return false;
        if (right != null ? !right.equals(that.right) : that.right != null) return false;

        return true;
    <|file_separator|>class Expression.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public interface Expression {
    /**
     * @return the left hand side of the expression
     */
    public Expression getLeft();

    /**
     * @return the right hand side of the expression
     */
    public Expression getRight();

    /**
     * @return the string representation of the expression
     */
    public String toString();

    /**
     * @return the hashcode of the expression
     */
    public int hashCode();

    /**
     * @return true if the expression is equal to the given object
     */
    public boolean equals(Object o);
}<|file_separator|>class ExpressionFactory.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class ExpressionFactory {
    /**
     * @param left
     * @param right
     * @param symbol
     * @return
     */
    public static Expression createExpression(Expression left, Expression right, String symbol) {
        if (symbol.equals("+")) {
            return new AdditionExpression(left, right);
        } else if (symbol.equals("-")) {
            return new SubtractionExpression(left, right);
        } else if (symbol.equals("*")) {
            return new MultiplicationExpression(left, right);
        } else if (symbol.equals("/")) {
            return new DivisionExpression(left, right);
        } else {<nl>
        return (Boolean) value;
    <|file_separator|>class BooleanExpression.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public interface BooleanExpression {
    boolean matches(EvaluationContext context) throws Exception;
}<|file_separator|>class EvaluationContext.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class EvaluationContext {
    public static final EvaluationContext NULL = new EvaluationContext(null);
    public static final EvaluationContext TRUE = new EvaluationContext(Boolean.TRUE);
    public static final EvaluationContext FALSE = new EvaluationContext(Boolean.FALSE);

    private final Object value;

    public EvaluationContext(Object value) {
        this.value = value;
    }

    public Object getValue() {
        return value;
    }
}<|file_separator|>class ConstantExpression.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class ConstantExpression extends Expression {
    protected final Object value;

    public ConstantExpression(Object value) {
        this.value = value;
    }

    public Object getValue() {
        return value;
    }
}<|file_separator|>class Expression.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public abstract class Expression {
    public abstract Object getValue();
}<|file_separator|><nl>
        return name.hashCode();
    <|file_separator|>class Expression.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public interface Expression {
    Object evaluate(EvaluationContext context) throws Exception;
}<|file_separator|>class EvaluationContext.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>import java.util.HashMap;
import java.util.Map;

public class EvaluationContext {
    private final Map<String, Object> variables = new HashMap<>();

    public void set(String name, Object value) {
        variables.put(name, value);
    }

    public Object get(String name) {
        return variables.get(name);
    }
}<|file_separator|>class BinaryExpression.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class BinaryExpression implements Expression {
    private final Expression left;
    private final Expression right;
    private final String operator;

    public BinaryExpression(Expression left, Expression right, String operator) {
        this.left = left;
        this.right = right;
        this.operator = operator;
    }

    @Override
    public Object evaluate(EvaluationContext context) throws Exception {
        Object leftValue = left.evaluate(context);
        Object rightValue = right.evaluate(context);

        if (operator.equals("+")) {
            return leftValue + rightValue;
        } else if (operator.equals("-")) {
            return leftValue - rightValue;
        } else if (operator.equals("*")) {
            return leftValue * rightValue;
        } else if (operator.equals("/")) {
            return leftValue / rightValue;
        } else {
            throw new IllegalArgumentException("Invalid operator: " + operator);
        }
    }

    /**
     * @see Object#toString()
     */
    @Override
    public String toString() {
        return "(" + left + " " + operator + "<nl>
    <|file_separator|><nl>

    }

    @Override
    public void doAfterException(String remoteAddr, RemotingCommand request, Throwable t) {

    }

    @Override
    public void doAfterException(String remoteAddr, RemotingCommand request, RemotingCommand response, Throwable t) {

    }

    @Override
    public void doAfterException(String remoteAddr, RemotingCommand request, RemotingCommand response, Throwable t,
                                 String remoteAddr2, RemotingCommand request2, RemotingCommand response2) {

    }

    @Override
    public void doAfterException(String remoteAddr, RemotingCommand request, RemotingCommand response, Throwable t,
                                 String remoteAddr2, RemotingCommand request2, RemotingCommand response2, Throwable t2) {

    }

    @Override
    public void doAfterException(String remoteAddr, RemotingCommand request, RemotingCommand response, Throwable t,
                                 String remoteAddr2, RemotingCommand request2, RemotingCommand response2, Throwable t2,
                                 String remoteAddr3, RemotingCommand request3, RemotingCommand response3) {

    }

    @Override
    public void doAfterException(String remoteAddr, RemotingCommand request, RemotingCommand response, Throwable t,
                                 String remoteAddr2, RemotingCommand request2, RemotingCommand response2, Throwable t2,
                                 String remoteAddr3, RemotingCommand request3, RemotingCommand response3, Throwable t3) {

    }

    @Override
    public void doAfterException(String remoteAddr, RemotingCommand request, RemotingCommand response, Throwable t,
                                 String remoteAddr2, RemotingCommand request2, RemotingCommand response2, Throwable t2,
                                 String remoteAddr3, RemotingCommand request3, Rem<nl>
        namesrvController = new NamesrvController(nettyServerConfig, remotingServer);
    <|file_separator|><nl>
        return populate(properties, obj);
    <|file_separator|><nl>
        SendResult sendResult = new SendResult();
        sendResult.setSendStatus(SendStatus.FLUSH_DISK_TIMEOUT);

        when(rocketmqProducer.send(any(Message.class), anyLong())).thenThrow(new RemotingException("Test"));
        try {
            producer.send(producer.createBytesMessage("HELLO_TOPIC", new byte[] {'a'}));
            failBecauseExceptionWasNotThrown(OMSRuntimeException.class);
        } catch (Exception e) {
            assertThat(e).hasMessageContaining("Send message to RocketMQ broker failed.");
        }
    <|file_separator|><nl>
        return brokerConfigPath;
    <|file_separator|><nl>
        return code;
    <|file_separator|>class ProxyExceptionCode.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public enum ProxyExceptionCode {
    PROXY_NOT_FOUND,
    PROXY_NOT_VALID,
    PROXY_NOT_AVAILABLE,
    PROXY_NOT_SUPPORTED,
    PROXY_NOT_FOUND_IN_LIST,
    PROXY_NOT_FOUND_IN_LIST_BY_TYPE,
    PROXY_NOT_FOUND_IN_LIST_BY_TYPE_AND_COUNTRY,
    PROXY_NOT_FOUND_IN_LIST_BY_TYPE_AND_COUNTRY_AND_PORT,
    PROXY_NOT_FOUND_IN_LIST_BY_TYPE_AND_COUNTRY_AND_PORT_AND_PROTOCOL,
    PROXY_NOT_FOUND_IN_LIST_BY_TYPE_AND_COUNTRY_AND_PORT_AND_PROTOCOL_AND_COUNTRY,
    PROXY_NOT_FOUND_IN_LIST_BY_TYPE_AND_COUNTRY_AND_PORT_AND_PROTOCOL_AND_COUNTRY_AND_PORT,
    PROXY_NOT_FOUND_IN_LIST_BY_TYPE_AND_COUNTRY_AND_PORT_AND_PROTOCOL_AND_COUNTRY_AND_PORT_AND_PROTOCOL,
    PROXY_NOT_FOUND_IN_LIST_BY_TYPE_AND_COUNTRY_AND_PORT_AND_PROTOCOL_AND_COUNTRY_AND_PORT_AND_PROTOCOL_AND_COUNTRY,
    PROXY_NOT_FOUND_IN_LIST_BY_TYPE_AND_COUNTRY_AND_PORT_AND_PROTOCOL_AND_COUNTRY_AND_PORT_AND_PROTOCOL_AND_COUNTRY_AND_PORT,
    PROXY_NOT_FOUND_IN_LIST_BY_TYPE_AND_COUNTRY_AND_PORT_AND_PROTOCOL_AND_COUNTRY_AND_PORT_AND_PROTOCOL_AND_COUNTRY_<nl>
        if (channel instanceof GrpcClientChannel) {
            return true;
        } else if (channel instanceof RemotingChannel) {
            return true;
        } else if (channel instanceof RemoteChannel) {
            RemoteChannel remoteChannel = (RemoteChannel) channel;
            return remoteChannel.isRemote();
        }
        return false;
    <|file_separator|><nl>
        if (tagsSet == null || tagsSet.isEmpty()) {
            return true;
        }
        if (tags == null || tags.isEmpty()) {
            return false;
        }
        for (String tag : tagsSet) {
            if (tags.contains(tag)) {
                return true;
            }
        }
        return false;
    <|file_separator|><nl>
            if (pne.isTls()) {
                ctx.pipeline().remove(this);
                ctx.pipeline().addFirst(new TlsHandler(ctx.channel(), pne.getTlsConfig()));
            } else {
                super.decode(ctx, in, out);
            }
        <|file_separator|><nl>
        AuthenticationHeader authenticationHeader = AuthenticationHeader.fromMetadata(headers);
        if (authenticationHeader == null) {
            return next.startCall(call, headers);
        }

        validate(authenticationHeader, headers, call.getMessageType());
        return next.startCall(call, headers);
    <|file_separator|><nl>
    <|file_separator|><nl>
        if (instance == null) {
            synchronized (INSTANCE_CREATE_LOCK) {
                if (instance == null) {
                    instance = new ResponseBuilder();
                }
            }
        }
        return instance;
    <|file_separator|><nl>
        try {
            ReceiveMessageResponse response = this.createWriter(ctx, responseObserver).write(request);
            responseObserver.onNext(response);
            responseObserver.onCompleted();
        } catch (Throwable t) {
            responseObserver.onError(t);
        }
    <|file_separator|><nl>
        if (handle.isExpired()) {
            throw EXPIRED_HANDLE_PROXY_EXCEPTION;
        }
    <|file_separator|><nl>
        return receiptHandleMessage;
    <|file_separator|>class BatchAckResult.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class BatchAckResult {

    private final ReceiptHandleMessage receiptHandleMessage;
    private AckResult ackResult;
    private ProxyException proxyException;

    public BatchAckResult(ReceiptHandleMessage receiptHandleMessage,
        AckResult ackResult) {
        this.receiptHandleMessage = receiptHandleMessage;
        this.ackResult = ackResult;
    }

    public BatchAckResult(ReceiptHandleMessage receiptHandleMessage,
        ProxyException proxyException) {
        this.receiptHandleMessage = receiptHandleMessage;
        this.proxyException = proxyException;
    }

    public ReceiptHandleMessage getReceiptHandleMessage() {
        return receiptHandleMessage;
    }

    public AckResult getAckResult() {
        return ackResult;
    }

    public ProxyException getProxyException() {
        return proxyException;
    }
}<|file_separator|>class BatchAckResult.ReceiptHandleMessage.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class ReceiptHandleMessage {

    private final String receiptHandle;

    public ReceiptHandleMessage(String receiptHandle) {
        this.receiptHandle = receiptHandle;
    }

    public String getReceiptHandle() {
        return receiptHandle;
    }
}<|file_separator|>class BatchAckResult.AckResult.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class AckResult {

    private final String messageId;
    private final String receiptHandle;

    public AckResult(String messageId, String receiptHandle) {
        this.messageId = messageId;
        this.receiptHandle = receiptHandle;
    }

    public String getMessageId() {
        return messageId;
    }

    public String getReceiptHandle() {
        return receiptHandle;
    }
}<|file_separator|>class BatchAckResult.ProxyException<nl>
        if (expectedType != actualType) {
            throw new InvalidTopicMessageTypeException();
        }
    <|file_separator|><nl>
        ChannelPipeline pipeline = ch.pipeline();
        pipeline.addLast("http2", http2ProtocolProxyHandler);
        pipeline.addLast("remoting", remotingProtocolHandler);
        return pipeline;
    <|file_separator|><nl>
        return null;
    <|file_separator|><nl>
        if (request instanceof SendMessageRequest) {
            return sendMessage(ctx, request, context);
        } else if (request instanceof SendMessageRequestHeader) {
            return consumerSendMessage(ctx, request, context);
        } else {
            throw new RemotingException("Unsupported request type: " + request.getClass().getName());
        }
    <|file_separator|><nl>
        RemotingChannel remotingChannel = new RemotingChannel(channel, clientId, subscriptionData);
        Map<Channel, RemotingChannel> clientIdChannelMap = this.groupChannelMap.computeIfAbsent(group, k -> new ConcurrentHashMap<>());
        clientIdChannelMap.put(getOrgRawChannel(channel), remotingChannel);
        return remotingChannel;
    }

    public RemotingChannel getProducerChannel(ProxyContext ctx, String group, Channel channel) {
        return getChannel(buildProducerKey(group), channel);
    }

    public RemotingChannel getConsumerChannel(ProxyContext ctx, String group, Channel channel) {
        return getChannel(buildConsumerKey(group), channel);
    <|file_separator|><nl>
        List<AuthorizationContext> contexts = newContexts(request, ctx, context);
        if (contexts.isEmpty()) {
            return;
        }
        AuthorizationContext context = contexts.get(0);
        if (context.isAuthorized()) {
            return;
        }
        if (LOGGER.isDebugEnabled()) {
            LOGGER.debug("Authorization failed for request: " + request);
        }
        throw new AuthorizationException("Authorization failed for request: " + request);
    <|file_separator|><nl>
        if (in.readableBytes() < 2) {
            return;
        }
        int protocol = in.readUnsignedShort();
        for (ProtocolHandler protocolHandler : protocolHandlerList) {
            if (protocolHandler.isProtocolSupported(protocol)) {
                out.add(protocolHandler.getProtocolHandler(ctx, in));
                return;
            }
        }
        out.add(fallbackProtocolHandler.getProtocolHandler(ctx, in));
    <|file_separator|><nl>
                if (future.isSuccess()) {
                    ctx.read();
                } else {
                    future.channel().close();
                }
            <|file_separator|><nl>
            return TopicConfigAndQueueMapping.getTopicConfigAndQueueMapping(topic);
        <|file_separator|><nl>
        SubscriptionGroupConfig groupConfig = brokerController.getSubscriptionGroupConfigManager().selectSubscriptionGroupConfig(group);
        if (groupConfig == null) {
            return SubscriptionGroupConfig.UNSPECIFIED;
        }
        return groupConfig;
    }

    @Override
    public CompletableFuture<User> getUser(ProxyContext ctx, String username) {
        return this.brokerController.getAuthenticationMetadataManager().getUser(username);
    }

    @Override
    public CompletableFuture<Acl> getAcl(ProxyContext ctx, Subject subject) {
        return this.brokerController.getAuthorizationMetadataManager().getAcl(subject);
    }
}

class LocalMetadataService implements MetadataService {
    private final BrokerController brokerController;

    public LocalMetadataService(BrokerController brokerController) {
        this.brokerController = brokerController;
    }

    @Override
    public TopicMessageType getTopicMessageType(ProxyContext ctx, String topic) {
        TopicConfig topicConfig = brokerController.getTopicConfigManager().selectTopicConfig(topic);
        if (topicConfig == null) {
            return TopicMessageType.UNSPECIFIED;
        }
        return topicConfig.getTopicMessageType();
    }

    @Override
    public SubscriptionGroupConfig getSubscriptionGroupConfig(ProxyContext ctx, String group) {
        SubscriptionGroupConfig groupConfig = brokerController.getSubscriptionGroupConfigManager().selectSubscriptionGroupConfig(group);
        if (groupConfig == null) {
            return SubscriptionGroupConfig.UNSPECIFIED;
        }
        return groupConfig;
    <|file_separator|><nl>
        TopicRouteData topicRouteData = new TopicRouteData();
        topicRouteData.setQueueDatas(queueDatas);
        topicRouteData.setBrokerDatas(brokerDatas);
        return topicRouteData;
    }
<|file_separator|><nl>
    <|file_separator|><nl>
        return "HeartbeatSyncerData{" +
            "heartbeatType=" + heartbeatType +
            ", clientId='" + clientId + '\'' +
            ", language=" + language +
            ", version=" + version +
            ", lastUpdateTimestamp=" + lastUpdateTimestamp +
            ", subscriptionDataSet=" + subscriptionDataSet +
            ", group='" + group + '\'' +
            ", consumeType=" + consumeType +
            ", messageModel=" + messageModel +
            ", consumeFromWhere=" + consumeFromWhere +
            ", localProxyId='" + localProxyId + '\'' +
            ", channelData='" + channelData + '\'' +
            '}';
    <|file_separator|><nl>
        int times = 0;
        while (this.retryPolicy.nextDelayDuration() != null) {
            times++;
        }
        Assert.assertEquals(times, 3);
    <|file_separator|><nl>
        SubscriptionData subscriptionData = FilterAPI.buildSubscriptionData("tagA", "tagB");
        assertThat(subscriptionData.getTagsSet().contains("tagA")).isTrue();
        assertThat(subscriptionData.getTagsSet().contains("tagB")).isTrue();
    <|file_separator|><nl>
        assertThrows(GrpcProxyException.class, () -> messingActivity.validateConsumer(Resource.newBuilder().build()));
        assertThrows(GrpcProxyException.class, () -> messingActivity.validateConsumer(Resource.newBuilder().setName(ConsumerValidator.RMQ_SYS_TRACE_CONSUMER).build()));
        assertThrows(GrpcProxyException.class, () -> messingActivity.validateConsumer(Resource.newBuilder().setName("@").build()));
        assertThrows(GrpcProxyException.class, () -> messingActivity.validateConsumer(Resource.newBuilder().setName(createString(128)).build()));
        messingActivity.validateConsumer(Resource.newBuilder().setName(createString(127)).build());
    }<|file_separator|><nl>
        this.grpcClientChannel.setChannelExtendAttribute("key", "value");
        assertEquals("value", this.grpcClientChannel.getChannelExtendAttribute("key"));
    <|file_separator|><nl>
        return new ReceiptHandle(messageExt);
    }

    protected static ReceiptHandle create(MessageExt messageExt, long commitLogOffset) {
        return new ReceiptHandle(messageExt, commitLogOffset);
    }

    protected static ReceiptHandle create(MessageExt messageExt, long commitLogOffset, long invisibleTime) {
        return new ReceiptHandle(messageExt, commitLogOffset, invisibleTime);
    }

    protected static ReceiptHandle create(MessageExt messageExt, long commitLogOffset, long invisibleTime, long popTime) {
        return new ReceiptHandle(messageExt, commitLogOffset, invisibleTime, popTime);
    }

    protected static ReceiptHandle create(MessageExt messageExt, long commitLogOffset, long invisibleTime, long popTime,
        int reviveQid, String topic, String brokerName, int queueId, long queueOffset) {
        return new ReceiptHandle(messageExt, commitLogOffset, invisibleTime, popTime, reviveQid, topic, brokerName, queueId, queueOffset);
    }

    protected static ReceiptHandle create(MessageExt messageExt, long commitLogOffset, long invisibleTime, long popTime,
        int reviveQid, String topic, String brokerName, int queueId, long queueOffset, String tags) {
        return new ReceiptHandle(messageExt, commitLogOffset, invisibleTime, popTime, reviveQid, topic, brokerName, queueId, queueOffset, tags);
    <|file_separator|><nl>
        super.before();
        topicRouteService = new TopicRouteService();
        mqClientAPIFactory = new MQClientAPIFactory();
        mqClientAPIExt = new MQClientAPIExt();
    }

    @After
    public void after() throws Throwable {
        super.after();
    <|file_separator|><nl>
        MockProxyChannel channel = new MockProxyChannel(null, null, null, null);
        channel.writeAndFlush(null);
    }
<|file_separator|><nl>
        String txId = MessageClientIDSetter.createUniqID();
        this.transactionDataManager.addTransactionData(PRODUCER_GROUP, txId, createTransactionData());
        assertEquals(1, this.transactionDataManager.pollTransactionData(PRODUCER_GROUP, txId).size());
    <|file_separator|><nl>
        for (Class<? extends CommandCustomHeader> clazz : this.requestHeaderMap.values()) {
            this.registerHeader(clazz);
        }
    <|file_separator|><nl>
        this.brokerMemberGroup = brokerMemberGroup;
    <|file_separator|>class GetBrokerMemberGroupResponse.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class GetBrokerMemberGroupResponse extends RemotingCommand {
    private GetBrokerMemberGroupResponseBody body;

    public GetBrokerMemberGroupResponseBody getBody() {
        return body;
    }

    public void setBody(final GetBrokerMemberGroupResponseBody body) {
        this.body = body;
    }
}<|file_separator|>class GetBrokerMemberGroupRequest.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class GetBrokerMemberGroupRequest extends RemotingCommand {
    private String brokerId;
    private String groupId;

    public String getBrokerId() {
        return brokerId;
    }

    public void setBrokerId(final String brokerId) {
        this.brokerId = brokerId;
    }

    public String getGroupId() {
        return groupId;
    }

    public void setGroupId(final String groupId) {
        this.groupId = groupId;
    }
}<|file_separator|><nl>
        this.messageRequestModeMap = messageRequestModeMap;
    <|file_separator|><nl>
        this.dataVersion = dataVersion;
    <|file_separator|><nl>
        return "UnlockBatchRequestBody{" +
                "consumerGroup='" + consumerGroup + '\'' +
                ", clientId='" + clientId + '\'' +
                ", onlyThisBroker=" + onlyThisBroker +
                ", mqSet=" + mqSet +
                '}';
    <|file_separator|><nl>
        this.invisibleTime = invisibleTime;
    <|file_separator|><nl>
        return clientAddr;
    <|file_separator|><nl>
        if (cluster == null) {
            throw new RemotingCommandException("cluster is required");
        }
    <|file_separator|><nl>
        return username;
    <|file_separator|><nl>
        return hasMsg;
    <|file_separator|><nl>
        this.consumerGroup = consumerGroup;
    <|file_separator|><nl>
        return index;
    <|file_separator|><nl>
        this.timestamp = timestamp;
    <|file_separator|><nl>
        this.consumerGroup = consumerGroup;
    <|file_separator|><nl>
        super.checkFields();
        if (this.getBatchId() == null) {
            throw new RemotingCommandException("invalid field: batchId");
        }
        if (this.getBatchId() == null) {
            throw new RemotingCommandException("invalid field: batchId");
        }
    <|file_separator|><nl>
        // TODO Auto-generated method stub
        
    <|file_separator|><nl>
        return newSyncStateSetEpoch;
    <|file_separator|>class AlterSyncStateSetRequestHeader implements CommandCustomHeader {
    private int newSyncStateSetEpoch;

    public AlterSyncStateSetRequestHeader() {
    }

    public int getNewSyncStateSetEpoch() {
        return newSyncStateSetEpoch;
    }

    public void setNewSyncStateSetEpoch(int newSyncStateSetEpoch) {
        this.newSyncStateSetEpoch = newSyncStateSetEpoch;
    }

    @Override
    public String toString() {
        return "AlterSyncStateSetRequestHeader{" +
            "newSyncStateSetEpoch=" + newSyncStateSetEpoch +
            '}';
    }

    @Override
    public void checkFields() throws RemotingCommandException {
    }
}<|file_separator|>class AlterSyncStateSetRequest implements CommandCustomHeader {
    private int newSyncStateSetEpoch;

    public AlterSyncStateSetRequest() {
    }

    public int getNewSyncStateSetEpoch() {
        return newSyncStateSetEpoch;
    }

    public void setNewSyncStateSetEpoch(int newSyncStateSetEpoch) {
        this.newSyncStateSetEpoch = newSyncStateSetEpoch;
    }

    @Override
    public String toString() {
        return "AlterSyncStateSetRequest{" +
            "newSyncStateSetEpoch=" + newSyncStateSetEpoch +
            '}';
    }

    @Override
    public void checkFields() throws RemotingCommandException {
    }
}<|file_separator|><nl>
        this.registerCheckCode = registerCheckCode;
    <|file_separator|><nl>
        this.topic = topic;
    <|file_separator|><nl>
        this.brokerName = brokerName;
    <|file_separator|><nl>
        if (brokerAddrs == null || brokerAddrs.isEmpty()) {
            return null;
        }
        if (enableActingMaster) {
            return brokerAddrs.get(0);
        }
        return brokerAddrs.get(random.nextInt(brokerAddrs.size()));
    <|file_separator|><nl>
        return new HashCodeBuilder()
                .append(topic)
                .append(group)
                .append(readable)
                .toHashCode();
    <|file_separator|><nl>
        return null;<|file_separator|><nl>
        nettyRemotingServer.handleHAProxyTLV(channel, attribute);
    <|file_separator|><nl>
        DataVersion dataVersion = new DataVersion();
        DataVersion other = new DataVersion();
        Assert.assertTrue(dataVersion.equals(other));
    }

    @Test
    public void testEquals_falseWhenTimestampDifferent() {
        DataVersion dataVersion = new DataVersion();
        DataVersion other = new DataVersion();
        other.setTimestamp(dataVersion.getTimestamp());
        Assert.assertFalse(dataVersion.equals(other));
    <|file_separator|><nl>
        HashSet<String> groups = createUniqueNewSet();
        GroupList groupList = new GroupList(groups);
        assertEquals(groups, groupList.getGroups());
    <|file_separator|><nl>
        assertEquals(RequestType.GET, RequestType.valueOf("GET"));
    <|file_separator|><nl>
        String json = "[{\"name\":\"test\",\"value\":1},{\"name\":\"test\",\"value\":2}]";
        ConsumeStatsList list = ConsumeStatsList.fromJson(json);
        assertEquals(2, list.size());
    <|file_separator|><nl>
        KVTable kvTable = KVTable.fromJson(KVTable.class, "kvtable.json");
        System.out.println(kvTable);
    <|file_separator|><nl>
        SubscriptionGroupWrapper subscriptionGroupWrapper = SubscriptionGroupWrapper.fromJson("{\"subscriptionGroup\":{\"id\":1,\"name\":\"test\",\"description\":\"test\",\"subscriptionType\":\"test\",\"subscriptionStatus\":\"test\",\"subscriptionStatusDate\":\"test\",\"subscriptionStatusReason\":\"test\",\"subscriptionStatusReasonDate\":\"test\",\"subscriptionStatusReasonDescription\":\"test\",\"subscriptionStatusReasonDescriptionDate\":\"test\",\"subscriptionStatusReasonDescriptionDescription\":\"test\",\"subscriptionStatusReasonDescriptionDateDescription\":\"test\",\"subscriptionStatusReasonDescriptionDescriptionDate\":\"test\",\"subscriptionStatusReasonDescriptionDescriptionDateDescription\":\"test\",\"subscriptionStatusReasonDescriptionDescriptionDateDescriptionDate\":\"test\",\"subscriptionStatusReasonDescriptionDescriptionDateDescriptionDateDescription\":\"test\",\"subscriptionStatusReasonDescriptionDescriptionDateDescriptionDateDescriptionDate\":\"test\",\"subscriptionStatusReasonDescriptionDescriptionDateDescriptionDateDescriptionDateDescription\":\"test\",\"subscriptionStatusReasonDescriptionDescriptionDateDescriptionDateDescriptionDateDescriptionDateDescription\":\"test\"}}");
        Assert.assertEquals(1, subscriptionGroupWrapper.getSubscriptionGroup().getId());
    <|file_separator|><nl>
        header.setTopic(topic);
        header.setQueueId(queueId);
        byte[] bytes = header.encode();
        SendMessageRequestHeaderV2 header2 = new SendMessageRequestHeaderV2();
        header2.decode(bytes);
        assertEquals(topic, header2.getTopic());
        assertEquals(queueId, header2.getQueueId());
    <|file_separator|><nl>
        TopicRouteData topicRouteData = new TopicRouteData();
        TopicRouteData topicRouteDataClone = topicRouteData.clone();
        assertThat(topicRouteData).isEqualTo(topicRouteDataClone);
    <|file_separator|><nl>
        while (!isInterrupted()) {
            try {
                Thread.sleep(WATCH_INTERVAL);
            } catch (InterruptedException e) {
                log.info("FileWatchService interrupted");
                return;
            }
            for (Map.Entry<String, String> entry : currentHash.entrySet()) {
                String filePath = entry.getKey();
                String currentHash = md5Digest(filePath);
                if (!currentHash.equals(entry.getValue())) {
                    log.info("File {} changed", filePath);
                    listener.onChanged(filePath);
                    currentHash.put(filePath, currentHash);
                }
            }
        }
    <|file_separator|><nl>
        return nextReputFromOffset;
    <|file_separator|><nl>
        Lock lock = this.lockList.get((topicQueueKey.hashCode() & 0x7fffffff) % this.size);
        lock.unlock();
    <|file_separator|><nl>
        boolean needNotify = false;
        for (Map.Entry<Long, AtomicBoolean> entry : this.waitingThreadTable.entrySet()) {
            if (entry.getValue().compareAndSet(false, true)) {
                needNotify = true;
            }
        }
        if (needNotify) {
            synchronized (this) {
                this.notifyAll();
            }
        }
    <|file_separator|><nl>
        this.byteBuffer.putLong(beginTimestampIndex, this.beginTimestamp.get());
        this.byteBuffer.putLong(endTimestampIndex, this.endTimestamp.get());
        this.byteBuffer.putLong(beginPhyoffsetIndex, this.beginPhyOffset.get());
        this.byteBuffer.putLong(endPhyoffsetIndex, this.endPhyOffset.get());
        this.byteBuffer.putInt(hashSlotcountIndex, this.hashSlotCount.get());
        this.byteBuffer.putInt(indexCountIndex, this.indexCount.get());
    <|file_separator|><nl>
        return phyOffsets;
    <|file_separator|><nl>
        this.cptService.dispatch(request);
    <|file_separator|><nl>
        this.decode(RemotingSerializable.fromJson(jsonString));
    }

    @Override
    public void decode(RemotingSerializable remotingSerializable) {
        if (remotingSerializable instanceof CompactionPositionMgr) {
            CompactionPositionMgr compactionPositionMgr = (CompactionPositionMgr) remotingSerializable;
            this.queueOffsetMap = compactionPositionMgr.queueOffsetMap;
        }
    <|file_separator|><nl>
        return tagsCode != 0 && tagsCode != -1;
    }

    public ByteBuffer getNativeBuffer() {
        return nativeBuffer;
    <|file_separator|><nl>
        return new ColumnFamilyOptions().
                setCompressionType(CompressionType.LZ4_COMPRESSION).
                setBottommostCompressionType(CompressionType.ZSTD_COMPRESSION);
    <|file_separator|><nl>
        StoreCheckpoint storeCheckpoint = new StoreCheckpoint();
        storeCheckpoint.write("key", "value");
        String value = storeCheckpoint.read("key");
        Assert.assertEquals("value", value);
    <|file_separator|><nl>
        MessageExtBatch messageExtBatch = new MessageExtBatch();
        messageExtBatch.setTopic("StoreTest");
        messageExtBatch.setTags("TAG1");
        messageExtBatch.setKeys("Hello");
        messageExtBatch.setQueueId(Math.abs(queueId.getAndIncrement()) % QUEUE_TOTAL);
        messageExtBatch.setSysFlag(0);

        messageExtBatch.setBornTimestamp(System.currentTimeMillis());
        messageExtBatch.setBornHost(bornHost);
        messageExtBatch.setStoreHost(storeHost);

        List<Message> messageList = new ArrayList<>(size);
        for (int i = 0; i < size; i++) {
            messageList.add(buildIPv6HostMessage());
        }

        messageExtBatch.setBody(MessageDecoder.encodeMessages(messageList));

        return messageExtBatch;
    <|file_separator|><nl>
        return msgBodys.getFirstData();
    }

    public Object getFirstOriginMsg() {
        return originMsgs.getFirstData();
    }

    public Object getFirstErrorMsg() {
        return errorMsgs.getFirstData();
    }

    public Object getFirstMsgRT() {
        return msgRTs.getFirstData();
    }

    public Object getLastMsg() {
        return msgBodys.getLastData();
    }

    public Object getLastOriginMsg() {
        return originMsgs.getLastData();
    }

    public Object getLastErrorMsg() {
        return errorMsgs.getLastData();
    }

    public Object getLastMsgRT() {
        return msgRTs.getLastData();
    }

    public Object getMsgBodyByIndex(int index) {
        return msgBodys.getDataByIndex(index);
    }

    public Object getOriginMsgByIndex(int index) {
        return originMsgs.getDataByIndex(index);
    }

    public Object getErrorMsgByIndex(int index) {
        return errorMsgs.getDataByIndex(index);
    }

    public Object getMsgRTByIndex(int index) {
        return msgRTs.getDataByIndex(index);
    }

    public int getMsgBodySize() {
        return msgBodys.getDataSize();
    }

    public int getOriginMsgSize() {
        return originMsgs.getDataSize();
    }

    public int getErrorMsgSize() {
        return errorMsgs.getDataSize();
    }

    public int getMsgRTSize() {
        return msgRTs.getDataSize();
    }

    public Object getMsgBodyByMsgId(String msgId) {
        return msgBodys.getDataByMsgId(msgId);
    }

    public Object getOrigin<nl>
        List<Object> msgs = new ArrayList<Object>();
        for (String tag : tags) {
            msgs.addAll(MQMessageFactory.getMessageBody(rmqMsgs.get(tag)));
        }

        return msgs;
    <|file_separator|><nl>
        return "ResultWrapper{" +
                "sendResult=" + sendResult +
                ", msgId='" + msgId + '\'' +
                ", sendException=" + sendException +
                ", brokerIp='" + brokerIp + '\'' +
                '}';
    <|file_separator|><nl>
        List<Map.Entry<K, V>> list = new LinkedList<>(map.entrySet());
        Collections.sort(list, new Comparator<Map.Entry<K, V>>() {
            @Override
            public int compare(Map.Entry<K, V> o1, Map.Entry<K, V> o2) {
                return o2.getValue().compareTo(o1.getValue());
            }
        });
        Map<K, V> result = new LinkedHashMap<>();
        for (Map.Entry<K, V> entry : list) {
            result.put(entry.getKey(), entry.getValue());
        }
        return result;
    <|file_separator|><nl>
        super.setUp();
        producer = new RMQNormalProducer(NAMESRV_ADDR);
        topic = "order";
    <|file_separator|><nl>
        int msgSize = 150;
        RMQNormalConsumer consumer1 = getConsumer(NAMESRV_ADDR, topic, "*", new RMQNormalListener());
        RMQNormalConsumer consumer2 = getConsumer(NAMESRV_ADDR, topic, "*", new RMQNormalListener());

        MQAsyncProducer asyncDefaultMQProducer = new MQAsyncProducer(producer, msgSize, 100);
        asyncDefaultMQProducer.start();
        TestUtils.waitForSeconds(WAIT_TIME);

        MQWait.waitConsumeAll(CONSUME_TIME, producer.getAllMsgBody(), consumer1.getListener(),
            consumer2.getListener());

        boolean recvAll = MQWait.waitConsumeAll(CONSUME_TIME, producer.getAllMsgBody(),
            consumer1.getListener(), consumer2.getListener());
        assertThat(recvAll).isEqualTo(true);
    }

    @Test
    public void testAddOneConsumerAndCrashAfterWhileWithDelay() {
        int msgSize = 150;
        RMQNormalConsumer consumer1 = getConsumer(NAMESRV_ADDR, topic, "*", new RMQNormalListener());

        MQAsyncProducer asyncDefaultMQProducer = new MQAsyncProducer(producer, msgSize, 100);
        asyncDefaultMQProducer.start();
        TestUtils.waitForSeconds(WAIT_TIME);

        RMQNormalConsumer consumer2 = getConsumer(NAMESRV_ADDR, consumer1.getConsumerGroup(), topic,
            "*", new RMQNormalListener());
        TestUtils.waitForSeconds(WAIT_TIME);
        consumer2.shutdown();

        asyncDefaultMQProducer.waitSendAll(WAIT_TIME * 6);

        MQWait.waitConsumeAll(CONSUME_TIME, producer.getAllMsgBody(), consumer1.getListener(),
            consumer2.get<nl>
        for (int i = 0; i < 100; i++) {
            String msg = "test message " + i;
            logger.info(String.format("send message[%s]!", msg));
            producer.send(msg);
        }
    <|file_separator|><nl>
        String msg = "test";
        String key = "key";
        producer.send(msg, key, new MessageSelector() {
            @Override
            public String select(String key) {
                return key.substring(0, 1);
            }
        });
    <|file_separator|>class AsyncSendWithMessageQueueSelector.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>package com.alibaba.rocketmq.test.async;

import com.alibaba.rocketmq.client.producer.DefaultMQProducer;
import com.alibaba.rocketmq.client.producer.MessageSelector;
import com.alibaba.rocketmq.client.producer.SendCallback;
import com.alibaba.rocketmq.client.producer.SendResult;
import com.alibaba.rocketmq.common.message.Message;
import com.alibaba.rocketmq.test.BaseConf;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

public class AsyncSendWithMessageQueueSelector extends BaseConf {
    private static Logger logger = LoggerFactory.getLogger(AsyncSendWithMessageQueueSelector.class);
    private RMQAsyncSendProducer producer = null;
    private String topic = null;

    @Before
    public void setUp() {
        topic = initTopic();
        logger.info(String.format("user topic[%s]!", topic));
        producer = getAsyncProducer(NAMESRV_ADDR, topic);
    }

    @After
    public void tearDown() {
        super.shutdown();
    }

    @Test
    public void testSendWithSelector() {
        String msg = "test";
<nl>
        RMQNormalProducer producer1 = getProducer(NAMESRV_ADDR, topic);
        assertThat(producer1.isStartSuccess()).isEqualTo(true);
        RMQNormalProducer producer2 = getProducer(NAMESRV_ADDR, topic,
            producer1.getProducerGroupName());
        assertThat(producer2.isStartSuccess()).isEqualTo(false);
    }

    /**
     * @since version3.4.6
     */
    @Test
    public void testTwoProducerSameInstanceName() {
        RMQNormalProducer producer1 = getProducer(NAMESRV_ADDR, topic);
        assertThat(producer1.isStartSuccess()).isEqualTo(true);
        RMQNormalProducer producer2 = getProducer(NAMESRV_ADDR, topic,
            producer1.getProducerInstanceName());
        assertThat(producer2.isStartSuccess()).isEqualTo(false);
    }

    /**
     * @since version3.4.6
     */
    @Test
    public void testTwoProducerSameInstanceNameAndGroup() {
        RMQNormalProducer producer1 = getProducer(NAMESRV_ADDR, topic);
        assertThat(producer1.isStartSuccess()).isEqualTo(true);
        RMQNormalProducer producer2 = getProducer(NAMESRV_ADDR, topic,
            producer1.getProducerInstanceName(), producer1.getProducerGroupName());
        assertThat(producer2.isStartSuccess()).isEqualTo(false);
    <|file_separator|><nl>
        super.setUp();
        producer = new RMQAsyncSendProducer(NAMESRV_ADDR, BROKER1_NAME, BROKER2_NAME);
        topic = "test";
        producer.setTopic(topic);
        producer.setSendFail(sendFail);
    <|file_separator|><nl>
        producer = new RMQNormalProducer(MQMessageFactory.getMessageQueues(MQMessageFactory.getQueue("test")));
        consumer = new RMQOrderListener(MQMessageFactory.getMessageQueues(MQMessageFactory.getQueue("test")));
        topic = MQMessageFactory.getQueue("test").getTopic();
        consumer.setTopic(topic);
        consumer.setConsumeTime(CONSUME_TIME);
        consumer.setListener(this);
        consumer.start();
    <|file_separator|><nl>
        removeSlaveBroker(1, brokerContainer1, master3With3Replicas);
        createAndAddSlave(1, brokerContainer1, master3With3Replicas);

        await().atMost(100, TimeUnit.SECONDS)
            .until(() -> ((DefaultMessageStore) master3With3Replicas.getMessageStore()).getHaService().inSyncReplicasNums(0) == 3);

        Thread.sleep(1000 * 101);
    <|file_separator|><nl>
        System.setProperty("sendThreadNum", "1");
        System.setProperty("pullConsumerNum", "1");
        System.setProperty("consumerThreadNum", "1");
        BenchLmqStore.defaultMQProducer = mock(DefaultMQProducer.class);
        SendResult sendResult = new SendResult();
        when(BenchLmqStore.defaultMQProducer.send(any(Message.class))).thenReturn(sendResult);
        BenchLmqStore.doSend();
        Thread.sleep(100L);
        //verify(BenchLmqStore.defaultMQProducer, atLeastOnce()).send(any(Message.class));
        BenchLmqStore.defaultMQPullConsumers = new DefaultMQPullConsumer[1];
        BenchLmqStore.defaultMQPullConsumers[0] = mock(DefaultMQPullConsumer.class);
        BenchLmqStore.doPull(new ConcurrentHashMap<>(), new MessageQueue(), 1L);
        verify(BenchLmqStore.defaultMQPullConsumers[0], atLeastOnce()).pullBlockIfNotFound(any(MessageQueue.class), anyString(), anyLong(), anyInt(), any(
            PullCallback.class));
    <|file_separator|><nl>
    <|file_separator|><nl>
        String message = "Hello TLS";
        producer.send(message);
        String receivedMessage = consumer.receive();
        Assert.assertEquals(message, receivedMessage);
    <|file_separator|><nl>
        return read(new byte[1], 0, 1);
    <|file_separator|><nl>
        String filePath = MessageStoreUtil.toFilePath(queue);
        FlatCommitLogFile flatFile = flatFileFactory.createFlatFileForCommitLog(filePath);

        // append some messages
        for (int i = 0; i < 10; i++) {
            ByteBuffer byteBuffer = MessageFormatUtilTest.buildMockedMessageBuffer();
            byteBuffer.putLong(MessageFormatUtil.QUEUE_OFFSET_POSITION, i);
            Assert.assertEquals(AppendResult.SUCCESS, flatFile.append(byteBuffer, 1L));
        }
        Assert.assertEquals(10L, flatFile.getMinOffsetFromFile());
        Assert.assertEquals(10L, flatFile.getMinOffsetFromFileAsync().join().longValue());

        // try rolling file
        Assert.assertEquals(10L, flatFile.tryRollingFile());
        Assert.assertEquals(10L, flatFile.getMinOffsetFromFile());
        Assert.assertEquals(10L, flatFile.getMinOffsetFromFileAsync().join().longValue());
    <|file_separator|><nl>
        return "BrokerOperatorResult{" +
                "successList=" + successList +
                ", failureList=" + failureList +
                '}';
    <|file_separator|><nl>
        this.exceptionDesc = exceptionDesc;
    <|file_separator|><nl>
        return new AdminToolResult(true, AdminToolsResultCodeEnum.SUCCESS.getCode(), null, data);
    <|file_separator|><nl>
        String fromBroker = commandLine.getOptionValue("fromBroker");
        String toBroker = commandLine.getOptionValue("toBroker");
        String usernames = commandLine.getOptionValue("usernames");

        if (usernames == null) {
            usernames = "all";
        }

        if (usernames.equals("all")) {
            usernames = "all";
        } else {
            usernames = usernames.split(",")[0];
        }

        if (usernames.equals("all")) {
            usernames = "all";
        } else {
            usernames = usernames.split(",")[0];
        }

        if (usernames.equals("all")) {
            usernames = "all";
        } else {
            usernames = usernames.split(",")[0];
        }

        if (usernames.equals("all")) {
            usernames = "all";
        } else {
            usernames = usernames.split(",")[0];
        }

        if (usernames.equals("all")) {
            usernames = "all";
        } else {
            usernames = usernames.split(",")[0];
        }

        if (usernames.equals("all")) {
            usernames = "all";
        } else {
            usernames = usernames.split(",")[0];
        }

        if (usernames.equals("all")) {
            usernames = "all";
        } else {
            usernames = usernames.split(",")[0];
        }

        if (usernames.equals("all")) {
            usernames = "all";
        } else {
            usernames = usernames.split(",")[0];
        }

        if (usernames.equals("all")) {
            user<nl>
        options.addOption(Option.builder("u")
            .longOpt("username")
            .desc("The username of user.")
            .hasArg()
            .argName("username")
            .build());
        options.addOption(Option.builder("b")
            .longOpt("broker")
            .desc("The broker address of cluster.")
            .hasArg()
            .argName("broker")
            .build());
        options.addOption(Option.builder("c")
            .longOpt("cluster")
            .desc("The cluster name of cluster.")
            .hasArg()
            .argName("cluster")
            .build());
        return options;
    <|file_separator|><nl>
        String brokerAddr = commandLine.getOptionValue("brokerAddr");
        String clusterName = commandLine.getOptionValue("clusterName");

        if (brokerAddr == null && clusterName == null) {
            throw new SubCommandException("Please specify brokerAddr or clusterName");
        }

        if (brokerAddr != null) {
            getAndPrint(defaultMQAdminExt, "Broker[" + brokerAddr + "] config: ", brokerAddr);
        }

        if (clusterName != null) {
            getAndPrint(defaultMQAdminExt, "Cluster[" + clusterName + "] config: ", clusterName);
        }
    <|file_separator|><nl>
        options.addOption("b", "brokerAddr", true, "Broker address");
        options.addOption("o", "masterFlushOffset", true, "Master flush offset");
        return options;
    <|file_separator|><nl>
        String groupName = commandLine.getOptionValue("groupName");
        String clusterName = getClusterName(groupName,
            rpcHook.getClusterAddrTable());
        if (clusterName == null) {
            throw new SubCommandException("No such cluster name");
        }
        String config = rpcHook.getConsumerConfig(groupName, clusterName);
        System.out.println(config);
    <|file_separator|><nl>
        String brokerContainerAddr = commandLine.getOptionValue("brokerContainerAddr");
        String brokerConfigPath = commandLine.getOptionValue("brokerConfigPath");
        String brokerName = commandLine.getOptionValue("brokerName");
        String brokerType = commandLine.getOptionValue("brokerType");
        String brokerVersion = commandLine.getOptionValue("brokerVersion");
        String brokerConfig = commandLine.getOptionValue("brokerConfig");
        String brokerConfigType = commandLine.getOptionValue("brokerConfigType");
        String brokerConfigVersion = commandLine.getOptionValue("brokerConfigVersion");
        String brokerConfigContent = commandLine.getOptionValue("brokerConfigContent");
        String brokerConfigContentVersion = commandLine.getOptionValue("brokerConfigContentVersion");
        String brokerConfigContentFormat = commandLine.getOptionValue("brokerConfigContentFormat");
        String brokerConfigContentEncoding = commandLine.getOptionValue("brokerConfigContentEncoding");
        String brokerConfigContentHash = commandLine.getOptionValue("brokerConfigContentHash");
        String brokerConfigContentHashAlgorithm = commandLine.getOptionValue("brokerConfigContentHashAlgorithm");
        String brokerConfigContentHashAlgorithmVersion = commandLine.getOptionValue("brokerConfigContentHashAlgorithmVersion");
        String brokerConfigContentHashAlgorithmVersionHash = commandLine.getOptionValue("brokerConfigContentHashAlgorithmVersionHash");
        String brokerConfigContentHashAlgorithmVersionHashAlgorithm = commandLine.getOptionValue("brokerConfigContentHashAlgorithmVersionHashAlgorithm");
        String brokerConfigContentHashAlgorithmVersionHashAlgorithmVersion = commandLine.getOptionValue("brokerConfigContentHashAlgorithmVersionHashAlgorithmVersion");
        String brokerConfigContentHashAlgorithmVersionHashAlgorithmVersionHash = commandLine.getOptionValue("brokerConfigContentHashAlgorithmVersionHashAlgorithmVersionHash");
        String brokerConfigContentHashAlgorithmVersionHashAlgorithmVersionHashAlgorithm = commandLine.getOptionValue("brokerConfig<nl>
        String controllerAddress = commandLine.getOptionValue('a');
        String clusterName = commandLine.getOptionValue('c');
        String brokerName = commandLine.getOptionValue('b');

        List<String> brokerNames = new ArrayList<>();
        if (brokerName != null && !brokerName.trim().equals("")) {
            brokerNames.add(brokerName);
        } else {
            brokerNames = defaultMQAdminExt.getBrokerNames(controllerAddress, clusterName);
        }

        printData(controllerAddress, brokerNames, defaultMQAdminExt);
    <|file_separator|><nl>
        String fileName = options.getOptionValue("file");
        if (fileName == null) {
            throw new SubCommandException("file is required");
        }

        // TODO: implement
    <|file_separator|><nl>
        String topic = commandLine.getOptionValue("topic");
        String brokerName = commandLine.getOptionValue("brokerName");
        String queueId = commandLine.getOptionValue("queueId");
        String offset = commandLine.getOptionValue("offset");
        String bodyFormat = commandLine.getOptionValue("bodyFormat");
        if (bodyFormat == null) {
            bodyFormat = "json";
        }
        if (bodyFormat.equals("json")) {
            rpcHook.queryMsgByOffset(topic, brokerName, queueId, offset);
        } else {
            rpcHook.queryMsgByOffset(topic, brokerName, queueId, offset);
        }
    <|file_separator|>class QueryMsgByOffsetSubCommand.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>package com.example.demo;

import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.Option;
import org.apache.commons.cli.Options;
import org.apache.commons.cli.ParseException;

public class QueryMsgByOffsetSubCommand implements SubCommand {

    @Override
    public String commandName() {
        return "queryMsgByOffset";
    }

    @Override
    public String commandDesc() {
        return "Query Message by offset.";
    }

    @Override
    public Options buildCommandlineOptions(Options options) {
        Option opt = new Option("t", "topic", true, "topic name");
        opt.setRequired(true);
        options.addOption(opt);

        opt = new Option("b", "brokerName", true, "Broker Name");
        opt.setRequired(true);
        options.addOption(opt);

        opt = new Option("i", "queueId", true, "Queue Id");
        opt.setRequired<nl>
        // TODO
    <|file_separator|><nl>
        Order order = new Order();
        order.setConf("CONF");
        Order order2 = new Order();
        order2.setConf("CONF");
        Order order3 = new Order();
        order3.setConf("CONF");
        Order order4 = new Order();
        order4.setConf("CONF");
        Order order5 = new Order();
        order5.setConf("CONF");
        Order order6 = new Order();
        order6.setConf("CONF");
        Order order7 = new Order();
        order7.setConf("CONF");
        Order order8 = new Order();
        order8.setConf("CONF");
        Order order9 = new Order();
        order9.setConf("CONF");
        Order order10 = new Order();
        order10.setConf("CONF");
        Order order11 = new Order();
        order11.setConf("CONF");
        Order order12 = new Order();
        order12.setConf("CONF");
        Order order13 = new Order();
        order13.setConf("CONF");
        Order order14 = new Order();
        order14.setConf("CONF");
        Order order15 = new Order();
        order15.setConf("CONF");
        Order order16 = new Order();
        order16.setConf("CONF");
        Order order17 = new Order();
        order17.setConf("CONF");
        Order order18 = new Order();
        order18.setConf("CONF");
        Order order19 = new Order();
        order19.setConf("CONF");
        Order order20 = new Order();
        order20.setConf("CONF");<nl>
    Map<String, String> configurationFromItems = new HashMap<>();
    configurationFromItems = generateMapFromItems(namespaceItems, configurationFromItems);
    configurationFromItems = generateMapFromItems(namespace.getItems(), configurationFromItems);
    return configurationFromItems;
  <|file_separator|><nl>
    return appNamespaceService.create(appNamespace, silentCreation);
  }

  @GetMapping("/apps/{appId}/appnamespaces/{namespaceName:.+}")
  public AppNamespaceDTO get(@PathVariable("appId") String appId, @PathVariable("namespaceName") String namespaceName) {
    AppNamespace entity = appNamespaceService.findOne(appId, namespaceName);
    if (entity == null) {
      throw BadRequestException.appNamespaceNotExists(appId, namespaceName);
    }
    return BeanUtils.transform(AppNamespaceDTO.class, entity);
  }

  @PutMapping("/apps/{appId}/appnamespaces/{namespaceName:.+}")
  public AppNamespaceDTO update(@PathVariable("appId") String appId, @PathVariable("namespaceName") String namespaceName,
                                @RequestBody AppNamespaceDTO appNamespace) {
    AppNamespace entity = appNamespaceService.findOne(appId, namespaceName);
    if (entity == null) {
      throw BadRequestException.appNamespaceNotExists(appId, namespaceName);
    }
    return appNamespaceService.update(entity, appNamespace);
  <|file_separator|><nl>
    return "Hello World";
  <|file_separator|><nl>
    itemSetService.create(appId, clusterName, namespaceName, changeSet);
    return ResponseEntity.noContent().build();
  <|file_separator|><nl>
    ServerConfig serverConfig = new ServerConfig();
    serverConfig.setKey("name");
    serverConfig.setValue("kl");
    restTemplate.postForObject(url("/server/config/create-or-update-config"), serverConfig, ServerConfig.class);
  <|file_separator|><nl>
    http.authorizeRequests()
      .antMatchers("/").permitAll()
      .antMatchers("/admin/**").hasRole("ADMIN")
      .anyRequest().authenticated()
      .and()
      .formLogin()
      .loginPage("/login")
      .permitAll()
      .and()
      .logout()
      .permitAll();
  <|file_separator|><nl>
    return fieldNewValue;
  <|file_separator|><nl>
    return beanDefinition;
  <|file_separator|><nl>
    this.followsFromSpanId = followsFromSpanId;
  <|file_separator|><nl>
    api.create(event.getAuditLogDataInfluence());
  <|file_separator|><nl>
    manager.activate();
  <|file_separator|><nl>
    return new ApolloAuditLogDataInfluenceEventListener(api);
  <|file_separator|><nl>
    this.dataChangeLastModifiedTime = dataChangeLastModifiedTime;
  <|file_separator|><nl>
    return instanceRepository.findByIds(instanceIds);
  <|file_separator|><nl>
    return namespaceLockRepository.findByNamespaceId(namespaceId);
  <|file_separator|><nl>
    SettableFuture<ReleaseMessage> someListenerFuture = SettableFuture.create();
    ReleaseMessageListener someListener = (message, channel) -> someListenerFuture.set(message);
    releaseMessageScanner.addMessageListener(someListener);

    String someMessage = "someMessage";
    long someId = 100;
    ReleaseMessage someReleaseMessage = assembleReleaseMessage(someId, someMessage);

    when(releaseMessageRepository.findFirst500ByIdGreaterThanOrderByIdAsc(0L)).thenReturn(
        Lists.newArrayList(someReleaseMessage));

    ReleaseMessage someListenerMessage =
        someListenerFuture.get(5000, TimeUnit.MILLISECONDS);

    assertEquals(someMessage, someListenerMessage.getMessage());
    assertEquals(someId, someListenerMessage.getId());

    SettableFuture<ReleaseMessage> anotherListenerFuture = SettableFuture.create();
    ReleaseMessageListener anotherListener = (message, channel) -> anotherListenerFuture.set(message);
    releaseMessageScanner.addMessageListener(anotherListener);

    String anotherMessage = "anotherMessage";
    long anotherId = someId + 1;
    ReleaseMessage anotherReleaseMessage = assembleReleaseMessage(anotherId, anotherMessage);

    when(releaseMessageRepository.findFirst500ByIdGreaterThanOrderByIdAsc(someId)).thenReturn(
        Lists.newArrayList(anotherReleaseMessage));

    Awaitility.await().atMost(databaseScanInterval * 2, TimeUnit.MILLISECONDS).until(() -> {
      return anotherListenerFuture.get(5000, TimeUnit.MILLISECONDS) != null;
    });

    ReleaseMessage anotherListenerMessage =
        anotherListenerFuture.get(5000, TimeUnit.MILLISECONDS);

    assertEquals(anotherMessage, anotherListenerMessage.getMessage());
    assertEquals(anotherId, anotherListenerMessage.getId());
<nl>
    for (int i = 0; i < 100; i++) {
      instanceConfigRepository.save(new InstanceConfig());
    }
    Page<InstanceConfig> page = instanceConfigRepository.findAll(new PageRequest(0, 10));
    assertThat(page.getTotalElements()).isEqualTo(100);
  <|file_separator|><nl>
  <|file_separator|><nl>
    return this.template;
  <|file_separator|><nl>
    try {
      String value = getValue(key);
      return value == null ? defaultValue : splitter.splitToList(value).toArray(new String[0]);
    } catch (Throwable e) {
      Tracer.logError("Get array property failed.", e);
      return defaultValue;
    }
  }

  public String[] getArrayProperty(String key) {
    return getArrayProperty(key, new String[0]);
  }

  public String getStringValue(String key, String defaultValue) {
    try {
      String value = getValue(key);
      return value == null ? defaultValue : value;
    } catch (Throwable e) {
      Tracer.logError("Get string property failed.", e);
      return defaultValue;
    }
  <|file_separator|><nl>
    FilterRegistrationBean registrationBean = new FilterRegistrationBean();
    CharacterEncodingFilter characterEncodingFilter = new CharacterEncodingFilter();
    characterEncodingFilter.setEncoding("UTF-8");
    characterEncodingFilter.setForceEncoding(true);
    registrationBean.setFilter(characterEncodingFilter);
    return registrationBean;
  <|file_separator|><nl>
    printLog(gson.toJson(ex), ex, logLevel);
    return new ResponseEntity<>(HttpStatus.valueOf(status.value()));
  <|file_separator|><nl>
    this.dataLocations = dataLocations;
  <|file_separator|><nl>
    this.dataChangeCreatedByDisplayName = dataChangeCreatedByDisplayName;
  <|file_separator|><nl>
    return parentClusterId;
  <|file_separator|><nl>
    this.ruleItems.add(ruleItem);
  <|file_separator|><nl>
    this.httpStatus = httpStatus;
  <|file_separator|><nl>
    someList.add(77);
    assertNotNull(BeanUtils.batchTransform(String.class, someList));
  <|file_separator|><nl>
    checkAppNamespaceName("some.app-namespace-_name.123", true);
    checkAppNamespaceName("some.app-namespace-_name.123.yml", true);
    checkAppNamespaceName("some.&.app-namespace", false);
    checkAppNamespaceName("", false);
    checkAppNamespaceName(null, false);
    checkAppNamespaceName(".",false);
  <|file_separator|><nl>
    try {
      appService.check();
    } catch (final Exception e) {
      throw new HealthCheckException("Error checking app service", e);
    }
  <|file_separator|><nl>
    return new ArrayList<>();
  }

  @RequestMapping("/discovery")
  public List<ServiceDTO> getDiscoveryService(
      @RequestParam(value = "appId", defaultValue = "") String appId,
      @RequestParam(value = "ip", required = false) String clientIp) {
    return discoveryService.getServiceInstances(ServiceNameConsts.APOLLO_DISCOVERYSERVICE);
  <|file_separator|><nl>
    instanceConfigAuditUtil = new InstanceConfigAuditUtil();
    audits = new LinkedBlockingQueue<>();
    instanceConfigAuditUtil.setAudits(audits);
    instanceConfigAuditUtil.setInstanceService(instanceService);
  <|file_separator|><nl>
    return releaseHistory.getReleaseContent();
  <|file_separator|><nl>
    return emailContent(env, releaseHistory, null);
  <|file_separator|><nl>
    return consumerService.getConsumerList(page);
  <|file_separator|><nl>
    favoriteService.toTop(favoriteId);
  <|file_separator|><nl>
    this.syncItems = syncItems;
  <|file_separator|><nl>
    this.permissionType = permissionType;
  <|file_separator|><nl>
    return canAppAdminCreatePrivateNamespace;
  <|file_separator|><nl>
    AppDTO app = BeanUtils.transform(AppDTO.class, event.getApp());
    List<Env> envs = portalSettings.getActiveEnvs();
    String appId = app.getId();
    String operator = app.getDataChangeLastModifiedBy();

    for (Env env : envs) {
      try {
        appAPI.deleteApp(env, appId, operator);
      } catch (Throwable e) {
        logger.error("Delete app failed. appId = {}, env = {}", appId, env, e);
        Tracer.logError(String.format("Delete app failed. appId = %s, env = %s", appId, env), e);
      }
    }
  <|file_separator|><nl>
    return namespaceLockAPI.getNamespaceLockInfo(appId, env, clusterName, namespaceName);
  }

  public void lockNamespace(String appId, Env env, String clusterName, String namespaceName) {
    namespaceLockAPI.lockNamespace(appId, env, clusterName, namespaceName);
  }

  public void unlockNamespace(String appId, Env env, String clusterName, String namespaceName) {
    namespaceLockAPI.unlockNamespace(appId, env, clusterName, namespaceName);
  }

  public void lockNamespace(String appId, Env env, String clusterName, String namespaceName, String lockId) {
    namespaceLockAPI.lockNamespace(appId, env, clusterName, namespaceName, lockId);
  }

  public void unlockNamespace(String appId, Env env, String clusterName, String namespaceName, String lockId) {
    namespaceLockAPI.unlockNamespace(appId, env, clusterName, namespaceName, lockId);
  }

  public void lockNamespace(String appId, Env env, String clusterName, String namespaceName, String lockId, String lockReason) {
    namespaceLockAPI.lockNamespace(appId, env, clusterName, namespaceName, lockId, lockReason);
  }

  public void unlockNamespace(String appId, Env env, String clusterName, String namespaceName, String lockId, String lockReason) {
    namespaceLockAPI.unlockNamespace(appId, env, clusterName, namespaceName, lockId, lockReason);
  }

  public void lockNamespace(String appId, Env env, String clusterName, String namespaceName, String lockId, String lockReason, String lockReasonType) {
    namespaceLockAPI.lockNamespace(appId, env, clusterName, namespaceName, lockId, lockReason, lockReasonType);
  }

  <nl>
    List<ReleaseHistoryBO> result = new ArrayList<>(source.size());
    for (ReleaseHistoryDTO dto : source) {
      ReleaseDTO release = releases.stream().filter(r -> r.getId() == dto.getReleaseId()).findFirst().orElse(null);
      result.add(transformReleaseHistoryDTO2BO(dto, release));
    }
    return result;
  <|file_separator|><nl>
      DefaultMQService mqService = new DefaultMQService("default");
      mqService.setNamesrvAddr("localhost:9876");
      mqService.start();
      return mqService;
    <|file_separator|><nl>
    return super.authenticate(authentication);
  <|file_separator|><nl>
    try {
      Name userDn = searchUserById(username);
      return super.searchForUser(userDn.getName());
    } catch (Exception e) {
      logger.error("Error searching for user", e);
      return null;
    }
  }

  @Override
  public DirContextOperations searchForUser(Name userDn) {
    try {
      return super.searchForUser(userDn);
    } catch (Exception e) {
      logger.error("Error searching for user", e);
      return null;
    }
  <|file_separator|><nl>
    return this.getUserInternal();
  <|file_separator|><nl>
    if (StringUtils.isEmpty(keyword)) {
      return userRepository.findAll();
    }
    return userRepository.findByUsernameLike(keyword);
  <|file_separator|><nl>
    return String.join(File.separator, app.getOwnerName(), app.getAppId(), env.getName(), cluster.getName() + ".metadata");
  <|file_separator|><nl>
    return namespaceBO.getItems().stream().map(itemBO -> {
      ItemDTO dto = itemBO.getItem();
      dto.setId(0);
      dto.setNamespaceId(0);
      return dto;
    }).collect(Collectors.toList());
  <|file_separator|><nl>
    this.mockMvc.perform(get("/api/v1/namespaces/invalid"))
      .andExpect(status().isBadRequest());
  }

  @Test
  public void shouldFailWhenConsumerNamespaceNameIsInvalid() {
    this.mockMvc.perform(get("/api/v1/namespaces/app/invalid"))
      .andExpect(status().isBadRequest());
  }

  @Test
  public void shouldFailWhenConsumerNamespaceNameIsInvalidAndAppNamespaceNameIsInvalid() {
    this.mockMvc.perform(get("/api/v1/namespaces/invalid/invalid"))
      .andExpect(status().isBadRequest());
  }

  @Test
  public void shouldFailWhenConsumerNamespaceNameIsInvalidAndAppNamespaceNameIsInvalidAndConsumerNamespaceNameIsInvalid() {
    this.mockMvc.perform(get("/api/v1/namespaces/invalid/invalid/invalid"))
      .andExpect(status().isBadRequest());
  }

  @Test
  public void shouldFailWhenConsumerNamespaceNameIsInvalidAndAppNamespaceNameIsInvalidAndConsumerNamespaceNameIsInvalidAndConsumerNamespaceNameIsInvalid() {
    this.mockMvc.perform(get("/api/v1/namespaces/invalid/invalid/invalid/invalid"))
      .andExpect(status().isBadRequest());
  }

  @Test
  public void shouldFailWhenConsumerNamespaceNameIsInvalidAndAppNamespaceNameIsInvalidAndConsumerNamespaceNameIsInvalidAndConsumerNamespaceNameIsInvalidAndConsumerNamespaceNameIsInvalid() {
    this.mockMvc.perform(get("/api/v1/namespaces/invalid/invalid/invalid/invalid/invalid"))
      .andExpect(status().isBadRequest());
  }

  @Test
  public void shouldFailWhenConsumerNamespaceNameIsInvalidAndAppNamespaceNameIsInvalidAndConsumerNamespaceNameIsInvalidAndConsumerNamespaceNameIsInvalidAndConsumer<nl>
        try {
            final AtmosphereInterceptor interceptor = framework.getFramework().getInterceptor(annotatedClass);
            if (interceptor != null) {
                logger.info("Found interceptor for class {}", annotatedClass.getName());
            }
        } catch (final Exception e) {
            logger.error("Error while getting interceptor for class {}", annotatedClass.getName(), e);
        }
    <|file_separator|><nl>
        logger.info("BroadcastFilterServiceProcessor");
    <|file_separator|><nl>
        try {
            WebSocketHandlerService service = annotatedClass.newInstance();
            service.setFramework(framework);
            service.setLogger(logger);
            service.setContext(framework.getServletContext());
            service.setApplicationContext(framework.getApplicationContext());
            service.setWebSocketHandler(annotatedClass);
            service.init();
        } catch (Exception e) {
            logger.error("Error initializing WebSocketHandlerService", e);
        }
    <|file_separator|><nl>
        super.init(sc);
        glassfishWebSocketHandler = new GlassFishWebSocketHandler(config);
        WebSocketEngine.getEngine().register(glassfishWebSocketHandler);
    <|file_separator|><nl>
        for (String path : sc.getInitParameter("webSocket.path").split(",")) {
            paths.put(path, true);
        }
    <|file_separator|><nl>
        logger.trace("onOpen");
        webSocket = webSocketProcessor.open(request);
    <|file_separator|><nl>
    <|file_separator|><nl>
            return this;
        <|file_separator|><nl>
        if (session.getMaxInactiveInterval() != timeout) {
            session.setMaxInactiveInterval(timeout);
            logger.trace("Session timeout updated to {}", timeout);
        }
    <|file_separator|><nl>
        return new WebSocketProcessor(framework);
    <|file_separator|><nl>
        return new Action() {
            @Override
            public void onResponse(final Response response) {
                if (response.isDisconnection()) {
                    logger.info("Browser disconnected");
                    config.getAtmosphereHandler().disconnect(r);
                }
            }
        };
    <|file_separator|><nl>
        try {
            return super.inspect(r);
        } catch (Exception e) {
            logger.error("Error in ShiroInterceptor", e);
            return Action.DENY;
        }<|file_separator|><nl>
        o.write(data);
        return this;
    <|file_separator|><nl>
        if (message instanceof String) {
            bufferedMessage.get().append(message);
            if (bufferedMessage.get().length() > maxBufferedString) {
                return BroadcastAction.DROP;
            }
        }
        return BroadcastAction.CONTINUE;
    }

    public String getBufferedMessage() {
        return bufferedMessage.get().toString();
    <|file_separator|><nl>
        return Version.getMajorVersion() == major && Version.getMinorVersion() == minor;
    }

    /**
     * Checks if current Atmosphere framework version equals to one passed
     *
     * @param major Atmosphere framework major version
     * @param minor Atmosphere framework minor version
     * @param micro Atmosphere framework micro version
     * @return true, if versions are equal; false otherwise
     */
    public static boolean equalVersion(int major, int minor, int micro) {
        return Version.getMajorVersion() == major && Version.getMinorVersion() == minor && Version.getMicroVersion() == micro;
    <|file_separator|><nl>
        return initParams.get(name);
    <|file_separator|><nl>
        return name;
    <|file_separator|><nl>
        try {
            URL url = new URL(urlString);
            HttpURLConnection urlConnection = openURLConnection(url);
            urlConnection.setRequestMethod(GET_METHOD_NAME);
            urlConnection.setRequestProperty("User-Agent", uaName);
            urlConnection.setRequestProperty("Accept", "text/html");
            urlConnection.setRequestProperty("Accept-Language", "en-US");
            urlConnection.setRequestProperty("Accept-Charset", "UTF-8");
            urlConnection.setRequestProperty("Connection", "close");
            urlConnection.connect();
            int responseCode = getResponseCode(urlConnection);
            if (responseCode == HttpURLConnection.HTTP_OK) {
                logMessage(SUCCESS_MESSAGE);
            } else {
                logError("HTTP GET request failed with response code: "
                        + responseCode);
            }
        } catch (IOException e) {
            logError("HTTP GET request failed with exception: " + e.getMessage());
        }
    <|file_separator|><nl>
        String url = urlBuildingStrategy.buildURL(focusPoint);
        httpRequest.get(url);
    <|file_separator|><nl>
        if (size == buffer.length) {
            buffer = Arrays.copyOf(buffer, buffer.length * 2);
        }
    <|file_separator|><nl>
        logger.trace("onTextMessage {}", webSocket);
    }

    @Override
    public void onBinaryMessage(WebSocket webSocket, byte[] data, int offset, int length) {
        logger.trace("onBinaryMessage {}", webSocket);
    <|file_separator|><nl>
        return new AtmosphereRequestImpl.Builder()
                .setWebSocket(webSocket)
                .setPathInfo(pathInfo)
                .setRequestURI(requestURI)
                .setMethod(methodType)
                .setContentType(contentType)
                .setDestroyable(destroyable);
    }

    protected static AtmosphereResponseImpl.Builder constructResponse(WebSocket webSocket,
                                String responseType,
                                String responseStatus,
                                String responseReason,
                                String contentType,
                                boolean destroyable) {
        return new AtmosphereResponseImpl.Builder()
                .setWebSocket(webSocket)
                .setResponseType(responseType)
                .setResponseStatus(responseStatus)
                .setResponseReason(responseReason)
                .setContentType(contentType)
                .setDestroyable(destroyable);
    <|file_separator|><nl>
            // do something
        <|file_separator|><nl>
        <|file_separator|><nl>
        ar = new AR();
        atmosphereHandler = new AR();
        config = new AtmosphereConfig();
        broadcaster = new Broadcaster(config);
        broadcaster.addAtmosphereResource(ar);
        broadcaster.addAtmosphereResource(atmosphereHandler);
    <|file_separator|><nl>
            outputStream.write(s.getBytes());
            return this;
        <|file_separator|><nl>
        if (e.getType() == AtmosphereResourceEvent.Type.OPEN) {
            final JerseyResource jerseyResource = (JerseyResource) r;
            jerseyResource.setBroadcaster(this);
        }
    <|file_separator|><nl>
    <|file_separator|><nl>
        if (e.getType() == AtmosphereResourceEvent.Type.OPEN) {
            r.getBroadcaster().broadcast(r, e);
        }
    <|file_separator|><nl>
        return "Hello";
    }

    @GET
    @Path("/b")
    public String pathParam(@PathParam("topic") String topic) {
        return topic;
    <|file_separator|><nl>
        while (countDown > 0) {
            System.out.println(countDown);
            countDown--;
            Thread.sleep(1000);
        }
        return countDown;
    <|file_separator|><nl>
        return repository.getValue();
    <|file_separator|>class FakeRepository.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class FakeRepository {
    public Integer getValue() {
        return 1;
    }
}<|file_separator|>class FakeRepositoryValue.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class FakeRepositoryValue implements Callable<Integer> {
    private final FakeRepository repository;

    public FakeRepositoryValue(FakeRepository repository) {
        this.repository = repository;
    }

    public Integer call() throws Exception {
        return repository.getValue();
    }
}<|file_separator|><nl>
        logPrinter.accept(String.format("%s", ignoredException.getDescription()));
    <|file_separator|><nl>
            return this.failFastFailureReason;
        <|file_separator|><nl>
            return () -> {
                try {
                    return (T) (foundField == null ? WhiteboxImpl.getInternalState(object, expectedFieldType) : foundField
                            .get(object));
                } catch (IllegalAccessException e) {
                    throw new RuntimeException(e);
                }
            };
        <|file_separator|><nl>
        originalDefaultUncaughtExceptionHandler = eh;
    <|file_separator|><nl>
        // Given
        DoubleAdder accumulator = new DoubleAdder();

        // When
        new Thread(() -> {
            try {
                Thread.sleep(400);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }

            accumulator.add(5.0);
        }).start();

        // Then
        await().untilAdder(accumulator, equalTo(5.0));
    <|file_separator|><nl>
        exception.expect(ConditionTimeoutException.class);
        exception.expectMessage("expected <1> but was <0> within 200 milliseconds.");
        AtomicReference<String> atomic = new AtomicReference<>("0");
        await().atMost(200, MILLISECONDS).untilAtomic(atomic, equalTo("1"));
    }

    @Test(timeout = 2000)
    public void usingAtomicIntegerArray() {
        AtomicIntegerArray atomic = new AtomicIntegerArray(new int[]{0});
        new Asynch(new FakeRepositoryWithAtomicIntegerArray(atomic)).perform();
        await().untilAtomic(atomic, equalTo(new int[]{1}));
    }

    @Test(timeout = 2000)
    public void usingAtomicIntegerArrayAndTimeout() {
        exception.expect(ConditionTimeoutException.class);
        exception.expectMessage("expected <[1]> but was <[0]> within 200 milliseconds.");
        AtomicIntegerArray atomic = new AtomicIntegerArray(new int[]{0});
        await().atMost(200, MILLISECONDS).untilAtomic(atomic, equalTo(new int[]{1}));
    }

    @Test(timeout = 2000)
    public void usingAtomicReferenceArray() {
        AtomicReferenceArray<String> atomic = new AtomicReferenceArray<>(new String[]{"0"});
        new Asynch(new FakeRepositoryWithAtomicReferenceArray(atomic)).perform();
        await().untilAtomic(atomic, equalTo(new String[]{"1"}));
    }

    @Test(timeout = 2000)
    public void usingAtomicReferenceArrayAndTimeout() {
        exception.expect(ConditionTimeoutException.class);
        exception.expectMessage("expected <[1]> but was <[0]> within 200 milliseconds<nl>
        new WasAddedWithDefaultValue().start();

        await().atMost(FIVE_SECONDS).untilTrue(wasAddedWithDefaultValue);
    <|file_separator|><nl>
		this.value = value;
	<|file_separator|><nl>
        Awaitility.setLogging(new ConditionEvaluationLogger(System.out::println));
    <|file_separator|><nl>
        return "AxonServerRemoteCommandHandlingException{" +
                "errorCode='" + errorCode + '\'' +
                ", server='" + server + '\'' +
                ", errorMessage=" + getErrorMessage() +
                '}';
    <|file_separator|>class AxonServerRemoteCommandException.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class AxonServerRemoteCommandException extends AxonServerRemoteCommandHandlingException {

    /**
     * Initialize the exception with given {@code errorCode} and {@code errorMessage}.
     *
     * @param errorCode    the code reported by the server
     * @param errorMessage the message describing the exception on the remote end
     */
    public AxonServerRemoteCommandException(String errorCode, ErrorMessage errorMessage) {
        super(errorCode, errorMessage);
    }
}<|file_separator|>class AxonServerRemoteCommand.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class AxonServerRemoteCommand {

    private final String name;
    private final String[] parameters;

    /**
     * Initialize the command with given {@code name} and {@code parameters}.
     *
     * @param name        the name of the command
     * @param parameters  the parameters of the command
     */
    public AxonServerRemoteCommand(String name, String[] parameters) {
        this.name = name;
        this.parameters = parameters;
    }

    /**
     * Returns the name of the command.
     *
     * @return the name of the command
     */
    public String getName() {
        return name;
    }

    /**
     * Returns the parameters of the command.
     *
     * @return the parameters of the command
     */
    public String[] getParameters() {
        return parameters;
    }
}<|file_separator|>class AxonServerRemoteCommandResponse.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class AxonServerRemoteCommandResponse {<nl>
    <|file_separator|><nl>
        return new AdditionalMessageRequestingCall<>(next.newCall(method, callOptions), additionalBuffer);
    <|file_separator|><nl>
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            TestCommand that = (TestCommand) o;
            return someValue == that.someValue &&
                    Objects.equals(aggregateId, that.aggregateId);
        <|file_separator|><nl>
        return platformService;
    <|file_separator|><nl>
        values.add(value);
    <|file_separator|><nl>
        for (Class<? extends ModuleConfiguration> moduleType : moduleTypes) {
            if (!configuration.hasModule(moduleType)) {
                throw new AssertionError("Expected module of type " + moduleType.getName() + " is not present in the configuration");
            }
        }
    <|file_separator|><nl>
        when(configuration.getComponent(String.class)).thenReturn("donor");

        assertNull(testSubject.createInstance(method, parameters, 0));

        verify(configuration).getComponent(String.class);
    <|file_separator|><nl>
                                     firstEnhancerInvoked.set(true);
                                     return original;
                                 <|file_separator|><nl>
        if (valueRef == null) {
            return null;
        }
        return valueRef.get();
    <|file_separator|><nl>
        delegate.appendEvents(events);
    }

    @Override
    public void storeEvent(@Nonnull EventMessage<?> event) {
        delegate.storeEvent(event);
    <|file_separator|><nl>
        return this.resolver.resolveRevision(snapshot.getPayload().getClass())
                .equals(this.serializer.deserialize(snapshot.getPayload(), snapshot.getPayload().getClass()));
    <|file_separator|><nl>
        return "VARCHAR(255)";<|file_separator|><nl>
        UnitOfWork<EventMessage<Object>> unitOfWork = DefaultUnitOfWork.startAndGet(TEST_EVENT);

        // when _only_ publishing...
        testSubject.appendEvents(TEST_EVENT);

        // then there are events in the storage engine.
        Stream<? extends TrackedEventMessage<?>> eventStream = testSubject.readEvents(null, true);
        assertEquals(1L, eventStream.count());
    <|file_separator|><nl>
    <|file_separator|><nl>
        DeadlineManager deadlineManager = buildDeadlineManager(new Configuration());
        deadlineManager.shutdown();
        verify(scopeAwareProvider).shutdown();
    }

    @Test
    void deadlineCancellationOnAggregate() {
    }

    @Test
    void deadlineCancelAllOnAggregate() {
    <|file_separator|><nl>
        // test passes if no exception is thrown
        testSubject.createDomainEventTable(connection, eventSchema)
                   .execute();
        connection.prepareStatement("SELECT * FROM " + eventSchema.domainTable())
                  .execute();

        connection.prepareStatement("DROP TABLE " + eventSchema.domainTable())
                  .execute();
    <|file_separator|><nl>
    <|file_separator|><nl>
        return cmd.getState() + "HandledByChild2";
    <|file_separator|>class ParentAggregate.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class ParentAggregate {

    private String id;
    private String state;

    public ParentAggregate() {
    }

    @CommandHandler
    public ParentAggregate(CreateParentCommand cmd) {
        apply(new CreatedEvent(cmd.getId()));
    }

    @EventSourcingHandler
    public void on(CreatedEvent evt) {
        this.id = evt.getId();
    }

    @EventHandler
    public void on(ChildEvent evt) {
        this.state = "parent" + evt.getId();
    }

    @CommandHandler
    public String handle(InterceptedByParentCommand cmd) {
        return cmd.getState() + "HandledByParent";
    }

    @CommandHandlerInterceptor
    public void intercept(InterceptedByChildCommand cmd) {
        cmd.setState(cmd.getState() + "InterceptedByParent");
    }

    @Override
    public String handle(AbstractCommandHandlerCommand cmd) {
        return cmd.getState() + "HandledByParent";
    }
}<|file_separator|>class Child1Aggregate.java
<|fim_prefix|>public class Child1Aggregate {

    private String id;
    private String state;

    public Child1Aggregate() {
    }

    @CommandHandler
    public Child1Aggregate(CreateChild1Command cmd) {
        apply(new CreatedEvent(cmd.getId()));
    }

    @EventSourcingHandler
    public void on(CreatedEvent evt) {
        this.id = evt.getId();
    }

    @EventHandler
    public void on(ChildEvent evt) {
        this.state = "child1" + evt.getId();
    }

    @CommandHandler
    public String handle(Inter<nl>
        return id;
    <|file_separator|><nl>
        AggregateLifecycle.delete();
    <|file_separator|><nl>
        return new MethodCommandMessageHandlingMember<>(original, original.annotationAttributes());
    <|file_separator|><nl>
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        AndCommandMessageFilter that = (AndCommandMessageFilter) o;
        return Objects.equals(first, that.first) &&
                Objects.equals(second, that.second);
    <|file_separator|><nl>
        return !isNonTransientFailure(failure);
    <|file_separator|><nl>
        if (cause instanceof ClassCastException) {
            return new Class<?>[1] { (Class<? extends Throwable>) cause.getCause().getClass() };
        } else {
            return new Class<?>[1] { cause.getClass() };
        }
    <|file_separator|><nl>
        if (predicate.test(exception)) {
            return Optional.of(exception);
        }
        if (exception.getCause() != null) {
            return findException(exception.getCause(), predicate);
        }
        return Optional.empty();
    <|file_separator|><nl>
        return whiteList.containsKey(identifierType);
    }

    /**
     * Adds the given {@code identifierType} to the white list.
     *
     * @param identifierType The class of the identifier
     */
    public void addIdentifier(Class<?> identifierType) {
        whiteList.put(identifierType, NULL);
    <|file_separator|><nl>
        return !emptyOrNull(s);
    <|file_separator|><nl>
    <|file_separator|><nl>
        return 100;
    <|file_separator|><nl>
        return messageStream.stream();
    <|file_separator|><nl>
        <|file_separator|><nl>
        return new GenericEventMessage<>(getDelegate().withMetaData(metaData), timestampSupplier);
    <|file_separator|><nl>
        return FULL_SEQUENTIAL_POLICY;
    <|file_separator|><nl>
        if (logger.isTraceEnabled()) {
            logger.trace("Marked sequenceIdentifier [{}] as not present to the cache for segment [{}].",
                         sequenceIdentifier,
                         segmentId);
        }
        nonEnqueuedIdentifiers.add(sequenceIdentifier);
        enqueuedIdentifiers.remove(sequenceIdentifier);
        return this;
    <|file_separator|><nl>
        return latch.getAndSet(CompletableFuture.completedFuture(null));
    <|file_separator|><nl>
        if (throwable instanceof HandlerExecutionException) {
            return ((HandlerExecutionException) throwable).getDetails();
        }
        return Optional.empty();
    <|file_separator|><nl>
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        SimpleHandlerAttributes that = (SimpleHandlerAttributes) o;
        return Objects.equals(attributes, that.attributes);
    <|file_separator|><nl>
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        AnnotatedHandlerAttributes that = (AnnotatedHandlerAttributes) o;
        return Objects.equals(annotatedElement, that.annotatedElement) &&
                Objects.equals(simpleHandlerAttributes, that.simpleHandlerAttributes);
    <|file_separator|><nl>
    <|file_separator|><nl>
        CURRENT.set(interceptorChain);
        try {
            return action.call();
        } finally {
            CURRENT.remove();
        }
    <|file_separator|><nl>
        return (index, message) -> {
            logger.info("Incoming message: [{}]", message.getPayloadType().getSimpleName());
            return message;
        };
    <|file_separator|><nl>
        return validator.validate(message);
    <|file_separator|><nl>
        return isStarted() ? get().getCorrelationData() : MetaData.empty();
    <|file_separator|><nl>
        processingContext.setRollbackCause(cause);
    <|file_separator|><nl>
        Deque<Consumer<UnitOfWork<T>>> l = handlers.getOrDefault(phase, EMPTY);
        l.add(handler);
        handlers.put(phase, l);
    <|file_separator|><nl>
        fluxSink.complete();
    <|file_separator|><nl>
        return new GenericQueryMessage<>(getDelegate().withMetaData(metaData), queryName, responseType);
    <|file_separator|><nl>
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        SimpleSerializedType that = (SimpleSerializedType) o;
        return Objects.equals(type, that.type) &&
                Objects.equals(revisionId, that.revisionId);
    <|file_separator|><nl>
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        byte[] buffer = new byte[1024];
        int len;
        while ((len = original.read(buffer)) != -1) {
            bos.write(buffer, 0, len);
        }
        return bos.toByteArray();
    <|file_separator|><nl>
        return converter.canConvertDataTo(requiredType);
    <|file_separator|><nl>
        return new TracingHandlerEnhancer(original, spanFactory, showEventSourcingHandlers);
    }

    private static <T> String getSpanName(T target, Executable executable) {
        return getSpanName(target, toMethodSignature(executable));
    <|file_separator|><nl>
        return Collections.emptyMap();<|file_separator|><nl>
        AtomicLong retryCounter = new AtomicLong();
        ProcessUtils.executeWithRetry(() -> {
            if (retryCounter.getAndIncrement() < 11) {
                throw new IllegalArgumentException("Waiting for 11");
            }
        }, e -> false, 100, TimeUnit.MILLISECONDS, 10);
        assertEquals(11, retryCounter.get());
    <|file_separator|><nl>
        return new EhCache3AdapterTest.TestSubjectWrapper(new EhCache3Adapter());
    <|file_separator|><nl>
        return new JCacheAdapterTest.TestSubjectWrapper();
    }

    public class TestSubjectWrapper extends AbstractCacheAdapterTest.TestSubjectWrapper {
        @Override
        protected AbstractCacheAdapter getCacheAdapter() {
            return new JCacheAdapter();
        }
    <|file_separator|><nl>
        Connection wrapper = wrap(connection, closeHandler);
        assertThrows(InvocationTargetException.class, () -> wrapper.commit());
    <|file_separator|><nl>
        entityManager.persist(new TestJpaEntry("1"));
        entityManager.persist(new TestJpaEntry("2"));
        entityManager.persist(new TestJpaEntry("3"));
        entityManager.persist(new TestJpaEntry("4"));
        entityManager.persist(new TestJpaEntry("5"));
        entityManager.persist(new TestJpaEntry("6"));
        entityManager.persist(new TestJpaEntry("7"));
        entityManager.persist(new TestJpaEntry("8"));
        entityManager.persist(new TestJpaEntry("9"));
        entityManager.persist(new TestJpaEntry("10"));
        entityManager.persist(new TestJpaEntry("11"));
        entityManager.persist(new TestJpaEntry("12"));
        entityManager.persist(new TestJpaEntry("13"));
        entityManager.persist(new TestJpaEntry("14"));
        entityManager.persist(new TestJpaEntry("15"));
        entityManager.persist(new TestJpaEntry("16"));
        entityManager.persist(new TestJpaEntry("17"));
        entityManager.persist(new TestJpaEntry("18"));
        entityManager.persist(new TestJpaEntry("19"));
        entityManager.persist(new TestJpaEntry("20"));

        PagingJpaQueryIterable<TestJpaEntry, String> iterable = new PagingJpaQueryIterable<>(
                10,
                transactionManager,
                () -> entityManager.createQuery("select t from TestJpaEntry t", TestJpaEntry.class),
                TestJpaEntry::getId);

        List<String> result = StreamSupport.stream(iterable.spliterator(), false).collect(Collectors.toList());
        assertEquals(10, result.size());
        assertEquals("1", result.get(0));
        assertEquals("2", result.get(1));
        assertEquals("3",<nl>
        Property<T> property = getProperty(voidPropertyName());

        assertThrows(PropertyAccessException.class, () -> property.getValue(propertyHoldingInstance()));
    <|file_separator|><nl>
            return new StubProperty<>(property);
        <|file_separator|><nl>
        List<Serializer> serializerList = new ArrayList<>();
        serializerList.add(new DbSchedulerBinaryDeadlineDetailsSerializer());
        return serializerList;
    <|file_separator|><nl>
        assertTrue(thisStatus.matchStates(thatStatus));

        thisStatus.setMerging(true);
        thatStatus.setMerging(false);
        assertTrue(thisStatus.matchStates(thatStatus));

        thisStatus.setMerging(false);
        thisStatus.setCurrentPosition(10L);
        thatStatus.setCurrentPosition(42L);
        assertFalse(thisStatus.matchStates(thatStatus));

        thatStatus.setCurrentPosition(10L);
        thatStatus.setResetPosition(42L);
        thatStatus.setMergeCompletedPosition(1337L);
        assertTrue(thisStatus.matchStates(thatStatus));
    <|file_separator|><nl>
        EventMessage<?> message1 = createEvent("aggregate1", 1);
        EventMessage<?> message2 = createEvent("aggregate2", 1);

        testSubject.handle(Arrays.asList(message1, message2), mock(Consumer.class));

        verify(executor, times(2)).execute(isA(Runnable.class));
    <|file_separator|><nl>
            for (int i = 0; i < ITERATIONS; i++) {
                List<EventMessage<?>> events = new ArrayList<>();
                for (int j = 0; j < EVENTS_COUNT; j++) {
                    events.add(new EventMessage<>());
                }
                processor.accept(events);
            }
        <|file_separator|><nl>
        DomainEventMessage message = newStubDomainEvent("1");
        DomainEventMessage message2 = newStubDomainEvent("2");
        DomainEventMessage message3 = newStubDomainEvent("3");
        DomainEventMessage message4 = newStubDomainEvent("4");
        DomainEventMessage message5 = newStubDomainEvent("5");
        DomainEventMessage message6 = newStubDomainEvent("6");
        DomainEventMessage message7 = newStubDomainEvent("7");
        DomainEventMessage message8 = newStubDomainEvent("8");
        DomainEventMessage message9 = newStubDomainEvent("9");
        DomainEventMessage message10 = newStubDomainEvent("10");
        DomainEventMessage message11 = newStubDomainEvent("11");
        DomainEventMessage message12 = newStubDomainEvent("12");
        DomainEventMessage message13 = newStubDomainEvent("13");
        DomainEventMessage message14 = newStubDomainEvent("14");
        DomainEventMessage message15 = newStubDomainEvent("15");
        DomainEventMessage message16 = newStubDomainEvent("16");
        DomainEventMessage message17 = newStubDomainEvent("17");
        DomainEventMessage message18 = newStubDomainEvent("18");
        DomainEventMessage message19 = newStubDomainEvent("19");
        DomainEventMessage message20 = newStubDomainEvent("20");
        DomainEventMessage message21 = newStubDomainEvent("21");
        DomainEventMessage message22 = newStubDomainEvent("22");
        DomainEventMessage message23 = newStubDomainEvent("23");
        DomainEventMessage message24 = newStubDomainEvent("24");
        DomainEventMessage message25 = newStub<nl>
        eventHandlerOne = mock(EventMessageHandler.class);
        eventHandlerTwo = mock(EventMessageHandler.class);
        enqueuePolicy = mock(EnqueuePolicy.class);
        transactionManager = new StubTransactionManager();
        eventHandlingComponents = Arrays.asList(eventHandlerOne, eventHandlerTwo);
        testSubject = new DeadLetteredEventProcessingTask(eventHandlingComponents, enqueuePolicy, transactionManager);
    <|file_separator|><nl>
    <|file_separator|><nl>
        assertThrows(IllegalStateException.class, () -> {
            new BinaryDbSchedulerEventScheduler();
        });
    <|file_separator|><nl>
        SimpleScheduleToken token = new SimpleScheduleToken();
        token.setSchedule(new Schedule());
        serializer.serialize(token);
    <|file_separator|><nl>
    <|file_separator|><nl>
        // given
        final ConfigToken token = new ConfigToken();

        // when
        final String serialized = serializer.serialize(token);

        // then
        final ConfigToken deserialized = serializer.deserialize(serialized);
        assertEquals(token, deserialized);
    <|file_separator|><nl>
        GenericMessage<String> testMessage = new GenericMessage<>("payload");

        Message<?> result = GenericMessage.asMessage(testMessage);

        assertEquals(testMessage, result);
    }

    @Test
    void asMessageThrowsExceptionIfProvidedObjectIsNotMessage() {
        Object testObject = new Object();

        CannotConvertBetweenTypesException exception = new CannotConvertBetweenTypesException("foo");

        Message<?> result = GenericMessage.asMessage(testObject);

        assertNotNull(result);
    }

    @Test
    void asMessageThrowsExceptionIfProvidedObjectIsMessage() {
        GenericMessage<String> testMessage = new GenericMessage<>("payload");

        CannotConvertBetweenTypesException exception = new CannotConvertBetweenTypesException("foo");

        Message<?> result = GenericMessage.asMessage(testMessage);

        assertNotNull(result);
    <|file_separator|><nl>
        return new GenericDeadLetter<>("sequenceIdentifier", generateEvent(), generateThrowable());
    }

    @Override
    protected DeadLetter<EventMessage<?>> generateRequeuedLetter(DeadLetter<EventMessage<?>> original,
                Throwable requeueCause,
                MetaData diagnostics) {
        return original.withCause(requeueCause)
                       .withDiagnostics(diagnostics)
                       .markTouched();
    <|file_separator|><nl>
        uow.transformMessage(m -> new GenericMessage<>(new JSR303AnnotatedInstance("abc")));
        try {
            testSubject.handle(uow, interceptorChain);
            fail("Expected exception");
        } catch (JSR303ViolationException e) {
            assertFalse(e.getViolations().isEmpty());
        }
        verify(interceptorChain, never()).proceed();
    }

    @Test
    void validateAnnotatedObject_IllegalValue_WithCustomValidator() throws Exception {
        uow.transformMessage(m -> new GenericMessage<>(new JSR303AnnotatedInstance("abc")));
        ValidatorFactory mockValidatorFactory = spy(Validation.buildDefaultValidatorFactory());
        testSubject = new BeanValidationInterceptor<>(mockValidatorFactory);
        try {
            testSubject.handle(uow, interceptorChain);
            fail("Expected exception");
        } catch (JSR303ViolationException e) {
            assertFalse(e.getViolations().isEmpty());
        }
        verify(mockValidatorFactory).getValidator();
    <|file_separator|><nl>
        serializer.serialize(queryResponse());
    <|file_separator|><nl>
        MySerializableObject object = new MySerializableObject("some property");
        SerializedObject<byte[]> serialized = testSubject.serialize(object, object.getClass());
        assertEquals(object, testSubject.deserialize(serialized));
    <|file_separator|><nl>
        SerializedMetaData<byte[]> serializedMetaData = new SerializedMetaData<>(new byte[]{}, byte[].class);
        assertEquals(serializedMetaData.getSerializedObject(), new byte[] {});
        assertEquals(serializedMetaData.getSerializedType(), byte[].class);
    <|file_separator|><nl>
        Object a = "a", b = "b", c = "c", d = "d";
        Upcaster<Object> testSubject = new UpcasterWithRemainder(a, d, a);
        Stream<Object> result = testSubject.upcast(Stream.of(a, d, a, b, d, a));
        assertEquals(Arrays.asList(a, d, a, a), result.collect(toList()));
    <|file_separator|><nl>
        multiSpanFactory.createRootSpan(stringSupplier);

        Mockito.verify(spanFactory1).createRootSpan(stringSupplier);
        Mockito.verify(spanFactory2).createRootSpan(stringSupplier);
    <|file_separator|><nl>
        Message<?> message = new DomainEventMessage<>("payload");

        Map<String, String> map = provider.provideForMessage(message);
        assertEquals(0, map.size());
    <|file_separator|><nl>
        metricsConfigurerModule.configureModule(new Configuration());
        verify(globalMetricRegistry).register(any(Metric.class));
    <|file_separator|><nl>
        return this.aggregateIdentifier;
    <|file_separator|><nl>
        return new VersionedAggregateIdentifier(findIdentifier(command), findVersion(command));
    <|file_separator|><nl>
        <|file_separator|><nl>
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        VersionedAggregateIdentifier that = (VersionedAggregateIdentifier) o;
        return Objects.equals(identifier, that.identifier) &&
                Objects.equals(version, that.version);
    <|file_separator|><nl>
        methodsOf(saga.getClass()).forEach(
                method -> Stream.of(injectorAnnotationNames())
                               .filter(ann -> AnnotationUtils.isAnnotationPresent(method, ann))
                               .forEach(annotatedMethods -> {
                                   Class<?> requiredType = method.getParameterTypes()[0];
                                   findResource(requiredType).ifPresent(resource -> injectMethodResource(saga, method, resource));
                               }));
    <|file_separator|><nl>
        return new InspectedSagaModel<>(AnnotatedHandlerInspector.inspectType(sagaType,
                parameterResolverFactory,
                handlerDefinition).handlers());
    <|file_separator|><nl>
        AggregateLifecycle.delete();
    <|file_separator|><nl>
            return "Hello";
        <|file_separator|><nl>
        Object message = new Object();
        when(childMember.canHandle(message)).thenReturn(true);

        assertTrue(testSubject.canHandle(message));

        verify(childMember).canHandle(message);
    }

    @Test
    void canHandleMessageTypeIsNotDelegatedToChildHandler() {
        Object message = new Object();
        when(childMember.canHandle(message)).thenReturn(false);

        assertFalse(testSubject.canHandle(message));

        verify(childMember).canHandle(message);
    }

    @Test
    void handleMessageTypeIsDelegatedToChildHandler() {
        Object message = new Object();
        Object result = new Object();
        when(childMember.handle(message)).thenReturn(result);

        Object actual = testSubject.handle(message);

        assertEquals(result, actual);

        verify(childMember).handle(message);
    }

    @Test
    void handleMessageTypeIsNotDelegatedToChildHandler() {
        Object message = new Object();
        when(childMember.handle(message)).thenThrow(new RuntimeException());

        assertThrows(RuntimeException.class, () -> testSubject.handle(message));

        verify(childMember).handle(message);
    }

    @Test
    void canHandleMessageTypeIsDelegatedToChildHandler() {
        Object message = new Object();
        when(childMember.canHandle(message)).thenReturn(true);

        assertTrue(testSubject.canHandle(message));

        verify(childMember).canHandle(message);
    }

    @Test
    void canHandleMessageTypeIsNotDelegatedToChildHandler() {
        Object message = new Object();
        when(childMember.canHandle(message)).thenReturn(false);

        assertFalse(testSubject.canHandle(message));

<nl>
        testSubject.add(associationValue);
        testSubject.add(associationValue);

        assertEquals(1, testSubject.addedAssociations().size());
        assertEquals(1, testSubject.removedAssociations().size());
    <|file_separator|><nl>
        end();
    <|file_separator|><nl>
                return new EntityManagerProvider() {
                    @Override
                    public EntityManager getEntityManager() {
                        return entityManager;
                    }
                };
            <|file_separator|><nl>
            return new EntityManagerProvider();
        <|file_separator|><nl>
        testContext.withPropertyValues("axon.eventhandling.processors.first.tokenStoreClaimTimeout=1000")
                   .run(context -> {
                       assertNotNull(context.getBean(TokenStore.class));
                       assertEquals(1000,
                                    ((JpaTokenStore) context.getBean(TokenStore.class)).getTokenStoreClaimTimeout());
                   });
    }

    @Test
    void setTokenStoreClaimTimeoutToDefault() {
        testContext.run(context -> {
            assertNotNull(context.getBean(TokenStore.class));
            assertEquals(TokenStore.DEFAULT_TOKEN_STORE_CLAIM_TIMEOUT,
                         ((JpaTokenStore) context.getBean(TokenStore.class)).getTokenStoreClaimTimeout());
        });
    <|file_separator|><nl>
        return new TagsConfiguration(tags);
    <|file_separator|><nl>
        return anyMatch ? ConditionOutcome.noMatch() : ConditionOutcome.match();<|file_separator|><nl>
        return new ConditionOutcome(anyMatch, message);<|file_separator|><nl>
        testContext
            .withPropertyValues("axon.axonserver.servers=localhost:1234")
            .withBean(TestContext.class)
            .run(context -> {
                assertThat(context).hasSingleBean(GrpcServerStub.class);
                assertThat(context).hasSingleBean(TestContext.class);
            });
    <|file_separator|><nl>
        new ApplicationContextRunner()
                .withPropertyValues("axon.axonserver.enabled=false")
                .withUserConfiguration(HumanReadableContext.class)
                .run(context -> {
                    assertEquals(2, context.getBeanNamesForType(Task.class).length);
                });
    <|file_separator|><nl>
        final EventSerializer eventSerializer = applicationContext.getBean(EventSerializer.class);
        assertThat(eventSerializer).isInstanceOf(JacksonSerializer.class);
        assertThat(eventSerializer.getObjectMapper()).isSameAs(applicationContext.getBean(AxonObjectMapper.class));
    <|file_separator|><nl>
        new ApplicationContextRunner()
                .withPropertyValues("axon.axonserver.enabled=false")
                .run(context -> {
                    assertNotNull(context.getBean(Snapshotter.class));
                });
    <|file_separator|><nl>
        return new XStreamSerializer(new XStream(new CompactDriver()));
    <|file_separator|><nl>
        GenericBeanDefinition beanDefinition = new GenericBeanDefinition();
        beanDefinition.setBeanClass(AnnotationCommandHandlerBeanPostProcessor.class);
        beanDefinition.getPropertyValues().add("parameterResolverFactory",
                                               SpringContextParameterResolverFactoryBuilder.getBeanReference(registry));
        beanDefinition.getPropertyValues().add("handlerDefinition",
                                               SpringContextHandlerDefinitionBuilder.getBeanReference(registry));

        registry.registerBeanDefinition(COMMAND_HANDLER_BEAN_NAME, beanDefinition);
    <|file_separator|><nl>
        if (initialized) {
            throw new IllegalStateException("The EventHandlerRegistrar has already been initialized");
        }
        initialized = true;
    <|file_separator|><nl>
            if (method.isAnnotationPresent(HasCommandHandler.class)) {
                result.set(true);
            }
        <|file_separator|><nl>
        MessageHeaders headers = new SettableTimestampMessageHeaders(event.getHeaders().entrySet()
                .stream()
                .filter(entry -> !entry.getKey().startsWith(AXON_MESSAGE_PREFIX))
                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue)),
                                                                        event.getTimestamp().toEpochMilli());
        if (event instanceof GenericDomainEventMessage) {
            return new GenericMessage<>(event.getPayload(), headers);
        } else {
            return new GenericMessage<>(event.getPayload(), headers);
        }
    <|file_separator|><nl>
        BeanHelper beanHelper = new BeanHelper();
        beanHelper.setApplicationContext(new ClassPathXmlApplicationContext("applicationContext.xml"));
        BeanHelper.setBeanHelper(beanHelper);
        BeanHelper.getBeanHelper().setApplicationContext(new ClassPathXmlApplicationContext("applicationContext.xml"));
        BeanHelper.getBeanHelper().setApplicationContext(new ClassPathXmlApplicationContext("applicationContext.xml"));
    <|file_separator|><nl>
        TokenEntry entry = new TokenEntry();
        entry.setAccessToken("access");
        entry.setRefreshToken("refresh");
        entry.setTokenType("type");
        entry.setScope("scope");
        entry.setExpiresAt(Instant.now().plus(Duration.ofDays(1)));
        entry.setNodeId("node");
        entry.setClientId("client");
        entry.setClientSecret("secret");
        entry.setAuthorizedGrantTypes(Collections.singletonList("grant"));
        entry.setAuthorities(Collections.singletonList("auth"));
        entry.setAdditionalInformation(Collections.singletonMap("info", "value"));
        entityManager.persist(entry);

        stealingJpaTokenStore.storeAccessToken(entry);
        stealingJpaTokenStore.storeRefreshToken(entry);
        stealingJpaTokenStore.storeAccessToken(entry);
        stealingJpaTokenStore.storeRefreshToken(entry);
        stealingJpaTokenStore.storeAccessToken(entry);
        stealingJpaTokenStore.storeRefreshToken(entry);
        stealingJpaTokenStore.storeAccessToken(entry);
        stealingJpaTokenStore.storeRefreshToken(entry);
        stealingJpaTokenStore.storeAccessToken(entry);
        stealingJpaTokenStore.storeRefreshToken(entry);
    <|file_separator|><nl>
        testSubject.setTransactionManager(mockTransactionManager);
    <|file_separator|><nl>
        this.context = applicationContext;
    <|file_separator|><nl>
        JpaAggregate agg = new JpaAggregate("First message");
        <|file_separator|><nl>
        if (payload instanceof EventMessage) {
            appliedMessages.add((EventMessage<?>) payload);
        }
        return null;
    <|file_separator|><nl>
        return item instanceof List && ((List) item).isEmpty();
    <|file_separator|><nl>
        return !ignoredField.equals(field);
    <|file_separator|><nl>
        return !field.isGetter();
    <|file_separator|><nl>
        return shouldPublishEvents;
    <|file_separator|><nl>
        testSubject.getRepository();

        assertThrows(FixtureExecutionException.class,
                     () -> testSubject.registerParameterResolverFactory());
    <|file_separator|><nl>
        return aggregateIdentifier;
    <|file_separator|><nl>
        return aggregateIdentifier;
    <|file_separator|><nl>
        return new EventMessage<>(mockEvent, Instant.now().plus(Duration.ofDays(1)));
    <|file_separator|><nl>
        return identifier;
    <|file_separator|><nl>
        return identifier;
    <|file_separator|><nl>
        return message.getMetaData().keySet();
    <|file_separator|><nl>
        assertEquals(2, MetadataContextGetter.INSTANCE.get(message, "MyKeyTwo"));
    <|file_separator|><nl> return super.getPointer(i); }
    @Override public SizeTPointer getPointer(long i, long j) { return super.getPointer(i, j); }
    @Override public SizeTPointer getPointer(long i, long j, long k) { return super.getPointer(i, j, k); }
    @Override public SizeTPointer getPointer(long i, long j, long k, long l) { return super.getPointer(i, j, k, l); }
    @Override public SizeTPointer getPointer(long i, long j, long k, long l, long m) { return super.getPointer(i, j, k, l, m); }
    @Override public SizeTPointer getPointer(long i, long j, long k, long l, long m, long n) { return super.getPointer(i, j, k, l, m, n); }
    @Override public SizeTPointer getPointer(long i, long j, long k, long l, long m, long n, long o) { return super.getPointer(i, j, k, l, m, n, o); }
    @Override public SizeTPointer getPointer(long i, long j, long k, long l, long m, long n, long o, long p) { return super.getPointer(i, j, k, l, m, n, o, p); }
    @Override public SizeTPointer getPointer(long i, long j, long k, long l, long m, long n, long o, long p, long q) { return super.getPointer(i, j, k, l, m, n, o, p, q); }
    @Override public SizeTPointer getPointer(long i, long j, long k<nl>
        return index.toString();
    <|file_separator|><nl>
        for (int n = 0; n < length; n++) {
            buffer.put((int)index(i) + n, m[offset + n]);
        }
        return this;
    <|file_separator|>class IntIndexer.java
<|fim_prefix|><|fim_suffix|>
    public IntIndexer put(long i, int n) {
        return put(i, n, 0, 1);
    }
    public IntIndexer put(long i, int[] m, int offset, int length) {
        return put(i, m, offset, length, 0, 1);
    }
    public IntIndexer put(long i, int[] m, int offset, int length, int stride) {
        return put(i, m, offset, length, stride, 1);
    }
    public IntIndexer put(long i, int[] m, int offset, int length, int stride, int lengthStride) {
        for (int n = 0; n < length; n++) {
            put(i + n * stride, m[offset + n]);
        }
        return this;
    }
    public IntIndexer put(long i, int[] m, int offset, int length, int stride, int lengthStride, int lengthLength) {
        for (int n = 0; n < length; n++) {
            put(i + n * stride, m[offset + n * lengthLength], lengthLength);
        }
        return this;
    }
    public IntIndexer put(long i, int[] m, int offset, int length, int stride, int lengthStride, int lengthLength, int lengthLengthLength) {
        for (int n = 0; n < length; n++) {
            put(i + n * stride, m[offset + n<nl>
        for (int n = 0; n < length; n++) {
            m[offset + n] = array[(int)index(i, j) + n] & 0xFFFFFFFFL;
        }
        return this;
    <|file_separator|><nl>
        buffer.put((int)index(i, j), fromBigInteger(l));
        return this;
    <|file_separator|><nl>
        if (decl == null) {
            return false;
        }
        if (decl instanceof Info) {
            if (infoMap == null) {
                infoMap = new InfoMap();
            }
            infoMap.add((Info) decl);
        }
        if (decl instanceof Template) {
            if (templateMap == null) {
                templateMap = new TemplateMap();
            }
            templateMap.add((Template) decl);
        }
        if (decl instanceof Context) {
            if (context == null) {
                context = (Context) decl;
            }
        }
        if (decl instanceof InfoMap) {
            if (infoMap == null) {
                infoMap = (InfoMap) decl;
            }
        }
        if (decl instanceof TemplateMap) {
            if (templateMap == null) {
                templateMap = (TemplateMap) decl;
            }
        }
        if (decl instanceof Context) {
            if (context == null) {
                context = (Context) decl;
            }
        }
        if (decl instanceof DeclarationList) {
            if (inherited == null) {
                inherited = (DeclarationList) decl;
            }
        }
        return super.add(decl);
    }

    public void rescan() {
        if (infoMap != null) {
            infoMap.rescan();
        }
        if (templateMap != null) {
            templateMap.rescan();
        }
        if (inherited != null) {
            inherited.rescan();
        }
    }

    public void rescan(String lines) {
        if (infoMap != null) {
            infoMap.rescan(lines);
        }<nl>
        if (System.getProperty("org.bytedeco.javacpp.logger.debug") != null) {
            return new Slf4jLogger(cls);
        }
        return new Logger();
    }

    /** Returns a new {@link #Logger()}. */
    public Logger() {}
}

class Slf4jLogger extends Logger {
    public Slf4jLogger(Class cls) {<|file_separator|><nl>
        LOGGER.info("Starting application");
        LOGGER.info("Application started");
    <|file_separator|><nl>
        int n = array.length;
        k = k % n;
        int[] result = new int[n];
        for (int i = 0; i < n; i++) {
            result[(i + k) % n] = array[i];
        }
        for (int i = 0; i < n; i++) {
            array[i] = result[i];
        }
    <|file_separator|><nl>
        if(node == null){
            return null ;
        }
        BinaryNodeTravel next = new BinaryNodeTravel() ;
        next.next = node ;
        return next ;
    <|file_separator|><nl>
                        aVolatile.stopThread();
                    <|file_separator|><nl>
        System.out.println("Fish");<|file_separator|>class Animal.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class Animal {
    protected void desc() {
        System.out.println("Animal");
    }
}<|file_separator|>class Dog.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class Dog extends Animal {


    @Override
    protected void desc() {
        System.out.println("Dog");
    }
}<|file_separator|>class Cat.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class Cat extends Animal {


    @Override
    protected void desc() {
        System.out.println("Cat");
    }
}<|file_separator|><nl>
        LOGGER.info("Hello World");
    <|file_separator|><nl>
        LOGGER.info("RealSubject.exec");
    <|file_separator|>class RealSubject.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class RealSubject {
    public void exec(){
        System.out.println("RealSubject.exec");
    }
}<|file_separator|>class RealSubject.js.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>class RealSubject {
    public void exec(){
        System.out.println("RealSubject.exec");
    }
}<|file_separator|><nl>
        LOGGER.info("SpringLifeCycle destroy");
    <|file_separator|><nl>
            System.out.println("Worker is working");
        <|file_separator|><nl>
        return null;
    <|file_separator|><nl>
            return new DataInputStream(_originalStream);
        <|file_separator|><nl>
        return set(instance, value);
    <|file_separator|><nl>
        return new AtomicBoolean(p.getBooleanValue());
    <|file_separator|><nl>
        return null;
    <|file_separator|><nl>
        if (_pathClass.isAssignableFrom(rawType)) {
            return new NioPathDeserializer();
        }
        return null;
    <|file_separator|><nl>
        if (_localMixIns != null && _localMixIns.containsKey(new ClassKey(cls))) {
            return _localMixIns.get(new ClassKey(cls));
        }
        if (_overrides != null) {
            return _overrides.findMixInClassFor(cls);
        }
        return null;
    }

    @Override
    public Class<?> findTargetClassFor(Class<?> cls) {
        if (_localMixIns != null && _localMixIns.containsKey(new ClassKey(cls))) {
            return cls;
        }
        if (_overrides != null) {
            return _overrides.findTargetClassFor(cls);
        }
        return null;
    }

    public ClassIntrospector.MixInResolver getOverrides() {
        return _overrides;
    }

    public Map<ClassKey,Class<?>> getLocalMixIns() {
        return _localMixIns;
    <|file_separator|><nl>
            return _typeFactory.createType(type, _bindings);
        <|file_separator|><nl>
        return _name;
    <|file_separator|><nl>
            return null;
        <|file_separator|><nl>
        // [databind#4327] 2.17 @JsonAlias should be respected by polymorphic deduction
        // [databind#3139] 03-May-2021, tatu: for [databind#3139], support for "empty" type
        if (EMPTY_CLASS_FINGERPRINT.equals(subtypeFingerprints.get(EMPTY_CLASS_FINGERPRINT))) {
            return null;
        }

        // [databind#4327] 2.17 @JsonAlias should be respected by polymorphic deduction
        // [databind#3139] 03-May-2021, tatu: for [databind#3139], support for "empty" type
        if (EMPTY_CLASS_FINGERPRINT.equals(subtypeFingerprints.get(new BitSet(0)))) {
            return null;
        }

        // [databind#4327] 2.17 @JsonAlias should be respected by polymorphic deduction
        // [databind#3139] 03-May-2021, tatu: for [databind#3139], support for "empty" type
        if (EMPTY_CLASS_FINGERPRINT.equals(subtypeFingerprints.get(new BitSet(1)))) {
            return null;
        }

        // [databind#4327] 2.17 @JsonAlias should be respected by polymorphic deduction
        // [databind#3139] 03-May-2021, tatu: for [databind#3139], support for "empty" type
        if (EMPTY_CLASS_FINGERPRINT.equals(subtypeFingerprints.get(new BitSet(2)))) {
            return null;
        }

        return super.<nl>
        return As.WRAPPER;
    }

    @Override
    public void write(JsonGenerator g, Object value, TypeSerializerProvider provider) throws IOException {
        if (value == null) {
            g.writeNull();
        } else {
            g.writeStartObject();
            g.writeFieldName(_property.getName());
            provider.getSerializer(value.getClass()).write(g, value);
            g.writeEndObject();
        }
    <|file_separator|><nl>
        if (id.startsWith(_basePackagePrefix)) {
            // note: we will leave the leading dot in there
            return ctxt.getTypeFactory().constructType(Class.forName(id.substring(_basePackagePrefix.length())));
        }
        return super._typeFromId(id, ctxt);
    <|file_separator|><nl>
        return this;
    }

    @Override
    protected JsonNode _at(JsonPointer ptr, boolean allowMissing) {
        return this;
    }

    @Override
    protected JsonNode _at(JsonPointer ptr, boolean allowMissing,
            boolean allowMissingArray) {
        return this;
    }

    @Override
    protected JsonNode _at(JsonPointer ptr, boolean allowMissing,
            boolean allowMissingArray, boolean allowMissingObject) {
        return this;
    }

    @Override
    protected JsonNode _at(JsonPointer ptr, boolean allowMissing,
            boolean allowMissingArray, boolean allowMissingObject,
            boolean allowMissingNull) {
        return this;
    }

    @Override
    protected JsonNode _at(JsonPointer ptr, boolean allowMissing,
            boolean allowMissingArray, boolean allowMissingObject,
            boolean allowMissingNull, boolean allowMissingBoolean) {
        return this;
    }

    @Override
    protected JsonNode _at(JsonPointer ptr, boolean allowMissing,
            boolean allowMissingArray, boolean allowMissingObject,
            boolean allowMissingNull, boolean allowMissingBoolean,
            boolean allowMissingNumber) {
        return this;
    }

    @Override
    protected JsonNode _at(JsonPointer ptr, boolean allowMissing,
            boolean allowMissingArray, boolean allowMissingObject,
            boolean allowMissingNull, boolean allowMissingBoolean,
            boolean allowMissingNumber, boolean allowMissingString) {
        return this;
    }

    @Override
    protected JsonNode _at(JsonPointer ptr, boolean allowMissing,
            boolean allowMissingArray, boolean allowMissingObject,
            boolean allowMissingNull, boolean allowMissingBoolean,
            boolean allowMissingNumber, boolean allowMissingString,
            boolean allow<nl>
        return serializer;
    <|file_separator|><nl>
        return new AttributePropertyWriter(attrName, propDef, contextAnnotations, declaredType);
    <|file_separator|><nl>
        return (gen instanceof PropertyBasedObjectIdGenerator)
                && ((PropertyBasedObjectIdGenerator)gen)._property == _property;
    <|file_separator|><nl>
        if (value == null) {
            g.writeNull();
        } else {
            g.writeNumber(value.getTime());
        }
    <|file_separator|><nl>
        if (property == null) {
            return this;
        }
        if (property.getDeclaringClass() == null) {
            return this;
        }
        if (property.getDeclaringClass().isAssignableFrom(Collection.class)) {
            return this;
        }
        if (property.getDeclaringClass().isAssignableFrom(List.class)) {
            return this;
        }
        if (property.getDeclaringClass().isAssignableFrom(Set.class)) {
            return this;
        }
        if (property.getDeclaringClass().isAssignableFrom(Map.class)) {
            return this;
        }
        if (property.getDeclaringClass().isAssignableFrom(Map.Entry.class)) {
            return this;
        }
        if (property.getDeclaringClass().isAssignableFrom(Set.class)) {
            return this;
        }
        if (property.getDeclaringClass().isAssignableFrom(Map.Entry.class)) {
            return this;
        }
        if (property.getDeclaringClass().isAssignableFrom(Map.Entry.class)) {
            return this;
        }
        if (property.getDeclaringClass().isAssignableFrom(Map.Entry.class)) {
            return this;
        }
        if (property.getDeclaringClass().isAssignableFrom(Map.Entry.class)) {
            return this;
        }
        if (property.getDeclaringClass().isAssignableFrom(Map.Entry.class)) {
            return this;
        }
        if (property.getDeclaringClass().isAssignableFrom(Map.Entry.class)) {
            return this;
        }
        if (property.getDeclaringClass().isAssignableFrom(Map.Entry.class)) {
<nl>
        byte[] buffer = new byte[16];
        _appendInt(uuid.getMostSignificantBits(), buffer, 0);
        _appendInt(uuid.getLeastSignificantBits(), buffer, 8);
        return buffer;
    <|file_separator|><nl>
        if (cls == _current) {
            return this;
        }
        if (_parent != null) {
            return _parent.find(cls);
        }
        return null;
    }

    public Class<?> current() {
        return _current;
    <|file_separator|><nl>
        return new CollectionType(rawType, elemT);
    }

    /**
     * @since 2.7
     */
    public static CollectionType construct(Class<?> rawType, TypeBindings bindings,
            JavaType superClass, JavaType[] superInts, JavaType elemT,
            Object valueHandler, Object typeHandler, boolean asStatic) {
        return new CollectionType(rawType, bindings, superClass, superInts, elemT,
                valueHandler, typeHandler, asStatic);
    }

    /**
     * @since 2.7
     */
    public static CollectionType construct(Class<?> rawType, JavaType elemT,
            Object valueHandler, Object typeHandler, boolean asStatic) {
        return new CollectionType(rawType, elemT, valueHandler, typeHandler, asStatic);
    }

    /**
     * @since 2.7
     */
    public static CollectionType construct(Class<?> rawType, JavaType elemT,
            Object valueHandler, boolean asStatic) {
        return new CollectionType(rawType, elemT, valueHandler, asStatic);
    }

    /**
     * @since 2.7
     */
    public static CollectionType construct(Class<?> rawType, JavaType elemT,
            boolean asStatic) {
        return new CollectionType(rawType, elemT, null, asStatic);
    }

    /**
     * @since 2.7
     */
    public static CollectionType construct(Class<?> rawType, JavaType elemT) {
        return new CollectionType(rawType, elemT, null, false);
    }

    /**
     * @since 2.7
     */
    public static CollectionType construct(Class<?> rawType, JavaType<nl>
        if (isFatal(throwable)) {
            throw throwable;
        }
        if (throwable instanceof Error) {
            throw (Error) throwable;
        }
        throw new RuntimeException(throwable);
    <|file_separator|><nl>
        if (_value == null) {
            jgen.writeNull();
        } else {
            jgen.writeRawValue(_prefix);
            jgen.writeObject(_value);
            jgen.writeRawValue(_suffix);
        }
    <|file_separator|><nl>
        return tf.getJavaType(this);
    <|file_separator|><nl>
        GetLocations3063 locations = new GetLocations3063(Map.of("foo", "bar"));
        String json = MAPPER.writeValueAsString(locations);
        assertEquals("{\"nameToLocation\":{\"foo\":\"bar\"}}", json);
    <|file_separator|><nl>
        try {
            creator.call(data, offset, len);
            fail("Should not pass");
        } catch (IllegalArgumentException e) {
            if (data == null) {
                // If it gets to TokenStreamFactory we'll have:
                // verifyException(e, "Invalid `byte[]` argument: `null`");
                // But ObjectMapper/ObjectReader use different exception
                verifyException(e, "argument ");
                verifyException(e, "is null");
            } else {
                verifyException(e, "Invalid 'offset'");
                verifyException(e, "'len'");
                verifyException(e, "arguments for `byte[]` of length "+data.length);
            }
        }
    <|file_separator|><nl>
        SerializationConfig config = MAPPER.getSerializationConfig();
        assertNotNull(config);
        assertEquals(config.isEnabled(JsonWriteFeature.WRITE_DATES_AS_TIMESTAMPS), false);
        assertEquals(config.isEnabled(JsonWriteFeature.WRITE_DATES_WITH_ZONE_ID), false);
        assertEquals(config.isEnabled(JsonWriteFeature.WRITE_DATES_WITH_ZONE_OFFSET), false);
        assertEquals(config.isEnabled(JsonWriteFeature.WRITE_DATES_WITH_ZONE_ID_IN_ISO_8601), false);
        assertEquals(config.isEnabled(JsonWriteFeature.WRITE_DATES_WITH_ZONE_OFFSET_IN_ISO_8601), false);
        assertEquals(config.isEnabled(JsonWriteFeature.WRITE_DATES_WITH_ZONE_OFFSET_IN_ISO_8601_WITH_TIME_ZONE), false);
        assertEquals(config.isEnabled(JsonWriteFeature.WRITE_DATES_WITH_ZONE_OFFSET_IN_ISO_8601_WITH_TIME_ZONE_IN_ISO_8601), false);
        assertEquals(config.isEnabled(JsonWriteFeature.WRITE_DATES_WITH_ZONE_OFFSET_IN_ISO_8601_WITH_TIME_ZONE_IN_ISO_8601_WITH_TIME_ZONE), false);
        assertEquals(config.isEnabled(JsonWriteFeature.WRITE_DATES_WITH_ZONE_OFFSET_IN_ISO_8601_WITH_TIME_ZONE_IN_ISO_8601_WITH_TIME_ZONE_IN_ISO_8601), false);
        assertEquals(config.isEnabled(JsonWriteFeature.WRITE_DATES_WITH_ZONE_OFFSET_IN_ISO_8601_WITH_TIME_ZONE_IN<nl>
        assertNull(MAPPER_TO_EMPTY.readValue("true", String.class));
        StringWrapper w = MAPPER_TO_EMPTY.readValue("{"str": false}", StringWrapper.class);
        assertNull(w.str);
        String[] arr = MAPPER_TO_EMPTY.readValue("[ true ]", String[].class);
        assertEquals(1, arr.length);
        assertNull(arr[0]);
    <|file_separator|><nl>
        // NO coercion + empty string input + normal CollectionDeserializer
        assertArrayEquals(new StringWrapper[]{new StringWrapper("")},
                NORMAL_MAPPER.readValue("""", new TypeReference<StringWrapper[]>() {}));
    }
<|file_separator|><nl>
        assertNull(MAPPER.convertValue(null, Byte.class));
        assertNull(MAPPER.convertValue(null, Short.class));
        assertNull(MAPPER.convertValue(null, Integer.class));
        assertNull(MAPPER.convertValue(null, Long.class));
        assertNull(MAPPER.convertValue(null, Float.class));
        assertNull(MAPPER.convertValue(null, Double.class));
        assertNull(MAPPER.convertValue(null, Character.class));
        assertNull(MAPPER.convertValue(null, Boolean.class));
    <|file_separator|><nl>
        List<String> base = new ArrayList<>();
        base.add("foo");
        List<String> overrides = new ArrayList<>();
        overrides.add("bar");
        List<String> ob = MAPPER.updateValue(base, overrides);
        // first: should return first argument
        assertSame(base, ob);
        assertEquals(1, ob.size());
        assertEquals("bar", ob.get(0));
    <|file_separator|><nl>
        List<BooleanElement> list = new ArrayList<>();
        list.add(new BooleanElement(true));
        list.add(new BooleanElement(false));
        assertEquals(2, list.size());
        assertEquals(true, list.get(0).value());
        assertEquals(false, list.get(1).value());
    }
<|file_separator|><nl>
        // null doesn't really have a type, fake by assuming Object
        Object result = MAPPER.readValue("   null", Object.class);
        assertNull(result);
    }
<|file_separator|><nl>
        final String json = a2q("{'first_name':'John','last_name':'Doe','animal_id':1234,'living':true,'years_old':30}");

        final ObjectMapper mapper = new ObjectMapper();
        Animal animal = mapper.readValue(json, Animal.class);
        assertEquals(1234, animal.getId());
        assertNotNull(animal.getName());
        assertEquals("John", animal.getName().getFirst());
        assertEquals("Doe", animal.getName().getLast());
        assertEquals(30, animal.getAge());
        assertEquals(true, animal.isAlive());
    }
}
<|file_separator|><nl>
        String ser = MAPPER.writeValueAsString(new Something1503(null));
        try {
            MAPPER.readValue(ser, Something1503.class);
            fail("Should not pass");
        } catch (InvalidDefinitionException e) {
            verifyException(e, "Cannot construct instance");
            verifyException(e, "InnerSomething1503");
            verifyException(e, "non-static inner classes like this can only by instantiated using default");
        }
    }
}<|file_separator|><nl>
        MultiPropCreator1476 m = MAPPER.readValue("{"intField":1,"stringField":"foo"}", MultiPropCreator1476.class);
        assertEquals(1, m.getIntField());
        assertEquals("foo", m.getStringField());
    }
<|file_separator|><nl>
        final ObjectMapper mapper = newJsonMapper();
        mapper.setAnnotationIntrospector(new MyParamIntrospector());

        final String JSON = a2q("{'a':'123','b':'foo'}");
        final MultiCtor bean = mapper.readValue(JSON, MultiCtor.class);
        assertNotNull(bean);
        assertEquals("123", bean._a);
        assertEquals("foo", bean._b);
    }<|file_separator|><nl>
        Issue580Bean bean = new Issue580Bean(new Issue580Base());
        assertEquals(bean.value(), new Issue580Base());
    }
<|file_separator|><nl>
        String json = """
                {
                    "brand": "005"
                }
                """;
        Brand4403 brand = MAPPER.readValue(json, Brand4403.class);
        assertEquals(Brand4403.SEAT, brand);
    <|file_separator|><nl>
        String json = a2q("{'enumValue':'1'}");

        InsensitiveBean insensitiveBean = MAPPER.readValue(json, InsensitiveBean.class);

        assertEquals(Member.SECOND_MEMBER, insensitiveBean.enumValue);
    }
<|file_separator|><nl>
       PersonAnnotations person = MAPPER.readerFor(PersonAnnotations.class)
               .readValue("{"testEnum":"abc", "name":"def"}");
       assertEquals(TestEnum.ABC, person.getTestEnum());
       assertEquals("def", person.name);
   }
<|file_separator|><nl>
        try {
            MAPPER.readValue(generateJson("bd"), BigDecimalWrapper.class);
            fail("expected StreamReadException");
        } catch (StreamConstraintsException e) {
            verifyException(e, "Number value length", "exceeds the maximum allowed");
        }
    }

    @Test
    public void testBigDecimalUnlimited() throws Exception
    {
        BigDecimalWrapper bd =
            newJsonMapperWithUnlimitedNumberSizeSupport().readValue(generateJson("bd"), BigDecimalWrapper.class);
        assertNotNull(bd);
    }<|file_separator|><nl>
        assertEquals(Locale.ROOT,
                MAPPER.readerFor(Locale.class)
                    .with(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)
                        .readValue(""""));
    <|file_separator|><nl>
        try
        {
            MAPPER.readValue(a2q("[{'a':15},{'b':42}]"), new TypeReference<List<Map.Entry<String,Long>>>() { });
            fail("expected exception");
        }
        catch (JsonMappingException e)
        {
            assertEquals("No such property: b", e.getMessage());
        }
    }

    @Test
    public void testMapEntryWithNull() throws Exception
    {
        List<Map.Entry<String,String>> stuff = MAPPER.readValue(a2q("[{'a':null}]"),
                new TypeReference<List<Map.Entry<String,String>>>() { });
        assertNotNull(stuff);
        assertEquals(1, stuff.size());
        assertEquals(null, stuff.get(0).getValue());
    }

    @Test
    public void testMapEntryWithNullValue() throws Exception
    {
        List<Map.Entry<String,String>> stuff = MAPPER.readValue(a2q("[{'a':null}]"),
                new TypeReference<List<Map.Entry<String,String>>>() { });
        assertNotNull(stuff);
        assertEquals(1, stuff.size());
        assertEquals(null, stuff.get(0).getValue());
    }

    @Test
    public void testMapEntryWithNullKey() throws Exception
    {
        List<Map.Entry<String,String>> stuff = MAPPER.readValue(a2q("[{'a':null}]"),
                new TypeReference<List<Map.Entry<String,String>>>() { });
        assertNotNull(stuff);
        assertEquals(1, stuff.size());
        assertEquals(null, stuff.get(0).getKey());
    }

    @Test
    public void test<nl>
        ObjectMapper mapper = new ObjectMapper();
        MapWrapper result = mapper.readValue
            ("{"a":true }", MapWrapper.class);
        assertEquals(1, result.size());
        Object value = result.get("a");
        assertEquals(BooleanWrapper.class, value.getClass());
        BooleanWrapper bw = (BooleanWrapper) value;
        assertEquals(Boolean.TRUE, bw.b);
    }<|file_separator|><nl>
        assertEquals(TEST_UUID, UUID_DESERIALIZER._deserialize(Base64.getUrlEncoder().withoutPadding().encodeToString(getBytesFromUUID(TEST_UUID)), null));
    }
<|file_separator|><nl>
        ObjectMapper mapperWithObjectMerge = sharedMapper();

        JsonNode merged = _updateTreeWithObject(mapperWithObjectMerge);

        ObjectNode expected = mapperWithObjectMerge.createObjectNode();
        ObjectNode obj = expected.putObject("object");
        obj.put("b", "xyz");

        expected.put("number", 42);
        ArrayNode array = expected.putArray("array");
        array.add(1);
        array.add(2);
        array.add(3);

        assertEquals(expected, merged);
    <|file_separator|><nl>
        _testBetterDeserializationError(Optional.class);
        _testBetterDeserializationError(OptionalInt.class);
        _testBetterDeserializationError(OptionalLong.class);
        _testBetterDeserializationError(OptionalDouble.class);
    <|file_separator|><nl>
        DupSetter3125BeanFail bean = MAPPER.readValue(a2q("{'value':42}"),
                DupSetter3125BeanFail.class);
        assertEquals(42, bean.value);
    }
<|file_separator|><nl>
        Bean1592 bean = new Bean1592();
        bean.i = 10;
        bean.l = 1000000000000000000L;
        String json = MAPPER.writeValueAsString(bean);
        System.out.println(json);
    }
<|file_separator|><nl>
        // Create a simple schema
        Schemable schemable = new Schemable();
        schemable.name = "test";
        schemable.nameBuffer = "test".getBytes();
        schemable.states = new boolean[]{true, false};
        schemable.binaryData = new byte[]{1, 2, 3};
        schemable.shorts = new short[]{1, 2};
        schemable.ints = new int[]{1, 2};
        schemable.longs = new long[]{1, 2};
        schemable.floats = new float[]{1.0f, 2.0f};
        schemable.doubles = new double[]{1.0, 2.0};
        schemable.objects = new Object[]{new Object(), new Object()};
        schemable.someSerializable = new JsonSerializable();
        schemable.iterableOhYeahBaby = Arrays.asList("a", "b", "c").iterator();
        schemable.extra = Arrays.asList("a", "b", "c");
        schemable.extra2 = new ArrayList<>(Arrays.asList("a", "b", "c"));
        schemable.extra3 = Arrays.asList("a", "b", "c").iterator();
        schemable.sizes = new HashMap<>();
        schemable.sizes.put("a", 1.0);
        schemable.sizes.put("b", 2.0);
        schemable.sizes.put("c", 3.0);
        schemable.testEnum = SchemaEnum.A;
        schemable.testEnums = EnumSet.of(SchemaEnum.A, SchemaEnum.B);
    }<|file_separator|><nl>
            return children;
        <|file_separator|><nl>
        String jsonStr = a2q("{'@c':'.JsonTypeInfoSimpleClassName4061Test$MixedSub4061A'}");
        
        // ser
        assertEquals(jsonStr, MAPPER.writeValueAsString(new MixedSub4061A()));
        
        // deser
        MixedSuper4061 bean = MAPPER.readValue(jsonStr, MixedSuper4061.class);
        assertInstanceOf(MixedSuper4061.class, bean);
        assertInstanceOf(MixedSub4061A.class, bean);
    }<|file_separator|><nl>
        AtomicStringWrapper atomicStringWrapper = new AtomicStringWrapper("test");
        String json = MAPPER.writeValueAsString(atomicStringWrapper);
        System.out.println(json);
    }
<|file_separator|><nl>
        try {
            om.readValue("{}", DoSomethingCommand.class);
            fail("Should not pass");
        } catch (InvalidTypeIdException e) {
            verifyException(e, "missing type id property '@type'");
        }
    }
}<|file_separator|><nl>
        List<Class> subTypes = new ArrayList<Class>();
        subTypes.add(Child.class);
        subTypes.add(Child2.class);
        subTypes.add(Parent.class);
        subTypes.add(Object.class);
        subTypes.add(Object.class);
        subTypes.add(Object.class);
        subTypes.add(Object.class);
        subTypes.add(Object.class);
        subTypes.add(Object.class);
        subTypes.add(Object.class);
        subTypes.add(Object.class);
        subTypes.add(Object.class);
        subTypes.add(Object.class);
        subTypes.add(Object.class);
        subTypes.add(Object.class);
        subTypes.add(Object.class);
        subTypes.add(Object.class);
        subTypes.add(Object.class);
        subTypes.add(Object.class);
        subTypes.add(Object.class);
        subTypes.add(Object.class);
        subTypes.add(Object.class);
        subTypes.add(Object.class);
        subTypes.add(Object.class);
        subTypes.add(Object.class);
        subTypes.add(Object.class);
        subTypes.add(Object.class);
        subTypes.add(Object.class);
        subTypes.add(Object.class);
        subTypes.add(Object.class);
        subTypes.add(Object.class);
        subTypes.add(Object.class);
        subTypes.add(Object.class);
        subTypes.add(Object.class);
        subTypes.add(Object.class);<nl>
    Cat cat = new AnotherLiveCat();
    cat.angry = true;
  }<|file_separator|><nl>
        final String[] values = {"one", "two", "three"};
        final DataValueList list = new DataValueList();
        for (final String value : values)
        {
            list.add(value);
        }
        assertEquals(values.length, list.size());
        for (int i = 0; i < values.length; i++)
        {
            assertEquals(values[i], list.get(i));
        }
    }<|file_separator|><nl>
            try {
                return new Dog(p.getCodec().readValueAsTree(p, Dog.class));
            } catch (IOException e) {
                throw new JsonParseException(e);
            }
        <|file_separator|><nl>
        String JSON = "{"base64Text":"aGVsbG8="}";
        JsonNode root = MAPPER.readTree(JSON);
        Base64Text base64Text = MAPPER.treeToValue(root, Base64Text.class);
        assertEquals("hello", base64Text.text);
    }<|file_separator|><nl>
        JsonNodeFactory factory = new SortingNodeFactory();
        ObjectNode objectNode = (ObjectNode) factory.objectNode();
        objectNode.put("name", "test");
        objectNode.put("age", 10);
        objectNode.put("height", 1.8);
        objectNode.put("isMale", true);
        System.out.println(objectNode);
    }<|file_separator|><nl>
        // so by default we'll get null written
        assertEquals(JSON_WITH_NULL, WRITER.writeValueAsString(DOC_WITH_NULL));

        ObjectMapper noNullsMapper = JsonMapper.builder()
                .enable(JsonNodeFeature.SORT_PROPERTIES_ALPHABETICALLY)
                .build();
        ObjectWriter w = noNullsMapper.writer();
        assertFalse(w.isEnabled(JsonNodeFeature.SORT_PROPERTIES_ALPHABETICALLY));
        assertEquals(JSON_WITH_NULL, w.writeValueAsString(DOC_WITH_NULL));
    <|file_separator|><nl>
        final String json = "{\n" +
                "  \"name\": \"root\",\n" +
                "  \"children\": [\n" +
                "    {\n" +
                "      \"name\": \"child1\",\n" +
                "      \"children\": [\n" +
                "        {\n" +
                "          \"name\": \"child1.1\",\n" +
                "          \"children\": [\n" +
                "            {\n" +
                "              \"name\": \"child1.1.1\",\n" +
                "              \"children\": [\n" +
                "                {\n" +
                "                  \"name\": \"child1.1.1.1\",\n" +
                "                  \"children\": [\n" +
                "                    {\n" +
                "                      \"name\": \"child1.1.1.1.1\",\n" +
                "                      \"children\": [\n" +
                "                        {\n" +
                "                          \"name\": \"child1.1.1.1.1.1\",\n" +
                "                          \"children\": [\n" +
                "                            {\n" +
                "                              \"name\": \"child1.1.1.1.1.1.1\",\n" +
                "                              \"children\": [\n" +
                "                                {\n" +
                "                                  \"name\": \"child1.1.1.1.1.1.1.1\",\n" +
                "                                  \"children\": [\n" +
                "                                    {\n" +
                "                                      \"name\": \"child1.1.1.1.1.1.1.1.1\",\n" +
                "<nl>
        SimpleFieldBean bean = new SimpleFieldBean();
        // let's set x, leave y as is
        bean.x = 13;
        Map<String,Object> result = writeAndMap(MAPPER, bean);
        assertEquals(2, result.size());
        assertEquals(Integer.valueOf(13), result.get("x"));
        assertEquals(Integer.valueOf(0), result.get("y"));
    }<|file_separator|><nl>
        assertEquals("{"a":"a","b":"b"}", MAPPER.writeValueAsString(new MapValueWrapper()));
    }
<|file_separator|><nl>
        // test for [JACKSON-311]
        ObjectMapper mapper = new ObjectMapper();
        String s = mapper.writeValueAsString(new StringListBean(Arrays.asList("a")));
        assertEquals("[\"a\"]", s);
    }
<|file_separator|><nl>
        final ObjectMapper mapper = new ObjectMapper();
        mapper.registerModule(new JavaTimeModule());
        mapper.registerModule(new EnumModule());
        final String json = _w(EnumBaseA.ITEM_A, mapper);
        assertEquals("A_base", json);
        final EnumBaseA a = mapper.readValue(json, EnumBaseA.class);
        assertEquals(EnumBaseA.ITEM_A, a);
        final String json2 = _w(EnumMixinA.ITEM_A, mapper);
        assertEquals("A_mixin", json2);
        final EnumMixinA a2 = mapper.readValue(json2, EnumMixinA.class);
        assertEquals(EnumMixinA.ITEM_A, a2);
    <|file_separator|><nl>
        Item3160 item = new Item3160();
        item.setAmount(100);
        item.setCurrency("USD");
        item.setAmount(100);
        item.setCurrency("USD");
        item.setAmount(100);
        item.setCurrency("USD");
        item.setAmount(100);
        item.setCurrency("USD");
        item.setAmount(100);
        item.setCurrency("USD");
        item.setAmount(100);
        item.setCurrency("USD");
        item.setAmount(100);
        item.setCurrency("USD");
        item.setAmount(100);
        item.setCurrency("USD");
    }<|file_separator|><nl>
        FilterProvider prov = new SimpleFilterProvider().addFilter("RootFilter",
                SimpleBeanPropertyFilter.filterOutAllExcept("a"));
        assertEquals("{"a":"a"}", MAPPER.writer(prov).writeValueAsString(new Bean()));
    }
<|file_separator|><nl>
        ObjectMapper om = new ObjectMapper();
        om.setSerializationInclusion(JsonInclude.Include.ALWAYS);

        final String jsonString = om.writeValueAsString(new Issue1327BeanAlways());

        if (!jsonString.contains("myList")) {
            fail("Should contain `myList`: "+jsonString);
        }
    }<|file_separator|><nl>
            return false;
        <|file_separator|><nl>
        String json = a2q(
                "{ 'roles': { 'Name': 'User', 'ID': '333' } }");
        RolesInList response = MAPPER.readValue(json, RolesInList.class);
        assertNotNull(response.roles);
        assertEquals(1, response.roles.size());
        assertEquals("333", response.roles.get(0).ID);
    }
<|file_separator|><nl>
            this.boolValue = boolValue;
        }

        public List<NestedItem> getNestedItems() {
            return nestedItems;
        }

        public void setNestedItems(List<NestedItem> nestedItems) {
            this.nestedItems = nestedItems;
        }
    }<|file_separator|><nl>
        ViewsAndCreatorBean bean = new ViewsAndCreatorBean(1, 2);
        String json = mapper.writeValueAsString(bean);
        System.out.println(json);
    }
<|file_separator|><nl>
        Foo foo = new Foo();
        String json = MAPPER.writeValueAsString(foo);
        System.out.println(json);
    }
<|file_separator|><nl>
        String json = "{\"field\": \"value\"}";
        Inner inner = new ObjectMapper().readValue(json, Inner.class);
        assertEquals("value", inner.getField());
    }
<|file_separator|><nl>
        SubA2039 sub = new SubA2039();
        sub.bool = true;
        sub.int = 1;
        sub.string = "string";
        sub.sub = new SubType2039();
        sub.sub.bool = true;
        sub.sub.int = 1;
        sub.sub.string = "string";
        sub.sub.sub = new SubType2039();
        sub.sub.sub.bool = true;
        sub.sub.sub.int = 1;
        sub.sub.sub.string = "string";
        sub.sub.sub.sub = new SubType2039();
        sub.sub.sub.sub.bool = true;
        sub.sub.sub.sub.int = 1;
        sub.sub.sub.sub.string = "string";
        sub.sub.sub.sub.sub = new SubType2039();
        sub.sub.sub.sub.sub.bool = true;
        sub.sub.sub.sub.sub.int = 1;
        sub.sub.sub.sub.sub.string = "string";
        sub.sub.sub.sub.sub.sub = new SubType2039();
        sub.sub.sub.sub.sub.sub.bool = true;
        sub.sub.sub.sub.sub.sub.int = 1;
        sub.sub.sub.sub.sub.sub.string = "string";
        sub.sub.sub.sub.sub.sub.sub = new SubType2039();
        sub.sub.sub.sub.sub.sub.sub.bool = true;
        <nl>
        new ManualReadPerfUntypedStream().run();
    <|file_separator|><nl>
        ManualWritePerfUntyped.main(args);
    <|file_separator|>class ManualWritePerfTyped
    extends ObjectWriterTestBase<Object,Object>
{
    @Override
    protected int targetSizeMegs() { return 15; }

    public static void main(String[] args) throws Exception
    {
        ManualWritePerfTyped.main(args);
    }

    @SuppressWarnings("resource")
    @Override
    protected double testSer(int REPS, Object value, ObjectWriter writer) throws Exception
    {
        long start = System.nanoTime();

        // As Bytes
        /*
//        byte[] output = null;
        NopOutputStream out = new NopOutputStream();
        while (--REPS >= 0) {
//            output = writer.writeValueAsBytes(value);
            writer.writeValue(out, value);
        }
        long nanos = System.nanoTime() - start;
        hash = out.size;
        out.close();
        */

        // As String

//        String output = null;
        NopWriter w = new NopWriter();
        while (--REPS >= 0) {
//            output = writer.writeValueAsString(value);
            writer.writeValue(w, value);
        }
        long nanos = System.nanoTime() - start;
//        hash = output.length();
        hash = w.size();

        return _msecsFromNanos(nanos);
    }
}<|file_separator|><nl>
        return this.getDeploymentResource(deploymentId, null, request);
    }

    @ApiOperation(value = "Get a deployment resource", tags = { "App Deployments" }, notes = "Replace ** by ResourceId")
    /*
     * @ApiImplicitParams({
     * 
     * @ApiImplicitParam(name = "resourceId", dataType = "string", value =
     * "The id of the resource to get. Make sure you URL-encode the resourceId in case it contains forward slashes. Eg: use folder%2FoneApp.app instead of folder/oneApp.app."
     * , paramType = "path") })
     */
    @ApiResponses(value = {
            @ApiResponse(code = 200, message = "Indicates both deployment and resource have been found and the resource has been returned."),
            @ApiResponse(code = 404, message = "Indicates the requested deployment was not found or there is no resource with the given id present in the deployment. The status-description contains additional information.")
    })
    @GetMapping(value = "/app-repository/deployments/{deploymentId}/resources/{resourceId}", produces = "application/json")
    public AppDeploymentResourceResponse getDeploymentResource(@ApiParam(name = "deploymentId") @PathVariable("deploymentId") String deploymentId, @ApiParam(name = "resourceId") @PathVariable("resourceId") String resourceId, HttpServletRequest request) {
        return this.getDeploymentResource(deploymentId, resourceId, request);
    }

    protected AppDeploymentResourceResponse getDeploymentResource(String deploymentId, String resourceId, HttpServletRequest request) {
        AppDeploymentResourceResponse response = new AppDeploymentResourceResponse();
        AppDeploymentResource resource = this.repositoryService.getDeploymentResource(deploymentId, resourceId);
        if (resource ==<nl>

        // given
        // that the AbstractEngineConfiguration is configured with forceCloseMybatisConnectionPool = false
        StandaloneInMemAppEngineConfiguration appEngineConfiguration =  new StandaloneInMemAppEngineConfiguration();
        appEngineConfiguration.setJdbcUrl("jdbc:h2:mem:flowable-app-" + this.getClass().getName());
        appEngineConfiguration.setForceCloseMybatisConnectionPool(false);

        AppEngine appEngine = appEngineConfiguration.buildAppEngine();


        PooledDataSource pooledDataSource = (PooledDataSource) appEngineConfiguration.getDataSource();
        PoolState state = pooledDataSource.getPoolState();
        assertThat(state.getIdleConnectionCount()).isPositive();

        // then
        // if the  engine is closed
        appEngine.close();

        // the idle connections are not closed
        assertThat(state.getIdleConnectionCount()).isPositive();
    <|file_separator|><nl>
        appRepositoryService.deleteDeployment(deploymentId1);
    <|file_separator|><nl>
        appRepositoryService.createDeployment().addClasspathResource("org/flowable/app/engine/test/vacationRequest.app").deploy();
    <|file_separator|><nl>
        return getBatchEntityManager().findBatchCountByQueryCriteria((BatchQueryImpl) batchQuery);
    <|file_separator|><nl>
        return getBatchServiceConfiguration().getBatchPartEntityManager();
    }

    protected BatchPartInstanceEntityManager getBatchPartInstanceEntityManager() {
        return getBatchServiceConfiguration().getBatchPartInstanceEntityManager();
    }

    protected BatchPartInstanceEventDispatcher getBatchPartInstanceEventDispatcher() {
        return getBatchServiceConfiguration().getBatchPartInstanceEventDispatcher();
    }

    protected BatchPartInstanceRepository getBatchPartInstanceRepository() {
        return getBatchServiceConfiguration().getBatchPartInstanceRepository();
    }

    protected BatchPartInstanceService getBatchPartInstanceService() {
        return getBatchServiceConfiguration().getBatchPartInstanceService();
    }

    protected BatchPartInstanceServiceConfiguration getBatchPartInstanceServiceConfiguration() {
        return getBatchServiceConfiguration().getBatchPartInstanceServiceConfiguration();
    }

    protected BatchPartInstanceServiceConfiguration getBatchPartInstanceServiceConfiguration() {
        return getBatchServiceConfiguration().getBatchPartInstanceServiceConfiguration();
    }

    protected BatchPartInstanceServiceConfiguration getBatchPartInstanceServiceConfiguration() {
        return getBatchServiceConfiguration().getBatchPartInstanceServiceConfiguration();
    }

    protected BatchPartInstanceServiceConfiguration getBatchPartInstanceServiceConfiguration() {
        return getBatchServiceConfiguration().getBatchPartInstanceServiceConfiguration();
    }

    protected BatchPartInstanceServiceConfiguration getBatchPartInstanceServiceConfiguration() {
        return getBatchServiceConfiguration().getBatchPartInstanceServiceConfiguration();
    }

    protected BatchPartInstanceServiceConfiguration getBatchPartInstanceServiceConfiguration() {
        return getBatchServiceConfiguration().getBatchPartInstanceServiceConfiguration();
    }

    protected BatchPartInstanceServiceConfiguration getBatchPartInstanceServiceConfiguration() {
        return getBatchServiceConfiguration().getBatchPartInstanceServiceConfiguration();
    }

    protected BatchPartInstanceServiceConfiguration getBatchPartInstanceServiceConfiguration() {
        return<nl>
        HashMap<String, Object> params = new HashMap<>();
        params.put("batchId", batchId);
        params.put("status", status);
        
        return getDbSqlSession().selectList("selectBatchPartsByBatchIdAndStatus", params);
    }
    
    @Override
    @SuppressWarnings("unchecked")
    public List<BatchPart> findBatchPartsByScopeId(String scopeId) {
        HashMap<String, Object> params = new HashMap<>();
        params.put("scopeId", scopeId);
        
        return getDbSqlSession().selectList("selectBatchPartsByScopeId", params);
    <|file_separator|><nl>
        writer.writeAttribute(prefix, namespaceURI, localName, value);
    <|file_separator|><nl>
        // TODO Auto-generated method stub
        
    <|file_separator|><nl>
        String documentation = xtr.getElementText();
        if (documentation != null) {
            parentElement.setDocumentation(documentation);
        }
    <|file_separator|><nl>
        String id = xtr.getAttributeValue(null, "id");
        String name = xtr.getAttributeValue(null, "name");
        String type = xtr.getAttributeValue(null, "type");
        String ref = xtr.getAttributeValue(null, "ref");
        String refType = xtr.getAttributeValue(null, "refType");
        String refName = xtr.getAttributeValue(null, "refName");
        String refId = xtr.getAttributeValue(null, "refId");
        String refElement = xtr.getAttributeValue(null, "refElement");
        String refElementId = xtr.getAttributeValue(null, "refElementId");
        String refElementName = xtr.getAttributeValue(null, "refElementName");
        String refElementRef = xtr.getAttributeValue(null, "refElementRef");
        String refElementRefType = xtr.getAttributeValue(null, "refElementRefType");
        String refElementRefName = xtr.getAttributeValue(null, "refElementRefName");
        String refElementRefId = xtr.getAttributeValue(null, "refElementRefId");
        String refElementRefElement = xtr.getAttributeValue(null, "refElementRefElement");
        String refElementRefElementId = xtr.getAttributeValue(null, "refElementRefElementId");
        String refElementRefElementName = xtr.getAttributeValue(null, "refElementRefElementName");
        String refElementRefElementRef = xtr.getAttributeValue(null, "refElementRefElementRef");
        String refElementRefElementRefType = xtr.getAttributeValue(null, "refElementRefElementRefType");
        String refElementRefElementRefName = xtr.getAttributeValue(null,<nl>
        SignalEventDefinition signalEventDefinition = new SignalEventDefinition();
        signalEventDefinition.setEventDefinition(parentElement);
        signalEventDefinition.setEventDefinitionName(xtr.getAttributeValue(0));
        signalEventDefinition.setEventDefinitionType(xtr.getAttributeValue(1));
        signalEventDefinition.setEventDefinitionValue(xtr.getAttributeValue(2));
        signalEventDefinition.setEventDefinitionValueExpression(xtr.getAttributeValue(3));
        signalEventDefinition.setEventDefinitionValueExpressionType(xtr.getAttributeValue(4));
        signalEventDefinition.setEventDefinitionValueExpressionType(xtr.getAttributeValue(5));
        signalEventDefinition.setEventDefinitionValueExpressionType(xtr.getAttributeValue(6));
        signalEventDefinition.setEventDefinitionValueExpressionType(xtr.getAttributeValue(7));
        signalEventDefinition.setEventDefinitionValueExpressionType(xtr.getAttributeValue(8));
        signalEventDefinition.setEventDefinitionValueExpressionType(xtr.getAttributeValue(9));
        signalEventDefinition.setEventDefinitionValueExpressionType(xtr.getAttributeValue(10));
        signalEventDefinition.setEventDefinitionValueExpressionType(xtr.getAttributeValue(11));
        signalEventDefinition.setEventDefinitionValueExpressionType(xtr.getAttributeValue(12));
        signalEventDefinition.setEventDefinitionValueExpressionType(xtr.getAttributeValue(13));
        signalEventDefinition.setEventDefinitionValueExpressionType(xtr.getAttributeValue(14));
        signalEventDefinition.setEventDefinitionValueExpressionType(xtr.getAttributeValue(15));
        signalEventDefinition.setEventDefinitionValueExpressionType(xtr.getAttributeValue(16));
        signalEventDefinition.setEventDefinitionValueExpressionType(xtr.getAttribute<nl>
        if (fieldExtensionList != null && !fieldExtensionList.isEmpty()) {
            if (didWriteExtensionStartElement) {
                xtw.writeStartElement(FIELD_EXTENSIONS);
            }
            for (FieldExtension fieldExtension : fieldExtensionList) {
                if (fieldExtension != null) {
                    if (fieldExtension.getExtensionId() != null) {
                        xtw.writeStartElement(FIELD_EXTENSION);
                        xtw.writeAttribute(EXTENSION_ID, fieldExtension.getExtensionId());
                        xtw.writeEndElement();
                    }
                }
            }
            if (didWriteExtensionStartElement) {
                xtw.writeEndElement();
            }
        }
        return true;
    <|file_separator|><nl>
        String elementName = xtr.getLocalName();
        if (elementName.equals(MESSAGEFLOW)) {
            String id = xtr.getAttributeValue(null, ID);
            String name = xtr.getAttributeValue(null, NAME);
            String sourceRef = xtr.getAttributeValue(null, SOURCE);
            String targetRef = xtr.getAttributeValue(null, TARGET);
            String type = xtr.getAttributeValue(null, TYPE);
            String condition = xtr.getAttributeValue(null, CONDITION);
            String conditionExpression = xtr.getAttributeValue(null, CONDITION_EXPRESSION);
            String conditionType = xtr.getAttributeValue(null, CONDITION_TYPE);
            String conditionValue = xtr.getAttributeValue(null, CONDITION_VALUE);
            String conditionValueExpression = xtr.getAttributeValue(null, CONDITION_VALUE_EXPRESSION);
            String conditionValueVariable = xtr.getAttributeValue(null, CONDITION_VALUE_VARIABLE);
            String conditionValueVariableType = xtr.getAttributeValue(null, CONDITION_VALUE_VARIABLE_TYPE);
            String conditionValueVariableValue = xtr.getAttributeValue(null, CONDITION_VALUE_VARIABLE_VALUE);
            String conditionValueVariableValueType = xtr.getAttributeValue(null, CONDITION_VALUE_VARIABLE_VALUE_TYPE);
            String conditionValueVariableValueExpression = xtr.getAttributeValue(null, CONDITION_VALUE_VARIABLE_VALUE_EXPRESSION);
            String conditionValueVariableValueVariable = xtr.getAttributeValue(null, CONDITION_VALUE_VARIABLE_VALUE_VARIABLE);
            String conditionValueVariableValueVariableType = xtr.getAttributeValue(null, CONDITION_VALUE_VARIABLE_VALUE_VARIABLE_TYPE);
            String conditionValueVariableValueVariableValue = xtr.getAttributeValue(null, CONDITION_VALUE_VARIABLE_VALUE_VARIABLE_VALUE<nl>
        // TODO: Add your test code here
    <|file_separator|><nl>
        assertNotNull(model);
    <|file_separator|><nl>
        assertEquals(1, model.getProcesses().size());
    <|file_separator|><nl>
        // TODO: Add your test code here
    <|file_separator|><nl>
        assertNotNull(model);
    <|file_separator|><nl>
        assertNotNull(model);
    <|file_separator|><nl>
        // do something
    <|file_separator|><nl>
        return modelSupplier.get();
    <|file_separator|><nl>
        return to;
    <|file_separator|><nl>
    	return new DoubleDataObject(this.value);
    <|file_separator|><nl>
        return new EventGateway(this);
    }

    public EventGateway(EventGateway otherElement) {
        super(otherElement);
    <|file_separator|>class Gateway.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class Gateway {

    public Gateway() {
    }

    public Gateway(Gateway otherElement) {
    }

    public void setValues(Gateway otherElement) {
    }
}<|file_separator|>class Event.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class Event {

    public Event() {
    }

    public Event(Event otherElement) {
    }

    public void setValues(Event otherElement) {
    }
}<|file_separator|><nl>
        return new FlowableHttpRequestHandler(this.getFlowable());
    <|file_separator|><nl>
        return new FlowableHttpResponseHandler();
    <|file_separator|><nl>
        return new ManualTask(this);
    <|file_separator|><nl>
        this.executable = executable;
    <|file_separator|>class BaseElement.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class BaseElement {
    protected String id;
    protected String name;
    protected String description;
    protected String type;
    protected String version;
    protected String status;
    protected String owner;
    protected String ownerGroup;
    protected String ownerUser;
    protected String ownerGroupUser;
    protected String ownerGroupUserPassword;
    protected String ownerGroupUserPasswordHash;
    protected String ownerGroupUserPasswordHashAlgorithm;
    protected String ownerGroupUserPasswordHashAlgorithmName;
    protected String ownerGroupUserPasswordHashAlgorithmNameId;
    protected String ownerGroupUserPasswordHashAlgorithmNameIdAlgorithm;
    protected String ownerGroupUserPasswordHashAlgorithmNameIdAlgorithmName;
    protected String ownerGroupUserPasswordHashAlgorithmNameIdAlgorithmNameId;
    protected String ownerGroupUserPasswordHashAlgorithmNameIdAlgorithmNameIdAlgorithm;
    protected String ownerGroupUserPasswordHashAlgorithmNameIdAlgorithmNameIdAlgorithmName;
    protected String ownerGroupUserPasswordHashAlgorithmNameIdAlgorithmNameIdAlgorithmNameId;
    protected String ownerGroupUserPasswordHashAlgorithmNameIdAlgorithmNameIdAlgorithmNameIdAlgorithm;
    protected String ownerGroupUserPasswordHashAlgorithmNameIdAlgorithmNameIdAlgorithmNameIdAlgorithmName;
    protected String ownerGroupUserPasswordHashAlgorithmNameIdAlgorithmNameIdAlgorithmNameIdAlgorithmNameId;
    protected String ownerGroupUserPasswordHashAlgorithmNameIdAlgorithmNameIdAlgorithmNameIdAlgorithmNameIdAlgorithm;
    protected String ownerGroupUserPasswordHashAlgorithmNameIdAlgorithmNameIdAlgorithmNameIdAlgorithmNameIdAlgorithmName;
    protected String ownerGroupUserPasswordHashAlgorithmNameIdAlgorithmNameIdAlgorithmNameIdAlgorithmNameIdAlgorithmNameId;
    protected String ownerGroupUserPasswordHashAlgorithmNameIdAlgorithmNameIdAlgorithmNameIdAlgorithmNameIdAlgorithm<nl>
        <|file_separator|><nl>
        // TODO Auto-generated method stub
        
    <|file_separator|><nl>
        endpoint.setVariable("body", endpoint.getBody());
    <|file_separator|><nl>
        service1 = (MockEndpoint) camelContext.getEndpoint("mock:service1");
        service1.expectedMessageCount(1);
        service1.expectedBodiesReceived("ala");

        service2 = (MockEndpoint) camelContext.getEndpoint("mock:service2");
        service2.expectedMessageCount(1);
        service2.expectedBodiesReceived("var2");
    <|file_separator|><nl>
        // do something
    <|file_separator|><nl>
        validators.add(validator);
    <|file_separator|>class Validator.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public interface Validator {

    public boolean validate(String value);
}<|file_separator|>class ValidatorSetFactory.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class ValidatorSetFactory {

    public static ValidatorSet createValidatorSet(String name) {
        return new ValidatorSet(name);
    }
}<|file_separator|><nl>
        PlanModel planModel = new PlanModel();
        planModel.setPlanName("Test");
        planModel.setPlanDescription("Test");
        planModel.setPlanPrice(100);
        planModel.setPlanDuration(1);
        planModel.setPlanStatus(true);
        planModel.setPlanType("Test");
        planModel.setPlanImage("Test");
        planModel.setPlanFeatures("Test");
        planModel.setPlanFeatures("Test");
        planModel.setPlanFeatures("Test");
        planModel.setPlanFeatures("Test");
        planModel.setPlanFeatures("Test");
        planModel.setPlanFeatures("Test");
        planModel.setPlanFeatures("Test");
        planModel.setPlanFeatures("Test");
        planModel.setPlanFeatures("Test");
        planModel.setPlanFeatures("Test");
        planModel.setPlanFeatures("Test");
        planModel.setPlanFeatures("Test");
        planModel.setPlanFeatures("Test");
        planModel.setPlanFeatures("Test");
        planModel.setPlanFeatures("Test");
        planModel.setPlanFeatures("Test");
        planModel.setPlanFeatures("Test");
        planModel.setPlanFeatures("Test");
        planModel.setPlanFeatures("Test");
        planModel.setPlanFeatures("Test");
        planModel.setPlanFeatures("Test");
        planModel.setPlanFeatures("Test");
        planModel.setPlanFeatures("Test");
        planModel.setPlanFeatures("Test");
        planModel.setPlanFeatures("Test");
        planModel.setPlanFeatures("Test");
        planModel.setPlanFeatures("Test");
        planModel.setPlanFeatures("Test");
        <nl>
        return businessProcess.getProcessInstance();
    <|file_separator|><nl>
        return processInstance.getBusinessKey();
    <|file_separator|><nl>
        if (businessProcess.isComplete()) {
            return ctx.proceed();
        }
        return null;
    <|file_separator|><nl>
        return getWrappedResolver().getValue(this.context, base, property);
    <|file_separator|><nl>
        return activityId;
    <|file_separator|><nl>
        if (jndiName == null) {
            return null;
        }
        return JndiUtil.lookupBeanManager(jndiName);
    <|file_separator|><nl>
        TestEventListener listenerBean = getBeanInstance(TestEventListener.class);
        listenerBean.reset();

        assertThat(listenerBean.getEventsReceivedByKey()).isEmpty();
        // start the process
        runtimeService.startProcessInstanceByKey("process1");

        // assert that now the bean has received 11 events
        assertThat(listenerBean.getEventsReceivedByKey()).hasSize(11);
    <|file_separator|><nl>
        // TODO
    <|file_separator|><nl>
        this.batchId = batchId;
    <|file_separator|><nl>
        return convert(xtr, conversionHelper);
    <|file_separator|><nl>
        CmmnCase cmmnCase = new CmmnCase();
        
        cmmnCase.setCaseId(conversionHelper.getXmlText(xtr, CmmnXmlConstants.ATTRIBUTE_CASE_ID));
        cmmnCase.setCaseName(conversionHelper.getXmlText(xtr, CmmnXmlConstants.ATTRIBUTE_CASE_NAME));
        cmmnCase.setCaseDescription(conversionHelper.getXmlText(xtr, CmmnXmlConstants.ATTRIBUTE_CASE_DESCRIPTION));
        
        return cmmnCase;
    <|file_separator|><nl>
        return new Condition(conversionHelper);
    <|file_separator|>class ConditionXmlConverter.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>package com.cmmn.xml.converter;

import com.cmmn.xml.CmmnXmlConstants;
import com.cmmn.xml.CmmnXmlConstants.ConditionType;
import com.cmmn.xml.CmmnXmlConstants.OperatorType;
import com.cmmn.xml.CmmnXmlConstants.OperatorType.Operator;
import com.cmmn.xml.CmmnXmlConstants.OperatorType.Operator.OperatorType;
import com.cmmn.xml.CmmnXmlConstants.OperatorType.Operator.OperatorType.OperatorType;
import com.cmmn.xml.CmmnXmlConstants.OperatorType.Operator.OperatorType.OperatorType.OperatorType;
import com.cmmn.xml.CmmnXmlConstants.OperatorType.Operator.OperatorType.OperatorType.OperatorType.OperatorType;
import com.cmmn.xml.CmmnXmlConstants.OperatorType.Operator.OperatorType.OperatorType.OperatorType.OperatorType.OperatorType;
import com.cmmn.xml.CmmnXmlConstants.OperatorType.Operator.OperatorType.OperatorType.OperatorType.OperatorType.OperatorType.OperatorType;
import com.cmmn.xml.CmmnXmlConstants.OperatorType.Operator.OperatorType.OperatorType.OperatorType.OperatorType.OperatorType.OperatorType.OperatorType;
import com.cmmn.xml.CmmnXmlConstants.OperatorType.Operator.OperatorType.OperatorType.OperatorType.OperatorType.OperatorType.OperatorType.OperatorType;
import com.cmmn.xml.CmmnXmlConstants.OperatorType.<nl>
        return new ProcessRefExpression(conversionHelper.getProcessRefExpressionId(xtr));
    <|file_separator|>class ProcessRefExpression.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class ProcessRefExpression extends CmmnElement {
    
    private String processRefExpressionId;
    
    public ProcessRefExpression(String processRefExpressionId) {
        this.processRefExpressionId = processRefExpressionId;
    }
    
    public String getProcessRefExpressionId() {
        return processRefExpressionId;
    }
    
    public void setProcessRefExpressionId(String processRefExpressionId) {
        this.processRefExpressionId = processRefExpressionId;
    }
    
    @Override
    public String toString() {
        return "ProcessRefExpression [processRefExpressionId=" + processRefExpressionId + "]";
    }
    
}<|file_separator|>class ProcessRefExpressionXmlConverter.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class ProcessRefExpressionXmlConverter extends CaseElementXmlConverter {
    
    @Override
    public String getXMLElementName() {
        return CmmnXmlConstants.ELEMENT_PROCESS_REF_EXPRESSION;
    }
    
    @Override
    public boolean hasChildElements() {
        return false;
    }

    @Override
    protected CmmnElement convert(XMLStreamReader xtr, ConversionHelper conversionHelper) {
        return new ProcessRefExpression(conversionHelper.getProcessRefExpressionId(xtr));
    }
    
}<|file_separator|><nl>
        StandardEvent standardEvent = new StandardEvent();
        standardEvent.setEventCode(xtr.getAttributeValue(0));
        standardEvent.setEventDescription(xtr.getAttributeValue(1));
        return standardEvent;
    <|file_separator|><nl>
        return "timer-expression";
    <|file_separator|><nl>
        xtw.writeStartElement(NS_PREFIX, "definitions", NS_URI);
        xtw.writeAttribute("xmlns", NS_URI);
        xtw.writeAttribute("xmlns:xsi", XSI_URI);
        xtw.writeAttribute("xsi:schemaLocation", NS_URI + " " + NS_URI + "definitions.xsd");
        xtw.writeAttribute("xmlns:flowable-extensions", FLOWABLE_EXTENSIONS_URI);
        xtw.writeAttribute("xmlns:cmmndi", CMMNDI_URI);
        xtw.writeAttribute("xmlns:omgdc", OMGDC_URI);
        xtw.writeAttribute("xmlns:omgdi", OMGDI_URI);
        xtw.writeAttribute("xmlns:cmmn", CMMN_URI);
        xtw.writeAttribute("xmlns:cmmn2", CMMN2_URI);
        xtw.writeAttribute("xmlns:cmmn3", CMMN3_URI);
        xtw.writeAttribute("xmlns:cmmn4", CMMN4_URI);
        xtw.writeAttribute("xmlns:cmmn5", CMMN5_URI);
        xtw.writeAttribute("xmlns:cmmn6", CMMN6_URI);
        xtw.writeAttribute("xmlns:cmmn7", CMMN7_URI);
        xtw.writeAttribute("xmlns:cmmn8", CMMN8_URI);
        xtw.writeAttribute("xmlns:cmmn9", CMMN9_URI);
        xtw.writeAttribute("xmlns:cmmn10", CMMN10_URI);
        xtw.writeAttribute("xmlns:cmmn11", CMMN11_URI);
        xtw.writeAttribute("<nl>
        super.writePlanItemDefinitionSpecificAttributes(processTask, xtw);
        
        if (StringUtils.isNotEmpty(processTask.getProcessRef()) || StringUtils.isNotEmpty(processTask.getProcessRefExpression())) {
            xtw.writeAttribute(ATTRIBUTE_PROCESS_REF, processTask.getProcessRef());
        }
    <|file_separator|><nl>
        xtw.writeAttribute(ATTR_ID, task.getId());
        xtw.writeAttribute(ATTR_NAME, task.getName());
        xtw.writeAttribute(ATTR_DESCRIPTION, task.getDescription());
        xtw.writeAttribute(ATTR_STATUS, task.getStatus().name());
        xtw.writeAttribute(ATTR_PRIORITY, task.getPriority().name());
        xtw.writeAttribute(ATTR_DUE_DATE, task.getDueDate().toString());
        xtw.writeAttribute(ATTR_START_DATE, task.getStartDate().toString());
        xtw.writeAttribute(ATTR_CREATED_DATE, task.getCreatedDate().toString());
        xtw.writeAttribute(ATTR_CREATED_BY, task.getCreatedBy());
        xtw.writeAttribute(ATTR_LAST_MODIFIED_DATE, task.getLastModifiedDate().toString());
        xtw.writeAttribute(ATTR_LAST_MODIFIED_BY, task.getLastModifiedBy());
    <|file_separator|><nl>
        ScriptInfo scriptInfo = new ScriptInfo();
        CmmnXmlUtil.addXMLLocation(scriptInfo, xtr);
        scriptInfo.setScript(xtr.getAttributeValue(null, CmmnXmlConstants.ATTRIBUTE_SCRIPT));
        return scriptInfo;
    <|file_separator|><nl>
        assertThat(cmmnModel).isNotNull();
        Case primaryCase = cmmnModel.getPrimaryCase();
        assertThat(primaryCase).isNotNull();
        assertThat(primaryCase.getExtensionElements()).containsOnlyKeys("customElement");

        List<ExtensionElement> customElements = primaryCase.getExtensionElements().get("customElement");
        assertThat(customElements)
                .extracting(ExtensionElement::getElementText,
                        ExtensionElement::getNamespacePrefix,
                        ExtensionElement::getNamespace,
                        extensionElement -> extensionElement.getAttributeValue(null, "attribute"))
                .containsExactly(tuple("Element text", "flowable", "http://flowable.org/cmmn", "Value"));<|file_separator|><nl>
        assertEquals("org.flowable.test.cmmn.converter.case.custom.extension.attribute", cmmnModel.getProcessDefinition(0).getProcessDefinitionXml().getProcess().getExtensionElements().getExtensionElement("custom").getExtensionElements().getExtensionElement("attribute").getExtensionElements().getExtensionElement("attribute").getExtensionElements().getExtensionElement("attribute").getExtensionElements().getExtensionElement("attribute").getExtensionElements().getExtensionElement("attribute").getExtensionElements().getExtensionElement("attribute").getExtensionElements().getExtensionElement("attribute").getExtensionElements().getExtensionElement("attribute").getExtensionElements().getExtensionElement("attribute").getExtensionElements().getExtensionElement("attribute").getExtensionElements().getExtensionElement("attribute").getExtensionElements().getExtensionElement("attribute").getExtensionElements().getExtensionElement("attribute").getExtensionElements().getExtensionElement("attribute").getExtensionElements().getExtensionElement("attribute").getExtensionElements().getExtensionElement("attribute").getExtensionElements().getExtensionElement("attribute").getExtensionElements().getExtensionElement("attribute").getExtensionElements().getExtensionElement("attribute").getExtensionElements().getExtensionElement("attribute").getExtensionElements().getExtensionElement("attribute").getExtensionElements().getExtensionElement("attribute").getExtensionElements().getExtensionElement("attribute").getExtensionElements().getExtensionElement("attribute").getExtensionElements().getExtensionElement("attribute").getExtensionElements().getExtensionElement("attribute").getExtensionElements().getExtensionElement("attribute").getExtensionElements().getExtensionElement("attribute").getExtensionElements().getExtensionElement("attribute").getExtensionElements().getExtensionElement("attribute").getExtensionElements().getExtensionElement("attribute").getExtensionElements().getExtensionElement("attribute").getExtensionElements().getExtensionElement("attribute").getExtensionElements().getExtensionElement("attribute").getExtensionElements().getExtension<nl>
        // TODO: Implement test<|file_separator|><nl>
        // TODO: add your test here<|file_separator|><nl>
        HumanTaskVariableCompleter humanTaskVariableCompleter = (HumanTaskVariableCompleter) cmmnModel.getFlowElement("humanTaskVariableCompleter");
        assertEquals("humanTaskVariableCompleter", humanTaskVariableCompleter.getName());
        assertEquals("humanTaskVariableCompleter", humanTaskVariableCompleter.getRef());
        assertEquals("humanTaskVariableCompleter", humanTaskVariableCompleter.getRefId());
        assertEquals("humanTaskVariableCompleter", humanTaskVariableCompleter.getRefName());
        assertEquals("humanTaskVariableCompleter", humanTaskVariableCompleter.getRefType());
        assertEquals("humanTaskVariableCompleter", humanTaskVariableCompleter.getRefVersion());
        assertEquals("humanTaskVariableCompleter", humanTaskVariableCompleter.getRefKey());
        assertEquals("humanTaskVariableCompleter", humanTaskVariableCompleter.getRefNamespace());
        assertEquals("humanTaskVariableCompleter", humanTaskVariableCompleter.getRefSchema());
        assertEquals("humanTaskVariableCompleter", humanTaskVariableCompleter.getRefPath());
        assertEquals("humanTaskVariableCompleter", humanTaskVariableCompleter.getRefUrl());
        assertEquals("humanTaskVariableCompleter", humanTaskVariableCompleter.getRefClass());
        assertEquals("humanTaskVariableCompleter", humanTaskVariableCompleter.getRefInterface());
        assertEquals("humanTaskVariableCompleter", humanTaskVariableCompleter.getRefInterfaceVersion());
        assertEquals("humanTaskVariableCompleter", humanTaskVariableCompleter.getRefInterfaceKey());
        assertEquals("humanTaskVariableCompleter", humanTaskVariableCompleter.getRefInterfaceNamespace());
        assertEquals("humanTaskVariableCompleter", humanTaskVariableCompleter.getRefInterfaceSchema());
        assertEquals("humanTaskVariableCompleter", humanTaskVariableCompleter.getRefInterfacePath());
        assertEquals<nl>
        // TODO: add your test code here<|file_separator|><nl>
        // TODO: Add your test code here<|file_separator|><nl>
        assertNotNull(cmmnModel);
        assertNotNull(cmmnModel.getDefinitions());
        assertEquals(1, cmmnModel.getDefinitions().size());
        Definition definition = cmmnModel.getDefinitions().get(0);
        assertNotNull(definition);
        assertEquals("parentCompletionRuleAtPlanItem", definition.getId());
        assertEquals("parentCompletionRuleAtPlanItem", definition.getName());
        assertEquals("parentCompletionRuleAtPlanItem", definition.getProcessId());
        assertEquals("parentCompletionRuleAtPlanItem", definition.getProcessType());
        assertEquals("parentCompletionRuleAtPlanItem", definition.getProcessCategory());
        assertEquals("parentCompletionRuleAtPlanItem", definition.getProcessDescription());
        assertEquals("parentCompletionRuleAtPlanItem", definition.getProcessVersion());
        assertEquals("parentCompletionRuleAtPlanItem", definition.getProcessVersionTag());
        assertEquals("parentCompletionRuleAtPlanItem", definition.getProcessVersionDescription());
        assertEquals("parentCompletionRuleAtPlanItem", definition.getProcessVersionCategory());
        assertEquals("parentCompletionRuleAtPlanItem", definition.getProcessVersionDescription());
        assertEquals("parentCompletionRuleAtPlanItem", definition.getProcessVersionDescription());
        assertEquals("parentCompletionRuleAtPlanItem", definition.getProcessVersionDescription());
        assertEquals("parentCompletionRuleAtPlanItem", definition.getProcessVersionDescription());
        assertEquals("parentCompletionRuleAtPlanItem", definition.getProcessVersionDescription());
        assertEquals("parentCompletionRuleAtPlanItem", definition.getProcessVersionDescription());
        assertEquals("parentCompletionRuleAtPlanItem", definition.getProcessVersionDescription());
        assertEquals("parentCompletionRuleAtPlanItem", definition.getProcessVersionDescription());
        assertEquals("parentCompletionRuleAtPlanItem", definition.getProcessVersionDescription());
        assertEquals("parentCompletionRuleAtPlan<nl>
        // TODO: Implement the test<|file_separator|><nl>
        System.out.println("Hello World!");
    <|file_separator|><nl>
        // given
        String processId = "VariablesTest";
        String variableName = "testVariable";
        String variableValue = "testValue";

        // when
        Map<String, Object> variables = new HashMap<>();
        variables.put(variableName, variableValue);
        Map<String, Object> processInstanceResult = runtimeService.startProcessInstanceByKey(processId, variables);
        Map<String, Object> processInstance = runtimeService.createProcessInstanceView(processInstanceResult.get("processInstanceId").toString());
        Map<String, Object> processVariables = processInstance.get("variables").toString();

        // then
        assertThat(processVariables).containsEntry(variableName, variableValue);
        runtimeService.deleteVariable(processInstanceResult.get("processInstanceId").toString(), variableName);
        processInstance = runtimeService.createProcessInstanceView(processInstanceResult.get("processInstanceId").toString());
        assertThat(processInstance.get("variables")).doesNotContainEntry(variableName);
    <|file_separator|><nl>
        return cmmnEngineConfiguration.getCmmnManagementService().createHistoricCaseInstanceCleaningQuery()
                .completeTimeLowerThan(getEndedBefore())
                .caseInstanceType(CaseInstance.HISTORIC_CASE_INSTANCE_TYPE);
    <|file_separator|><nl>
        if (planItemInstance == null) {
            return false;
        }
        if (planItemInstance.getPlanItem() == null) {
            return false;
        }
        if (planItemInstance.getPlanItem().isRepetitionBased()) {
            return planItemInstance.getPlanItemInstanceStatus() == PlanItemInstanceStatus.COMPLETED;
        }
        return false;
    <|file_separator|><nl>
        super.internalExecute();
    <|file_separator|><nl>
        scriptTask.execute(commandContext, planItemInstanceEntity);
    <|file_separator|><nl>
        Object delegateInstance = instantiate(className);
        if (delegateInstance instanceof HttpResponseHandler) {
            return (HttpResponseHandler) delegateInstance;
        } else {
            throw new FlowableIllegalArgumentException(delegateInstance.getClass().getName() + " doesn't implement " + HttpResponseHandler.class);
        }
    <|file_separator|><nl>
        CaseInstanceEntity caseInstanceEntity = commandContext.getCaseInstanceEntity(caseInstanceId);
        internalExecute(commandContext, caseInstanceEntity);
        return null;
    <|file_separator|><nl>
        // TODO: Implement bulk termination of case instances
        return null;
    <|file_separator|><nl>
        
        if (caseDefinitionId != null) {
            return executeCaseDefinitionId(commandContext);
        } else if (caseDefinitionKey != null) {
            return executeCaseDefinitionKey(commandContext);
        } else {
            throw new FlowableException("Must specify a case definition id or key to migrate");
        }
    }

    protected Batch executeCaseDefinitionId(CommandContext commandContext) {
        
        CaseDefinition caseDefinition = cmmnEngineConfiguration.getCaseDefinitionService().getCaseDefinition(caseDefinitionId);
        if (caseDefinition == null) {
            throw new FlowableException("Case definition with id " + caseDefinitionId + " not found");
        }
        return executeCaseDefinition(commandContext, caseDefinition);
    }

    protected Batch executeCaseDefinitionKey(CommandContext commandContext) {
        
        CaseDefinition caseDefinition = cmmnEngineConfiguration.getCaseDefinitionService().getCaseDefinition(caseDefinitionKey, caseDefinitionVersion, caseDefinitionTenantId);
        if (caseDefinition == null) {
            throw new FlowableException("Case definition with key " + caseDefinitionKey + " and version " + caseDefinitionVersion + " not found");
        }
        return executeCaseDefinition(commandContext, caseDefinition);
    }

    protected Batch executeCaseDefinition(CommandContext commandContext, CaseDefinition caseDefinition) {
        
        return cmmnEngineConfiguration.getCaseInstanceMigrationService().migrateCaseInstances(caseDefinition, caseInstanceMigrationDocument, commandContext);
    <|file_separator|><nl>
        
        if (force) {
            planItemInstanceEntity.setComplete(true);
        } else {
            planItemInstanceEntity.setComplete(false);
        }
        
        planItemInstanceEntity.save();
    <|file_separator|><nl>
        
        Task task = commandContext.getTaskService().getTask(taskId);
        
        if (task == null) {
            throw new TaskNotFoundException(taskId);
        }
        
        if (task.getCreatorId() != commandContext.getUserId()) {
            throw new NotAuthorizedException();
        }
        
        if (task.getExecutorId() != null && !task.getExecutorId().equals(commandContext.getUserId())) {
            throw new NotAuthorizedException();
        }
        
        if (task.getExecutorId() == null) {
            throw new NotAuthorizedException();
        }
        
        if (task.getExecutorId() == null) {
            throw new NotAuthorizedException();
        }
        
        if (task.getExecutorId() == null) {
            throw new NotAuthorizedException();
        }
        
        if (task.getExecutorId() == null) {
            throw new NotAuthorizedException();
        }
        
        if (task.getExecutorId() == null) {
            throw new NotAuthorizedException();
        }
        
        if (task.getExecutorId() == null) {
            throw new NotAuthorizedException();
        }
        
        if (task.getExecutorId() == null) {
            throw new NotAuthorizedException();
        }
        
        if (task.getExecutorId() == null) {
            throw new NotAuthorizedException();
        }
        
        if (task.getExecutorId() == null) {
            throw new NotAuthorizedException();
        }
        
        if (task.getExecutorId() == null) {
            throw new NotAuthorizedException();
        }
        
        if (task.getExecutorId() == null) {
            <nl>
        return taskBuilder.build();
    <|file_separator|><nl>
        return commandContext.getHistoricTaskService().deleteHistoricTaskInstance(taskId);
    <|file_separator|><nl>
        return commandContext.getHistoricEntityLinkService().getHistoricEntityLinkChildrenWithSameRootAsCaseInstance(caseInstanceId);
    <|file_separator|><nl>
        return commandContext.getPlanItemVariableInstances(planItemInstanceId);
    <|file_separator|><nl>
        return commandContext.getVariableManager().getVariableInstances(taskId, variableNames, isLocal);
    <|file_separator|><nl>
        return commandContext.getCaseInstance().getPlanItemInstanceVariable(planItemInstanceId, variableName);
    <|file_separator|><nl>
        if (oldDate == null) {
            return new Date(System.currentTimeMillis() + waitTimeInSeconds * 1000);
        } else {
            return new Date(oldDate.getTime() + waitTimeInSeconds * 1000);
        }
    <|file_separator|><nl>
        task.setPriority(priority);
        return null;
    <|file_separator|><nl>
        try {
            CmmnEngineConfiguration engineConfiguration = commandContext.getEngineConfiguration();
            JsonNode batchPartResult = getBatchPartResult(job.getBatchPart(), engineConfiguration);
            if (batchPartResult != null) {
                List<String> caseIds = batchPartResult.get("caseIds").toList();
                if (caseIds != null) {
                    for (String caseId : caseIds) {
                        commandContext.getCaseService().deleteHistoricCaseInstance(caseId);
                    }
                }
            }
        } catch (Exception e) {
            ExceptionUtil.sneakyThrow(e);
        }
    <|file_separator|><nl>
        if (caseDefinition == null) {
            throw new IllegalArgumentException("CaseDefinitionEntity must not be null");
        }
        if (cmmnModel == null) {
            throw new IllegalArgumentException("CmmnModel must not be null");
        }
        if (caseDefinition.getResourceName() == null) {
            throw new IllegalArgumentException("CaseDefinitionEntity must have a resource name");
        }
        if (caseDefinition.getKey() == null) {
            throw new IllegalArgumentException("CaseDefinitionEntity must have a key");
        }

        CmmnResourceEntity resourceEntity = createResourceEntity();
        resourceEntity.setResourceName(caseDefinition.getResourceName());
        resourceEntity.setResourceName(caseDefinition.getKey());
        resourceEntity.setResourceName(caseDefinition.getKey());
        resourceEntity.setResourceName(caseDefinition.getKey());
        resourceEntity.setResourceName(caseDefinition.getKey());
        resourceEntity.setResourceName(caseDefinition.getKey());
        resourceEntity.setResourceName(caseDefinition.getKey());
        resourceEntity.setResourceName(caseDefinition.getKey());
        resourceEntity.setResourceName(caseDefinition.getKey());
        resourceEntity.setResourceName(caseDefinition.getKey());
        resourceEntity.setResourceName(caseDefinition.getKey());
        resourceEntity.setResourceName(caseDefinition.getKey());
        resourceEntity.setResourceName(caseDefinition.getKey());
        resourceEntity.setResourceName(caseDefinition.getKey());
        resourceEntity.setResourceName(caseDefinition.getKey());
        resourceEntity.setResourceName(caseDefinition.getKey());
        resourceEntity.setResourceName(caseDefinition.getKey());
        resourceEntity.setResourceName(caseDefinition.getKey());
        resourceEntity.setResourceName(case<nl>
        caseTask.setCaseId(planItem.getCaseId());
        caseTask.setCaseName(planItem.getCaseName());
        caseTask.setCaseType(planItem.getCaseType());
        caseTask.setCaseStatus(planItem.getCaseStatus());
        caseTask.setCasePriority(planItem.getCasePriority());
        caseTask.setCaseOwner(planItem.getCaseOwner());
        caseTask.setCaseAssignee(planItem.getCaseAssignee());
        caseTask.setCaseDescription(planItem.getCaseDescription());
        caseTask.setCaseCreationDate(planItem.getCaseCreationDate());
        caseTask.setCaseLastUpdateDate(planItem.getCaseLastUpdateDate());
        caseTask.setCaseDueDate(planItem.getCaseDueDate());
        caseTask.setCaseClosedDate(planItem.getCaseClosedDate());
        caseTask.setCaseClosedReason(planItem.getCaseClosedReason());
        caseTask.setCaseClosedBy(planItem.getCaseClosedBy());
        caseTask.setCaseClosedByLogin(planItem.getCaseClosedByLogin());
        caseTask.setCaseClosedByFullName(planItem.getCaseClosedByFullName());
        caseTask.setCaseClosedByEmail(planItem.getCaseClosedByEmail());
        caseTask.setCaseClosedByPhone(planItem.getCaseClosedByPhone());
        caseTask.setCaseClosedByMobile(planItem.getCaseClosedByMobile());
        caseTask.setCaseClosedByAddress(planItem.getCaseClosedByAddress());
        caseTask.setCaseClosedByCity(planItem.getCaseClosedByCity());
        caseTask.setCaseClosedByState(planItem.getCaseClosedByState());
        caseTask<nl>
        return Arrays.asList(DecisionTask.class);
    <|file_separator|><nl>
        scriptServiceTask.setScriptService(cmmnParser.getScriptService());
    <|file_separator|><nl>
        stage.setName(planItem.getName());
    <|file_separator|><nl>
        return "AbstractCmmnEngineVariableScopeEntity";
    <|file_separator|><nl>
        innerQuery.planItemDefinitionId(planItemDefinitionId);
        return this;
    <|file_separator|>class SignalEventListenerInstanceImpl.java
<|fim_prefix|><|fim_suffix|>

    @Override
    public String getPlanItemInstanceElementId() {
        return planItemInstance.getPlanItemInstanceElementId();
    }

    @Override
    public String getPlanItemInstanceName() {
        return planItemInstance.getPlanItemInstanceName();
    }

    @Override
    public String getPlanItemInstanceDescription() {
        return planItemInstance.getPlanItemInstanceDescription();
    }

    @Override
    public String getPlanItemInstanceState() {
        return planItemInstance.getPlanItemInstanceState().name();
    }

    @Override
    public String getPlanItemInstanceStateDescription() {
        return planItemInstance.getPlanItemInstanceState().getDescription();
    }

    @Override
    public String getPlanItemInstanceStateAvailable() {
        return planItemInstance.getPlanItemInstanceState().isAvailable() ? "true" : "false";
    }

    @Override
    public String getPlanItemInstanceStateSuspended() {
        return planItemInstance.getPlanItemInstanceState().isSuspended() ? "true" : "false";
    }

    @Override
    public String getPlanItemInstanceStateAvailableDate() {
        return planItemInstance.getPlanItemInstanceState().getAvailableDate().toString();
    }

    @Override
    public String getPlanItemInstanceStateSuspendedDate() {
        return planItemInstance.getPlanItemInstanceState().getSuspendedDate().toString();
    }

    @Override
    public String getPlanItemInstanceStateAvailableBy() {
        return planItemInstance.getPlanItemInstanceState().getAvailableBy();
    }

    @Override
    public String getPlanItem<nl>
        List<ExtensionElement> inParameters = baseElement.getExtensionElements()
            .getOrDefault(CmmnXmlConstants.ELEMENT_EVENT_IN_PARAMETER, Collections.emptyList());
        if (!inParameters.isEmpty()) {
            Map<String, EventPayloadInstance> payloadInstances = new HashMap<>();
            for (ExtensionElement inParameter : inParameters) {
                String payloadSourceName = inParameter.getAttributeValue(null, CmmnXmlConstants.ATTRIBUTE_IOPARAMETER_SOURCE);
                String variableName = inParameter.getAttributeValue(null, CmmnXmlConstants.ATTRIBUTE_IOPARAMETER_TARGET);
                if (StringUtils.isNotEmpty(variableName)) {
                    Boolean isTransient = Boolean.valueOf(inParameter.getAttributeValue(null, "transient"));
                    Object value = variableScope.getVariable(variableName);
                    if (Boolean.TRUE.equals(isTransient)) {
                        value = expressionManager.evaluateExpression(value, null);
                    }
                    EventPayloadInstance payloadInstance = new EventPayloadInstance();
                    payloadInstance.setDefinitionName(payloadSourceName);
                    payloadInstance.setValue(value);
                    payloadInstances.put(payloadSourceName, payloadInstance);
                }
            }
            return payloadInstances.values();
        }
        return Collections.emptyList();
    <|file_separator|><nl>
        if (parameterContext.isAnnotated(CmmnDeploymentId.class)) {
            return getTestHelper(context).getDeploymentIdFromDeploymentAnnotation();
        }
        return null;
    <|file_separator|><nl>
        if (cmmnEngine == null) {
            initCmmnEngine();
        }
    }

    protected ProcessEngine getProcessEngine() {
        return cmmnEngine.getProcessEngine();
    }

    protected RepositoryService getRepositoryService() {
        return getProcessEngine().getRepositoryService();
    }

    protected RuntimeService getRuntimeService() {
        return getProcessEngine().getRuntimeService();
    }

    protected TaskService getTaskService() {
        return getProcessEngine().getTaskService();
    }

    protected HistoryService getHistoryService() {
        return getProcessEngine().getHistoryService();
    }

    protected IdentityService getIdentityService() {
        return getProcessEngine().getIdentityService();
    }

    protected FormService getFormService() {
        return getProcessEngine().getFormService();
    }

    protected TaskFormService getTaskFormService() {
        return getProcessEngine().getTaskFormService();
    }

    protected TaskFormDataService getTaskFormDataService() {
        return getProcessEngine().getTaskFormDataService();
    }

    protected VariableService getVariableService() {
        return getProcessEngine().getVariableService();
    }

    protected AttachmentService getAttachmentService() {
        return getProcessEngine().getAttachmentService();
    }

    protected MessageService getMessageService() {
        return getProcessEngine().getMessageService();
    }

    protected IdentityLinkService getIdentityLinkService() {
        return getProcessEngine().getIdentityLinkService();
    }

    protected TaskListenerService getTaskListenerService() {
        return getProcessEngine().getTaskListenerService();
    }

    protected TaskListenerEngineConfiguration getTaskListenerEngineConfiguration() {
        return (TaskListenerEngineConfiguration) cmmnEngineConfiguration.getEngineConfigurations()
<nl>
        inboundEventChannelAdapter.triggerTestEvent("kermit");
    <|file_separator|><nl>
        deployCaseModel("testEvent", TENANT_A);
        deployCaseModel("testEvent", TENANT_B);

        outboundEventChannelAdapter.sendEvent("{\"tenantACustomerId\": \"123\"}", null);
        outboundEventChannelAdapter.sendEvent("{\"tenantBCustomerId\": \"123\"}", null);

        assertThat(outboundEventChannelAdapter.receivedEvents).hasSize(2);
        assertThat(outboundEventChannelAdapter.receivedEvents.get(0)).isEqualTo("{\"tenantACustomerId\": \"123\"}");
        assertThat(outboundEventChannelAdapter.receivedEvents.get(1)).isEqualTo("{\"tenantBCustomerId\": \"123\"}");
    <|file_separator|><nl>
        delegateTask.setAssignee("test");
    <|file_separator|><nl>
        String str = "abc";
        String prefix = "ab";
        String suffix = "cd";
        String expected = "ab";
        String actual = CmmnPrefix.getCommonPrefix(str, prefix, suffix);
        assertEquals(expected, actual);
    <|file_separator|><nl>
        taskId = delegateTask.getId();
        historicTaskId = delegateTask.getExecutionId();
    <|file_separator|><nl>
        CaseInstance caseInstance = cmmnRuntimeService.createCaseInstanceBuilder().caseDefinitionKey("businessKeyCase").start();
        assertThat(caseInstance.getBusinessKey()).isEqualTo("bzKey");

        Task task = cmmnTaskService.createTaskQuery().singleResult();
        cmmnTaskService.complete(task.getId());

        if (CmmnHistoryTestHelper.isHistoryLevelAtLeast(HistoryLevel.ACTIVITY, cmmnEngineConfiguration)) {
            HistoricCaseInstance historicCaseInstance = cmmnHistoryService.createHistoricCaseInstanceQuery().singleResult();
            assertThat(historicCaseInstance.getBusinessKey()).isEqualTo("bzKey");
        }
    }

    @Test
    @CmmnDeployment
    public void testUpdateExistingCaseBusinessKeyWithPlanItem() {
        CaseInstance caseInstance = cmmnRuntimeService.createCaseInstanceBuilder().caseDefinitionKey("businessKeyCase").start();
        assertThat(caseInstance.getBusinessKey()).isEqualTo("bzKey");

        Task task = cmmnTaskService.createTaskQuery().singleResult();
        cmmnTaskService.complete(task.getId());

        if (CmmnHistoryTestHelper.isHistoryLevelAtLeast(HistoryLevel.ACTIVITY, cmmnEngineConfiguration)) {
            HistoricCaseInstance historicCaseInstance = cmmnHistoryService.createHistoricCaseInstanceQuery().singleResult();
            assertThat(historicCaseInstance.getBusinessKey()).isEqualTo("bzKey");
        }
    <|file_separator|><nl>
        CaseInstance caseInstance = cmmnRuntimeService.createCaseInstanceBuilder()
                .caseDefinitionKey("exitSentryCompletionExceptionTestCase")
                .start();

        List<PlanItemInstance> planItemInstances = getPlanItemInstances(caseInstance.getId());

        assertThat(planItemInstances).hasSize(4);
        assertPlanItemInstanceState(planItemInstances, "Task C", ACTIVE);

        // Triggering Task C must fail as the stage is not yet completable.
        assertThatThrownBy(() -> cmmnRuntimeService.triggerPlanItemInstance(getPlanItemInstanceIdByName(planItemInstances, "Task C")))
                .isExactlyInstanceOf(FlowableIllegalArgumentException.class)
                .hasMessageContaining("The plan item 'Stage (expandedStage1)' prevented it from completion.");
    <|file_separator|><nl>
        // given
        final String processInstanceId = "processInstanceId";
        final String processDefinitionId = "processDefinitionId";
        final String processDefinitionKey = "processDefinitionKey";
        final String processDefinitionVersion = "processDefinitionVersion";
        final String processDefinitionVersionTag = "processDefinitionVersionTag";
        final String processDefinitionVersionTagStart = "processDefinitionVersionTagStart";
        final String processDefinitionVersionTagEnd = "processDefinitionVersionTagEnd";
        final String processDefinitionVersionStart = "processDefinitionVersionStart";
        final String processDefinitionVersionEnd = "processDefinitionVersionEnd";
        final String processDefinitionVersionRange = "processDefinitionVersionRange";
        final String processDefinitionVersionRangeStart = "processDefinitionVersionRangeStart";
        final String processDefinitionVersionRangeEnd = "processDefinitionVersionRangeEnd";
        final String processDefinitionVersionRangeStartInclusive = "processDefinitionVersionRangeStartInclusive";
        final String processDefinitionVersionRangeEndInclusive = "processDefinitionVersionRangeEndInclusive";
        final String processDefinitionVersionRangeStartInclusiveStart = "processDefinitionVersionRangeStartInclusiveStart";
        final String processDefinitionVersionRangeStartInclusiveEnd = "processDefinitionVersionRangeStartInclusiveEnd";
        final String processDefinitionVersionRangeEndInclusiveStart = "processDefinitionVersionRangeEndInclusiveStart";
        final String processDefinitionVersionRangeEndInclusiveEnd = "processDefinitionVersionRangeEndInclusiveEnd";
        final String processDefinitionVersionRangeStartInclusiveStartInclusive = "processDefinitionVersionRangeStartInclusiveStartInclusive";
        final String processDefinitionVersionRangeStartInclusiveEndInclusive = "processDefinitionVersionRangeStartInclusiveEndInclusive";
        final String processDefinitionVersionRangeEndInclusiveStartInclusive = "processDefinitionVersionRangeEndInclusiveStartInclusive";
        final String processDefinitionVersionRangeEndInclusiveEndInclusive = "processDefinitionVersionRangeEndInclusiveEndInclusive";
        final String<nl>
        caseInstanceId = planItemInstance.getCaseInstanceId();
        planItemInstanceId = planItemInstance.getId();
        historicCaseInstanceId = planItemInstance.getHistoricCaseInstanceId();
        historicPlanItemInstanceId = planItemInstance.getHistoricPlanItemInstanceId();
    <|file_separator|><nl>
                        return cmmnEngineConfiguration.getCommandExecutor().execute(new Command<>() {
                            @Override
                            public void execute() {
                                return;
                            }
                        });
                    <|file_separator|><nl>
        return namespacePrefix;
    <|file_separator|><nl>
        this.name = otherElement.getName();
        this.namespace = otherElement.getNamespace();
        this.namespacePrefix = otherElement.getNamespacePrefix();
        this.elementText = otherElement.getElementText();
        this.childElements = otherElement.getChildElements();
    <|file_separator|><nl>
        return new ArrayList<>();
    <|file_separator|><nl>
        this.implementationType = implementationType;
    <|file_separator|><nl>
        return new HistoricMilestoneInstanceResponse(this.getMilestoneInstance(milestoneInstanceId));
    <|file_separator|><nl>
        this.caseDefinitionUrl = caseDefinitionUrl;
    <|file_separator|><nl>
        this.type = type;
    <|file_separator|><nl>
        return restResponseFactory.createDataResponse(managementService.getHistoryJobs(allRequestParams));
    <|file_separator|><nl>
        this.planItemInstanceId = planItemInstanceId;
    <|file_separator|><nl>
        try {
            return repositoryService.getDeploymentResourceData(deploymentId, resourceName);
        } catch (Exception e) {
            throw new CmmnException(e);
        }
    <|file_separator|><nl>
        return restResponseFactory.createDataResponse(repositoryService.getCaseDefinitions(allRequestParams));
    <|file_separator|><nl>
        return super.getModelResource(caseDefinitionId);
    <|file_separator|><nl>
        this.id = id;
    <|file_separator|><nl>
        CmmnDeployment deployment = getCmmnDeployment(deploymentId);
        deployment.delete(cascade);
    <|file_separator|><nl>
        return repositoryService.getDeploymentResources(deploymentId);
    <|file_separator|><nl>
        return super.queryCaseInstances(queryRequest, allRequestParams);
    <|file_separator|><nl>
        return restResponseFactory.createSuccessResponse(runtimeService.getEventSubscription(eventSubscriptionId));
    <|file_separator|><nl>
        return new CmmnRestResponseFactory(objectMapper);
    <|file_separator|><nl>
        HistoricTaskInstance historicTaskInstance = getHistoricTaskInstance();
        HistoricTaskInstanceIdentityLinkCollection historicTaskInstanceIdentityLinkCollection =
                historicTaskInstance.getIdentityLinks();
        assertEquals(1, historicTaskInstanceIdentityLinkCollection.size());
        HistoricTaskInstanceIdentityLink identityLink = historicTaskInstanceIdentityLinkCollection.get(0);
        assertEquals("user", identityLink.getType());
        assertEquals("user", identityLink.getLinkType());
        assertEquals("user", identityLink.getTaskId());
        assertEquals("user", identityLink.getProcessInstanceId());
        assertEquals("user", identityLink.getProcessDefinitionId());
        assertEquals("user", identityLink.getProcessDefinitionKey());
        assertEquals("user", identityLink.getProcessDefinitionName());
        assertEquals("user", identityLink.getProcessDefinitionVersion());
        assertEquals("user", identityLink.getProcessDefinitionVersionTag());
        assertEquals("user", identityLink.getProcessDefinitionVersionDescription());
        assertEquals("user", identityLink.getProcessDefinitionVersionFlowElementId());
        assertEquals("user", identityLink.getProcessDefinitionVersionFlowElementName());
        assertEquals("user", identityLink.getProcessDefinitionVersionFlowElementCategory());
        assertEquals("user", identityLink.getProcessDefinitionVersionFlowElementVersion());
        assertEquals("user", identityLink.getProcessDefinitionVersionFlowElementVersionTag());
        assertEquals("user", identityLink.getProcessDefinitionVersionFlowElementVersionDescription());
        assertEquals("user", identityLink.getProcessDefinitionVersionFlowElementVersionFlowElementId());
        assertEquals("user", identityLink.getProcessDefinitionVersionFlowElementVersionFlowElementName());
        assertEquals("user", identityLink.getProcessDefinitionVersionFlowElementVersionFlowElementCategory());
        assertEquals("user", identityLink.getProcessDefinitionVersionFlowElementVersionFlowElementVersion());
        assertEquals("user",<nl>
        this.someField = someField;
    <|file_separator|><nl>
        this.webServiceMock = webServiceMock;
        this.server = server;
        originalOverriddenEndpointAddresses = processEngineConfiguration.getWsOverridenEndpointAddresses();
    <|file_separator|><nl>
        this.webServiceMock = webServiceMock;
    }

    @Test
    public void test() {
        webServiceMock.setResponse(new Response(200, "OK"));
        webServiceMock.setResponse(new Response(400, "Bad Request"));
        webServiceMock.setResponse(new Response(500, "Internal Server Error"));
    <|file_separator|><nl>
        processEngineConfiguration = Flowable.configure()
                .useDatabaseForIdentityLink(true)
                .jdbcUrl(H2_TEST_JDBC_URL)
                .username("sa")
                .password("")
                .buildProcessEngineConfiguration();
        cachedProcessEngine = Flowable.init(processEngineConfiguration).buildProcessEngine();
        repositoryService = cachedProcessEngine.getRepositoryService();
        runtimeService = cachedProcessEngine.getRuntimeService();
        historyService = cachedProcessEngine.getHistoryService();
    <|file_separator|><nl>
        return failed;
    <|file_separator|><nl>
        LOGGER.info("Executing decision: {}", decision.getName());
    <|file_separator|><nl>
        List<Decision> decisions = executeDecisionContext.getDecisions();
        List<Decision> outputDecisions = new ArrayList<>();
        List<Decision> encapsulatedDecisions = new ArrayList<>();

        for (Decision decision : decisions) {
            if (decision.isEncapsulated()) {
                encapsulatedDecisions.add(decision);
            } else {
                outputDecisions.add(decision);
            }
        }

        List<Decision> order = determineDecisionExecutionOrder(encapsulatedDecisions, outputDecisions);
        for (Decision decision : order) {
            executeDecisionContext.getDecisionExecution().addDecision(decision);
        }
    <|file_separator|><nl>
        commandContext.getDeploymentService().deleteDeployment(deploymentId);
        return null;
    <|file_separator|><nl>
        HistoricDecisionExecutionQuery query = this.query;
        HistoricDecisionExecutionQueryExecution execution = query.getExecution();
        HistoricDecisionExecutionQueryExecutionService service = execution.getService();
        service.deleteHistoricDecisionExecutionsByQuery(query);
        return null;
    <|file_separator|><nl>
        return commandContext.getDeploymentClient().getDeploymentResource(this.deploymentId, this.resourceName);
    <|file_separator|><nl>
        return commandContext.getDecisionService().getDecisionDefinition(decisionTableId);
    <|file_separator|><nl>
        if (decisionTable.getInputs() != null) {
            for (InputClause inputClause : decisionTable.getInputs()) {
                if (inputClause.getInputValues() != null && inputClause.getInputValues().getTextValues() != null) {
                    inputVariables.put(inputClause.getName(),
                        ExecutionVariableFactory.getExecutionVariables(inputClause.getTypeRef(), inputClause.getInputValues().getTextValues()));
                }
            }
        }
    <|file_separator|><nl>
        return Date.class;
    <|file_separator|><nl>
        return CollectionContainsFunction.class;
    <|file_separator|><nl>
        return (DecisionEntity) getDbSqlSession().selectOne("selectDecisionByKeyAndVersionAndTenantId", params);
    <|file_separator|><nl>
        Map<String, Object> params = new HashMap<>();
        params.put("deploymentId", deploymentId);
        getDbSqlSession().delete("deleteDmnResourcesByDeploymentId", params);
    <|file_separator|><nl>
        if (dmnEngine != null) {
            LOGGER.info("Closing down DMN engine");
            dmnEngine.close();
        }
    <|file_separator|><nl>

        // given
        // that the AbstractEngineConfiguration is configured with forceCloseMybatisConnectionPool = false
        StandaloneInMemDmnEngineConfiguration standaloneInMemDmnEngineConfiguration =  new StandaloneInMemDmnEngineConfiguration();
        standaloneInMemDmnEngineConfiguration.setJdbcUrl("jdbc:h2:mem:flowable-dmn-" + this.getClass().getName());
        standaloneInMemDmnEngineConfiguration.setForceCloseMybatisConnectionPool(false);

        DmnEngine dmnEngine = standaloneInMemDmnEngineConfiguration.buildDmnEngine();


        PooledDataSource pooledDataSource = (PooledDataSource) standaloneInMemDmnEngineConfiguration.getDataSource();
        PoolState state = pooledDataSource.getPoolState();
        assertThat(state.getIdleConnectionCount()).isPositive();

        // then
        // if the  engine is closed
        dmnEngine.close();

        // the idle connections are not closed
        assertThat(state.getIdleConnectionCount()).isPositive();

    <|file_separator|><nl>
        Map<String, Object> processVariablesInput = new HashMap<>();

        List inputVariable1 = Arrays.asList("test1", "test2", "test3");
        List inputVariable2 = Arrays.asList(5L, 10L, 20L, 50L);
        List inputVariable3 = Arrays.asList("test4", "test5");
        List inputVariable4 = Arrays.asList("test1", "test2", "test3", "test4", "test5");

        processVariablesInput.put("collection1", inputVariable1);
        processVariablesInput.put("collection2", inputVariable2);
        processVariablesInput.put("collection3", inputVariable3);
        processVariablesInput.put("collection4", inputVariable4);

        DmnEngine dmnEngine = flowableDmnRule.getDmnEngine();
        DmnDecisionService dmnRuleService = dmnEngine.getDmnDecisionService();

        DecisionExecutionAuditContainer result = dmnRuleService.createExecuteDecisionBuilder()
                .decisionKey("decision")
                .variables(processVariablesInput)
                .executeWithAuditTrail();

        assertThat(result.isFailed()).isFalse();
        assertThat(result.getRuleExecutions().get(3).isValid()).isTrue();
        assertThat(result.getRuleExecutions().get(4).isValid()).isTrue();
    <|file_separator|><nl>
        this.requiredDecision = requiredDecision;
    <|file_separator|><nl>
        this.typeRef = typeRef;
    <|file_separator|><nl>
        this.outputClause = outputClause;
    <|file_separator|>class RuleOutputClause.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class RuleOutputClause {
    private String outputClause;
    private String outputEntry;

    public RuleOutputClause(String outputClause, String outputEntry) {
        this.outputClause = outputClause;
        this.outputEntry = outputEntry;
    }

    public RuleOutputClause() {
    }

    public String getOutputClause() {
        return outputClause;
    }

    public void setOutputClause(String outputClause) {
        this.outputClause = outputClause;
    }

    public String getOutputEntry() {
        return outputEntry;
    }

    public void setOutputEntry(String outputEntry) {
        this.outputEntry = outputEntry;
    }
}<|file_separator|>class RuleInputClauseContainer.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class RuleInputClauseContainer {
    private InputClause inputClause;
    private LiteralExpression inputEntry;

    public RuleInputClauseContainer(InputClause inputClause, LiteralExpression inputEntry) {
        this.inputClause = inputClause;
        this.inputEntry = inputEntry;
    }

    public RuleInputClauseContainer() {
    }

    public InputClause getInputClause() {
        return inputClause;
    }

    public void setInputClause(InputClause inputClause) {
        this.inputClause = inputClause;
    }

    public LiteralExpression getInputEntry() {
        return inputEntry;
    }

    public void setInputEntry(LiteralExpression inputEntry) {
        this.inputEntry = inputEntry;
    }
}<|file_separator|>class RuleInputClause.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class RuleInputClause {
    private String inputClause;
    private String inputEntry;

    public RuleInput<nl>
        return super.getHistoricDecisionExecution(historicDecisionExecutionId);
    <|file_separator|><nl>
        Decision decision = this.decisionService.getDecision(decisionId);
        if (decision == null) {
            response.setStatus(HttpServletResponse.SC_NOT_FOUND);
            return null;
        }
        Resource resource = decision.getResource(decisionId);
        if (resource == null) {
            response.setStatus(HttpServletResponse.SC_NOT_FOUND);
            return null;
        }
        return resource.getData();
    <|file_separator|><nl>
        return super.getDecisionTableResource(decisionTableId, response);
    <|file_separator|><nl>
        
        DmnDeployment deployment = dmnRepositoryService.createDeploymentQuery().deploymentId(deploymentId).singleResult();

        if (deployment == null) {
            throw new FlowableObjectNotFoundException("Could not find a DMN deployment with id '" + deploymentId);
        }
        
        return dmnRestResponseFactory.createDmnDeploymentResponse(deployment);
    <|file_separator|><nl>
        return super.getDmnDeploymentResource(deploymentId, resourceName, response);
    <|file_separator|><nl>
        return new DmnRestResponseFactory();
    <|file_separator|><nl>
        HttpGet httpGet = new HttpGet(SERVER_URL_PREFIX + DmnRestUrls.createRelativeResourceUrl(DmnRestUrls.URL_DECISION_TABLE, "simple"));
        CloseableHttpResponse response = executeRequest(httpGet, HttpStatus.SC_OK);
        closeResponse(response);
    <|file_separator|><nl>
        HttpGet httpGet = new HttpGet(SERVER_URL_PREFIX + DmnRestUrls.createRelativeResourceUrl(DmnRestUrls.URL_DEPLOYMENT_RESOURCE_CONTENT, "test", "test.txt"));
        CloseableHttpResponse response = executeRequest(httpGet, HttpStatus.SC_OK);
        closeResponse(response);
    <|file_separator|><nl>
        super.configure(engineConfiguration);
        engineConfiguration.setDmnEngineConfiguration(new DmnEngineConfiguration());
    <|file_separator|><nl>
        final Map<String, Set<Resource>> resourcesMap = createMap(resources);
        for (final Map.Entry<String, Set<Resource>> entry : resourcesMap.entrySet()) {
            final String deploymentName = determineDeploymentName(deploymentNameHint, entry.getKey());
            final DmnDeployment deployment = engine.createDeployment(deploymentName);
            for (final Resource resource : entry.getValue()) {
                deployment.addResource(resource);
            }
            deployment.deploy();
        }
    <|file_separator|><nl>
        super.initializeDmnEngine();
        // we need to store the DmnEngine in a thread-safe way
        this.cachedDmnEngines.put(this.dmnEngine, this.dmnEngine);
    }

    @Override
    protected DmnEngine getDmnEngine() {
        return this.cachedDmnEngines.get(this.dmnEngine);
    <|file_separator|><nl>
        MockitoAnnotations.initMocks(this);
    <|file_separator|><nl>
        String name = xtr.getAttributeValue(null, "name");
        String value = xtr.getAttributeValue(null, "value");
        if (name != null && value != null) {
            decision.addOutputClause(name, value);
        }
    <|file_separator|>class DecisionParser extends BaseChildElementParser {

    @Override
    public String getElementName() {
        return ELEMENT_DECISION;
    }

    @Override
    public void parseChildElement(XMLStreamReader xtr, DmnElement parentElement, Decision decision) throws Exception {
        String name = xtr.getAttributeValue(null, "name");
        if (name != null) {
            decision.addDecision(name);
        }
    }
}<|file_separator|>class DmnElementParser.java
<|fim_prefix|><|fim_suffix|>
    public static final String ELEMENT_DECISION = "decision";
    public static final String ELEMENT_OUTPUT_CLAUSE = "outputClause";
    public static final String ELEMENT_INPUT_CLAUSE = "inputClause";
    public static final String ELEMENT_INPUT_CLAUSE_VALUE = "value";
    public static final String ELEMENT_INPUT_CLAUSE_NAME = "name";
    public static final String ELEMENT_INPUT_CLAUSE_TYPE = "type";
    public static final String ELEMENT_INPUT_CLAUSE_DEFAULT = "default";
    public static final String ELEMENT_INPUT_CLAUSE_DEFAULT_VALUE = "value";
    public static final String ELEMENT_INPUT_CLAUSE_DEFAULT_NAME = "name";
    public static final String ELEMENT_INPUT_CLAUSE_DEFAULT_TYPE = "type";
    public static final String ELEMENT_INPUT_CLAUSE_DEFAULT_VALUE_TYPE = "type";
    public static final String ELEMENT_INPUT_CLAUSE_DEFAULT_VALUE_VALUE = "value";
<nl>
        DmnDiDecisionServiceDividerLine dmnDiDecisionServiceDividerLine = new DmnDiDecisionServiceDividerLine();
        return dmnDiDecisionServiceDividerLine;
    }

    @Override
    protected void writeElementAttributes(DmnElement element, DmnDefinition model, XMLStreamWriter xtw) throws Exception {
        DmnDiDecisionServiceDividerLine dmnDiDecisionServiceDividerLine = (DmnDiDecisionServiceDividerLine) element;
        xtw.writeAttribute(DmnXMLConstants.ATTRIBUTE_ID, dmnDiDecisionServiceDividerLine.getId());
    <|file_separator|>class DmnDiDecisionServiceDividerLine.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>package com.example.demo;

import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.Set;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Date;
import java.util.Calendar;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.io.Serializable;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.io.IOException<nl>
        DmnElement element = super.convertXMLToElement(xtr, conversionHelper);
        element.setAttribute(ATTRIBUTE_ID, String.valueOf(inputClauseCounter++));
        return element;
    <|file_separator|><nl>
        DmnDefinition bpmnModel = readXMLFile();
        DmnDefinition parsedModel = importAndReadXMLFile(bpmnModel);
        validateModel(parsedModel);
    <|file_separator|><nl>
        assertNotNull(model);
        assertEquals("EmptyDecisionService", model.getName());
        assertEquals("EmptyDecisionService", model.getNamespace());
        assertEquals("EmptyDecisionService", model.getPrefix());
        assertEquals("EmptyDecisionService", model.getNamespaceUri());
        assertEquals("EmptyDecisionService", model.getIdentifier());
        assertEquals("EmptyDecisionService", model.getDocumentation());
        assertEquals("EmptyDecisionService", model.getDocumentation());
        assertEquals("EmptyDecisionService", model.getDocumentation());
        assertEquals("EmptyDecisionService", model.getDocumentation());
        assertEquals("EmptyDecisionService", model.getDocumentation());
        assertEquals("EmptyDecisionService", model.getDocumentation());
        assertEquals("EmptyDecisionService", model.getDocumentation());
        assertEquals("EmptyDecisionService", model.getDocumentation());
        assertEquals("EmptyDecisionService", model.getDocumentation());
        assertEquals("EmptyDecisionService", model.getDocumentation());
        assertEquals("EmptyDecisionService", model.getDocumentation());
        assertEquals("EmptyDecisionService", model.getDocumentation());
        assertEquals("EmptyDecisionService", model.getDocumentation());
        assertEquals("EmptyDecisionService", model.getDocumentation());
        assertEquals("EmptyDecisionService", model.getDocumentation());
        assertEquals("EmptyDecisionService", model.getDocumentation());
        assertEquals("EmptyDecisionService", model.getDocumentation());
        assertEquals("EmptyDecisionService", model.getDocumentation());
        assertEquals("EmptyDecisionService", model.getDocumentation());
        assertEquals("EmptyDecisionService", model.getDocumentation());
        assertEquals("EmptyDecisionService", model.getDocumentation());
        assertEquals("EmptyDecisionService", model.getDocumentation());
        assertEquals("EmptyDecisionService", model.getDocumentation());
        assertEquals("EmptyDecisionService", model.getDocumentation());
        assertEquals("EmptyDecisionService", model.getDocumentation());
        assertEquals("<nl>
        return directions.get(directionName);
    <|file_separator|><nl>
        return getAgendaFutureMaxWaitTimeoutProvider().getAgendaFutureMaxWaitTimeout();
    <|file_separator|><nl>
        return null;
    <|file_separator|><nl>
        return commandContext.getLockValue(lockName, engineType);
    <|file_separator|><nl>
        return engineConfiguration.getDataSource();
    }

    @Override
    public String getDatabaseName() {
        return engineConfiguration.getDatabaseName();
    <|file_separator|><nl>
		return obj instanceof TreeValueExpression && getStructuralId().equals(((TreeValueExpression)obj).getStructuralId());
	<|file_separator|><nl>
		if (cache != null) {
			Tree tree = cache.get(expression);
			if (tree != null) {
				return tree;
			}
		}
		
		return builder.build(expression);
	}
	
	/**
	 * Add a {@link Tree} to the cache.
	 * @param expression expression string
	 * @param tree the tree
	 */
	public void put(String expression, Tree tree) {
		if (cache != null) {
			cache.put(expression, tree);
		}
	<|file_separator|><nl>
		b.append("?");
		question.appendStructure(b, bindings);
		b.append(" ");
		yes.appendStructure(b, bindings);
		b.append(" ");
		no.appendStructure(b, bindings);
	<|file_separator|>class AstIf.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>class AstIf extends AstNode {
	private final AstNode condition, then, else_;
	
	public AstIf(AstNode condition, AstNode then, AstNode else_) {
		this.condition = condition;
		this.then = then;
		this.else_ = else_;
	}

	@Override 
	public Object eval(Bindings bindings, ELContext context) throws ELException {
		Boolean value = bindings.convert(condition.eval(bindings, context), Boolean.class);
		return value.booleanValue() ? then.eval(bindings, context) : else_.eval(bindings, context);
	}

	@Override
	public String toString() {
		return "if";
	}	

	@Override 
	public void appendStructure(StringBuilder b, Bindings bindings) {
		b.append("if");
		condition.appendStructure(b, bindings);
		b.append(" then");
		then.appendStructure(b, bindings);
		if (else_ != null) {
			b.append(" else");
			else_.appendStructure(b, bindings);
		}
	}

    @Override
	public int getCardinality() {
		return 3;
	}

    @Override
	public AstNode getChild(int i) {
		return i == 0 ? condition : i == 1 ? then : i == 2 ? else_ : null;
	}
}<|file_separator|>class AstNode.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>abstract<nl>
        return new ExpressionFactory();
    <|file_separator|><nl>
        return variableContainer.getVariable(variableName).getValue() != null && !variableContainer.getVariable(variableName).getValue().isEmpty();
    <|file_separator|><nl>
                    return properties[next++];
                }
            };
		}
		return Collections.<FeatureDescriptor> emptyList().iterator();
	}
}<|file_separator|><nl>
        if (timeBasedGenerator == null) {
            synchronized (StrongUuidGenerator.class) {
                if (timeBasedGenerator == null) {
                    timeBasedGenerator = new TimeBasedGenerator();
                }
            }
        }
    <|file_separator|><nl>
            throw new UnsupportedOperationException();
        <|file_separator|><nl>
    <|file_separator|><nl>
        PropertyEntityImpl property = new PropertyEntityImpl();
        property.setName(name);
        property.setValue(value);
        property.setId(idGenerator.generateId());
        getDbSqlSession().insert("insertProperty", property);
    }
    
    @Override
    public void insert(PropertyEntity entity) {
        getDbSqlSession().insert("insertProperty", entity);
    }

    @Override
    public void update(PropertyEntity entity) {
        getDbSqlSession().update("updateProperty", entity);
    }

    @Override
    public void delete(PropertyEntity entity) {
        getDbSqlSession().delete("deleteProperty", entity);
    }

    @Override
    public PropertyEntity findById(String id) {
        return getDbSqlSession().selectOne("selectPropertyById", id);
    <|file_separator|><nl>
        return execute(commandContext, generateParameterMap());
    }

    public Object execute(CommandContext commandContext, Map<String, Object> parameterMap) {
        return null;
    }

    public Map<String, Object> generateParameterMap() {
        return parameters;
    }

    public CommandExecutor getCommandExecutor() {
        return commandExecutor;
    }

    public CommandContext getCommandContext() {
        return commandContext;
    }

    public String getSqlStatement() {
        return sqlStatement;
    }

    public void setSqlStatement(String sqlStatement) {
        this.sqlStatement = sqlStatement;
    }

    public int getFirstResult() {
        return firstResult;
    }

    public void setFirstResult(int firstResult) {
        this.firstResult = firstResult;
    }

    public int getMaxResults() {
        return maxResults;
    }

    public void setMaxResults(int maxResults) {
        this.maxResults = maxResults;
    }

    public ResultType getResultType() {
        return resultType;
    }

    public void setResultType(ResultType resultType) {
        this.resultType = resultType;
    }

    public Map<String, Object> getParameters() {
        return parameters;
    }

    public void setParameters(Map<String, Object> parameters) {
        this.parameters = parameters;
    }

    public void setCommandContext(CommandContext commandContext) {
        this.commandContext = commandContext;
    }

    public void setCommandExecutor(CommandExecutor commandExecutor) {
        this.commandExecutor = commandExecutor;
    }

    public void setSqlStatement(String sqlStatement, Map<String, Object> parameters<nl>
        StringBuilder sb = new StringBuilder();
        sb.append("Script evaluation failed: ");
        sb.append(trace.getScript());
        sb.append("\n");
        sb.append(trace.getScriptException().getMessage());
        sb.append("\n");
        sb.append(trace.getScriptException().getStackTrace());
        return sb.toString();
    <|file_separator|><nl>
        return configuration;
    <|file_separator|><nl>
        return this.resultMap.get(entityType);
    <|file_separator|><nl>
        return dataSource.getLoginTimeout();
    }

    @Override
    public Logger getParentLogger() throws SQLFeatureNotSupportedException {
        return dataSource.getParentLogger();
    }

}

class ClosingEngine implements Engine {

    private static final org.slf4j.Logger LOGGER = LoggerFactory.getLogger(ClosingEngine.class);

    protected Engine engine;

    public ClosingEngine(Engine engine) {
        this.engine = engine;
    }

    @Override
    public void onEngineBuilt(EngineLifecycleListener listener) {
        engine.onEngineBuilt(listener);
    }

    @Override
    public void onEngineClosed(EngineLifecycleListener listener) {
        if (engine instanceof Closeable) {
            try {
                LOGGER.info("About to close engine");
                ((Closeable) engine).close();
                LOGGER.info("Engine closed");
            } catch (IOException e) {
                LOGGER.warn("Exception while closing engine", e);
            }
        }
    }

    @Override
    public void onEngineStarted() {
        engine.onEngineStarted();
    }

    @Override
    public void onEngineStopped() {
        engine.onEngineStopped();
    }

    @Override
    public void onEngineFailed(Throwable cause) {
        engine.onEngineFailed(cause);
    }

    @Override
    public void onEngineFailed(Throwable cause, EngineLifecycleListener listener) {
        engine.onEngineFailed(cause, listener);
    }

    @Override
    public void onEngineFailed(Throwable cause, EngineLifecycleListener listener, boolean retry) {
        engine.onEngineFailed(cause, listener, retry);
    }

    @Override
    public void onEngineFailed(Throwable cause, EngineLifecycleListener listener, boolean retry, boolean retry<nl>
        if (isValidEvent(event)) {
            if (event instanceof FlowableEntityEvent) {
                if (event.getEntity() instanceof BaseEntity) {
                    if (event.getEntity().getClass().equals(entityClass)) {
                        if (event instanceof FlowableCreateEvent) {
                            onCreate(event);
                        } else if (event instanceof FlowableInitializedEvent) {
                            onInitialized(event);
                        } else if (event instanceof FlowableDeleteEvent) {
                            onDelete(event);
                        } else if (event instanceof FlowableUpdateEvent) {
                            onUpdate(event);
                        } else {
                            onEntityEvent(event);
                        }
                    }
                }
            }
        }
    <|file_separator|><nl>
        this.escalationName = escalationName;
    <|file_separator|><nl>
        return rescheduledJobId;
    <|file_separator|><nl>
    <|file_separator|><nl>
        return properties.get(propertyName);
    <|file_separator|><nl>
        return properties.get(propertyName);
    <|file_separator|><nl>
        return CommandContextUtil.getModelEntityManager(commandContext).countModelsByNativeQuery(parameterMap);
    }

    // results ////////////////////////////////////////////////////////////////

    @Override
    public List<Model> executeList(CommandExecutor commandExecutor, Map<String, Object> parameterMap) {
        return CommandContextUtil.getModelEntityManager(commandExecutor).findModelsByNativeQuery(parameterMap);
    }

    @Override
    public long executeCount(CommandExecutor commandExecutor, Map<String, Object> parameterMap) {
        return CommandContextUtil.getModelEntityManager(commandExecutor).countModelsByNativeQuery(parameterMap);
    <|file_separator|><nl>
        return CommandContextUtil.getProcessDefinitionEntityManager(commandContext).countProcessDefinitionsByNativeQuery(parameterMap);
    }

    // query //////////////////////////////////////////////////////////////////

    @Override
    public NativeProcessDefinitionQueryImpl setProcessDefinitionId(String processDefinitionId) {
        setParameter("processDefinitionId", processDefinitionId);
        return this;
    }

    @Override
    public NativeProcessDefinitionQueryImpl setProcessDefinitionKey(String processDefinitionKey) {
        setParameter("processDefinitionKey", processDefinitionKey);
        return this;
    }

    @Override
    public NativeProcessDefinitionQueryImpl setProcessDefinitionVersion(int processDefinitionVersion) {
        setParameter("processDefinitionVersion", processDefinitionVersion);
        return this;
    }

    @Override
    public NativeProcessDefinitionQueryImpl setProcessDefinitionName(String processDefinitionName) {
        setParameter("processDefinitionName", processDefinitionName);
        return this;
    }

    @Override
    public NativeProcessDefinitionQueryImpl setProcessDefinitionResourceName(String processDefinitionResourceName) {
        setParameter("processDefinitionResourceName", processDefinitionResourceName);
        return this;
    }

    @Override
    public NativeProcessDefinitionQueryImpl setProcessDefinitionResourceNameLike(String processDefinitionResourceNameLike) {
        setParameter("processDefinitionResourceNameLike", processDefinitionResourceNameLike);
        return this;
    }

    @Override
    public NativeProcessDefinitionQueryImpl setProcessDefinitionResourceNameIn(List<String> processDefinitionResourceNames) {
        setParameter("processDefinitionResourceNames", processDefinitionResourceNames);
        return this;
    }

    @Override
    public NativeProcessDefinitionQueryImpl setProcessDefinitionResourceNameNotIn(List<String> processDefinitionResourceNames) {
        setParameter("processDefinitionResourceNames", processDefinitionResourceNames<nl>
        commandExecutor.execute(new ProcessInstanceMigrationCmd(processDefinitionId, processInstanceMigrationDocument));
    <|file_separator|><nl>
        ExecutionEntityManager executionEntityManager = CommandContextUtil.getExecutionEntityManager(commandContext);
        for (ExecutionListener executionListener : elementWithExecutionListeners.getExecutionListeners(eventType)) {
            executionListener.execute(executionEntity);
        }
    <|file_separator|><nl>
        try {
            ProcessEngine processEngine = CommandContext.getProcessEngine();
            ProcessInstance processInstance = processEngine.getRuntimeService().createProcessInstanceQuery().processInstanceId(processInstanceId).singleResult();
            if (processInstance == null) {
                LOGGER.error("Process instance with id {} not found", processInstanceId);
                return;
            }
            String processDefinitionId = processInstance.getProcessDefinitionId();
            if (processDefinitionId == null) {
                LOGGER.error("Process instance with id {} has no process definition id", processInstanceId);
                return;
            }
            List<String> eventDefinitions = processEngine.getManagementService().getProcessDefinition(processDefinitionId).getEventDefinitions();
            if (eventDefinitions == null || eventDefinitions.isEmpty()) {
                LOGGER.error("Process instance with id {} has no event definitions", processInstanceId);
                return;
            }
            for (String eventDefinition : eventDefinitions) {
                LOGGER.info("Event definition: {}", eventDefinition);
            }
        } catch (Exception e) {
            LOGGER.error("Error evaluating event definitions", e);
        }
    <|file_separator|><nl>
        // do nothing
    <|file_separator|><nl>
        
        if (escalationEventDefinition.isEscalation()) {
            
            if (escalationCode != null) {
                execution.setVariable(escalationCode, execution.getVariable(escalationName));
            }
            
            execution.setVariable(escalationEventDefinition.getEscalationCode(), execution.getVariable(escalationEventDefinition.getEscalationName()));
        }
    <|file_separator|><nl>
        try {
            if (skipExpression == null || skipExpression.evaluate(execution)) {
                Object value = expression.evaluate(execution);
                setExecutionVariableValue(value, execution);
                if (!triggerable) {
                    leave(execution);
                }
            }
        } catch (Throwable exc) {
            handleException(exc, execution);
        }
    <|file_separator|><nl>
        execution.setVariable(fromExpression.getVariableName(), toExpression.evaluate(execution));
    <|file_separator|><nl>
        if (array.length != 1) {
            throw new IllegalArgumentException("Invalid array length");
        }
        this.primitive = array[0];
    }

    @Override
    public void loadFrom(String string) {
        if (string == null) {
            throw new IllegalArgumentException("String is null");
        }
        this.primitive = string;
    }

    @Override
    public void loadFrom(Number number) {
        if (number == null) {
            throw new IllegalArgumentException("Number is null");
        }
        this.primitive = number;
    }

    @Override
    public void loadFrom(Boolean booleanValue) {
        if (booleanValue == null) {
            throw new IllegalArgumentException("Boolean is null");
        }
        this.primitive = booleanValue;
    }

    @Override
    public void loadFrom(StructureInstance structureInstance) {
        if (structureInstance == null) {
            throw new IllegalArgumentException("StructureInstance is null");
        }
        this.primitive = structureInstance.getPrimitive();
    }

    @Override
    public void loadFrom(StructureInstance[] structureInstances) {
        if (structureInstances == null) {
            throw new IllegalArgumentException("StructureInstance[] is null");
        }
        this.primitive = structureInstances;
    }

    @Override
    public void loadFrom(StructureInstance[][] structureInstances) {
        if (structureInstances == null) {
            throw new IllegalArgumentException("StructureInstance[][] is null");
        }
        this.primitive = structureInstances;
    }

    @Override
    public void loadFrom(StructureInstance[][][] structureInstances) {
        if (structureInstances == null) {
            throw new IllegalArgumentException("StructureInstance[][][] is null<nl>
        return new FlowableCollectionHandler(getDelegateClass(), getDelegateFieldDeclarations());
    <|file_separator|><nl>
        // do nothing
    <|file_separator|><nl>
        // do nothing
    <|file_separator|><nl>
        try {
            super.execute(execution);
        } catch (Exception e) {
            throw new ScriptException(e);
        }
    <|file_separator|><nl>
        return processInstanceId;
    <|file_separator|><nl>
        return new CxfWSDLImporter(theImport);
    }

    @Override
    public String getDefaultXMLImporterFactoryClassname() {
        return DEFAULT_XML_IMPORTER_FACTORY_CLASSNAME;
    <|file_separator|><nl>
        // TODO Auto-generated method stub
        
    <|file_separator|><nl>
        variableListenerEventDefinition.setVariable(bpmnParse.getVariable());
    <|file_separator|><nl>
        return this.item.getStructureInstance();
    }

    public ItemInstance getItem() {
        return this.item;
    <|file_separator|>class ItemInstance.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class ItemInstance {

    protected StructureInstance structure;

    public ItemInstance(StructureInstance structure) {
        this.structure = structure;
    }

    public StructureInstance getStructureInstance() {
        return this.structure;
    }
}<|file_separator|>class StructureInstance.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class StructureInstance {

    protected Structure structure;

    public StructureInstance(Structure structure) {
        this.structure = structure;
    }

    public Structure getStructure() {
        return this.structure;
    }
}<|file_separator|><nl>
        Flowable5CompatibilityHandler compatibilityHandler = Flowable5Util.getFlowable5CompatibilityHandler();
        compatibilityHandler.executeJobWithLockAndRetry(job);
    <|file_separator|><nl>
        return this.mapperClass;
    <|file_separator|><nl>
        // TODO: implement
    <|file_separator|><nl>
        return null;
    }

    @Override
    public void undo(CommandContext commandContext) {
        
    }

    @Override
    public void redo(CommandContext commandContext) {
        
    <|file_separator|><nl>
        HistoricProcessInstanceService historicProcessInstanceService = commandContext.getProcessEngineConfiguration().getProcessEngine().getHistoricProcessInstanceService();
        for (String processInstanceId : processInstanceIds) {
            historicProcessInstanceService.deleteHistoricProcessInstance(processInstanceId);
        }
        return null;
    <|file_separator|><nl>
        if (task.isCompleted()) {
            throw new IllegalStateException("Task is already completed");
        }
        if (task.isSuspended()) {
            throw new IllegalStateException("Task is suspended");
        }
        if (task.isCompleted()) {
            throw new IllegalStateException("Task is already completed");
        }
        if (task.isCompleted()) {
            throw new IllegalStateException("Task is already completed");
        }
        if (task.isCompleted()) {
            throw new IllegalStateException("Task is already completed");
        }
        if (task.isCompleted()) {
            throw new IllegalStateException("Task is already completed");
        }
        if (task.isCompleted()) {
            throw new IllegalStateException("Task is already completed");
        }
        if (task.isCompleted()) {
            throw new IllegalStateException("Task is already completed");
        }
        if (task.isCompleted()) {
            throw new IllegalStateException("Task is already completed");
        }
        if (task.isCompleted()) {
            throw new IllegalStateException("Task is already completed");
        }
        if (task.isCompleted()) {
            throw new IllegalStateException("Task is already completed");
        }
        if (task.isCompleted()) {
            throw new IllegalStateException("Task is already completed");
        }
        if (task.isCompleted()) {
            throw new IllegalStateException("Task is already completed");
        }
        if (task.isCompleted()) {
            throw new IllegalStateException("Task is already completed");
        }
        if (task.isCompleted()) {
            throw new IllegalStateException("Task is already completed");
        }
        if (task.isCompleted()) {
            throw new IllegalStateException("Task is already completed");
        }
<nl>
        commandContext.getProcessInstance().clearLockTimes(lockOwner);
    <|file_separator|><nl>
        HistoricProcessInstanceQueryImpl historicProcessInstanceQuery = (HistoricProcessInstanceQueryImpl) commandContext.getVariable("historicProcessInstanceQuery");
        HistoricProcessInstanceQueryImpl historicProcessInstanceQuery1 = historicProcessInstanceQuery;
        if (historicProcessInstanceQuery1 == null) {
            historicProcessInstanceQuery1 = new HistoricProcessInstanceQueryImpl();
        }
        historicProcessInstanceQuery1.setProcessInstanceId(commandContext.getVariable("processInstanceId"));
        historicProcessInstanceQuery1.setProcessDefinitionId(commandContext.getVariable("processDefinitionId"));
        historicProcessInstanceQuery1.setProcessDefinitionKey(commandContext.getVariable("processDefinitionKey"));
        historicProcessInstanceQuery1.setProcessDefinitionVersion(commandContext.getVariable("processDefinitionVersion"));
        historicProcessInstanceQuery1.setProcessInstanceBusinessKey(commandContext.getVariable("processInstanceBusinessKey"));
        historicProcessInstanceQuery1.setProcessInstanceName(commandContext.getVariable("processInstanceName"));
        historicProcessInstanceQuery1.setProcessInstanceState(commandContext.getVariable("processInstanceState"));
        historicProcessInstanceQuery1.setProcessInstanceStartTime(commandContext.getVariable("processInstanceStartTime"));
        historicProcessInstanceQuery1.setProcessInstanceEndTime(commandContext.getVariable("processInstanceEndTime"));
        historicProcessInstanceQuery1.setProcessInstanceDuration(commandContext.getVariable("processInstanceDuration"));
        historicProcessInstanceQuery1.setProcessInstanceStartUserId(commandContext.getVariable("processInstanceStartUserId"));
        historicProcessInstanceQuery1.setProcessInstanceTenantId(commandContext.getVariable("processInstanceTenantId"));
        historicProcessInstanceQuery1.setProcessInstanceRootProcessInstanceId(commandContext.getVariable("processInstanceRootProcessInstanceId"));
        historicProcessInstanceQuery1.setProcessInstanceRootProcessInstance<nl>
        return commandContext.getHistoricTaskService().deleteHistoricTaskInstance(taskId);
    <|file_separator|><nl>
        ProcessInstance processInstance = commandContext.getProcessEngineConfiguration().getProcessEngine().getRuntimeService().createProcessInstanceQuery().processInstanceId(processInstanceId).singleResult();
        if (processInstance == null) {
            throw new FlowableIllegalArgumentException("processInstance " + processInstanceId + " not found");
        }
        if (userId != null) {
            commandContext.getProcessEngineConfiguration().getProcessEngine().getRuntimeService().deleteIdentityLink(processInstance.getId(), userId);
        } else if (groupId != null) {
            commandContext.getProcessEngineConfiguration().getProcessEngine().getRuntimeService().deleteIdentityLink(processInstance.getId(), groupId);
        }
        return null;
    <|file_separator|><nl>
        ProcessEngine processEngine = commandContext.getProcessEngine();
        ProcessInstance processInstance = processEngine.getRuntimeService().getProcessInstance(processInstanceId);
        if (processInstance == null) {
            throw new ProcessException("Process instance [" + processInstanceId + "] not found");
        }
        processEngine.getRuntimeService().deleteProcessInstance(processInstanceId, deleteReason);
        return null;
    <|file_separator|><nl>
        commandContext.getEventBus().dispatch(event);
        return null;
    <|file_separator|><nl>
        if (execution.isAsync()) {
            async = true;
        }
        return super.execute(commandContext, execution);
    }

    @Override
    protected void executeInternal(CommandContext commandContext, ExecutionEntity execution) {
        if (async) {
            throw new IllegalStateException("Cannot evaluate conditions for async execution");
        }
        super.executeInternal(commandContext, execution);
    }

    @Override
    protected void executeInternal(CommandContext commandContext, ExecutionEntity execution, Map<String, Object> variables) {
        if (async) {
            throw new IllegalStateException("Cannot evaluate conditions for async execution");
        }
        super.executeInternal(commandContext, execution, variables);
    }

    @Override
    protected void executeInternal(CommandContext commandContext, ExecutionEntity execution, Map<String, Object> variables, Map<String, Object> transientVariables) {
        if (async) {
            throw new IllegalStateException("Cannot evaluate conditions for async execution");
        }
        super.executeInternal(commandContext, execution, variables, transientVariables);
    }

    @Override
    protected void executeInternal(CommandContext commandContext, ExecutionEntity execution, Map<String, Object> variables, Map<String, Object> transientVariables, Map<String, Object> processVariables) {
        if (async) {
            throw new IllegalStateException("Cannot evaluate conditions for async execution");
        }
        super.executeInternal(commandContext, execution, variables, transientVariables, processVariables);
    }

    @Override
    protected void executeInternal(CommandContext commandContext, ExecutionEntity execution, Map<String, Object> variables, Map<String, Object> transientVariables, Map<String, Object> processVariables, Map<String, Object> transientVariables2) {
        if<nl>
        return commandContext.getFlowEngine().getEnabledActivitiesForAdhocSubProcess(executionId);
    <|file_separator|><nl>
        return commandContext.getExecutionManager().getVariables(executionIds);
    <|file_separator|><nl>
        return getFormKey(commandContext);
    }

    protected String getFormKey(CommandContext commandContext) {
        FlowableProcessEngineConfiguration processEngineConfiguration = commandContext.getProcessEngineConfiguration();
        FlowableProcessEngine processEngine = processEngineConfiguration.getProcessEngine();
        FlowableRuntimeService runtimeService = processEngine.getRuntimeService();
        FlowableTaskService taskService = processEngine.getTaskService();
        FlowableTask task = taskService.createTaskQuery().processDefinitionId(processDefinitionId).singleResult();
        if (task == null) {
            throw new FlowableIllegalArgumentException("No task found for process definition id '" + processDefinitionId + "'.");
        }
        if (taskDefinitionKey == null || taskDefinitionKey.length() < 1) {
            return task.getFormKey();
        }
        return task.getTaskDefinitionKey();
    <|file_separator|><nl>
        return commandContext.getHistoricEntityLinkService().findChildrenByTaskId(taskId);
    <|file_separator|><nl>
        return commandContext.getHistoricEntityManager().getHistoricEntityLinkParentsForTask(taskId);
    <|file_separator|><nl>
        return commandContext.getModelManager().getModel(modelId);
    <|file_separator|><nl>
        return commandContext.getProcessDefinitionHistoryLevel(processDefinitionId);
    <|file_separator|><nl>
        return super.execute(commandContext);
    }

    @Override
    public String getType() {
        return type;
    <|file_separator|><nl>
        return commandContext.getCommentService().getCommentsByTaskId(taskId);
    <|file_separator|><nl>
        ProcessDefinitionManager processDefinitionManager = commandContext.getProcessDefinitionManager();
        ProcessDefinition processDefinition = processDefinitionManager.getProcessDefinition(processDefinitionId);
        processDefinition.setInfo(infoNode);
        return null;
    <|file_separator|><nl>
        ProcessInstance processInstance = commandContext.getProcessEngineConfiguration().getProcessEngine().getRuntimeService().createProcessInstanceQuery().processInstanceId(processInstanceId).singleResult();
        if (processInstance == null) {
            throw new ProcessEngineException("Process instance [" + processInstanceId + "] not found");
        }
        commandContext.getProcessEngineConfiguration().getProcessEngine().getRuntimeService().setVariable(processInstance.getId(), "assignee", assigneeUserId);
        return null;
    <|file_separator|><nl>
        commandContext.getProcessEngineConfiguration().getRuntimeService().setProcessInstanceBusinessKey(this.processInstanceId, this.businessKey);
        return null;
    <|file_separator|><nl>
        task.setPriority(priority);
        return null;
    <|file_separator|><nl>
        Map<String, ObjectNode> bpmnOverrideMap = getBpmnOverrideContext();
        bpmnOverrideMap.put(id, infoNode);
    <|file_separator|><nl>
        behaviorInstance.invoke(execution);
    <|file_separator|><nl>
        Batch batch = job.getBatch();
        ManagementService managementService = commandContext.getManagementService();
        BatchPartQuery statusQuery = createStatusQuery(batch, managementService);
        List<BatchPart> batchParts = statusQuery.list();
        for (BatchPart batchPart : batchParts) {
            managementService.deleteBatchPart(batchPart.getId());
        }
        completeBatch(batch, "COMPLETED", commandContext.getEngineConfiguration());
    <|file_separator|><nl>
        return callActivitySubProcessVersion;
    <|file_separator|><nl>
        return new JuelExpression(expression, valueExpression, this.delegateInterceptor);
    <|file_separator|><nl>
        return formTypes.get(formProperty.getType());
    <|file_separator|><nl>
        return "LongForm";
    <|file_separator|><nl>
        
        // TODO: Implement this method
    <|file_separator|><nl>
        return acquiredJobs.size();
    <|file_separator|><nl>
        return getProcessEngineConfiguration().getHistoricActivityInstanceEntityManager();
    <|file_separator|><nl>
        return "bpmn";
    <|file_separator|><nl>
        return engineConfiguration.getByteArrayEntityManager();
    <|file_separator|><nl>
        return dataManager.findDeploymentCountByQueryCriteria(deploymentQuery);
    <|file_separator|><nl>
        this.propertyValue = propertyValue;
    <|file_separator|><nl>
        return new Object[]{processDefinitionId, infoJsonId};
    }

    @Override
    public void setPersistentState(Object state) {
        if (state != null) {
            Object[] stateArray = (Object[]) state;
            if (stateArray.length == 2) {
                processDefinitionId = (String) stateArray[0];
                infoJsonId = (String) stateArray[1];
            }
        }
    <|file_separator|><nl>
        return getList("selectUnfinishedActivityInstanceExecutionIdAndActivityId", executionId, activityId, unfinishedActivityInstanceMatcher, true);
    <|file_separator|><nl>
        return getDbSqlSession().selectList("selectDeploymentsByQueryCriteria", deploymentQuery);
    }

    @Override
    public Deployment findDeploymentByDeploymentId(String deploymentId) {
        return getDbSqlSession().selectOne("selectDeploymentByDeploymentId", deploymentId);
    }

    @Override
    public void deleteDeploymentByDeploymentId(String deploymentId) {
        getDbSqlSession().delete("deleteDeploymentByDeploymentId", deploymentId);
    }

    @Override
    public void deleteDeploymentResourceByDeploymentId(String deploymentId) {
        getDbSqlSession().delete("deleteDeploymentResourceByDeploymentId", deploymentId);
    }

    @Override
    public void deleteDeploymentResourceByResourceName(String resourceName) {
        getDbSqlSession().delete("deleteDeploymentResourceByResourceName", resourceName);
    }

    @Override
    public void deleteDeploymentResourceByResourceNameAndDeploymentId(String resourceName, String deploymentId) {
        getDbSqlSession().delete("deleteDeploymentResourceByResourceNameAndDeploymentId", new Object[]{resourceName, deploymentId});
    }

    @Override
    public void deleteDeploymentResourceByResourceNameAndDeploymentIdAndResourceName(String resourceName, String deploymentId, String resourceName1) {
        getDbSqlSession().delete("deleteDeploymentResourceByResourceNameAndDeploymentIdAndResourceName", new Object[]{resourceName, deploymentId, resourceName1});
    }

    @Override
    public void deleteDeploymentResourceByResourceNameAndDeploymentIdAndResourceNameAndResourceName(String resourceName, String deploymentId, String resourceName1, String resourceName2) {
        getDbSqlSession().delete("deleteDeploymentResourceByResourceNameAndDeploymentIdAndResourceNameAndResourceName", new Object[]{resourceName, deploymentId, resourceName1, resourceName2});
    }

    @Override
    public void<nl>
        <|file_separator|><nl>
        return entity.getProcessInstanceId().equals(parameter);<|file_separator|><nl>
        return this;
    <|file_separator|><nl>
        return null;
    <|file_separator|><nl>
        return activityIds;
    <|file_separator|><nl>
        this.callActivitySubProcessVersion = callActivitySubProcessVersion;
    <|file_separator|><nl>
        return newAssigneeId;
    <|file_separator|><nl>
        CommandContext commandContext = CommandContextUtil.getCommandContext();
        FlowableRuntimeService flowableRuntimeService = CommandContextUtil.getFlowableRuntimeService(commandContext);
        
        if (payload instanceof Map) {
            @SuppressWarnings("unchecked")
            Map<String, Object> payloadMap = (Map<String, Object>) payload;
            flowableRuntimeService.signalEventReceived(eventSubscriptionEntity.getExecutionId(), eventSubscriptionEntity.getActivityId(), payloadMap);
        } else {
            flowableRuntimeService.signalEventReceived(eventSubscriptionEntity.getExecutionId(), eventSubscriptionEntity.getActivityId(), payload);
        }
    <|file_separator|><nl>
        return new FlowableVariableEvent(FlowableVariableEventType.VARIABLE_DELETE, variableInstance);
    <|file_separator|><nl>
        return businessKey;
    <|file_separator|><nl>
        return assignee;
    <|file_separator|><nl>
        MDC.put(LOG_MDC_EXECUTION_ID, e.getId());
    }

    public static void putMDCProcessInstance(ProcessInstanceEntity e) {
        MDC.put(LOG_MDC_PROCESSINSTANCE_ID, e.getId());
    }

    public static void putMDCProcessDefinition(ProcessDefinitionEntity e) {
        MDC.put(LOG_MDC_PROCESSDEFINITION_ID, e.getId());
    }

    public static void putMDCBusinessKey(String key) {
        MDC.put(LOG_MDC_BUSINESS_KEY, key);
    }

    public static void putMDCTask(TaskEntity e) {
        MDC.put(LOG_MDC_TASK_ID, e.getId());
    <|file_separator|><nl>
        return getElements().values().stream().filter(e -> e instanceof DiagramNode).map(e -> (DiagramNode) e).collect(Collectors.toList());
    }

    public List<DiagramEdge> getEdges() {
        return getElements().values().stream().filter(e -> e instanceof DiagramEdge).map(e -> (DiagramEdge) e).collect(Collectors.toList());
    <|file_separator|><nl>
        return height;
    <|file_separator|><nl>
        super.runTest();
    <|file_separator|><nl>
        FlowableProcessTerminatedEventImpl event = new FlowableProcessTerminatedEventImpl();
        event.setProcessInstanceId("123");
        event.setProcessDefinitionId("123");
        event.setProcessDefinitionKey("123");
        event.setProcessDefinitionName("123");
        event.setProcessDefinitionVersion("123");
        event.setProcessDefinitionVersionTag("123");
        event.setProcessDefinitionVersionDescription("123");
        event.setProcessDefinitionVersionStatus("123");
        event.setProcessDefinitionVersionTenantId("123");
        event.setProcessDefinitionVersionTenantName("123");
        event.setProcessDefinitionVersionTenantType("123");
        event.setProcessDefinitionVersionTenantIdType("123");
        event.setProcessDefinitionVersionTenantIdType("123");
        event.setProcessDefinitionVersionTenantIdType("123");
        event.setProcessDefinitionVersionTenantIdType("123");
        event.setProcessDefinitionVersionTenantIdType("123");
        event.setProcessDefinitionVersionTenantIdType("123");
        event.setProcessDefinitionVersionTenantIdType("123");
        event.setProcessDefinitionVersionTenantIdType("123");
        event.setProcessDefinitionVersionTenantIdType("123");
        event.setProcessDefinitionVersionTenantIdType("123");
        event.setProcessDefinitionVersionTenantIdType("123");
        event.setProcessDefinitionVersionTenantIdType("123");
        event.setProcessDefinitionVersionTenantIdType("123");
        event.setProcessDefinitionVersionTenantIdType("123");
        event.set<nl>
        this.street = street;
    <|file_separator|><nl>
        String processInstanceId = null;
        try {
            processEngineConfiguration.setHistoryLevel(HistoryLevel.NONE);
            ProcessInstance oneTaskProcess = runtimeService.createProcessInstanceBuilder().processDefinitionKey("oneTaskProcess").start();
            processInstanceId = oneTaskProcess.getProcessInstanceId();
            
        } finally {
            deleteHistoricData(processInstanceId, null);
        }
    <|file_separator|><nl>
        // given
        String userId = "user";
        String oldPassword = "oldPassword";
        String newPassword = "newPassword";

        // when
        IdentityService identityService = getProcessEngine().getIdentityService();
        identityService.setIdentity(userId, oldPassword, newPassword);

        // then
        User user = identityService.createUserQuery().userId(userId).singleResult();
        assertThat(user.getPassword(), is(equalTo(newPassword)));
    <|file_separator|><nl>
        org.flowable.task.api.Task task = createTask("test", new Date());
        taskService.complete(task.getId());
        List<org.flowable.task.api.Task> tasks = taskService.createTaskQuery().list();
        assertEquals(1, tasks.size());
        assertEquals(task.getId(), tasks.get(0).getId());
    <|file_separator|><nl>
        String deploymentId1 = deployTimerProcess();
        String deploymentId2 = deployProcessWithoutTimers(); // Process has same key
        String deploymentId3 = deployTimerProcess();
        String deploymentId4 = deployProcessWithoutTimers();

        assertTimerJobs(0);

        repositoryService.deleteDeployment(deploymentId1, true);
        assertTimerJobs(1);
        Job job = managementService.createTimerJobQuery().singleResult();
        assertThat(job.getProcessDefinitionId()).isEqualTo(repositoryService.createProcessDefinitionQuery().deploymentId(deploymentId3).singleResult().getId());

        cleanup(deploymentId2, deploymentId3, deploymentId4);
    <|file_separator|><nl>
        ProcessInstance instance = runtimeService.startProcessInstanceByKey("dynamicServiceTest");
        ArrayList<String> candidateGroups = new ArrayList<>(2);
        candidateGroups.add("HR");
        candidateGroups.add("SALES");

        ObjectNode processInfo = dynamicBpmnService.changeUserTaskCandidateGroups(TASK_ONE_SID, candidateGroups);
        dynamicBpmnService.saveProcessDefinitionInfo(instance.getProcessDefinitionId(), processInfo);

        runtimeService.startProcessInstanceByKey("dynamicServiceTest");

        long hrTaskCount = taskService.createTaskQuery().taskCandidateGroup("HR").count();
        long salesTaskCount = taskService.createTaskQuery().taskCandidateGroup("SALES").count();

        assertThat(hrTaskCount).isEqualTo(1);
        assertThat(salesTaskCount).isEqualTo(1);

        ArrayList<String> candidateGroups2 = new ArrayList<>(2);
        candidateGroups2.add("HR");
        candidateGroups2.add("SALES");
        candidateGroups2.add("MANAGER");

        processInfo = dynamicBpmnService.changeUserTaskCandidateGroups(TASK_ONE_SID, candidateGroups2);
        dynamicBpmnService.saveProcessDefinitionInfo(instance.getProcessDefinitionId(), processInfo);

        runtimeService.startProcessInstanceByKey("dynamicServiceTest");

        hrTaskCount = taskService.createTaskQuery().taskCandidateGroup("HR").count();
        salesTaskCount = taskService.createTaskQuery().taskCandidateGroup("SALES").count();
        managerTaskCount = taskService.createTaskQuery().taskCandidateGroup("MANAGER").count();

        assertThat(hrTaskCount).isEqualTo(1);
        assertThat(salesTaskCount).isEqualTo(1);
        assertThat(managerTaskCount).isEqualTo(1);
    <|file_separator|><nl>
        execution.setVariable("throwErrorIn", "execute");
        execution.setVariable("afterExecutionsBeforeError", 1);
        execution.setVariable("afterExecutions", 0);
        return "prepareExecutionData";
    <|file_separator|><nl>
        // given
        final Flowable<String> flowable = Flowable.interval(1, TimeUnit.SECONDS)
                .take(10)
                .map(s -> s + "a");

        // when
        final Flowable<String> result = flowable.process(new BoundaryTimerEventRepeatWithDurationAndEnd());

        // then
        final List<String> list = result.toList().blockingGet();
        assertThat(list).containsExactly("a", "a", "a", "a", "a", "a", "a", "a", "a", "a");
    <|file_separator|><nl>
        // given
        final int expected = 10;
        final int actual = 0;
        final int expectedEnd = 10;
        final int actualEnd = 0;
        final int expectedError = 10;
        final int actualError = 0;
        final int expectedErrorEnd = 10;
        final int actualErrorEnd = 0;
        final int expectedErrorEnd2 = 10;
        final int actualErrorEnd2 = 0;
        final int expectedErrorEnd3 = 10;
        final int actualErrorEnd3 = 0;
        final int expectedErrorEnd4 = 10;
        final int actualErrorEnd4 = 0;
        final int expectedErrorEnd5 = 10;
        final int actualErrorEnd5 = 0;
        final int expectedErrorEnd6 = 10;
        final int actualErrorEnd6 = 0;
        final int expectedErrorEnd7 = 10;
        final int actualErrorEnd7 = 0;
        final int expectedErrorEnd8 = 10;
        final int actualErrorEnd8 = 0;
        final int expectedErrorEnd9 = 10;
        final int actualErrorEnd9 = 0;
        final int expectedErrorEnd10 = 10;
        final int actualErrorEnd10 = 0;
        final int expectedErrorEnd11 = 10;
        final int actualErrorEnd11 = 0;
        final int expectedErrorEnd12 = 10;
        final int actualErrorEnd12 = 0;
        final int expectedErrorEnd13 = 10;
        final int actualErrorEnd13 = 0;
        final int<nl>
        job.setTimerDefinition(new TimerDefinition(job.getTimerDefinition().getTimerName(), new Date(job.getTimerDefinition().getStartTime().getTime() + 1000), new Date(job.getTimerDefinition().getStartTime().getTime() + 1000), new Date(job.getTimerDefinition().getStartTime().getTime() + 1000), new Date(job.getTimerDefinition().getStartTime().getTime() + 1000), new Date(job.getTimerDefinition().getStartTime().getTime() + 1000), new Date(job.getTimerDefinition().getStartTime().getTime() + 1000), new Date(job.getTimerDefinition().getStartTime().getTime() + 1000), new Date(job.getTimerDefinition().getStartTime().getTime() + 1000), new Date(job.getTimerDefinition().getStartTime().getTime() + 1000), new Date(job.getTimerDefinition().getStartTime().getTime() + 1000), new Date(job.getTimerDefinition().getStartTime().getTime() + 1000), new Date(job.getTimerDefinition().getStartTime().getTime() + 1000), new Date(job.getTimerDefinition().getStartTime().getTime() + 1000), new Date(job.getTimerDefinition().getStartTime().getTime() + 1000), new Date(job.getTimerDefinition().getStartTime().getTime() + 1000), new Date(job.getTimerDefinition().getStartTime().getTime() + 1000), new Date(job.getTimerDefinition().getStartTime().getTime() + 1000), new Date(job.getTimerDefinition().getStartTime().getTime() + 1000)));<nl>
        // given
        final String processId = "exclusiveTimerEventTest";
        final String processDefinitionKey = "exclusiveTimerEventTest";
        final String processDefinitionId = "exclusiveTimerEventTest";
        final String processInstanceId = "exclusiveTimerEventTest";
        final String processInstanceBusinessKey = "exclusiveTimerEventTest";
        final String processDefinitionVersion = "exclusiveTimerEventTest";
        final String processDefinitionVersionLabel = "exclusiveTimerEventTest";
        final String processDefinitionVersionDescription = "exclusiveTimerEventTest";
        final String processDefinitionVersionName = "exclusiveTimerEventTest";
        final String processDefinitionVersionTag = "exclusiveTimerEventTest";
        final String processDefinitionVersionKey = "exclusiveTimerEventTest";
        final String processDefinitionVersionCategory = "exclusiveTimerEventTest";
        final String processDefinitionVersionTenantId = "exclusiveTimerEventTest";
        final String processDefinitionVersionTenantName = "exclusiveTimerEventTest";
        final String processDefinitionVersionTenantType = "exclusiveTimerEventTest";
        final String processDefinitionVersionVersion = "exclusiveTimerEventTest";
        final String processDefinitionVersionVersionTag = "exclusiveTimerEventTest";
        final String processDefinitionVersionVersionLabel = "exclusiveTimerEventTest";
        final String processDefinitionVersionVersionDescription = "exclusiveTimerEventTest";
        final String processDefinitionVersionVersionName = "exclusiveTimerEventTest";
        final String processDefinitionVersionVersionKey = "exclusiveTimerEventTest";
        final String processDefinitionVersionVersionCategory = "exclusiveTimerEventTest";
        final String processDefinitionVersionVersionTenantId = "exclusiveTimerEventTest";
        final String processDefinitionVersionVersionTenantName = "exclusiveTimerEventTest";
        final String processDefinitionVersionVersionTenantType = "exclusiveTimerEventTest";
        final String processDefinitionVersionVersionVersion = "exclusiveTimer<nl>
        Flowable<String> flowable = Flowable.fromArray("Hello", "World");
        flowable.subscribe(new Subscriber<String>() {
            @Override
            public void onSubscribe(Subscription s) {
                s.request(1);
            }

            @Override
            public void onNext(String s) {
                System.out.println(s);
            }

            @Override
            public void onError(Throwable t) {
                System.out.println(t);
            }

            @Override
            public void onComplete() {
                System.out.println("Done");
            }
        });
    <|file_separator|><nl>
        super.setUp();
        wiser = new Wiser();
        wiser.start();
        initialForceTo = processEngineConfiguration.getMailServerForceTo();
        initialMailServers = processEngineConfiguration.getMailServers();
    <|file_separator|><nl>
        System.out.println("Task " + delegateTask.getName() + " is completed");
    <|file_separator|><nl>
        Flowable.run().withJobHandler("testJob", new TestJobHandler()).execute();
    <|file_separator|><nl>
        // do something
    <|file_separator|><nl>
        // TODO Auto-generated method stub
        
    <|file_separator|><nl>
        ProcessInstance processInstance = startProcessInstance();
        assertExecutions(processInstance, newExecutionRelationshipCountValue);
        finishProcessInstance(processInstance);
        rebootEngine(newExecutionRelationshipCountValue);
        assertExecutions(processInstance, !newExecutionRelationshipCountValue);
    <|file_separator|><nl>
        execution.setVariable("randomValue", random.nextInt(100));
    <|file_separator|><nl>
        return new EmbeddedDatabaseBuilder().setType(EmbeddedDatabaseType.H2).build();
    <|file_separator|><nl>
    <|file_separator|><nl>
        CountDownLatch waitingLatch = new CountDownLatch(1);
        TestAcquireTimerLifecycleListener listener = new TestAcquireTimerLifecycleListener(waitingLatch);
        ProcessEngine processEngine = ProcessEngineConfiguration.createStandaloneInMemProcessEngineConfiguration().buildProcessEngine();
        processEngine.getLifecycleService().addAcquireTimerLifecycleListener(listener);
        processEngine.getLifecycleService().addAcquireTimerLifecycleListener(listener);
        processEngine.getLifecycleService().addAcquireTimerLifecycleListener(listener);
        processEngine.getLifecycleService().addAcquireTimerLifecycleListener(listener);
        processEngine.getLifecycleService().addAcquireTimerLifecycleListener(listener);
        processEngine.getLifecycleService().addAcquireTimerLifecycleListener(listener);
        processEngine.getLifecycleService().addAcquireTimerLifecycleListener(listener);
        processEngine.getLifecycleService().addAcquireTimerLifecycleListener(listener);
        processEngine.getLifecycleService().addAcquireTimerLifecycleListener(listener);
        processEngine.getLifecycleService().addAcquireTimerLifecycleListener(listener);
        processEngine.getLifecycleService().addAcquireTimerLifecycleListener(listener);
        processEngine.getLifecycleService().addAcquireTimerLifecycleListener(listener);
        processEngine.getLifecycleService().addAcquireTimerLifecycleListener(listener);
        processEngine.getLifecycleService().addAcquireTimerLifecycleListener(listener);
        processEngine.getLifecycleService().addAcquireTimerLifecycleListener(listener);
        processEngine.getLifecycleService().addAcquireTimerLifecycleListener(listener);
        processEngine.getLifecycleService().addAcquireTimerLifecycleListener(listener);
        processEngine.getLifecycleService().addAcquireTimerLifecycleListener(listener);
        processEngine.getLifecycleService().addAcquireTimerLifecycleListener(listener);
        processEngine.getLifecycleService().addAcquireTimerLifecycleListener(listener);
        processEngine.<nl>
        TimerJobEntity message = new TimerJobEntityImpl();
        message.setJobType(JobEntity.JOB_TYPE_TIMER);
        message.setJobHandlerType("tweet");
        message.setJobHandlerConfiguration(msg);
        message.setDueDate(duedate);
        return message;
    }

    protected void assertJobExecuted(JobEntity job) {
        assertEquals(JobEntity.JOB_STATUS_SUCCESS, job.getStatus());
    <|file_separator|><nl>
        // given
        final String processId = "act1623";
        final String processDefinitionId = "act1623";
        final String processInstanceId = "act1623";
        final String processDefinitionKey = "act1623";
        final String processDefinitionVersion = "1";
        final String processDefinitionVersionLabel = "act1623";
        final String processDefinitionVersionDescription = "act1623";
        final String processDefinitionVersionName = "act1623";
        final String processDefinitionVersionReleaseId = "1";
        final String processDefinitionVersionReleaseDate = "2015-01-01";
        final String processDefinitionVersionReleaseUser = "admin";
        final String processDefinitionVersionReleaseUserName = "admin";
        final String processDefinitionVersionReleaseComment = "act1623";
        final String processDefinitionVersionReleaseActivate = "true";
        final String processDefinitionVersionReleaseActivateUser = "admin";
        final String processDefinitionVersionReleaseActivateUserName = "admin";
        final String processDefinitionVersionReleaseActivateDate = "2015-01-01";
        final String processDefinitionVersionReleaseActivateComment = "act1623";
        final String processDefinitionVersionReleaseActivateActivate = "true";
        final String processDefinitionVersionReleaseActivateActivateUser = "admin";
        final String processDefinitionVersionReleaseActivateActivateUserName = "admin";
        final String processDefinitionVersionReleaseActivateActivateDate = "2015-01-01";
        final String processDefinitionVersionReleaseActivateActivateComment = "act1623";
        final String processDefinitionVersionReleaseActivateActivateActivate = "true";
        final String processDefinitionVersionReleaseActivateActivateActivateUser = "admin";
<nl>
            return customPropertiesMap;
        <|file_separator|><nl>
        // TODO Auto-generated method stub
        super.notify(processInstanceId, executionId, currentFlowElement, executionVariables, customPropertiesMap);
    <|file_separator|><nl>
        runtimeService.startProcessInstanceByKey("scriptExecutionListenerProcess");
    <|file_separator|><nl>

        String from = "ordershipping@flowable.org";
        String recipient = "johndoe@flowable.com";

        Map<String, Object> vars = new HashMap<>();
        vars.put("sender", from);
        vars.put("recipient", recipient);

        runtimeService.startProcessInstanceByKey("sendMailExample", vars);

        List<WiserMessage> messages = wiser.getMessages();
        assertThat(messages).hasSize(1);

        WiserMessage message = messages.get(0);
        MimeMessage mimeMessage = message.getMimeMessage();

        assertThat(mimeMessage.getHeader("From", null)).isEqualTo(from);
        assertThat(mimeMessage.getHeader("To", null)).contains(recipient);
    <|file_separator|><nl>
        // TODO
    <|file_separator|><nl>
        System.out.println("foo");
    <|file_separator|><nl>
        // TODO: implement
    }

    public Expression getExpression() {
        return expression;
    <|file_separator|><nl>
        Map<String, Object> variables = new HashMap<>();
        variables.put("okReturningService", new OkReturningService());

        ProcessInstance pi = runtimeService.startProcessInstanceByKey("setServiceResultToProcessVariablesWithSkipExpression", variables);

        assertThat(runtimeService.getVariable(pi.getId(), "result")).isEqualTo("ok");
    }

    @Test
    @Deployment
    public void testSetServiceResultToProcessVariablesWithSkipExpressionAndSkipResult() {
        Map<String, Object> variables = new HashMap<>();
        variables.put("okReturningService", new OkReturningService());

        ProcessInstance pi = runtimeService.startProcessInstanceByKey("setServiceResultToProcessVariablesWithSkipExpressionAndSkipResult", variables);

        assertThat(runtimeService.getVariable(pi.getId(), "result")).isEqualTo(null);
    }

    @Test
    @Deployment
    public void testSetServiceResultToProcessVariablesWithSkipExpressionAndSkipResultAndSkipService() {
        Map<String, Object> variables = new HashMap<>();
        variables.put("okReturningService", new OkReturningService());

        ProcessInstance pi = runtimeService.startProcessInstanceByKey("setServiceResultToProcessVariablesWithSkipExpressionAndSkipResultAndSkipService", variables);

        assertThat(runtimeService.getVariable(pi.getId(), "result")).isEqualTo(null);
    }

    @Test
    @Deployment
    public void testSetServiceResultToProcessVariablesWithSkipExpressionAndSkipResultAndSkipServiceAndSkipResult() {
        Map<String, Object> variables = new HashMap<>();
        variables.put("okReturningService", new OkReturningService());

        ProcessInstance pi = runtimeService.startProcessInstanceByKey("setServiceResultToProcessVariablesWithSkipExpressionAndSkipResultAndSkipServiceAndSkipResult", variables);

        assertThat(runtimeService.<nl>
        // TODO
    <|file_separator|><nl>
        Clock testingClock = new DefaultClockImpl();
        CycleBusinessCalendar businessCalendar = new CycleBusinessCalendar(testingClock);

        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy MM dd - HH:mm");
        Date now = simpleDateFormat.parse("2011 03 11 - 17:23");
        testingClock.setCurrentTime(now);

        Date duedate = businessCalendar.resolveDuedate("0 0 0 1 * ?");

        Date expectedDuedate = simpleDateFormat.parse("2011 04 1 - 00:00");

        assertThat(duedate).isEqualTo(expectedDuedate);
    <|file_separator|><nl>
        return entry.getProcessDefinition();
    <|file_separator|><nl>
        // TODO
    <|file_separator|><nl>
        if (event.getEntity() instanceof ProcessInstance) {
            ProcessInstance processInstance = (ProcessInstance) event.getEntity();
            if (processId.equals(processInstance.getId())) {
                // process is initialized
            }
        }
    <|file_separator|><nl>
        String dateString = "2015-01-01T00:00:00.000Z";
        Date date = AsyncHistoryDateUtil.parseISO8601Date(dateString);
        Assert.assertEquals(dateString, AsyncHistoryDateUtil.formatISO8601Date(date));
    <|file_separator|><nl>
        assertThatThrownBy(() -> ProcessEngineConfiguration
                .createProcessEngineConfigurationFromResource("org/flowable/standalone/initialization/versionmismatch.flowable.cfg.xml").buildProcessEngine())
                .isInstanceOf(FlowableException.class)
                .hasMessageContaining("version mismatch");
    <|file_separator|><nl>
        // TODO
    <|file_separator|><nl>
        JobTestHelper jobTestHelper = new JobTestHelper(activitiRule);
        jobTestHelper.waitForJobsToComplete(1);
    <|file_separator|><nl>
        assertThat(flowableRule.mockSupport().getNrOfNoOpServiceTaskExecutions()).isZero();
        flowableRule.getRuntimeService().startProcessInstanceByKey("mockSupportTest");
        assertThat(flowableRule.mockSupport().getNrOfNoOpServiceTaskExecutions()).isEqualTo(5);

        for (int i = 1; i <= 5; i++) {
            assertThat(flowableRule.mockSupport().getExecutedNoOpServiceTaskDelegateClassNames().get(i - 1)).isEqualTo("com.yourcompany.delegate" + i);
        }
    <|file_separator|><nl>
        this.referenceScopeType = referenceScopeType;
    <|file_separator|><nl>
        return dataManager.findHistoricEntityLinksByScopeDefinitionIdAndScopeType(scopeDefinitionId, scopeType, linkType);
    <|file_separator|><nl>
        assertThat(channelModel.getDestination()).isEqualTo("amqp://localhost:5672/events");
        assertThat(channelModel.getExchange()).isEqualTo("events");
        assertThat(channelModel.getRoutingKey()).isEqualTo("events");
    <|file_separator|><nl>
        return type;
    <|file_separator|><nl>
    <|file_separator|><nl>
        LOGGER.info("Deploying default resources");
    <|file_separator|><nl>
        final Map<String, Set<Resource>> resourcesMap = createMap(resources);
        for (final Map.Entry<String, Set<Resource>> entry : resourcesMap.entrySet()) {
            final String groupName = entry.getKey();
            final Set<Resource> resources = entry.getValue();
            final String deploymentName = determineDeploymentName(deploymentNameHint, groupName);
            deployResources(deploymentName, resources, engine);
        }
    <|file_separator|><nl>
        try {
            return message.getBody(String.class);
        } catch (JMSException e) {
            throw new FlowableException("Could not get body information", e);
        }
    <|file_separator|><nl>
        this.jmsOperations = jmsOperations;
    <|file_separator|><nl>
        return consumerProperties;
    <|file_separator|><nl>
        return new EventRegistryEngine(context);
    <|file_separator|><nl>
        return new DefaultKafkaConsumerFactory<>(kafkaConsumerProperties());
    <|file_separator|><nl>
        // given
        RabbitChannelRebootEngine engine = new RabbitChannelRebootEngine();
        engine.setRabbitAdmin(new RabbitAdmin(new ConnectionFactory()));
        engine.setRabbitTemplate(new RabbitTemplate(new ConnectionFactory()));
        engine.setFlowableChannels(new ArrayList<>());
        engine.setFlowableChannels(new ArrayList<>());
        engine.setFlowableChannels(new ArrayList<>());
        engine.setFlowableChannels(new ArrayList<>());
        engine.setFlowableChannels(new ArrayList<>());
        engine.setFlowableChannels(new ArrayList<>());
        engine.setFlowableChannels(new ArrayList<>());
        engine.setFlowableChannels(new ArrayList<>());
        engine.setFlowableChannels(new ArrayList<>());
        engine.setFlowableChannels(new ArrayList<>());
        engine.setFlowableChannels(new ArrayList<>());
        engine.setFlowableChannels(new ArrayList<>());
        engine.setFlowableChannels(new ArrayList<>());
        engine.setFlowableChannels(new ArrayList<>());
        engine.setFlowableChannels(new ArrayList<>());
        engine.setFlowableChannels(new ArrayList<>());
        engine.setFlowableChannels(new ArrayList<>());
        engine.setFlowableChannels(new ArrayList<>());
        engine.setFlowableChannels(new ArrayList<>());
        engine.setFlowableChannels(new ArrayList<>());
        engine.setFlowableChannels(new ArrayList<>());
        engine.setFlowableChannels(new ArrayList<>());
        engine.setFlowableChannels(new ArrayList<>());
        engine.setFlowableChannels(new ArrayList<>());
        engine.setFlowableChannels(new ArrayList<>());
        engine.setFlowableChannels(new ArrayList<>());
        engine.setFlowableChannels(new ArrayList<>());
        engine.setFlowableChannels(new ArrayList<>());
        engine.setFlowableChannels(new ArrayList<>());
        <nl>
        return eventInstance;
    <|file_separator|><nl>
        return properties.get(propertyName);
    <|file_separator|><nl>
        EventDeploymentEntity deployment = deploymentBuilder.build();
        EventDeploymentEntity saved = commandContext.getDeploymentRepository().save(deployment);
        if (deploymentsDiffer(deployment, saved)) {
            commandContext.getDeploymentRepository().update(saved);
        }
        return saved;
    <|file_separator|><nl>
        return commandContext.getEntityManager().find(ChannelDefinitionEntity.class, channelDefinitionId);
    <|file_separator|><nl>
        return commandContext.getChannelModelService().getChannelModel(channelDefinitionKey, channelDefinitionId, tenantId, parentDeploymentId);
    <|file_separator|><nl>
        return commandContext.getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData().getCommandContextData<nl>
        this.parameterInstances = parameterInstances;
    <|file_separator|><nl>
        this.eventInstance = eventInstance;
    <|file_separator|><nl>
    <|file_separator|><nl>
        return (List<String>) getDbSqlSession().selectList("selectEventDeploymentResourceNames", deploymentId);
    <|file_separator|><nl>
        eventRegistry.registerEvent(rawEvent);
    <|file_separator|><nl>
        return getEventRegistryConfiguration(commandContext).getEventDefinitionEntityManager();
    }
    
    public static EventDefinitionEntityManager getEventDefinitionEntityManager(CommandContext commandContext, String eventDefinitionName) {
        return getEventRegistryConfiguration(commandContext).getEventDefinitionEntityManager(eventDefinitionName);
    }
    
    public static EventDefinitionEntityManager getEventDefinitionEntityManager(CommandContext commandContext, String eventDefinitionName, String eventDefinitionVersion) {
        return getEventRegistryConfiguration(commandContext).getEventDefinitionEntityManager(eventDefinitionName, eventDefinitionVersion);
    }
    
    public static EventDefinitionEntityManager getEventDefinitionEntityManager(CommandContext commandContext, String eventDefinitionName, String eventDefinitionVersion, String eventDefinitionType) {
        return getEventRegistryConfiguration(commandContext).getEventDefinitionEntityManager(eventDefinitionName, eventDefinitionVersion, eventDefinitionType);
    <|file_separator|><nl>
    <|file_separator|><nl>
        this.scopeType = scopeType;
    <|file_separator|><nl>
        CompilerConfiguration config = new CompilerConfiguration();
        config.addCompilationCustomizers(new GroovyStaticScriptEngineCustomizer());
        return config;
    <|file_separator|><nl>
        return headers.containsKey(key);
    <|file_separator|><nl>
        super.setUp();
    }

    @Test
    public void testHttpServiceTaskCfg() {
        // TODO
    <|file_separator|><nl>
        return getIdentityLinkServiceConfiguration().getHistoricIdentityLinkEntityManager();
    }

    protected IdentityLinkService getIdentityLinkService() {
        return getIdentityLinkServiceConfiguration().getIdentityLinkService();
    }

    protected IdentityLinkServiceConfiguration getIdentityLinkServiceConfiguration() {
        return getIdentityLinkServiceConfiguration();
    }

    protected IdentityLinkServiceConfiguration getIdentityLinkServiceConfiguration() {
        return getIdentityLinkServiceConfiguration();
    }

    protected IdentityLinkServiceConfiguration getIdentityLinkServiceConfiguration() {
        return getIdentityLinkServiceConfiguration();
    }

    protected IdentityLinkServiceConfiguration getIdentityLinkServiceConfiguration() {
        return getIdentityLinkServiceConfiguration();
    }

    protected IdentityLinkServiceConfiguration getIdentityLinkServiceConfiguration() {
        return getIdentityLinkServiceConfiguration();
    }

    protected IdentityLinkServiceConfiguration getIdentityLinkServiceConfiguration() {
        return getIdentityLinkServiceConfiguration();
    }

    protected IdentityLinkServiceConfiguration getIdentityLinkServiceConfiguration() {
        return getIdentityLinkServiceConfiguration();
    }

    protected IdentityLinkServiceConfiguration getIdentityLinkServiceConfiguration() {
        return getIdentityLinkServiceConfiguration();
    }

    protected IdentityLinkServiceConfiguration getIdentityLinkServiceConfiguration() {
        return getIdentityLinkServiceConfiguration();
    }

    protected IdentityLinkServiceConfiguration getIdentityLinkServiceConfiguration() {
        return getIdentityLinkServiceConfiguration();
    }

    protected IdentityLinkServiceConfiguration getIdentityLinkServiceConfiguration() {
        return getIdentityLinkServiceConfiguration();
    }

    protected IdentityLinkServiceConfiguration getIdentityLinkServiceConfiguration() {
        return getIdentityLinkServiceConfiguration();
    }

    protected IdentityLinkServiceConfiguration getIdentityLinkServiceConfiguration() {
        return getIdentityLinkServiceConfiguration();
    }

    protected IdentityLinkServiceConfiguration getIdentityLinkServiceConfiguration() {
<nl>
        dataManager.deleteHistoricProcessIdentityLinksForNonExistingInstances();
    <|file_separator|><nl>
        return name;
    <|file_separator|>class QueryProperty.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public interface QueryProperty {

    public String getName();

}<|file_separator|>class Query.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>import java.util.List;

public interface Query {

    public List<Object> execute();

}<|file_separator|>class QueryPropertyQuery.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>import java.util.List;

public class QueryPropertyQuery implements Query {

    private static final long serialVersionUID = 1L;

    private QueryProperty property;
    private List<Object> values;

    public QueryPropertyQuery(QueryProperty property, List<Object> values) {
        this.property = property;
        this.values = values;
    }

    @Override
    public List<Object> execute() {
        return null;
    }

}<|file_separator|>class QueryPropertyQueryProperty.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class QueryPropertyQueryProperty implements QueryProperty {

    private static final long serialVersionUID = 1L;

    private QueryProperty property;
    private List<Object> values;

    public QueryPropertyQueryProperty(QueryProperty property, List<Object> values) {
        this.property = property;
        this.values = values;
    }

    @Override
    public String getName() {
        return property.getName();
    }

}<|file_separator|><nl>
        return name;
    <|file_separator|><nl>
        return CommandContextUtil.getGroupEntityManager(commandContext).countGroupsByNativeQuery(parameterMap);
    <|file_separator|><nl>
        return null;
    <|file_separator|><nl>
        return commandContext.getCommandContext().createGroup(groupId);
    <|file_separator|><nl>
        return commandContext.getMembershipService().createMembership(userId, groupId);
    <|file_separator|><nl>
        return null;
    }

    @Override
    public String toString() {
        return "DeletePrivilegeCmd [id=" + id + "]";
    <|file_separator|><nl>
        return commandContext.getRedis().smembers(userId + userInfoType);
    <|file_separator|><nl>
        return entityToTableNameMap.get(entityClass);
    }

    public static String getApiTypeTableName(Class<?> apiType) {
        return apiTypeToTableNameMap.get(apiType);
    <|file_separator|><nl>
        dataManager.deleteByteArrayById(byteArrayEntityId);
    <|file_separator|><nl>
        return dataManager.findGroupsByNativeQuery(parameterMap);
    <|file_separator|><nl>
        return getDbSqlSession().selectList("selectPrivilegeByQueryCriteria", query);
    <|file_separator|><nl>
        this.idmEngine = idmEngine;
    <|file_separator|><nl>
        if (ensureCleanDb.cleanDb()) {
            idmEngine.cleanDb();
        }
    }

    protected void assertAndEnsureCleanDb(IdmEngine idmEngine, ExtensionContext context, EnsureCleanDb ensureCleanDb, String... tables) {
        if (ensureCleanDb.cleanDb()) {
            idmEngine.cleanDb(tables);
        }
    <|file_separator|><nl>
        UserQuery query = idmIdentityService.createUserQuery().userFirstNameLike("%|%%");
        assertThat(query.list()).hasSize(1);
        assertThat(query.count()).isEqualTo(1);
        assertThat(query.singleResult().getId()).isEqualTo("kermit");

        query = idmIdentityService.createUserQuery().userFirstNameLike("%|_%");
        assertThat(query.list()).hasSize(1);
        assertThat(query.count()).isEqualTo(1);
        assertThat(query.singleResult().getId()).isEqualTo("fozzie");
    <|file_separator|><nl>
        if (customClassLoader == null) {
            return ReflectUtil.class.getClassLoader().getResource(name);
        } else {
            return customClassLoader.getResource(name);
        }
    <|file_separator|><nl>
        List<ProcessDefinition> processDefinitions = repositoryService.createProcessDefinitionQuery().list();
        List<List<String>> result = new ArrayList<>(processDefinitions.size());
        for (ProcessDefinition processDefinition : processDefinitions) {
            List<String> item = new ArrayList<>(3);
            item.add(processDefinition.getId());
            item.add(processDefinition.getName());
            item.add(Integer.toString(processDefinition.getVersion()));
            item.add(Boolean.toString(processDefinition.isSuspended()));
            item.add(processDefinition.getDescription());
            result.add(item);
        }
        return result;
    <|file_separator|><nl>
        return st;
    <|file_separator|><nl>
        if (numberOfTasks < 1) {
            throw new FlowableIllegalArgumentException("numberOfTasks must be at least 1");
        }

        if (workerId == null) {
            throw new FlowableIllegalArgumentException("workerId is null");
        }

        if (numberOfRetries < 0) {
            throw new FlowableIllegalArgumentException("numberOfRetries must be at least 0");
        }

        return commandExecutor.execute(new AcquireExternalWorkerJobCommand(
                jobServiceConfiguration,
                topic,
                lockDuration,
                scopeType,
                tenantId,
                authorizedUser,
                authorizedGroups,
                workerId,
                numberOfTasks,
                numberOfRetries
        ));
    <|file_separator|><nl>
        
        if (this.errorMessage == null) {
            throw new IllegalStateException("errorMessage is required");
        }

        if (this.errorDetails == null) {
            throw new IllegalStateException("errorDetails is required");
        }

        if (this.retries == -1) {
            throw new IllegalStateException("retries is required");
        }

        if (this.retryTimeout == null) {
            throw new IllegalStateException("retryTimeout is required");
        }

        this.commandExecutor.execute(new Command() {
            @Override
            public void execute() {
                
                String command = String.format(
                    "java -jar %s %s %s %s %s %s %s %s",
                    jobServiceConfiguration.getFailureBuilderJar(),
                    externalJobId,
                    workerId,
                    errorMessage,
                    errorDetails,
                    retries,
                    retryTimeout.toMillis(),
                    jobServiceConfiguration.getFailureBuilderClass()
                );

                commandExecutor.execute(command);
            }
        });
    <|file_separator|><nl>
        this.onlyUnlocked = true;
        return this;
    <|file_separator|><nl>
        return (ExecutorPerTenantAsyncExecutor) super.getAsyncExecutor();
    <|file_separator|><nl>
        try {
            for (String deadLetterJobId : deadLetterJobIds) {
                Job job = jobServiceConfiguration.getJobService().getJob(deadLetterJobId);
                if (job != null) {
                    jobServiceConfiguration.getJobService().moveJobToHistory(job, retries);
                }
            }
        } catch (Exception e) {
            LOGGER.error("Error moving jobs to history", e);
        }
        return null;
    <|file_separator|><nl>
        JobService jobService = new JobService(jobServiceConfiguration);
        jobService.deleteJob(jobId);
    <|file_separator|><nl>
        LOGGER.info("Moving deadletter job {} to history", deadletterJobId);
        return new HistoryJob(deadletterJobId, retries, jobServiceConfiguration);
    <|file_separator|><nl>
        return null;
    <|file_separator|><nl>
        try {
            if (jobServiceConfiguration.isJobEnabled(job)) {
                jobServiceConfiguration.unlockJob(job);
            }
        } catch (Exception e) {
            LOGGER.error("Error unlocking job", e);
        }
        return null;
    <|file_separator|><nl>
        return getCommandContext();
    <|file_separator|><nl>
        return jobEntity.getExecutionId() == (Long) parameter;
    <|file_separator|><nl>
        return jobEntity.getExecutionId() == (Long) param;
    <|file_separator|><nl>
        return timerJobEntity.getScopeId() == (Long) param;
    <|file_separator|><nl>
        inMemoryDirectoryServer.stop();
    <|file_separator|><nl>
            return null;
        }

        @Override
        public void disconnect() {
        <|file_separator|><nl>
        this.activityId = activityId;
    <|file_separator|><nl>
        // TODO: Implement your validation logic here
    <|file_separator|><nl>
        if (authentication.getPrincipal() == null) {
            return null;
        }
        
        if (authentication.getCredentials() == null) {
            return null;
        }
        
        if (authentication instanceof UsernamePasswordAuthenticationToken) {
            UsernamePasswordAuthenticationToken token = (UsernamePasswordAuthenticationToken) authentication;
            
            if (token.getPrincipal() instanceof String) {
                String username = (String) token.getPrincipal();
                String password = (String) token.getCredentials();
                
                if (username != null && password != null) {
                    if (this.verifyRestApiPrivilege) {
                        if (this.idmIdentityService.authenticate(username, password)) {
                            return new UsernamePasswordAuthenticationToken(username, password);
                        }
                    } else {
                        if (this.identityService.authenticate(username, password)) {
                            return new UsernamePasswordAuthenticationToken(username, password);
                        }
                    }
                }
            }
        }
        
        return null;
    <|file_separator|><nl>
        return jobIds;
    <|file_separator|><nl>
        this.name = name;
    <|file_separator|><nl>
        return restResponseFactory.createDataResponse(historyService.createHistoricActivityInstanceQuery(queryRequest).list(), allRequestParams);
    <|file_separator|><nl>
        historyService.deleteHistoricProcessInstance(processInstanceId);
    <|file_separator|><nl>
        return isTypeChanged;
    <|file_separator|><nl>
        User user = getUserFromRequest(userId);
        String validKey = getValidKeyFromRequest(user, key);

        return restResponseFactory.createUserInfoResponse(key, identityService.getUserInfo(user.getId(), validKey), user.getId());
    <|file_separator|><nl>
        User user = getUserFromRequest(userId);
        Picture userPicture = identityService.getUserPicture(user.getId());

        if (userPicture == null) {
            throw new FlowableObjectNotFoundException("The user with id '" + user.getId() + "' does not have a picture.", Picture.class);
        }

        try {
            InputStream inputStream = request.getPart("file").getInputStream();
            userPicture.setInputStream(inputStream);
            userPicture.setMimeType(request.getPart("file").getContentType());
            identityService.updateUserPicture(userPicture);
        } catch (IOException e) {
            throw new FlowableException("Error updating picture: " + e.getMessage(), e);
        }
    <|file_separator|><nl>
        User user = getUserFromRequest(userId);
        
        if (restApiInterceptor != null) {
            restApiInterceptor.updateUser(user, userRequest);
        }
        
        identityService.updateUser(user, userRequest);
        
        return restResponseFactory.createUserResponse(user, false);
    <|file_separator|><nl>
        this.processInstanceUrl = processInstanceUrl;
    <|file_separator|><nl>
        return managementService.getProperties();
    <|file_separator|><nl>
        return managementService.getTables();
    <|file_separator|><nl>
        VariableInstanceQuery variableInstanceQuery = runtimeService.createVariableInstanceQuery();
        addVariables(variableInstanceQuery, queryRequest.getVariables());
        addSort(variableInstanceQuery, queryRequest.getSort());
        addLimit(variableInstanceQuery, queryRequest.getLimit());
        addOffset(variableInstanceQuery, queryRequest.getOffset());
        return restResponseFactory.createDataResponse(variableInstanceQuery.list(), queryRequest.getSort(), queryRequest.getLimit(), queryRequest.getOffset());
    }

    protected void addSort(VariableInstanceQuery variableInstanceQuery, List<String> sortProperties) {
        if (sortProperties != null) {
            for (String sortProperty : sortProperties) {
                if (!allowedSortProperties.containsKey(sortProperty)) {
                    throw new FlowableIllegalArgumentException("Invalid sort property: " + sortProperty);
                }
                variableInstanceQuery.sortBy(allowedSortProperties.get(sortProperty));
            }
        }
    }

    protected void addLimit(VariableInstanceQuery variableInstanceQuery, Integer limit) {
        if (limit != null) {
            variableInstanceQuery.limit(limit);
        }
    }

    protected void addOffset(VariableInstanceQuery variableInstanceQuery, Integer offset) {
        if (offset != null) {
            variableInstanceQuery.offset(offset);
        }
    <|file_separator|><nl>
        RestVariable variable = null;
        try {
            variable = runtimeService.getVariableInstance(varInstanceId);
        } catch (FlowableObjectNotFoundException e) {
            // Re-throw FlowableObjectNotFoundException
            throw e;
        }
        if (includeBinary && RestResponseFactory.BYTE_ARRAY_VARIABLE_TYPE.equals(variable.getType()) && variable.getValue() == null) {
            throw new FlowableObjectNotFoundException("The variable does not have a binary data stream.", null);
        }
        return variable;
    <|file_separator|><nl>
        return super.queryActivityInstances(queryRequest, allRequestParams);
    <|file_separator|><nl>
        return durationInMillis;
    <|file_separator|><nl>
        return restResponseFactory.createDataResponse(restApiInterceptor.getRestResponse(allRequestParams));
    <|file_separator|><nl>
        return referenceId;
    <|file_separator|><nl>
        HistoricTaskInstance task = getHistoricTaskFromRequest(taskId);
        return restResponseFactory.createRestComment(taskService.createTaskComment(task.getId(), comment));
    <|file_separator|><nl>
        return null;
    <|file_separator|><nl>

        Task task = getTaskFromRequestWithoutAccessCheck(taskId);
        validateIdentityLinkArguments(family, identityId, type);

        IdentityLink link = getIdentityLink(family, identityId, type, task.getId());

        if (restApiInterceptor != null) {
            restApiInterceptor.accessTaskIdentityLink(task, link);
        }

        taskService.deleteIdentityLink(link);
    <|file_separator|><nl>
        LOGGER.debug("Closing Spring root application context");
        AnnotationConfigWebApplicationContext rootContext = (AnnotationConfigWebApplicationContext) sce.getServletContext().getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE);
        if (rootContext != null) {
            rootContext.close();
        }
    <|file_separator|><nl>
        assertResultsPresentInDataResponse("/runtime/activity-instances", 1);
    }

    /**
     * Test querying activity instance. GET runtime/activity-instances?activityId=1
     */
    @Test
    @Deployment(resources = { "org/flowable/rest/service/api/twoTaskProcess.bpmn20.xml" })
    public void testQueryActivityInstancesWithActivityId() throws Exception {
        assertResultsPresentInDataResponse("/runtime/activity-instances?activityId=1", 1, "1");
    }

    /**
     * Test querying activity instance. GET runtime/activity-instances?activityId=1&activityInstanceId=1
     */
    @Test
    @Deployment(resources = { "org/flowable/rest/service/api/twoTaskProcess.bpmn20.xml" })
    public void testQueryActivityInstancesWithActivityIdAndActivityInstanceId() throws Exception {
        assertResultsPresentInDataResponse("/runtime/activity-instances?activityId=1&activityInstanceId=1", 1, "1");
    }

    /**
     * Test querying activity instance. GET runtime/activity-instances?activityId=1&activityInstanceId=1&activityInstanceId=2
     */
    @Test
    @Deployment(resources = { "org/flowable/rest/service/api/twoTaskProcess.bpmn20.xml" })
    public void testQueryActivityInstancesWithActivityIdAndActivityInstanceIdAndActivityInstanceId() throws Exception {
        assertResultsPresentInDataResponse("/runtime/activity-instances?activityId=1&activityInstanceId=1&activityInstanceId=2", 1, "1");
    <|file_separator|><nl>
    <|file_separator|><nl>
        this.someField = someField;
    <|file_separator|><nl>
        this.label = label;
    <|file_separator|><nl>

        String processDefinitionsUrl = "http://localhost:" + serverPort + "/process-api/repository/process-definitions";
        HttpEntity<?> request = new HttpEntity<>(createHeaders("kermit", "password"));
        ResponseEntity<DataResponse<ProcessDefinitionResponse>> response = testRestTemplate
            .exchange(processDefinitionsUrl, HttpMethod.GET, request, new ParameterizedTypeReference<DataResponse<ProcessDefinitionResponse>>() {

            });

        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
    <|file_separator|><nl>
        engineConfiguration.setDataSource(dataSource);
        engineConfiguration.setFlowableProperties(flowableProperties);
    <|file_separator|><nl>
        return loadOnStartup;
    <|file_separator|><nl>
        return processEngine.invoke();
    }

    @WriteOperation
    public void setProcessEngine(ProcessEngine processEngine) {
        this.processEngine = processEngine;
    }

    @ReadOperation
    public long getProcessEngineTimeout() {
        return processEngine.getTimeout();
    }

    @WriteOperation
    public void setProcessEngineTimeout(long timeout) {
        processEngine.setTimeout(timeout);
    }

    @ReadOperation
    public long getProcessEngineTimeoutInDays() {
        return secondsForDays(processEngine.getTimeout() / 1000 / 60 / 60 / 24);
    <|file_separator|><nl>
        return cmmnEngine.getCmmnMigrationService();
    }<|file_separator|><nl>
        return getSpringFactoriesLoader(classLoader).loadFactoryNames().stream()
                .map(SpringFactoriesLoader::getFactoryClass)
                .map(Class::getPackage)
                .map(Package::getName)
                .map(name -> name.replace('.', '/'))
                .map(name -> name + ".class")
                .collect(Collectors.toList());
    <|file_separator|><nl>
        return new EventRegistryRestResponseFactory(objectMapper);
    <|file_separator|><nl>
            return new IdmEngineFactoryBean(idmEngineConfiguration);
        <|file_separator|><nl>
        List<Deployment> deployments = appEngine.getRepositoryService().createDeploymentQuery().list();
        for (Deployment deployment : deployments) {
            appEngine.getRepositoryService().deleteDeployment(deployment.getId(), true);
        }
    <|file_separator|><nl>
        engineConfiguration.setProcessEngineConfiguration(this.processEngineConfiguration);
    <|file_separator|><nl>
        return this;
    <|file_separator|><nl>
        LOGGER.info("Deploying single resource");
        engine.executeProcess(deploymentNameHint, resources);
    <|file_separator|><nl>
            return customPropertiesMap;
        <|file_separator|><nl>
        runtimeService.startProcessInstanceByKey("delegateExpressionSingleton", CollectionUtil.singletonMap("input", 100));
        Task task = taskService.createTaskQuery().singleResult();
        Map<String, Object> variables = taskService.getVariables(task.getId());

        Integer resultServiceTask1 = (Integer) variables.get("resultServiceTask1");
        assertThat(resultServiceTask1.intValue()).isEqualTo(202);

        Integer resultServiceTask2 = (Integer) variables.get("resultServiceTask2");
        assertThat(resultServiceTask2.intValue()).isEqualTo(579);

        // Verify ONE INSTANCE was created
        assertThat(SingletonDelegateExpressionBean.INSTANCE_COUNT.get()).isEqualTo(1);
    <|file_separator|><nl>
        processEngine.close();
    <|file_separator|><nl>
        // do something
    <|file_separator|><nl>
        HistoricTaskLogEntry historicTaskLogEntry = new HistoricTaskLogEntry();
        historicTaskLogEntry.setTaskId(this.task.getId());
        historicTaskLogEntry.setTaskName(this.task.getName());
        historicTaskLogEntry.setTaskDefinitionKey(this.task.getTaskDefinitionKey());
        historicTaskLogEntry.setTaskDefinitionName(this.task.getTaskDefinitionName());
        historicTaskLogEntry.setTaskDefinitionResourceType(this.task.getTaskDefinitionResourceType());
        historicTaskLogEntry.setTaskDefinitionResourceName(this.task.getTaskDefinitionResourceName());
        historicTaskLogEntry.setTaskDefinitionResourceDescription(this.task.getTaskDefinitionResourceDescription());
        historicTaskLogEntry.setTaskDefinitionResourceClass(this.task.getTaskDefinitionResourceClass());
        historicTaskLogEntry.setTaskDefinitionResourceInterface(this.task.getTaskDefinitionResourceInterface());
        historicTaskLogEntry.setTaskDefinitionResourceInterfaceName(this.task.getTaskDefinitionResourceInterfaceName());
        historicTaskLogEntry.setTaskDefinitionResourceInterfaceDescription(this.task.getTaskDefinitionResourceInterfaceDescription());
        historicTaskLogEntry.setTaskDefinitionResourceInterfaceClass(this.task.getTaskDefinitionResourceInterfaceClass());
        historicTaskLogEntry.setTaskDefinitionResourceInterfaceInterface(this.task.getTaskDefinitionResourceInterfaceInterface());
        historicTaskLogEntry.setTaskDefinitionResourceInterfaceInterfaceName(this.task.getTaskDefinitionResourceInterfaceInterfaceName());
        historicTaskLogEntry.setTaskDefinitionResourceInterfaceInterfaceDescription(this.task.getTaskDefinitionResourceInterfaceInterfaceDescription());
        historicTaskLogEntry.setTaskDefinitionResourceInterfaceInterfaceClass(this.task.getTaskDefinitionResourceInterfaceInterfaceClass());
        historicTaskLogEntry.setTaskDefinitionResourceInterfaceInterfaceInterface(this.task.getTaskDefinitionResourceInterfaceInterfaceInterface());
        historicTaskLogEntry.setTaskDefinitionResourceInterfaceInterfaceInterfaceName(this.task.getTaskDefinitionResource<nl>
        return name;
    <|file_separator|><nl>
        hints.reflection().registerType(Flowable.class, new ReflectionHints(Flowable.class, ReflectionHints.ReflectionTarget.ALL));
    <|file_separator|><nl>
        return taskEntity.getSubScopeId() == (Long) parameter;
    <|file_separator|><nl>
        return Context.getCommandContext().getSession(DbSqlSession.class);
    <|file_separator|><nl>
        getHistoricVariableInstanceEntityManager().deleteHistoricVariableInstancesForNonExistingProcessInstances();
    <|file_separator|><nl>
        return variableServiceConfiguration.getHistoricVariableInstanceEntityManager().findHistoricVariableInstancesByNativeQuery(parameterMap);
    <|file_separator|><nl>
    <|file_separator|><nl>
        return true;
    <|file_separator|><nl>
        return true;
    <|file_separator|><nl>
        return true;
    <|file_separator|><nl>
        for (VariableType type : typesList) {
            if (type.isCompatible(value)) {
                return type;
            }
        }
        return null;
    }

    @Override
    public List<VariableType> getTypesList() {
        return typesList;
    }

    @Override
    public String toString() {
        return typesList.toString();
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        DefaultVariableTypes that = (DefaultVariableTypes) o;
        return typesList.equals(that.typesList);
    }

    @Override
    public int hashCode() {
        return typesList.hashCode();
    }

    @Override
    public VariableTypes addType(VariableType type, int index, boolean isDefault) {
        return addType(type, index, isDefault, typesList.size());
    }

    @Override
    public VariableTypes addType(VariableType type, int index, boolean isDefault, int size) {
        if (index < 0 || index > size) {
            throw new IndexOutOfBoundsException("Index " + index + " is out of bounds for length " + size);
        }
        typesList.add(index, type);
        typesMap.put(type.getTypeName(), type);
        return this;
    }

    @Override
    public VariableTypes addType(VariableType type, int index, boolean isDefault, int size, int typeIndex) {
        if (index < 0 || index > size) {
            throw new IndexOutOfBoundsException("Index " + index + " is out of bounds for length " + size<nl>
        return value instanceof Long;
    <|file_separator|><nl>
        CamelContext ctx = applicationContext.getBean(CamelContext.class);
        ProducerTemplate tpl = ctx.createProducerTemplate();
        Object expectedObj = Long.valueOf(99);

        Exchange exchange = ctx.getEndpoint("direct:startEmpty").createExchange();
        exchange.getIn().setBody(expectedObj);
        tpl.send("direct:startEmpty", exchange);

        String instanceId = (String) exchange.getProperty("PROCESS_ID_PROPERTY");

        assertProcessEnded(instanceId);
        HistoricVariableInstance var = processEngine.getHistoryService().createHistoricVariableInstanceQuery().variableName("camelBody").singleResult();
        assertNotNull(var);
        assertEquals(expectedObj.toString(), var.getValue().toString());
    <|file_separator|><nl>
        camelContext.stop();
    <|file_separator|><nl>
                from("direct:start").to("direct:receive");
                from("direct:receive").to("mock:service1");
                from("direct:receive").to("mock:service2");
            <|file_separator|><nl>
        isCalled = true;
    <|file_separator|><nl>
        // TODO Auto-generated method stub
        
    <|file_separator|><nl>
        // TODO
    <|file_separator|><nl>
        // given
        final String processDefinitionKey = "startProcessInstanceTest";
        final String processInstanceId = "1";

        // when
        final ProcessInstance processInstance = processEngine.getRuntimeService()
                .startProcessInstanceByKey(processDefinitionKey, processInstanceId);

        // then
        assertThat(processInstance).isNotNull();
        assertThat(processInstance.getId()).isEqualTo(processInstanceId);
    <|file_separator|><nl>
        // TODO Auto-generated method stub
        
    <|file_separator|><nl>
        userTask.setAssignee(userTask.getAssignee() + "B");
    <|file_separator|><nl>
        // TODO Auto-generated method stub
        
    <|file_separator|><nl>
        return activiti5ProcessInstance.isEnded();
    }

    @Override
    public boolean isTerminated() {
        return activiti5ProcessInstance.isTerminated();
    }

    @Override
    public boolean isSuspended() {
        return activiti5ProcessInstance.isSuspended();
    <|file_separator|><nl>
        return false;
    <|file_separator|><nl>
        // TODO: implement test
    <|file_separator|><nl>
        this.errorCode = errorCode;
    <|file_separator|><nl>
        return localScope;
    <|file_separator|><nl>
        return super.createPropertiesNode(flowElement, flowElementNode, objectMapper);
    <|file_separator|><nl>
        return directions.get(directionName);
    <|file_separator|><nl>
        if (eventName == null) {
            throw new ActivitiIllegalArgumentException("Provided event name is null");
        }
        this.eventName = eventName;
        return this;
    <|file_separator|><nl>
        return name;
    <|file_separator|><nl>
    <|file_separator|><nl>
        return properties.get(propertyName);
    <|file_separator|><nl>
        return commandContext
                .getHistoricVariableInstanceEntityManager()
                .findHistoricVariableInstancesByNativeQuery(parameterMap, firstResult, maxResults);
    <|file_separator|><nl>
        return commandExecutor.execute(this);
    }

    @Override
    public int getFirstResult() {
        return firstResult;
    }

    @Override
    public int getMaxResults() {
        return maxResults;
    }

    @Override
    public String toString() {
        return "TablePageQueryImpl [tableName=" + tableName + ", order=" + order + ", firstResult=" + firstResult
                + ", maxResults=" + maxResults + "]";
    }

    public void setFirstResult(int firstResult) {
        this.firstResult = firstResult;
    }

    public void setMaxResults(int maxResults) {
        this.maxResults = maxResults;
    <|file_separator|><nl>
        for (Entry<T, E> entry : map.entrySet()) {
            if (value.equals(entry.getValue())) {
                return entry.getKey();
            }
        }
        return null;
    <|file_separator|><nl>
        if (event.getMessageName().equals(messageName)) {
            throw new RuntimeException("Message " + messageName + " was thrown");
        }
    }

    public Class<?> getEntityClass() {
        return entityClass;
    }

    public void setEntityClass(Class<?> entityClass) {
        this.entityClass = entityClass;
    }

    public String getMessageName() {
        return messageName;
    <|file_separator|><nl>
        // do nothing
    }

    @Override
    public void notify(Task task) {
        // do nothing
    }

    @Override
    public void notify(TaskListener taskListener) {
        // do nothing
    }

    @Override
    public void notify(TaskListener[] taskListeners) {
        // do nothing
    }

    @Override
    public void notify(TaskListener taskListener, Task task) {
        // do nothing
    }

    @Override
    public void notify(TaskListener taskListener, Task[] tasks) {
        // do nothing
    }

    @Override
    public void notify(TaskListener taskListener, TaskListener[] taskListeners) {
        // do nothing
    }

    @Override
    public void notify(TaskListener taskListener, TaskListener[] taskListeners, Task task) {
        // do nothing
    }

    @Override
    public void notify(TaskListener taskListener, TaskListener[] taskListeners, Task[] tasks) {
        // do nothing
    }

    @Override
    public void notify(TaskListener taskListener, TaskListener[] taskListeners, TaskListener[] taskListeners2, Task task) {
        // do nothing
    }

    @Override
    public void notify(TaskListener taskListener, TaskListener[] taskListeners, TaskListener[] taskListeners2, Task[] tasks) {
        // do nothing
    }

    @Override
    public void notify(TaskListener taskListener, TaskListener[] taskListeners, TaskListener[] taskListeners2, TaskListener[] taskListeners3, Task task) {
        // do nothing
    }

    @Override
    public void notify(TaskListener taskListener, TaskListener[] taskListeners, TaskListener[] taskListeners2, TaskListener[] taskListeners3, Task[] tasks) {
<nl>
        return null;
    <|file_separator|><nl>
        if (element instanceof BpmnFlowNode) {
            BpmnFlowNode bpmnFlowNode = (BpmnFlowNode) element;
            bpmnFlowNode.setFlowNode(bpmnParse.getFlowNode(bpmnFlowNode.getId()));
        }
    <|file_separator|><nl>
        // TODO Auto-generated method stub
    <|file_separator|><nl>
        // TODO Auto-generated method stub
        
    <|file_separator|><nl>
        HistoricProcessInstanceManager manager = commandContext.getProcessEngineConfiguration().getHistoricProcessInstanceManager();
        HistoricProcessInstance historicProcessInstance = manager.findHistoricProcessInstance(this.processInstanceId);
        if (historicProcessInstance == null) {
            throw new ProcessEngineException("HistoricProcessInstance '" + this.processInstanceId + "' not found");
        }
        manager.deleteHistoricProcessInstance(historicProcessInstance);
        return null;
    <|file_separator|><nl>
        return commandContext.getExecutionService().findActiveActivityIds(executionId);
    <|file_separator|><nl>
        try {
            ProcessDefinition processDefinition = commandContext.getProcessEngineConfiguration().getProcessEngineConfiguration().getProcessDefinitionManager().findProcessDefinition(this.processDefinitionId);
            if (processDefinition == null) {
                throw new ActivitiException("No process definition found with id '" + this.processDefinitionId + "'.");
            }
            return new ByteArrayInputStream(processDefinition.getDiagramResourceName().getBytes());
        } catch (Exception e) {
            LOGGER.error("Error while retrieving the process definition diagram", e);
            throw new ActivitiException("Error while retrieving the process definition diagram", e);
        }
    <|file_separator|><nl>
        return commandContext.getExecutionManager().getVariables(executionIds);
    <|file_separator|><nl>
        if (processDefinitionId == null || processDefinitionId.length() < 1) {
            throw new ActivitiIllegalArgumentException("The process definition id is mandatory, but '" + processDefinitionId + "' has been provided.");
        }
        this.processDefinitionId = processDefinitionId;
    <|file_separator|><nl>
        ProcessDefinition processDefinition = commandContext.getProcessDefinitionService().getProcessDefinition(processDefinitionId);
        return processDefinition.getIdentityLinks();
    <|file_separator|><nl>
        return commandContext.getTableMetaData(tableName);
    <|file_separator|><nl>
        return commandContext.getComments().stream()
                .filter(comment -> comment.getType().equals(type))
                .collect(Collectors.toList());
    <|file_separator|><nl>
        if (this.async) {
            execution.getProcessEngine().getMessageService().asyncSend(this.messageName, this.payload);
        } else {
            execution.getProcessEngine().getMessageService().send(this.messageName, this.payload);
        }
        return null;
    <|file_separator|><nl>
        // TODO: Implement the command logic
        return null;
    <|file_separator|><nl>
        Job job = commandContext.getJobManager().getJob(jobId);
        if (job == null) {
            throw new ActivitiObjectNotFoundException("Job '" + jobId + "' not found.");
        }
        job.setRetries(retries);
        return null;
    <|file_separator|><nl>
        return lastId;
    <|file_separator|><nl>
        return valueExpression.getValue();
    <|file_separator|>class Expression.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public interface Expression {

    public Object getValue();

}<|file_separator|>class DelegateInvocation.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public abstract class DelegateInvocation {

    public abstract Object getTarget();

}<|file_separator|>class ValueExpression.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class ValueExpression implements Expression {

    private final Object value;

    public ValueExpression(Object value) {
        this.value = value;
    }

    @Override
    public Object getValue() {
        return value;
    }

}<|file_separator|>class Delegate.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class Delegate {

    private final DelegateInvocation invocation;

    public Delegate(DelegateInvocation invocation) {
        this.invocation = invocation;
    }

    public Object invoke() {
        return invocation.getTarget();
    }

}<|file_separator|><nl>
        elContext.setVariable(valueExpression.getVariableName(), value);
    <|file_separator|><nl>
        delegateInstance.execute(execution);
    <|file_separator|><nl>
        // TODO Auto-generated method stub
    <|file_separator|><nl>
        // TODO: Implement your event handler logic here
    <|file_separator|><nl>
        // TODO: Implement your event handler logic here
    <|file_separator|><nl>
        return new EventLogEntryEntity(
            commandContext.getVariable().getVariableId(),
            commandContext.getVariable().getVariableName(),
            commandContext.getVariable().getVariableType(),
            commandContext.getVariable().getVariableValue(),
            commandContext.getVariable().getVariableValue(),
            commandContext.getVariable().getVariableValue(),
            commandContext.getVariable().getVariableValue(),
            commandContext.getVariable().getVariableValue(),
            commandContext.getVariable().getVariableValue(),
            commandContext.getVariable().getVariableValue(),
            commandContext.getVariable().getVariableValue(),
            commandContext.getVariable().getVariableValue(),
            commandContext.getVariable().getVariableValue(),
            commandContext.getVariable().getVariableValue(),
            commandContext.getVariable().getVariableValue(),
            commandContext.getVariable().getVariableValue(),
            commandContext.getVariable().getVariableValue(),
            commandContext.getVariable().getVariableValue(),
            commandContext.getVariable().getVariableValue(),
            commandContext.getVariable().getVariableValue(),
            commandContext.getVariable().getVariableValue(),
            commandContext.getVariable().getVariableValue(),
            commandContext.getVariable().getVariableValue(),
            commandContext.getVariable().getVariableValue(),
            commandContext.getVariable().getVariableValue(),
            commandContext.getVariable().getVariableValue(),
            commandContext.getVariable().getVariableValue(),
            commandContext.getVariable().getVariableValue(),
            commandContext.getVariable().getVariableValue(),
            commandContext.getVariable().getVariableValue(),
            commandContext.getVariable().getVariableValue(),
            commandContext.getVariable().getVariableValue(),
            commandContext.getVariable().<nl>
        this.formKey = formKey;
        this.deploymentId = deployment.getId();
        for (org.flowable.bpmn.model.FormProperty formProperty : formProperties) {
            FormPropertyHandler formPropertyHandler = FormPropertyHandlerFactory.create(formProperty);
            formPropertyHandler.parseConfiguration(formProperty, deployment, processDefinition);
            formPropertyHandlers.add(formPropertyHandler);
        }
    <|file_separator|><nl>
        if (propertyValue == null) {
            return null;
        }
        return Double.parseDouble(propertyValue);
    <|file_separator|><nl>
        return propertyValue;
    <|file_separator|><nl>
        this.task = task;
    <|file_separator|><nl>
        System.out.println("Task " + task.getName() + " is done");
    <|file_separator|><nl>
        CommandConfig config = new CommandConfig(this);
        config.propagation = TransactionPropagation.REQUIRES_NEW;
        return config;
    }

    public CommandConfig transactionNever() {
        CommandConfig config = new CommandConfig(this);
        config.propagation = TransactionPropagation.NEVER;
        return config;
    <|file_separator|><nl>
        return command.execute(config);
    <|file_separator|>class CommandInterceptor.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public interface CommandInterceptor {

    <T> T execute(CommandConfig config, Command<T> command);

    CommandInterceptor getNext();

    void setNext(CommandInterceptor next);

}<|file_separator|>class Command.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public interface Command<T> {

    T execute(CommandConfig config);

}<|file_separator|>class CommandConfig.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class CommandConfig {

    private String name;
    private String description;
    private String[] tags;
    private String[] aliases;
    private String[] args;
    private String[] options;
    private String[] flags;
    private String[] subcommands;
    private String[] subcommandArgs;
    private String[] subcommandOptions;
    private String[] subcommandFlags;
    private String[] subcommandAliases;
    private String[] subcommandTags;
    private String[] subcommandDescription;
    private String[] subcommandName;
    private String[] subcommand;
    private String[] subcommandArgsName;
    private String[] subcommandOptionsName;
    private String[] subcommandFlagsName;
    private String[] subcommandAliasesName;
    private String[] subcommandTagsName;
    private String[] subcommandDescriptionName;
    private String[] subcommandNameName;
    private String[] subcommandNameNameName;
    private String[] subcommandNameNameNameName;
    private String[] subcommandNameNameNameNameName;
    private String[] subcommandNameNameNameNameNameName;
    private String[] subcommandNameNameNameNameNameNameName;
    private String[] subcommandNameNameNameNameNameNameNameName;
    private String[] subcommandNameNameNameNameNameNameNameNameName;
    <nl>
        try {
            commandExecutor.execute(commandContext);
        } catch (Throwable e) {
            LOGGER.error("Failed to execute command", e);
            setException(e);
        }
    <|file_separator|><nl>
        return commandContext.getTimerJobRepository().getUnlockedTimersByDuedate(duedate, page);
    <|file_separator|><nl>
        this.revision = revision;
    <|file_separator|><nl>
        checkHistoryEnabled();
        getDbSqlSession().delete("deleteAttachmentsByTaskId", taskId);
    }

    @SuppressWarnings("unchecked")
    public void deleteAttachmentsByProcessInstanceId(String processInstanceId) {
        checkHistoryEnabled();
        getDbSqlSession().delete("deleteAttachmentsByProcessInstanceId", processInstanceId);
    }

    @SuppressWarnings("unchecked")
    public void deleteAttachmentsByProcessInstanceIdAndTaskId(String processInstanceId, String taskId) {
        checkHistoryEnabled();
        getDbSqlSession().delete("deleteAttachmentsByProcessInstanceIdAndTaskId", new Object[]{processInstanceId, taskId});
    }

    @SuppressWarnings("unchecked")
    public void deleteAttachmentsByProcessInstanceIdAndTaskDefinitionId(String processInstanceId, String taskDefinitionId) {
        checkHistoryEnabled();
        getDbSqlSession().delete("deleteAttachmentsByProcessInstanceIdAndTaskDefinitionId", new Object[]{processInstanceId, taskDefinitionId});
    }

    @SuppressWarnings("unchecked")
    public void deleteAttachmentsByProcessInstanceIdAndTaskDefinitionKey(String processInstanceId, String taskDefinitionKey) {
        checkHistoryEnabled();
        getDbSqlSession().delete("deleteAttachmentsByProcessInstanceIdAndTaskDefinitionKey", new Object[]{processInstanceId, taskDefinitionKey});
    }

    @SuppressWarnings("unchecked")
    public void deleteAttachmentsByProcessInstanceIdAndTaskDefinitionName(String processInstanceId, String taskDefinitionName) {
        checkHistoryEnabled();
        getDbSqlSession().delete("deleteAttachmentsByProcessInstanceIdAndTaskDefinitionName", new Object[]{processInstanceId, taskDefinitionName});
    }

    @SuppressWarnings("unchecked")
    public void deleteAttachmentsByProcessInstanceIdAndTaskDefinitionCategory(String processInstanceId, String taskDefinitionCategory) {
        checkHistoryEnabled();
        getDbSqlSession().delete("deleteAttachmentsByProcessInstanceIdAndTaskDefinitionCategory", new Object[]{processInstanceId, taskDefinitionCategory});
    }

    @<nl>
        return (ProcessDefinitionEntity) getDbSqlSession().selectOne("selectProcessDefinitionByDeploymentAndKeyAndTenantId", parameters);
    <|file_separator|><nl>
        return lanes;
    }

    public void setLanes(List<Lane> lanes) {
        this.lanes = lanes;
    <|file_separator|>class Lane.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class Lane {

    private static final long serialVersionUID = 1L;

    protected String id;
    protected String name;
    protected String description;
    protected String laneType;
    protected String laneStatus;
    protected String laneStatusDescription;
    protected String laneStatusDate;
    protected String laneStatusTime;
    protected String laneStatusUser;
    protected String laneStatusUserDescription;
    protected String laneStatusUserDate;
    protected String laneStatusUserTime;
    protected String laneStatusUserIP;
    protected String laneStatusUserBrowser;
    protected String laneStatusUserOS;
    protected String laneStatusUserOSVersion;
    protected String laneStatusUserOSDescription;
    protected String laneStatusUserOSDescriptionShort;
    protected String laneStatusUserOSDescriptionLong;
    protected String laneStatusUserOSDescriptionLongShort;
    protected String laneStatusUserOSDescriptionLongLong;
    protected String laneStatusUserOSDescriptionLongLongShort;
    protected String laneStatusUserOSDescriptionLongLongLong;
    protected String laneStatusUserOSDescriptionLongLongLongShort;
    protected String laneStatusUserOSDescriptionLongLongLongLong;
    protected String laneStatusUserOSDescriptionLongLongLongLongShort;
    protected String laneStatusUserOSDescriptionLongLongLongLongLong;
    protected String laneStatusUserOSDescriptionLongLongLongLongLongShort;
    protected String laneStatusUserOSDescriptionLongLongLongLongLongLong;
    protected String laneStatusUserOSDescriptionLongLongLongLongLongLongShort;
    protected String laneStatusUserOSDescriptionLongLongLongLongLongLongLong;
    protected String laneStatusUser<nl>
        LOGGER.info("Executing atomic operation");
    <|file_separator|><nl>
        ScopeImpl scope = (ScopeImpl) execution.getScope();
        scope.remove(execution.getDestination());
    <|file_separator|><nl>
        return selectedInitial;
    <|file_separator|><nl>
        return anObject.toString().length();<|file_separator|><nl>
        return Long.parseLong(anObject.toString());<|file_separator|><nl>
        return deserialize(valueFields.getBytes(), valueFields);
    <|file_separator|><nl>
        this.taskInfoQuery = taskInfoQuery;
    <|file_separator|><nl>
        final Resource[] resources = new Resource[] { resourceMock1, resourceMock2 };
        classUnderTest.deployResources(deploymentNameHint, resources, repositoryServiceMock);

        verify(repositoryServiceMock).createDeployment();
        verify(deploymentBuilderMock).enableDuplicateFiltering();
        verify(deploymentBuilderMock).name(deploymentNameHint);
        verify(deploymentBuilderMock).addInputStream(isA(String.class), isA(InputStream.class));
        verify(deploymentBuilderMock).addInputStream(eq(resourceName1), isA(InputStream.class));
        verify(deploymentBuilderMock).addInputStream(eq(resourceName2), isA(InputStream.class));
        verify(deploymentBuilderMock).addZipInputStream(isA(ZipInputStream.class));
        verify(deploymentBuilderMock).deploy();
    <|file_separator|><nl>
        // do something
    <|file_separator|><nl>
        // Pretty useless LDAP service ...
        return Arrays.asList("Kermit The Frog");
    <|file_separator|><nl>
        if (processEngine != null) {
            processEngine.close();
        }
    <|file_separator|><nl>
        waitForJobExecutorOnCondition(managementService);
    <|file_separator|><nl>
        <|file_separator|><nl>
        return new MockResolver(variableScope);
    <|file_separator|><nl>
        ProcessInstance processInstance = runtimeService.startProcessInstanceByKey("oneTaskProcess");
        assertEquals(1, listener.getEventsReceived().size());
        assertEquals(Execution.class, listener.getEventsReceived().get(0).getEntityClass());
        assertEquals(processInstance.getId(), listener.getEventsReceived().get(0).getEntityId());
    <|file_separator|><nl>
        // given
        final String processId = "standalone-task-variable-standalone";
        final String processDefinitionId = "standalone-task-variable-standalone";
        final String processInstanceId = "standalone-task-variable-standalone";
        final String taskId = "standalone-task-variable-standalone";
        final String taskDefinitionKey = "standalone-task-variable-standalone";
        final String variableName = "standalone-task-variable-standalone";
        final String variableValue = "standalone-task-variable-standalone";

        // when
        final ProcessInstance processInstance = runtimeService.startProcessInstanceByKey(processId);
        final Task task = taskService.createTaskQuery().processInstanceId(processInstanceId).singleResult();
        taskService.complete(task.getId());

        // then
        final List<VariableEvent> events = listener.getEventsReceived();
        assertEquals(1, events.size());
        final VariableEvent event = events.get(0);
        assertEquals(processDefinitionId, event.getProcessDefinitionId());
        assertEquals(processInstanceId, event.getProcessInstanceId());
        assertEquals(taskId, event.getTaskId());
        assertEquals(taskDefinitionKey, event.getTaskDefinitionKey());
        assertEquals(variableName, event.getVariableName());
        assertEquals(variableValue, event.getVariableValue());
    <|file_separator|><nl>
        eventsReceived.clear();
    <|file_separator|><nl>
        // TODO Auto-generated method stub
        
    <|file_separator|><nl>
        // TODO Auto-generated method stub
        
    <|file_separator|><nl>
        ProcessInstance processInstance = startProcessInstanceWithFailingJob(PROCESS_DEFINITION_KEY_WITH_EXCEPTION_1);
        assertEquals(1, runtimeService.createProcessInstanceQuery().processInstanceId(processInstance.getId()).count());
        assertEquals(1, runtimeService.createProcessInstanceQuery().processInstanceId(processInstance.getId()).count());
    }

    public void testQueryWithException2() throws InterruptedException {
        ProcessInstance processInstance = startProcessInstanceWithFailingJob(PROCESS_DEFINITION_KEY_WITH_EXCEPTION_2);
        assertEquals(1, runtimeService.createProcessInstanceQuery().processInstanceId(processInstance.getId()).count());
        assertEquals(1, runtimeService.createProcessInstanceQuery().processInstanceId(processInstance.getId()).count());
    <|file_separator|><nl>
        Authentication.setAuthenticatedUserId(null);
        runtimeService.startProcessInstanceByKey("IdentityLinksProcess");

        String processInstanceId = runtimeService
                .createProcessInstanceQuery()
                .singleResult()
                .getId();

        runtimeService.addGroupIdentityLink(processInstanceId, "muppets", "playing");

        assertEquals(1, runtimeService.getIdentityLinksForProcessInstance(processInstanceId).size());
    <|file_separator|><nl>
        // TODO Auto-generated method stub
        
    <|file_separator|><nl>
        // TODO Auto-generated method stub
        
    <|file_separator|><nl>
        // given
        // when
        // then
    }
<|file_separator|><nl>
        LOGGER.info("DummyServiceTask received signal " + signalName);
    <|file_separator|><nl>
        // given
        String processId = "boundaryTimerEventFullHistory";
        String taskId = "task1";
        String processVariableName = "processVariable";
        String processVariableValue = "processVariableValue";
        String taskVariableName = "taskVariable";
        String taskVariableValue = "taskVariableValue";
        // when
        runtimeService.startProcessInstanceByKey(processId);
        taskService.complete(taskId);
        // then
        assertEquals(processVariableValue, runtimeService.getVariable(processId, processVariableName));
        assertEquals(taskVariableValue, taskService.getVariable(taskId, taskVariableName));
    <|file_separator|><nl>
        super.setUp();

        wiser = new Wiser();
        wiser.start();

        reinitiateMailClients();
    <|file_separator|><nl>
        // given
        final String taskName = "task";
        final String processName = "process";
        final String processDefinitionKey = "process";
        final String processDefinitionId = "process";
        final String processDefinitionVersion = "1";
        final String processDefinitionVersionLabel = "1";
        final String processDefinitionVersionDescription = "1";
        final String processDefinitionVersionName = "1";
        final String processDefinitionVersionCategory = "1";
        final String processDefinitionVersionTags = "1";
        final String processDefinitionVersionTenantId = "1";
        final String processDefinitionVersionTenantName = "1";
        final String processDefinitionVersionTenantType = "1";
        final String processDefinitionVersionTenantIdentifier = "1";
        final String processDefinitionVersionTenantIdentifierType = "1";
        final String processDefinitionVersionTenantIdentifierValue = "1";
        final String processDefinitionVersionTenantIdentifierValueType = "1";
        final String processDefinitionVersionTenantIdentifierValueValue = "1";
        final String processDefinitionVersionTenantIdentifierValueValueType = "1";
        final String processDefinitionVersionTenantIdentifierValueValueValueType = "1";
        final String processDefinitionVersionTenantIdentifierValueValueTypeType = "1";
        final String processDefinitionVersionTenantIdentifierValueValueTypeValueType = "1";
        final String processDefinitionVersionTenantIdentifierValueValueTypeValueTypeValueType = "1";
        final String processDefinitionVersionTenantIdentifierValueValueTypeValueTypeValueTypeValueType = "1";
        final String processDefinitionVersionTenantIdentifierValueValueTypeValueTypeValueTypeValueTypeValueType = "1";
        final String processDefinitionVersionTenantIdentifierValueValueTypeValueTypeValueTypeValueTypeValueTypeValueType = "1";
        final String processDefinitionVersionTenantIdentifierValueValueTypeValueTypeValueTypeValueTypeValueTypeValueTypeValueType = "1";
        final String processDefinitionVersionTenantIdentifierValueValueTypeValueTypeValueTypeValueTypeValueType<nl>
        BpmnModel bpmnModel = readXMLFile();
        BpmnModel parsedModel = exportAndReadXMLFile(bpmnModel);
        assertEquals(bpmnModel, parsedModel);
    }

    public void testImportExport() throws Exception {
        BpmnModel bpmnModel = readXMLFile();
        repositoryService.createDeployment().addBpmnModel("ImportExportTest.testImportExport.bpmn20.xml", bpmnModel).deploy();
        BpmnModel parsedModel = exportAndReadXMLFile(bpmnModel);
        assertEquals(bpmnModel, parsedModel);
    <|file_separator|><nl>
        runtimeService.startProcessInstanceByKey("candidateGroupsExtension");
        List<org.flowable.task.api.Task> tasks = taskService
                .createTaskQuery()
                .taskCandidateGroup("management")
                .list();
        assertEquals(1, tasks.size());
        assertEquals("my task", tasks.get(0).getName());
    <|file_separator|><nl>
        if (expression.matches(delegateTask)) {
            delegateTask.setDelegate(new CreateTaskDelegate());
        }
    <|file_separator|><nl>
        ConnectionPool connectionPool = new ConnectionPool();
        assertNotNull(connectionPool);
    <|file_separator|><nl>
            try {
                startBarrier.await();
                commandContext.getVariableManager().setVariable(executionId, "value");
                endBarrier.await();
            } catch (InterruptedException | BrokenBarrierException e) {
                throw new RuntimeException(e);
            }
            return null;
        <|file_separator|><nl>
                LOGGER.info("Activiti 5 compatibility handler is enabled: " + activiti5ProcessEngineConfig.isFlowable5CompatibilityHandlerEnabled());
                return null;
            <|file_separator|><nl>
        stringWriter.getBuffer().setLength(0);
    <|file_separator|><nl>
        Pvm.fork();
        Pvm.end();
    <|file_separator|>class PvmParallelTest.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>package org.pvm.test;

import org.pvm.Pvm;
import org.pvm.PvmTestCase;

public class PvmParallelTest extends PvmTestCase {

    /**
     * +----+ +--->|fork1| | +----+ | +-----+ +----+ |start|-->|fork2| +-----+ +----+ | | +----+ +--->|end1| +----+
     */
    public void testParallel() {
        Pvm.fork();
        Pvm.fork();
        Pvm.end();
    }
}<|file_separator|><nl>
        PvmProcess p = Pvm.start("java -jar pvm-test-1.0.jar");
        p.waitFor();
    <|file_separator|><nl>
        // TODO: Implement your custom logic here
    <|file_separator|><nl>
            return parameter;
        <|file_separator|><nl>
        // given
        Flowable.run().withJobHandler("job", job -> {
            // when
            job.setVariable("value", "value");
            job.setVariable("method", "method");
        }).execute();
        // then
        assertEquals("value", job.getVariable("value"));
        assertEquals("method", job.getVariable("method"));
    <|file_separator|><nl>
        this.price = price;
    <|file_separator|><nl>
        text1 = execution.getVariable("text1");
        text2 = execution.getVariable("text2");
        text1 = text1.reverse();
        text2 = text2.reverse();
    <|file_separator|><nl>
        return value;
    <|file_separator|><nl>
        if (osType == OsType.LINUX) {

            ProcessInstance pi = runtimeService.startProcessInstanceByKey("echoShellLinux");

            String st = (String) runtimeService.getVariable(pi.getId(), "resultVar");
            assertNotNull(st);
            assertTrue(st.startsWith("EchoTest"));
        }
    <|file_separator|><nl>
        return messages;
    <|file_separator|><nl>
        runtimeService.startProcessInstanceByKey("skipExpressionUserTask");
        assertEquals(0, taskService.createTaskQuery().list().size());
    <|file_separator|><nl>
        // TODO: implement
    <|file_separator|><nl>
        // TODO
    <|file_separator|><nl>
        super.setUp();
        deploymentId = repositoryService.createDeployment().getName("deployment").deploy();
        deploymentTwoId = repositoryService.createDeployment().getName("deploymentTwo").deploy();
        deploymentThreeId = repositoryService.createDeployment().getName("deploymentThree").deploy();
    <|file_separator|><nl>
        ModelQuery query = repositoryService.createModelQuery().modelNameLike("%|%%");
        Model model = query.singleResult();
        assertNotNull(model);
        assertEquals("someKey1", model.getKey());
        assertEquals("bytes", new String(repositoryService.getModelEditorSource(model.getId()), "utf-8"));
        assertEquals(1, query.list().size());
        assertEquals(1, query.count());

        query = repositoryService.createModelQuery().modelNameLike("%|_%");
        model = query.singleResult();
        assertNotNull(model);
        assertEquals("someKey2", model.getKey());
        assertEquals("bytes", new String(repositoryService.getModelEditorSource(model.getId()), "utf-8"));
        assertEquals(1, query.list().size());
        assertEquals(1, query.count());
    <|file_separator|><nl>
        // TODO
    <|file_separator|><nl>
        // test if the event listener is configured
    <|file_separator|><nl>
        // given
        final CommandContext commandContext = new CommandContext();
        final CommandContext commandContext2 = new CommandContext();
        commandContext.setCommandContext(commandContext2);
        // when
        commandContext.throwException();
        // then
        assertEquals(commandContext2, commandContext.getCommandContext());
    <|file_separator|><nl>
        this.bigDecimalId = bigDecimalId;
    <|file_separator|><nl>
        this.doubleId = doubleId;
    <|file_separator|><nl>
        this.id = id;
    <|file_separator|><nl>
        // The custom activity factory will change this value
        COUNTER.incrementAndGet();
        assertEquals(1, COUNTER.get());
    <|file_separator|><nl>
        super.executeParse(bpmnParse, userTask);
        userTask.setAssignee(userTask.getAssignee());
    <|file_separator|><nl>
        return itemCount;
    <|file_separator|><nl>
    return formatMessage(checkName, file, pos, cause, null);
  }

  private static String formatMessage(
      String checkName, JavaFileObject file, DiagnosticPosition pos, Throwable cause, String message) {
    String messageText = message == null ? "" : message + "\n";
    return String.format(
        "%s: %s\n%s%s",
        checkName,
        file.getFileName(),
        messageText,
        cause == null ? "" : cause.getMessage());
  <|file_separator|><nl>
    return new OrganizedImports(imports);
  <|file_separator|><nl>
      if (importString.startsWith("import")) {
        importString = importString.substring(importString.indexOf(" ") + 1);
      }
      if (importString.startsWith("static")) {
        importString = importString.substring(importString.indexOf(" ") + 1);
      }
      return new Import(importString);
    }

    /**
     * Create an {@link Import}
     *
     * @param type the type to import
     * @return the newly created {@link Import}
     */
    static Import importOf(String type) {
      return new Import(type);
    }

    /**
     * Create an {@link Import}
     *
     * @param type the type to import
     * @return the newly created {@link Import}
     */
    static Import importOf(Type type) {
      return new Import(type);
    }

    /**
     * Create an {@link Import}
     *
     * @param type the type to import
     * @return the newly created {@link Import}
     */
    static Import importOf(Class<?> type) {
      return new Import(type);
    }

    /**
     * Create an {@link Import}
     *
     * @param type the type to import
     * @return the newly created {@link Import}
     */
    static Import importOf(Type type, boolean isStatic) {
      return new Import(type, isStatic);
    }

    /**
     * Create an {@link Import}
     *
     * @param type the type to import
     * @return the newly created {@link Import}
     */
    static Import importOf(Class<?> type, boolean isStatic) {
      return new Import(<nl>
    if (node instanceof FieldAccessNode) {
      return fromFieldAccess((FieldAccessNode) node);
    } else if (node instanceof LocalVariableNode) {
      return fromLocalVariable((LocalVariableNode) node);
    } else if (node instanceof VariableDeclarationNode) {
      return fromVariableDecl((VariableDeclarationNode) node);
    }
    return null;
  <|file_separator|><nl>
    return annotationTree.getAnnotation().getElement().equals(element) && valueMatcher.matches(annotationTree.getValue(), state);
  <|file_separator|>class AnnotationTree.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class AnnotationTree {
  private final Annotation annotation;
  private final ExpressionTree value;

  public AnnotationTree(Annotation annotation, ExpressionTree value) {
    this.annotation = annotation;
    this.value = value;
  }

  public Annotation getAnnotation() {
    return annotation;
  }

  public ExpressionTree getValue() {
    return value;
  }
}<|file_separator|>class ExpressionTree.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class ExpressionTree {
  private final String element;
  private final List<ExpressionTree> children;

  public ExpressionTree(String element, List<ExpressionTree> children) {
    this.element = element;
    this.children = children;
  }

  public String getElement() {
    return element;
  }

  public List<ExpressionTree> getChildren() {
    return children;
  }
}<|file_separator|>class Matcher.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public interface Matcher<T> {
  boolean matches(T t, VisitorState state);
}<|file_separator|>class VisitorState.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class VisitorState {
  private final Map<String, Object> variables;

  public VisitorState(Map<String, Object> variables) {
    this.variables = variables;
  }

  public Map<String, Object> getVariables() {
    return variables;
  }
}<|file_separator|>class Visitor.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class Visitor {
  public void visit(AnnotationTree annotationTree, VisitorState state) {
    // do something with annotationTree
  }
}<|file_separator|><nl>
    return scan(tree.getTree(), state);
  <|file_separator|><nl>
    Description description = new MyChecker().getDescription();
    assertThat(description.checkName).isEqualTo("DeadException");
    assertThat(description.getMessageWithoutCheckName())
        .isEqualTo("Exception created but not thrownn" + URL);
    assertThat(description.getMessage())
        .isEqualTo("[DeadException] Exception created but not thrownn" + URL);
  }<|file_separator|><nl>
            throw new UnsupportedOperationException();
          <|file_separator|><nl>
    String identifier = "fooBar";
    String otherIdentifier = "bazQux";

    double levenschtein = LevenshteinEditDistance.getEditDistance(identifier, otherIdentifier);
    double needlemanWunsch =
        NeedlemanWunschEditDistance.getEditDistance(
            identifier, otherIdentifier, /* caseSensitive= */ false, 1, 10000, 10000);

    assertThat(needlemanWunsch).isEqualTo(levenschtein);
  <|file_separator|><nl>
                signatures.add(node.getSignature());
                return null;
              <|file_separator|><nl>
    return Objects.hash(range, replaceWith);
  <|file_separator|><nl>
    return tree.hashCode() ^ sym.hashCode();
  <|file_separator|>class AutoValue_MethodMatchState.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>package com.google.auto.value;

import com.google.auto.value.AutoValue;
import com.google.auto.value.AutoValue_MethodMatchState;
import com.google.auto.value.MethodMatchState;
import com.google.auto.value.ExpressionTree;
import com.google.auto.value.Symbol;

@AutoValue
public abstract class AutoValue_MethodMatchState extends MethodMatchState {

  private final ExpressionTree tree;

  private final Symbol.MethodSymbol sym;

  AutoValue_MethodMatchState(
      ExpressionTree tree,
      Symbol.MethodSymbol sym) {
    if (tree == null) {
      throw new NullPointerException("Null tree");
    }
    this.tree = tree;
    if (sym == null) {
      throw new NullPointerException("Null sym");
    }
    this.sym = sym;
  }

  @Override
  ExpressionTree tree() {
    return tree;
  }

  @Override
  public Symbol.MethodSymbol sym() {
    return sym;
  }

  @Override
  public String toString() {
    return "MethodMatchState{"
        + "tree=" + tree + ", "
        + "sym=" + sym
        + "}";
  }

  @Override
  public boolean equals(Object o) {
    if (o == this) {
      return true;
    }
    if (o instanceof MethodMatchState) {
      MethodMatchState that = (MethodMatchState) o;
      return this.tree.equals(that.tree())
          && this.sym.equals(that.sym());
    <nl>
    return "MethodInvocationMatcher.Token.ReceiverSupertype{"
        + "receiverSupertype=" + receiverSupertype
        + "}";
  <|file_separator|>class AutoValue_MethodInvocationMatcher_Token_ReceiverSupertype.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>package com.google.testing.compile.matchers;

import com.google.testing.compile.matchers.MethodInvocationMatcher.Token.ReceiverSupertype;

public final class AutoValue_MethodInvocationMatcher_Token_ReceiverSupertype extends ReceiverSupertype {

  private final String receiverSupertype;

  AutoValue_MethodInvocationMatcher_Token_ReceiverSupertype(
      String receiverSupertype) {
    if (receiverSupertype == null) {
      throw new NullPointerException("Null receiverSupertype");
    }
    this.receiverSupertype = receiverSupertype;
  }

  @Override
  public String receiverSupertype() {
    return receiverSupertype;
  }

  @Override
  public String toString() {
    return "MethodInvocationMatcher.Token.ReceiverSupertype{"
        + "receiverSupertype=" + receiverSupertype
        + "}";
  }

  @Override
  public boolean equals(Object o) {
    if (o == this) {
      return true;
    }
    if (o instanceof MethodInvocationMatcher.Token.ReceiverSupertype) {
      MethodInvocationMatcher.Token.ReceiverSupertype that = (MethodInvocationMatcher.Token.ReceiverSupertype) o;
      return this.receiverSupertype.equals(that.receiverSupertype());
    }
    return false;
  }

  @Override
  public int hashCode() {
    int h$ = 1;
    h$ *= 1000003;
    h$ ^= receiverSupertype.hashCode();
    return h$;
  <nl>
    if (methodTreeMatcher.matches(tree)) {
      return null;
    }
    return provideFix(tree).map(fix -> new Description(
        "Abstract method returns null",
        "Abstract method returns null",
        fix
    ));
  <|file_separator|><nl>
    return interfaceType.isFunctionalInterface() &&
        state.getReturnTypes().isEmpty() &&
        state.getReturnTypes().get(interfaceType) == null;
  }
<|file_separator|><nl>
    if (!CONSTRUCTORS.matches(tree, state)) {
      return NO_MATCH;
    }
    ExpressionTree argument = getOnlyElement(tree.getArguments());
    return handleMatch(
        argument,
        tree,
        () ->
            renameConstructor(tree, "Socket", state).toBuilder()
                .delete(argument)
                .build());
  <|file_separator|><nl>
    if (tree.getExpression() instanceof Expression) {
      return new Description(
          "Use instanceof instead of == null",
          getFix(tree, state));
    }
    return null;
  <|file_separator|><nl>
    return new Description(
        tree,
        new BareDotMetacharacter(regex, flags),
        new BareDotMetacharacter(regex, flags),
        new BareDotMetacharacter(regex, flags),
        new BareDotMetacharacter(regex, flags),
        new BareDotMetacharacter(regex, flags),
        new BareDotMetacharacter(regex, flags),
        new BareDotMetacharacter(regex, flags),
        new BareDotMetacharacter(regex, flags),
        new BareDotMetacharacter(regex, flags),
        new BareDotMetacharacter(regex, flags),
        new BareDotMetacharacter(regex, flags),
        new BareDotMetacharacter(regex, flags),
        new BareDotMetacharacter(regex, flags),
        new BareDotMetacharacter(regex, flags),
        new BareDotMetacharacter(regex, flags),
        new BareDotMetacharacter(regex, flags),
        new BareDotMetacharacter(regex, flags),
        new BareDotMetacharacter(regex, flags),
        new BareDotMetacharacter(regex, flags),
        new BareDotMetacharacter(regex, flags),
        new BareDotMetacharacter(regex, flags),
        new BareDotMetacharacter(regex, flags),
        new BareDotMetacharacter(regex, flags),
        new BareDotMetacharacter(regex, flags),
        new BareDotMetacharacter(regex, flags),
        new BareDotMetacharacter(regex, flags),
        new BareDotMetacharacter(regex, flags),
        new BareDotMetacharacter(regex, flags),
        new BareDotMetacharacter(regex, flags),
        new BareDotMetacharacter(regex, flags),
        new BareDotMetacharacter(regex, flags),
        new BareDotMetacharacter(regex, flags),
        new BareDotMeta<nl>
    return tree.getTryBlock().getCatchClauses().stream()
        .filter(c -> c.getCatchBlock().getExceptionType().equals(MATCHER))
        .map(c -> c.getCatchBlock().getTryBlock().getTryBlock())
        .filter(t -> t.getTryBlock().getCatchClauses().stream()
            .noneMatch(cc -> cc.getCatchBlock().getExceptionType().equals(MATCHER)))
        .map(t -> new Description(t.getTryBlock().getTryBlock().getTryBlock(),
            "Closing standard output streams in try-with-resources",
            "Closing standard output streams in try-with-resources",
            "Closing standard output streams in try-with-resources",
            "Closing standard output streams in try-with-resources",
            "Closing standard output streams in try-with-resources",
            "Closing standard output streams in try-with-resources",
            "Closing standard output streams in try-with-resources",
            "Closing standard output streams in try-with-resources",
            "Closing standard output streams in try-with-resources",
            "Closing standard output streams in try-with-resources",
            "Closing standard output streams in try-with-resources",
            "Closing standard output streams in try-with-resources",
            "Closing standard output streams in try-with-resources",
            "Closing standard output streams in try-with-resources",
            "Closing standard output streams in try-with-resources",
            "Closing standard output streams in try-with-resources",
            "Closing standard output streams in try-with-resources",
            "Closing standard output streams in try-with-resources",
            "Closing standard output streams in try-with-resources",
            "Closing standard output streams in<nl>
    return tree.getExpression().match(COMPUTE_IF_ABSENT, state);
  <|file_separator|><nl>
    if (conditionalExpression.getCondition().isBoolean()) {
      return Description.of(
          "Boolean expression is not supported in Java 8",
          ConditionalExpressionTreeMatcher.super.matchConditionalExpression(
              conditionalExpression, state));
    }
    return null;
  <|file_separator|><nl>
    return NO_MATCH;
  <|file_separator|><nl>
    if (state.isInsideClass(INSIDE_ASSERT_CLASS)) {
      return Description.empty();
    }
    if (state.isEnclosedBy(ENCLOSED_BY_ASSERT)) {
      return Description.empty();
    }
    if (state.isEnclosedBy(INSIDE_ASSERT_CLASS)) {
      return Description.empty();
    }
    if (state.isEnclosedBy(ENCLOSED_BY_ASSERT)) {
      return Description.empty();
    }
    if (state.isEnclosedBy(EQUALS_NULL)) {
      return Description.empty();
    }
    return super.matchMethodInvocation(invocationTree, state);
  <|file_separator|><nl>
    return new Description("Erroneous bitwise expression");<|file_separator|><nl>
    for (CaseTree caseTree : tree.getCases()) {
      int endPosition = caseEndPosition(state, caseTree);
      if (FALL_THROUGH_PATTERN.matcher(state.getText(endPosition)).find()) {
        return new Description(
            "fall through",
            state.getRange(getStartPosition(caseTree), endPosition),
            state.getRange(getStartPosition(caseTree), endPosition));
      }
    }
    return null;
  <|file_separator|><nl>
    return match(tree, state, 0, blockTree.getCondition(), blockTree.getStatement());
  <|file_separator|><nl>
      if (node.getName() == methodToCall) {
        inBoxedVoidReturningMethod = true;
      }
      return node.getStatements().size() == 1
          && Iterables.getOnlyElement(node.getStatements()).accept(this, state);
    <|file_separator|><nl>
    return new Description("InjectOnBugCheckers");<|file_separator|><nl>
    if (tree.getMethodName().equals("toLong")) {
      return Description.of("toLong() should be converted to a long");
    }
    return null;
  <|file_separator|><nl>
    if (ROUND_CALLS_WITH_INT_OR_LONG_ARG.matches(tree, state)) {
      return removeMathRoundCall(tree, state);
    }
    return null;
  <|file_separator|><nl>
    check(tree.getStatement(), state);
    return NO_MATCH;
  <|file_separator|><nl>
    if (STREAM.matches(t)) {
      return Description.empty();
    }
    if (PARALLELSTREAM.matches(t)) {
      return Description.empty();
    }
    return super.matchMethodInvocation(t, state);
  <|file_separator|><nl>
    return SuggestedFix.builder()
        .setShortDescription("Force the expression to be of the target type")
        .merge(forceExpressionType(tree, targetType, state))
        .build();
  }

  private static String forceExpressionType(ExpressionTree tree, Type targetType, VisitorState state) {
    if (tree.getKind().equals(Kind.LITERAL)) {
      return forceLiteralType(tree, targetType, state);
    }
    if (tree.getKind().equals(Kind.IDENTIFIER)) {
      return forceIdentifierType(tree, targetType, state);
    }
    return forceExpressionType(tree.getLeftOperand(), targetType, state)
        + suffixForType(targetType, state)
        + forceExpressionType(tree.getRightOperand(), targetType, state);
  }

  private static String forceIdentifierType(ExpressionTree tree, Type targetType, VisitorState state) {
    return state.getSourceForNode(tree).replaceAll("[LlFfDd]$", "")
        + suffixForType(targetType, state);
  <|file_separator|><nl>
    return new Description("Null Ternary");<|file_separator|><nl>
    return handle(tree.getModifiers().getAnnotations(), tree.getReturnType(), state);
  <|file_separator|><nl>
    if (hasNullableAnnotation(tree.getModifiers()) && isOptional(ASTHelpers.getType(tree), state)) {
      return describeMatch(tree);
    }
    return Description.NO_MATCH;
  <|file_separator|><nl>
    return type.isFinal() && !type.isInterface() && !type.isAbstract();
  <|file_separator|><nl>
    if (COMPARE_AND_SET.matches(tree)) {
      return Description.empty();
    }
    return super.matchMethodInvocation(tree, state);
  <|file_separator|><nl>
    return allOf(
        createMethodMatcher(className),
        not(PRIVATE_DO_NOT_ACCESS_OR_ELSE));
  <|file_separator|><nl>
    ImmutableList.Builder<SuggestedFix> builder = ImmutableList.builder();
    if (tree.getReceiver().matches(ProtoBuilderReturnValueIgnored.ROOT_INVOCATIONS_TO_IGNORE)) {
      builder.add(
          new SuggestedFix(
              "Use the builder's build() method instead of the builder's buildPartial() method.",
              tree.getReceiver(),
              tree.getReceiver().getReceiver(),
              tree.getReceiver().getReceiver()));
    }
    return builder.build();
  <|file_separator|><nl>
    if (FENCE_MATCHER.matches(tree)) {
      return Description.empty();
    }
    return super.matchMethodInvocation(tree, state);
  <|file_separator|><nl>
    if (tree.isConstructor()) {
      return null;
    }
    if (tree.isAbstract()) {
      return null;
    }
    if (tree.isFinal()) {
      return null;
    }
    if (tree.isNative()) {
      return null;
    }
    if (tree.isSynthetic()) {
      return null;
    }
    if (tree.isInterface()) {
      return null;
    }
    if (tree.isPrivate()) {
      return null;
    }
    if (tree.isProtected()) {
      return null;
    }
    if (tree.isPublic()) {
      return null;
    }
    if (tree.isStrictfp()) {
      return null;
    }
    if (tree.isSynchronized()) {
      return null;
    }
    if (tree.isTransient()) {
      return null;
    }
    if (tree.isVolatile()) {
      return null;
    }
    if (tree.isEnum()) {
      return null;
    }
    if (tree.isAnnotation()) {
      return null;
    }
    if (tree.isEnumConstant()) {
      return null;
    }
    if (tree.isInterface()) {
      return null;
    }
    if (tree.isInterface()) {
      return null;
    }
    if (tree.isInterface()) {
      return null;
    }
    if (tree.isInterface()) {
      return null;
    }
    if (tree.isInterface()) {
      return null;
    }
    if (tree.isInterface()) {
      return null;
    }
    <nl>
    if (!isSameType(getType(tree), state.getSymtab().iterableType, state)) {
      return NO_MATCH;
    }
    if (!tree.getKind().equals(MemberReferenceKind.METHOD)) {
      return NO_MATCH;
    }
    if (!tree.getMemberName().equals("iterator")) {
      return NO_MATCH;
    }
    // Only match variables, which we can be sure aren't being re-created.
    if (!(getSymbol(getReceiver(tree)) instanceof VarSymbol)) {
      return NO_MATCH;
    }
    return describeMatch(tree, tree, state);
  <|file_separator|><nl>
    if (SUBSTRING_CALLS_WITH_ZERO_ARG.matches(tree, state)) {
      return Description.of("Remove substring call");
    }
    return null;
  }

  @Override
  public Fix applyFix(MethodInvocationTree tree, VisitorState state) {
    return removeSubstringCall(tree, state);
  <|file_separator|><nl>
    for (StatementTree statement : statements) {
      if (statement instanceof JCExpressionStatement) {
        JCExpressionStatement expr = (JCExpressionStatement) statement;
        if (expr.getExpression().hasTag(Tag.THROW)) {
          JCThrow throwTree = (JCThrow) expr.getExpression();
          if (throwTree.getExceptionType().equals(expectedException)) {
            fix.replace(
                expr,
                "throw " + expectedException.toString() + ";",
                "throw " + expectedException.toString() + ";");
          }
        }
      }
    }
    return fix.build();
  <|file_separator|><nl>
    if (wellKnownTypeArgument(tree, state)) {
      return null;
    }
    if (isSubtype(tree.getSuper(), JAVA_LANG_THREADLOCAL.get(state), state)) {
      return null;
    }
    if (isSubtype(tree.getSuper(), COM_GOOGLE_INJECT_SCOPE.get(state), state)) {
      return null;
    }
    return NEW_THREAD_LOCAL;
  <|file_separator|><nl>
    return new Description("null");<|file_separator|>class ThrowNull.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>class ThrowNull extends BugChecker implements ThrowTreeMatcher {
  @Override
  public Description matchThrow(ThrowTree tree, VisitorState state) {
    return new Description("null");
  }
}<|file_separator|><nl>
    return tree.getThrowExpressions().stream()
        .map(expression -> {
          Matcher<ExpressionTree> matcher =
              AbstractLikeException.ABSTRACT_LIKE_EXCEPTIONS.stream()
                  .filter(abstractLikeException -> abstractLikeException.matcher().matches(expression))
                  .findFirst()
                  .map(abstractLikeException -> {
                    return new Matcher<ExpressionTree>() {
                      @Override
                      public boolean matches(ExpressionTree expression) {
                        return false;
                      }

                      @Override
                      public String toString() {
                        return "throw " + abstractLikeException.replacement() + " " + expression;
                      }
                    };
                  })
                  .orElse(Matchers.constructor().forClass(expression.getClass()));
          return new Matcher<ExpressionTree>() {
            @Override
            public boolean matches(ExpressionTree expression) {
              return matcher.matches(expression);
            }

            @Override
            public String toString() {
              return "throw " + abstractLikeException.replacement() + " " + expression;
            }
          };
        })
        .collect(ImmutableList.toImmutableList());
  <|file_separator|><nl>
    if (methodInvocationTree.getExpressionTree().getMatcher() == ASSERT_THAT) {
      return state.getTreeMatcher().match(methodInvocationTree.getExpressionTree(),
          TRUTH_SUBJECT_CALL);
    }
    return null;
  <|file_separator|><nl>
    if (MOCK_FACTORY.matches(tree.getInitializer(), state)
        && !classContainsInitializer(state.findEnclosing(ClassTree.class), state)) {
      return matchVariable(tree, state);
    }
    return matchVariable(tree, state);
  }

  private static SuggestedFix createMockFix(AssignmentTree tree, VisitorState state) {
    if (MOCK_FACTORY.matches(tree.getVariable(), state)
        && !classContainsInitializer(state.findEnclosing(ClassTree.class), state)) {
      return SuggestedFix.delete(tree.getVariable());
    }
    int startPos = getStartPosition(tree);
    List<ErrorProneToken> tokens =
        state.getOffsetTokens(startPos, getStartPosition(tree.getVariable()));
    for (ErrorProneToken token : Lists.reverse(tokens)) {
      if (token.kind() == TokenKind.EQ) {
        return SuggestedFix.replace(token.pos(), state.getEndPosition(tree.getVariable()), "");
      }
    }
    return SuggestedFix.emptyFix();
  <|file_separator|><nl>
    if (tree.getCatchClause() == null) {
      return null;
    }
    if (tree.getCatchClause().getException() == null) {
      return null;
    }
    if (isSuppressedViaName(tree.getCatchClause().getException())) {
      return null;
    }
    if (tree.getCatchClause().getException().getType() == JAVA_IO_INTERRUPTEDIOEXCEPTION.get()) {
      return null;
    }
    return new Description(
        "Add a catch block to suppress the exception",
        fixConstructor(tree.getCatchClause().getConstructor(), tree.getCatchClause().getException(), state));
  <|file_separator|><nl>
    return MATCHER.match(tree, state);
  <|file_separator|><nl>
    if (BUNDLE_DESERIALIZATION_CAST_EXPRESSION.matches(tree, state)) {
      return getDescriptionForType(tree, "android.os.Bundle");
    }
    return null;
  <|file_separator|><nl>
      return ImmutableList.of();
    <|file_separator|><nl>
    return null;
  <|file_separator|><nl>
    if (HAS_ASSISTED_INJECT_MATCHER.matches(annotationTree, state)) {
      return Description.empty();
    }
    return super.matchAnnotation(annotationTree, state);
  <|file_separator|><nl>
    return CLOSEABLE_PROVIDES_MATCHER.match(tree, state);
  <|file_separator|><nl>
    return null;
  }

  @Override
  public void visitMethod(MethodTree methodTree, VisitorState state) {
    if (TO_MATCH.matches(methodTree, state)) {
      state.visit(methodTree);
    }
  <|file_separator|><nl>
    return state.getModule().getFlags().contains(ModuleFlags.ALLOW_DAGGER_INTERNAL);
  <|file_separator|><nl>
    // TODO: Implement
  }
<|file_separator|><nl>
    return new GuardedByFlags();
  <|file_separator|><nl>
    if (tree.isAnnotation()) {
      return null;
    }
    if (tree.isInterface()) {
      return null;
    }
    if (tree.isEnum()) {
      return null;
    }
    if (tree.isAnnotationType()) {
      return null;
    }
    if (tree.isAnnotationTypeMember()) {
      return null;
    }
    if (tree.isAnnotationTypeMemberValue()) {
      return null;
    }
    if (tree.isAnnotationTypeMemberValueMember()) {
      return null;
    }
    if (tree.isAnnotationTypeMemberValueMemberValue()) {
      return null;
    }
    if (tree.isAnnotationTypeMemberValueMemberValueMember()) {
      return null;
    }
    if (tree.isAnnotationTypeMemberValueMemberValueMemberValue()) {
      return null;
    }
    if (tree.isAnnotationTypeMemberValueMemberValueMemberValueMember()) {
      return null;
    }
    if (tree.isAnnotationTypeMemberValueMemberValueMemberValueMemberValue()) {
      return null;
    }
    if (tree.isAnnotationTypeMemberValueMemberValueMemberValueMemberValueMember()) {
      return null;
    }
    if (tree.isAnnotationTypeMemberValueMemberValueMemberValueMemberValueMemberValue()) {
      return null;
    }
    if (tree.isAnnotationTypeMemberValueMemberValueMemberValueMemberValueMemberValueMember()) {
      return null;
    }
    if (tree.isAnnotationTypeMemberValueMemberValueMemberValueMemberValueMemberValueMemberValue()) {
      return null;
    }
    if (tree.isAnnotationTypeMemberValueMemberValueMemberValueMemberValueMemberValueMemberValue<nl>
    return new SuggestedFix()
        .withDescription("Use a Period instance instead of a long")
        .withText("new Period(" + tree.getArguments().get(0).getExpression() + ", " +
            tree.getArguments().get(1).getExpression() + ")");
  <|file_separator|><nl>
    return getName().toString();
  <|file_separator|><nl>
    throw new UnsupportedOperationException();
  <|file_separator|><nl>
      return annotations.stream().anyMatch(a -> rule.suppressedByAnyOf(a, s));
    <|file_separator|><nl>
    return unit.getRange(location);
  <|file_separator|><nl>
    return Choice.of(
        unifier.unify(getParameter().accept(this, unifier), node.getParameter()),
        unifier.unify(getBlock().accept(this, unifier), node.getBlock())
    );
  <|file_separator|>class UClass.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class UClass extends UType {
  private final UClassDecl decl;
  private final UClass superclass;
  private final List<UClass> interfaces;
  private final List<UField> fields;
  private final List<UMethod> methods;
  private final List<UMethod> constructors;
  private final List<UMethod> destructors;
  private final List<UMethod> staticMethods;
  private final List<UMethod> staticConstructors;
  private final List<UMethod> staticDestructors;
  private final List<UMethod> staticMethodsWithThis;
  private final List<UMethod> staticConstructorsWithThis;
  private final List<UMethod> staticDestructorsWithThis;
  private final List<UMethod> staticMethodsWithThisAndThis;
  private final List<UMethod> staticConstructorsWithThisAndThis;
  private final List<UMethod> staticDestructorsWithThisAndThis;
  private final List<UMethod> staticMethodsWithThisAndThisAndThis;
  private final List<UMethod> staticConstructorsWithThisAndThisAndThis;
  private final List<UMethod> staticDestructorsWithThisAndThisAndThis;
  private final List<UMethod> staticMethodsWithThisAndThisAndThisAndThis;
  private final List<UMethod> staticConstructorsWithThisAndThisAndThisAndThis;
  private final List<UMethod> staticDestructorsWithThisAndThisAndThisAndThis;
  private<nl>
    return (UnifierWithRemainingMembers unifierWithRemainingMembers) -> {
      return unifierWithRemainingMembers.unifier().match(tree);
    };
  }
}
<|file_separator|><nl>
    return new UExpression(new JCNot(this.getExpression()));
  <|file_separator|>class UExpression.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class UExpression extends UTree<JCExpression> implements ExpressionTree {
  public UExpression negate() {
    return new UExpression(new JCNot(this.getExpression()));
  }
}<|file_separator|>class UExpressionTree.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class UExpressionTree extends UTree<JCExpression> implements ExpressionTree {
  public UExpressionTree negate() {
    return new UExpressionTree(new JCNot(this.getExpression()));
  }
}<|file_separator|>class UExpressionTree.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class UExpressionTree extends UTree<JCExpression> implements ExpressionTree {
  public UExpressionTree negate() {
    return new UExpressionTree(new JCNot(this.getExpression()));
  }
}<|file_separator|>class UExpression.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class UExpression extends UTree<JCExpression> implements ExpressionTree {
  public UExpression negate() {
    return new UExpression(new JCNot(this.getExpression()));
  }
}<|file_separator|>class UExpressionTree.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class UExpressionTree extends UTree<JCExpression> implements ExpressionTree {
  public UExpressionTree negate() {
    return new UExpressionTree(new JCNot(this.getExpression()));
  }
}<|file_separator|>class UExpressionTree.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class UExpressionTree extends UTree<JCExpression> implements ExpressionTree {
  public UExpressionTree negate() {
    return new UExpressionTree(new JCNot(this.getExpression()));
  }
}<|file_separator|>class UExpressionTree.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class UExpressionTree extends UTree<JCExpression> implements ExpressionTree {
  public UExpressionTree negate()<nl>
    return target.getTypeVars().zip(getTypeVars()).map(
        (typeVar, typeVar2) -> typeVar.visit(typeVar2, unifier));
  }

  @Override
  public Choice<Unifier> visitTypeVar(TypeVar target, Unifier unifier) {
    return target.visit(this, unifier);
  }

  @Override
  public Choice<Unifier> visitTypeVar(TypeVar target, Unifier unifier, Unifier unifier2) {
    return target.visit(this, unifier, unifier2);
  }

  @Override
  public Choice<Unifier> visitTypeVar(TypeVar target, Unifier unifier, Unifier unifier2, Unifier unifier3) {
    return target.visit(this, unifier, unifier2, unifier3);
  }

  @Override
  public Choice<Unifier> visitTypeVar(TypeVar target, Unifier unifier, Unifier unifier2, Unifier unifier3,
      Unifier unifier4) {
    return target.visit(this, unifier, unifier2, unifier3, unifier4);
  }

  @Override
  public Choice<Unifier> visitTypeVar(TypeVar target, Unifier unifier, Unifier unifier2, Unifier unifier3,
      Unifier unifier4, Unifier unifier5) {
    return target.visit(this, unifier, unifier2, unifier3, unifier4, unifier5);
  }

  @Override
  public Choice<Unifier> visitTypeVar(TypeVar target, Unifier unifier, Unifier unifier2, Unifier unifier3,
      Unifier unifier4, Unifier unifier5<nl>
    if (matches(target, unifier)) {
      return Unifier.create(unifier, expression());
    }
    return null;
  <|file_separator|><nl>
    return methodInvocation.visitMethodInvocation(this, unifier);
  <|file_separator|>class UMethodInvocationTree.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public interface UMethodInvocationTree extends MethodInvocationTree {
  ImmutableList<UExpression> getTypeArguments();

  UExpression getMethodSelect();

  ImmutableList<UExpression> getArguments();
}<|file_separator|>class UMethodInvocationTreeVisitor.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public interface UMethodInvocationTreeVisitor<R, D> extends TreeVisitor<R, D> {
  R visitMethodInvocation(UMethodInvocationTree methodInvocation, D data);
}<|file_separator|><nl>
    return new UUnionType(ImmutableList.copyOf(typeAlternatives));
  }

  private UUnionType(ImmutableList<UExpression> typeAlternatives) {
    super(typeAlternatives);
  <|file_separator|>class UExpression.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.ImmutableSortedSet;
import com.google.common.collect.Iterables;
import com.google.common.collect.Sets;
import com.google.common.collect.TreeMultimap;
import com.google.common.collect.TreeMultimap.Entry;
import com.google.common.collect.TreeMultimap.EntrySet;
import com.google.common.collect.TreeMultimap.EntryView;
import com.google.common.collect.TreeMultimap.EntryViews;
import com.google.common.collect.TreeMultimap.EntryViews.EntryViewBuilder;
import com.google.common.collect.TreeMultimap.EntryViews.EntryViewBuilder.EntryViewBuilderImpl;
import com.google.common.collect.TreeMultimap.EntryViews.EntryViewBuilder.EntryViewBuilderImpl.EntryViewBuilderImplImpl;
import com.google.common.collect.TreeMultimap.EntryViews.EntryViewBuilder.EntryViewBuilderImpl.EntryViewBuilderImplImpl.EntryViewBuilderImplImplImpl;
import com.google.common.collect.TreeMultimap.EntryViews.EntryViewBuilder.EntryViewBuilderImpl.EntryViewBuilderImplImpl.EntryViewBuilderImplImplImpl.EntryViewBuilderImplImplImplImpl;
import com.google.common.collect.TreeMultimap.EntryViews.EntryViewBuilder.EntryViewBuilderImpl<nl>
    compilationHelper.addSourceFile("AsyncFunctionReturnsNullPositiveCases.java").doTest();
  <|file_separator|><nl>
    compilationHelper.addSourceFile("ChainedAssertionLosesContextPositiveCases.java").doTest();
  <|file_separator|><nl>
    compilationHelper.addSourceFile("ComparableTypePositiveCases.java").doTest();
  <|file_separator|><nl>
    testHelper
        .addSourceLines(
            "Test.java",
            "class Test {",
            "  // BUG: Diagnostic contains: int a = 1000 * 1000 * 1000 * 10 * 1;",
            "  int a = 1000 * 1000 * 1000 * 10 * 1;",
            "  // BUG: Diagnostic contains:",
            "  int b = (int) 24 * 60 * 60 * 1000 * 1000;",
            "  long c = (long) 24 * 60 * 60 * 1000 * 1000;",
            "  // BUG: Diagnostic contains: long d = 24 * 60 * 60 * 1000 * 1000;",
            "  long d = 24 * 60 * 60 * 1000 * 1000;",
            "}")
        .doTest();
  <|file_separator|>class ConstantOverflow.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class ConstantOverflow {
  public static void main(String[] args) {
    System.out.println(Integer.MAX_VALUE);
  }
}<|file_separator|><nl>
    testHelper
        .addSourceLines(
            "Test.java",
            "class Test {",
            "  void f(int x) {",
            "    switch (x) {",
            "      case 1:",
            "        for (;;) {}",
            "      case 2:",
            "        break;",
            "    }",
            "  }",
            "}")
        .doTest();
  <|file_separator|><nl>
    CompilationTestHelper.newInstance(FloatCast.class, getClass())
        .addSourceLines(
            "Test.java", //
            "class Test {",
            "  {",
            "    int x = (int) 0.9f + 42;",
            "    float y = (int) 0.9f - 0.9f;",
            "    x = ((int) 0.9f) * 42;",
            "    y = (int) (0.9f * 0.9f);",
            "    String s = (int) 0.9f + \"\";",
            "    boolean b = (int) 0.9f > 1;",
            "    long c = (long) Math.ceil(10.0d / 2) * 2;",
            "    long f = (long) Math.floor(10.0d / 2) * 2;",
            "    long g = (long) Math.signum(10.0d / 2) * 2;",
            "    long r = (long) Math.rint(10.0d / 2) * 2;",
            "  }",
            "}")
        .doTest();
  <|file_separator|><nl>
    compilationHelper
        .addSourceLines(
            "Test.java",
            "class Test {",
            "  enum TheEnum { ONE }",
            "  void f(TheEnum theEnum) {",
            "    System.err.println(theEnum.getClass());",
            "    System.err.println(this.getClass());",
            "  }",
            "}")
        .doTest();
  <|file_separator|><nl>
    testHelper
        .addSourceLines(
            "Test.java",
            "import java.awt.color.ICC_Profile;",
            "class Test {",
            "  void f(byte[] b) throws Exception {",
            "    ICC_Profile.getInstance(b);",
            "  }",
            "}")
        .doTest();
  <|file_separator|><nl>
    testHelper
        .addSourceLines(
            "Test.java",
            "class Test {", //
            "  // BUG: Diagnostic contains:",
            "  public static void main(String[] args) {}",
            "}")
        .doTest();
  <|file_separator|><nl>
    compilationHelper
        .addSourceLines(
            "Positive.java",
            "import org.junit.Test;",
            "public class Positive {",
            "  @Test",
            "  public void testCase() {}",
            "}")
        .doTest();
  <|file_separator|><nl>
    refactoring
        .addInputLines(
            "Test.java",
            "import com.google.common.base.Preconditions;",
            "class Test {",
            "  void test() {",
            "    Preconditions.checkState(false, \"%s\", 1, 1);",
            "  }",
            "}")
        .addOutputLines(
            "Test.java",
            "import com.google.common.base.Preconditions;",
            "class Test {",
            "  void test() {",
            "    Preconditions.checkState(false, \"%s (%s)",
            "      1, 1);",
            "  }",
            "}")
        .doTest();
  <|file_separator|><nl>
    compilationHelper
        .addSourceLines(
            "Test.java",
            "class Test {",
            "  private final Object okLock = Test.class;",
            "}")
        .doTest();
  <|file_separator|><nl>
    BugCheckerRefactoringTestHelper.newInstance(LogicalAssignment.class, getClass())
        .addInputLines(
            "in/Test.java",
            "class Test {",
            "  void f(boolean x){",
            "    if (x == true) {}",
            "    while (x == true) {}",
            "    for (; x == true; ) {}",
            "    do {} while (x == true);",
            "  }",
            "}")
        .addOutputLines(
            "out/Test.java",
            "class Test {",
            "  void f(boolean x){",
            "    if ((x == true)) {}",
            "    while ((x == true)) {}",
            "    for (; (x == true); ) {}",
            "    do {} while ((x == true));",
            "  }",
            "}")
        .doTest();
  <|file_separator|><nl>
    helper
        .addSourceLines(
            "Test.java",
            "class Test {",
            "  int[] results = {",
            "    // BUG: Diagnostic contains: Float.compare(0F, 0F)",
            "    Float.compare(0F, 0F),",
            "    // BUG: Diagnostic contains: Float.compare(Float.valueOf(0F), 0F)",
            "    Float.compare(Float.valueOf(0F), 0F),",
            "",
            "    // Not lossy.",
            "    Float.compare((byte) 0, (byte) 0),",
            "    Float.compare((short) 0, (short) 0),",
            "    Float.compare('0', '0'),",
            "    Float.compare(0, 0),",
            "    Float.compare(0.f, 0.f),",
            "    Float.compare(0.0, 0.0),",
            "  };",
            "}")
        .doTest();
  <|file_separator|><nl>
    helper
        .addSourceLines(
            "Case.java",
            "import com.google.common.testing.EqualsTester;",
            "class Case {",
            "  private EqualsTester et;",
            "  void add() {",
            "    et.addEqualityGroup(this, this);",
            "  }",
            "}")
        .doTest();
  <|file_separator|><nl>
    compilationHelper.addSourceFile("ModifySourceCollectionInStreamPositiveCases.java").doTest();
  <|file_separator|><nl>
    compilationHelper
        .addSourceLines(
            "Test.java",
            "class Test {",
            "  public static final int[] array = new int[-1];",
            "}")
        .doTest();
  <|file_separator|><nl>
    compilationHelper
        .addSourceLines(
            "Test.java", //
            "import java.util.Collections;",
            "class Test {{",
            "  Collections.nCopies(10, ' ');",
            "}}")
        .doTest();
  <|file_separator|><nl>
    compilationHelper
        .addSourceLines("Test.java", "class Test {", "  public void f() {}", "}")
        .doTest();
  <|file_separator|><nl>
    CompilationTestHelper.newInstance(
            ScannerSupplier.fromBugCheckerClasses(ObjectToString.class, CompletionChecker.class),
            getClass())
        .addSourceLines(
            "Test.java",
            "import " + TestLib.class.getCanonicalName() + ";",
            "class Test {",
            "  String f(TestLib lib) {",
            "    return "" + lib.f();",
            "  }",
            "}")
        .withClasspath(ObjectToStringTest.class, TestLib.class, TestLib.Two.class)
        .doTest();
  }<|file_separator|><nl>
    compilationHelper.addSourceFile("OverrideThrowableToStringFixes.java").doTest();
  <|file_separator|><nl>
    compilationHelper
        .addSourceFile("PrimitiveArrayPassedToVarargsMethodNegativeCases.java")
        .doTest();
  <|file_separator|><nl>
    compilationTestHelper
        .addSourceLines(
            "Test.java",
            "import java.lang.ref.Reference;",
            "class Test {",
            "  public void run() {",
            "    Reference.reachabilityFence(this);",
            "  }",
            "}")
        .doTest();
  <|file_separator|><nl>
    compilationHelper
        .addSourceLines(
            "Test.java",
            "import java.util.Collection;",
            "import java.util.HashMap;",
            "import java.util.List;",
            "import java.util.Map;",
            "import javax.annotation.Nullable;",
            "class Test {",
            "  @Nullable",
            "  Collection<String> methodReturnsNonNullCollection() {",
            "    return new ArrayList<>();",
            "  }",
            "  @Nullable",
            "  List<String> methodReturnsNonNullList() {",
            "    return new ArrayList<>();",
            "  }",
            "  @Nullable",
            "  Map<String, String> methodReturnsNonNullMap() {",
            "    return new HashMap<>();",
            "  }",
            "  @Nullable",
            "  HashMap<String, String> methodReturnsNonNullHashMap() {",
            "    return new HashMap<>();",
            "  }",
            "}")
        .doTest();
  <|file_separator|><nl>
    helper
        .addSourceLines(
            "Test.java",
            "class Test {",
            "  public Test() {",
            "    int foo = 1;",
            "    Runnable r = () -> this.foo = foo;",
            "  }",
            "}")
        .doTest();
  <|file_separator|><nl>
    helper
        .addInputLines(
            "Test.java",
            "class Test {",
            "  void f() {",
            "   String x = "HELLO";",
            "   String y = x.toLowerCase().substring(1);",
            "  }",
            "}")
        .expectUnchanged()
        .doTest();
  <|file_separator|><nl>
    helper
        .addSourceLines(
            "Test.java", //
            "class Test {",
            "  private static void main(String[] args) {",
            "    // BUG: Diagnostic contains: SystemExitOutsideMain",
            "   System.exit(0);",
            "  }",
            "}")
        .doTest();
  <|file_separator|><nl>
    compilationHelper
        .addSourceLines(
            "a/A.java",
            "package a;",
            "import org.joda.time.DateTimeZone;",
            "class A {",
            "  public static void test_PST() {",
            "    // BUG: Diagnostic contains: DateTimeZone.forID("America/Los_Angeles")",
            "    DateTimeZone.forID("PST");",
            "  }",
            "  public static void test_EST() {",
            "    // BUG: Diagnostic contains: DateTimeZone.forID("Etc/GMT+5")",
            "    DateTimeZone.forID("EST");",
            "  }",
            "}")
        .doTest();
  <|file_separator|><nl>
    compilationHelper
        .addSourceLines(
            "Test.java",
            "class Test {",
            "  public String toString() {",
            "    return "bar";",
            "  }",
            "}")
        .doTest();
  <|file_separator|><nl>
    testHelper
        .addSourceLines(
            "ExampleChecker.java",
            "import com.google.errorprone.BugPattern;",
            "import com.google.errorprone.BugPattern.SeverityLevel;",
            "import com.google.errorprone.VisitorState;",
            "import com.google.errorprone.bugpatterns.BugChecker;",
            "import com.google.errorprone.bugpatterns.BugChecker.ClassTreeMatcher;",
            "import com.google.errorprone.matchers.Description;",
            "import com.sun.source.tree.ClassTree;",
            "import com.sun.tools.javac.code.Types;",
            "@BugPattern(name = "Example", summary = "", severity = SeverityLevel.ERROR)",
            "public class ExampleChecker extends BugChecker implements ClassTreeMatcher {",
            "  @Override public Description matchClass(ClassTree t, VisitorState s) {",
            "    return Description.NO_MATCH;",
            "  }",
            "}")
        .addSourceLines(
            "Example.java",
            "import com.google.errorprone.BugPattern;",
            "import com.google.errorprone.BugPattern.SeverityLevel;",
            "import com.google.errorprone.VisitorState;",
            "import com.google.errorprone.bugpatterns.BugChecker;",
            "import com.google.errorprone.bugpatterns.BugChecker.ClassTreeMatcher;",
            "import com.google.errorprone.matchers.Description;",
            "import com.sun.source.tree.ClassTree;",
            "import com.sun.tools.javac.code.Types;",
            "@BugPattern(name = "Example", summary = "", severity = SeverityLevel.ERROR)",
            "public class Example {",
            "<nl>
    helper
        .addInputLines(
            "T.java", //
            "import org.junit.Test;",
            "class T {",
            "  @Test public void foo() {}",
            "}")
        .addOutputLines(
            "T.java", //
            "import org.junit.Test;",
            "class T {",
            "  @Test public void foo() {}",
            "}")
        .doTest();
  <|file_separator|><nl>
    compilationHelper
        .addSourceLines(
            "test/Test.java",
            "package test;",
            "class Test {",
            "  class B extends Throwable {",
            "    public Throwable getCause() {",
            "      return super.getCause();",
            "    }",
            "  }",
            "}")
        .doTest();
  <|file_separator|><nl>
    testHelper
        .addSourceLines(
            "Test.java", //
            "class Test {",
            "  int var;",
            "}")
        .setArgs(ImmutableList.of("-source", "11", "-target", "11"))
        .doTest();
  <|file_separator|><nl>
      return new CompilationResult(
          compiler.run(
              fileManager.getJavaCompiler(),
              fileManager.getStandardFileManager(),
              fileManager.getDiagnosticCollector(),
              fileManager.getFileManager(),
              classpath,
              sources,
              javacopts));
    <|file_separator|><nl>
    helper
        .addInputLines(
            "Client.java",
            "package com.google.frobber;",
            "public final class Client {",
            "  public void varNotUnused() {",
            "    var notUnused = new Client();",
            "  }",
            "  public void varUnused() {",
            "    var unused = new Client();",
            "  }",
            "  public void varUnusedFoo() {",
            "    var unusedFoo = new Client();",
            "  }",
            "  public void objectUnused() {",
            "    Object unused = new Client();",
            "  }",
            "  public void objectUnusedFoo() {",
            "    Object unusedFoo = new Client();",
            "  }",
            "  public void reuseOfUnusedVariable(Client unused) {",
            "    unused = new Client();",
            "  }",
            "  @com.google.errorprone.annotations.CanIgnoreReturnValue",
            "  public Client() {",
            "  }",
            "}")
        .addOutputLines(
            "Client.java",
            "package com.google.frobber;",
            "public final class Client {",
            "  public void varNotUnused() {",
            "    var notUnused = new Client();",
            "  }",
            "  public void varUnused() {",
            "    new Client();",
            "  }",
            "  public void varUnusedFoo() {",
            "    var unusedFoo = new Client();",
            "  }",
            "  public void objectUnused() {",
            "    new Client();",
            "  }",
            "  public void objectUnusedFoo() {",
            <nl>
    helper
        .addSourceLines(
            "Test.java",
            "import java.util.Collection;",
            "class Test {",
            "  boolean foo(Collection<Collection<Integer>> xs, Collection<Integer> x) {",
            "    return xs.contains(x);",
            "  }",
            "}")
        .doTest();
  }

  @Test
  public void collectionOfLists() {
    helper
        .addSourceLines(
            "Test.java",
            "import java.util.Collection;",
            "import java.util.List;",
            "class Test {",
            "  boolean foo(Collection<List<Integer>> xs, List<Integer> x) {",
            "    return xs.contains(x);",
            "  }",
            "}")
        .doTest();
  }

  @Test
  public void treeMap() {
    helper
        .addSourceLines(
            "Test.java",
            "import java.util.Collection;",
            "import java.util.TreeMap;",
            "class Test {",
            "  boolean foo(TreeMap<Collection<Integer>, Integer> xs, Collection<Integer> x) {",
            "    return xs.containsKey(x);",
            "  }",
            "}")
        .doTest();
  }

  @Test
  public void sortedMap() {
    helper
        .addSourceLines(
            "Test.java",
            "import java.util.Collection;",
            "import java.util.SortedMap;",
            "class Test {",
            "  boolean foo(SortedMap<Collection<Integer>, Integer> xs, Collection<Integer> x) {",
            "    return xs.containsKey(x);",<nl>
    compilationHelper
        .addSourceLines(
            "Test.java",
            "import static org.junit.Assert.assertEquals;",
            "import static org.junit.Assert.assertNotEquals;",
            "class Test {",
            "  public void test() {",
            "    assertEquals(1, 2);",
            "    assertNotEquals(1, 2);",
            "  }",
            "}")
        .doTest();
  <|file_separator|><nl>
    compilationHelper
        .addSourceLines(
            "Test.java",
            "import com.google.common.flogger.FluentLogger;",
            "class Test {",
            "  private static final FluentLogger logger = FluentLogger.forEnclosingClass();",
            "  public void test() {",
            "    try {}",
            "    catch (Exception e) {",
            "      logger.atWarning().log("failed");",
            "    }",
            "  }",
            "}")
        .doTest();
  <|file_separator|><nl>
    compilationHelper.addSourceFile("QualifierWithTypeUsePositiveCases.java").doTest();
  <|file_separator|><nl>
    compilationHelper.addSourceFile("ProvidesMethodOutsideOfModulePositiveCases.java").doTest();
  <|file_separator|><nl>
      System.out.println("foo");
    <|file_separator|><nl>
    Object a = new Object();
    Object b = new Object();

    if (a.equals(b)) {
      System.out.println("arrays are equal!");
    } else {
      System.out.println("arrays are not equal!");
    }

    if (Objects.equal(a, b)) {
      System.out.println("Objects are equal!");
    } else {
      System.out.println("Objects are not equal!");
    }
  <|file_separator|><nl>
    String s = "hello";
    char[] b = new char[3];

    // BUG: Diagnostic contains: Arrays.equals(s.toCharArray(), b)
    if (Objects.equal(s.toCharArray(), b)) {
      System.out.println("arrays are equal!");
    } else {
      System.out.println("arrays are not equal!");
    }
  <|file_separator|><nl>
    // BUG: Diagnostic contains: Arrays.hashCode(intArray, intArray)
    int hashCode = Arrays.hashCode(intArray, intArray);
  }

  public void varargsHashCodeOnMoreThanOneArg() {
    // BUG: Diagnostic contains: Arrays.hashCode(intArray, intArray)
    int hashCode = Arrays.hashCode(intArray, intArray);
  <|file_separator|>class ArrayHashCodeNegativeCases.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>class ArrayHashCodeNegativeCases {
  private Object[] objArray = {1, 2, 3};
  private String[] stringArray = {"1", "2", "3"};
  private int[] intArray = {1, 2, 3};
  private byte[] byteArray = {1, 2, 3};
  private int[][] multidimensionalIntArray = {{1, 2, 3}, {4, 5, 6}};
  private String[][] multidimensionalStringArray = {{"1", "2", "3"}, {"4", "5", "6"}};

  public void javaUtilObjectsHashCode() {
    int hashCode;
    // BUG: Diagnostic contains: Arrays.hashCode(objArray)
    hashCode = Objects.hashCode(objArray);
    // BUG: Diagnostic contains: Arrays.hashCode(stringArray)
    hashCode = Objects.hashCode(stringArray);
    // BUG: Diagnostic contains: Arrays.hashCode(intArray)
    hashCode = Objects.hashCode(intArray);

    // BUG: Diagnostic contains: Arrays.deepHashCode(multidimensionalIntArray)
    hashCode = Objects.hashCode(multidimensionalIntArray);
    // BUG: Diagnostic contains: Arrays.deepHashCode(multidimensionalStringArray)
    hashCode = Objects.hashCode(multidimensionalStringArray);
  }

  public void javaUtilObjectsHash() {
    int hashCode;
    <nl>
    Object a = new Object();
    String b = a.toString() + " a string";
  <|file_separator|><nl>
    // TODO
  <|file_separator|><nl>
        return (int) (this.value - other.value);
    <|file_separator|><nl>
    ByteBuffer buffer = ByteBuffer.allocate(0);

    ByteBuffer.allocate(0).array();
  }
}
<|file_separator|>class ArrayInFieldPrecededByByteBufferAllocateInFieldIsFlagged {
    ByteBuffer buffer = ByteBuffer.allocate(1);
    byte[] array = buffer.array();
  }

  void array_inAnonymousClass_precededByByteBufferAllocate_isFlagged() {
    final ByteBuffer buffer = ByteBuffer.allocate(0);

    new Function<Object, Object>() {
      @Override
      public Object apply(Object o) {
        buffer.array();
        return null;
      }
    };
  }

  void array_inLambdaExpression_precededByByteBufferAllocate_isFlagged() {
    ByteBuffer buffer = ByteBuffer.allocate(0);

    ByteBuffer.allocate(0).array();
  }
}
<|file_separator|>class ArrayInFieldPrecededByByteBufferAllocateInFieldIsNotFlagged {
    ByteBuffer buffer = ByteBuffer.allocate(1);
    byte[] array = buffer.array();
  }

  void array_inAnonymousClass_precededByByteBufferAllocate_isNotFlagged() {
    final ByteBuffer buffer = ByteBuffer.allocate(0);

    new Function<Object, Object>() {
      @Override
      public Object apply(Object o) {
        buffer.array();
        return null;
      }
    };
  }

  void array_inLambdaExpression_precededByByteBufferAllocate_isNotFlagged() {
    ByteBuffer buffer = ByteBuffer.allocate(0);

    ByteBuffer.allocate(0).array();
  }
}
<|file_separator|>class ArrayInFieldPrecededByByteBufferAllocateInFieldIsFlagged {
    ByteBuffer buffer = ByteBuffer.allocate(1);
    byte[] array = buffer.array();
  }

  void array_inAnonymous<nl>
    impossible.method();
  }
<|file_separator|><nl>
    // ...
  <|file_separator|><nl>
    boolean result;

    result = s == (short) Integer.MAX_VALUE;
  <|file_separator|><nl>
    // BUG: Diagnostic contains: remove this line
    new RuntimeException("oops");
    System.out.println("another statement after exception");
  }

  public void firstStatementWithNoSurroundingBlock2() {
    // BUG: Diagnostic contains: remove this line
    new RuntimeException("oops");
    System.out.println("another statement after exception");
  }

  public void firstStatementWithNoSurroundingBlock3() {
    // BUG: Diagnostic contains: remove this line
    new RuntimeException("oops");
    System.out.println("another statement after exception");
  }

  public void firstStatementWithNoSurroundingBlock4() {
    // BUG: Diagnostic contains: remove this line
    new RuntimeException("oops");
    System.out.println("another statement after exception");
  }

  public void firstStatementWithNoSurroundingBlock5() {
    // BUG: Diagnostic contains: remove this line
    new RuntimeException("oops");
    System.out.println("another statement after exception");
  }

  public void firstStatementWithNoSurroundingBlock6() {
    // BUG: Diagnostic contains: remove this line
    new RuntimeException("oops");
    System.out.println("another statement after exception");
  }

  public void firstStatementWithNoSurroundingBlock7() {
    // BUG: Diagnostic contains: remove this line
    new RuntimeException("oops");
    System.out.println("another statement after exception");
  }

  public void firstStatementWithNoSurroundingBlock8() {
    // BUG: Diagnostic contains: remove this line
    new RuntimeException("oops");
    System.out.println("another statement after exception");
  }

  public void firstStatementWithNoSurroundingBlock9() {
    // BUG: Diagnostic contains:<nl>
    assertThat(1.0).isEqualTo(1.0);
    assertThat(1d).isEqualTo(VALUE);
    assertThat(1e10).isEqualTo(1e10);
    assertThat(1d).isNotEqualTo(2d);
    assertEquals(1d, 1d, 0);
    assertEquals("equal!", 1d, 1d, 0);
  }

  public void testFloatWithTolerance() {
    assertThat(1.0f).isCloseTo(1.0f, TOLERANCE);
    assertThat(1f).isCloseTo(VALUE, TOLERANCE);
    assertThat(1e10f).isCloseTo(1e10f, TOLERANCE);
    assertThat(1f).isCloseTo(2f, TOLERANCE);
    assertEquals(1f, 1f, TOLERANCE);
    assertEquals("equal!", 1f, 1f, TOLERANCE);
  }

  public void testDoubleWithTolerance() {
    assertThat(1.0).isCloseTo(1.0, TOLERANCE2);
    assertThat(1d).isCloseTo(VALUE, TOLERANCE2);
    assertThat(1e10).isCloseTo(1e10, TOLERANCE2);
    assertThat(1d).isCloseTo(2d, TOLERANCE2);
    assertEquals(1d, 1d, TOLERANCE2);
    assertEquals("equal!", 1d, 1d, TOLERANCE2);
  <|file_separator|><nl>
    doAnswer(invocation -> null).when(null);
    doAnswer(invocation -> null).when(null, "method");
  }
<|file_separator|><nl>
    // We don't handle any exception as this code is not meant to be executed.
  }

  public void aesWrap() {
    // We don't handle any exception as this code is not meant to be executed.
  }

  public void aesWrapWithConstantString() {
    // We don't handle any exception as this code is not meant to be executed.
  }

  public void aesWrapWithProvider() {
    // We don't handle any exception as this code is not meant to be executed.
  }

  public void aesWrapWithConstantStringAndProvider() {
    // We don't handle any exception as this code is not meant to be executed.
  <|file_separator|><nl>
  <|file_separator|><nl>
    // do something
  }

  void tearDown() {
    // do something
  <|file_separator|><nl>
    // tear down
  <|file_separator|><nl>
    fail("This is a test");
  <|file_separator|><nl>
    return Arrays.asList(Arrays.asList("a"), Arrays.asList("b"));
  }

  @Test
  @Parameters
  public void paramsInIterableOfIterablesOfIterables(String p1, String p2) {}

  private List<List<List<String>>> parametersForParamsInIterableOfIterablesOfIterables() {
    return Arrays.asList(
        Arrays.asList(Arrays.asList("a"), Arrays.asList("b")),
        Arrays.asList(Arrays.asList("c"), Arrays.asList("d")));
  }

  @Test
  @Parameters
  public void paramsInIterableOfIterablesOfIterablesOfIterables(String p1, String p2) {}

  private List<List<List<List<String>>>> parametersForParamsInIterableOfIterablesOfIterablesOfIterables() {
    return Arrays.asList(
        Arrays.asList(
            Arrays.asList(Arrays.asList("a"), Arrays.asList("b")),
            Arrays.asList(Arrays.asList("c"), Arrays.asList("d"))),
        Arrays.asList(
            Arrays.asList(Arrays.asList("e"), Arrays.asList("f")),
            Arrays.asList(Arrays.asList("g"), Arrays.asList("h"))));
  }

  @Test
  @Parameters
  public void paramsInIterableOfIterablesOfIterablesOfIterablesOfIterablesOfIterables(
      String p1, String p2) {}

  private List<List<List<List<List<String>>>>> parametersForParamsInIterableOfIterablesOfIterablesOfIterablesOfIterablesOfIterables() {
    return Arrays.asList(
        Arrays.asList(
            Arrays.asList(
                Arrays.asList(Arrays.asList("a"), Arrays.asList("b")),
                <nl>
  <|file_separator|>class JUnitParameterMethodNotFoundNegativeCaseBaseClass
    extends JUnitParameterMethodNotFoundNegativeCaseBaseClass {
  @Test
  @Parameters(method = "named1")
  public void testNamed(int a) {
  }
}<|file_separator|>class JUnitParameterMethodNotFoundNegativeCaseBaseClass
    extends JUnitParameterMethodNotFoundNegativeCaseBaseClass {
  @Test
  @Parameters(method = "named1")
  public void testNamed(int a) {
  }
}<|file_separator|><nl>
      List<T> result = new ArrayList<>();
      for (int i = 0; i < 10; i++) {
        result.add(converter.apply(i));
      }
      return result;
    <|file_separator|><nl>
      synchronized (this) {
        System.out.println("Synchronized block");
      }
    <|file_separator|><nl>
    // This is a non-runtime annotation
    @NonRuntime
    public void test() {
    }
  <|file_separator|><nl>
    FinalGenericClassWithoutToString<int> intClass = new FinalGenericClassWithoutToString<int>();
    intClass.toString();
  }
<|file_separator|><nl>
    checkArgument(x > 0, "%s %s", x);
  <|file_separator|><nl>
    acceptFunctionOfVoid(ReturnValueIgnoredNegativeCases::methodDoesntMatch);
  <|file_separator|><nl>
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        swigCPtr = 0;
      }
      else {
        swigCPtr = 0;
      }
    }
  <|file_separator|><nl>
    try {
      // BUG: Diagnostic contains: Uninterruptibles.joinUninterruptibly(thread)
      thread.join();
    } catch (InterruptedException e) {
      // ignore
    }
  <|file_separator|><nl>
      whileInThread();
    <|file_separator|><nl>
    // BUG: Diagnostic contains: no-op
    throwIfUnchecked(e);
  }

  void simple2(IOException e) {
    // BUG: Diagnostic contains: no-op
    propagateIfPossible(e);
  }

  void simple3(IOException e) {
    // BUG: Diagnostic contains: no-op
    propagateIfPossible(e);
  }

  void simple4(IOException e) {
    // BUG: Diagnostic contains: no-op
    propagateIfPossible(e);
  }

  void simple5(IOException e) {
    // BUG: Diagnostic contains: no-op
    propagateIfPossible(e);
  }

  void simple6(IOException e) {
    // BUG: Diagnostic contains: no-op
    propagateIfPossible(e);
  }

  void simple7(IOException e) {
    // BUG: Diagnostic contains: no-op
    propagateIfPossible(e);
  }

  void simple8(IOException e) {
    // BUG: Diagnostic contains: no-op
    propagateIfPossible(e);
  }

  void simple9(IOException e) {
    // BUG: Diagnostic contains: no-op
    propagateIfPossible(e);
  }

  void simple10(IOException e) {
    // BUG: Diagnostic contains: no-op
    propagateIfPossible(e);
  }

  void simple11(IOException e) {
    // BUG: Diagnostic contains: no-op
    propagateIfPossible(e);
  }

  void simple12(IOException e) {
    // BUG: Diagnostic contains: no-op
    propagateIfPossible(e);
  }

  void simple13(IOException e) {
    // BUG: Diagnostic contains: no-op
<nl>
            // BUG: Diagnostic contains: [TreeToString] Tree#toString shouldn't be used
            classTree.toString();
            return false;
          <|file_separator|><nl>}

  public void quux(int x, int y, int z) {<|file_separator|>class OverloadsRefactoringInterleaved {

  public void foo() {}

  public void foo(int x) {}

  public void foo(int x, int y) {}

  public void foo(int x, int y, int z) {}

  public void baz() {}

  public void baz(int x) {}

  public void baz(int x, int y) {}

  public void bar() {}

  public void bar(int x) {}

  public void bar(int x, int y) {}

  public void quux() {}

  public void quux(int x) {}

  public void quux(int x, int y) {}
}<|file_separator|><nl>
    compilationHelper
        .addSourceLines(
            "test/TestCase.java",
            "package test;",
            "import java.time.LocalDate;",
            "import java.time.Month;",
            "public class TestCase {",
            "  // BUG: Diagnostic contains: MonthOfYear (valid values 1 - 12): 13",
            "  private static final LocalDate LD0 = LocalDate.of(1985, 13, 31);",
            "}")
        .doTest();
  <|file_separator|><nl>
    helper
        .addSourceLines(
            "TestClass.java",
            "import java.time.Duration;",
            "public class TestClass {",
            "  // BUG: Diagnostic contains: Duration.ofSeconds(Duration.ZERO.getSeconds(), 42);",
            "  private static final Duration DURATION = Duration.ZERO.withNanos(42);",
            "}")
        .doTest();
  <|file_separator|><nl>
    helper
        .addSourceLines(
            "TestClass.java",
            "import java.time.Duration;",
            "public class TestClass {",
            "  // BUG: Diagnostic contains: Duration.ofSeconds(42, Duration.ZERO.getNano());",
            "  private static final Duration DURATION = Duration.ZERO.withSeconds(42);",
            "}")
        .doTest();
  <|file_separator|><nl>
    helper
        .addSourceLines("TestClass.java", "import static java.util.concurrent.TimeUnit.MILLISECONDS;")
        .doTest();
  <|file_separator|><nl>
    for (String name : names) {
      assertWithMessage("unit for %s", name)
          .that(unitSuggestedByName(name))
          .isEqualTo(UNKNOWN);
    }
  <|file_separator|><nl>
    try (
      // BUG: Diagnostic contains: (Non-null)
      var t = something();
    ) {
      // BUG: Diagnostic contains: (Nullable)
      triggerNullnessChecker(t);
    }
  <|file_separator|>class NullnessPropagationTransferCases10 {
  public void caughtException() {
    try {
      System.out.println();
    } catch (Throwable t) {
      // BUG: Diagnostic contains: (Non-null)
      triggerNullnessChecker(t);

      t = something();
      // BUG: Diagnostic contains: (Nullable)
      triggerNullnessChecker(t);
    }
  }

  void tryWithResources() throws Exception {
    try (
      // BUG: Diagnostic contains: (Non-null)
      var t = something();
    ) {
      // BUG: Diagnostic contains: (Nullable)
      triggerNullnessChecker(t);
    }
  }

  <T> T something() {
    return null;
  }
}<|file_separator|>class NullnessPropagationTransferCases1 {
  public void caughtException() {
    try {
      System.out.println();
    } catch (Throwable t) {
      // BUG: Diagnostic contains: (Non-null)
      triggerNullnessChecker(t);

      t = something();
      // BUG: Diagnostic contains: (Nullable)
      triggerNullnessChecker(t);
    }
  }

  void tryWithResources() throws Exception {
    try (
      // BUG: Diagnostic contains: (Non-null)
      var t = something();
    ) {
      // BUG: Diagnostic contains: (Nullable)
      triggerNullnessChecker(t);
    }
  }

  <T> T something() {
    return null;
<nl>
    assertCompiles(() -> scanner);
  }

  protected void assertCompiles(String... lines) {
    assertCompiles(() -> new Scanner(new StringReader(String.join("\n", lines))));
  }<|file_separator|><nl>
        return null;
      }

      @Override
      public Void visitMethodInvocation(MethodInvocationTree node, VisitorState visitorState) {
        return null;
      }

      @Override
      public Void visitTypeCast(TypeCastTree node, VisitorState visitorState) {
        return null;
      }

      @Override
      public Void visitType(TypeTree node, VisitorState visitorState) {
        return null;
      }

      @Override
      public Void visitTypeVariable(TypeVariableTree node, VisitorState visitorState) {
        return null;
      }

      @Override
      public Void visitTypeParameter(TypeParameterTree node, VisitorState visitorState) {
        return null;
      }

      @Override
      public Void visitTypeArgument(TypeArgumentTree node, VisitorState visitorState) {
        return null;
      }

      @Override
      public Void visitTypeBound(TypeBoundTree node, VisitorState visitorState) {
        return null;
      }

      @Override
      public Void visitTypeVariableBound(TypeVariableBoundTree node, VisitorState visitorState) {
        return null;
      }

      @Override
      public Void visitTypeParameterBound(TypeParameterBoundTree node, VisitorState visitorState) {
        return null;
      }

      @Override
      public Void visitTypeParameterBoundType(TypeParameterBoundTypeTree node, VisitorState visitorState) {
        return null;
      }

      @Override
      public Void visitTypeParameterBoundTypeBound(TypeParameterBoundTypeBoundTree node, VisitorState visitorState) {
        return null;
      }

      @Override
      public Void visitTypeParameterBoundTypeBoundType(TypeParameterBoundTypeBoundTypeTree node, VisitorState visitorState) {
        return null;
      }<nl>
    return new AutoValue_Match(match);
  <|file_separator|><nl>
    SerializableTester.assertSerializable(
        UAssign.create(UFreeIdent.create("foo"), ULiteral.intLit(5)));
  <|file_separator|><nl>
    assertUnifiesAndInlines(
        "4 >= 17", UBinary.create(Kind.GREATER_THAN_EQUAL, ULiteral.intLit(4), ULiteral.intLit(17)));
  <|file_separator|>class ULiteralTest.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>import static org.junit.Assert.*;

import org.junit.Test;

public class ULiteralTest {

  @Test
  public void test() {
    fail("Not yet implemented");
  }

}
<|file_separator|>class ULiteral.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>import java.util.ArrayList;
import java.util.List;

public class ULiteral extends UExpression {
  public static ULiteral intLit(int i) {
    return new ULiteral(Kind.INT_LIT, i);
  }

  public static ULiteral doubleLit(double d) {
    return new ULiteral(Kind.DOUBLE_LIT, d);
  }

  public static ULiteral booleanLit(boolean b) {
    return new ULiteral(Kind.BOOLEAN_LIT, b);
  }

  public static ULiteral stringLit(String s) {
    return new ULiteral(Kind.STRING_LIT, s);
  }

  public static ULiteral charLit(char c) {
    return new ULiteral(Kind.CHAR_LIT, c);
  }

  public static ULiteral nullLit() {
    return new ULiteral(Kind.NULL_LIT, null);
  }

  public static ULiteral arrayLit(List<UExpression> elements) {
    return new ULiteral(Kind.ARRAY_LIT, elements);
  }

  public static ULiteral objectLit(List<UExpression> elements) {
    return new ULiteral(Kind.OBJECT_LIT, elements);
  }

  public static<nl>
    assertUnifies(
        "true ? -1 : 1",
        UConditional.create(ULiteral.booleanLit(true), ULiteral.intLit(-1), ULiteral.intLit(1)));
  <|file_separator|>class ULiteralTest.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>class ULiteralTest extends AbstractUTreeTest {

  @Test
  public void equality() {
    assertUnifies(
        "1",
        ULiteral.intLit(1));
  }

  @Test
  public void serialization() {
    SerializableTester.reserializeAndAssert(ULiteral.intLit(1));
  }
}<|file_separator|>class ULiteral.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class ULiteral extends UExpression {

  private final int value;

  public ULiteral(int value) {
    this.value = value;
  }

  public int getValue() {
    return value;
  }

  @Override
  public String toString() {
    return String.valueOf(value);
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ULiteral literal = (ULiteral) o;
    return value == literal.value;
  }

  @Override
  public int hashCode() {
    return value;
  }

  public static ULiteral intLit(int value) {
    return new ULiteral(value);
  }
}<|file_separator|>class UConditional.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class UConditional extends UExpression {

  private final UExpression condition;
  private final UExpression trueExpression;
  private final UExpression falseExpression;

  public U<nl>
    new EqualsTester()
        .addEqualityGroup(ULocalVarIdent.create("foo"))
        .addEqualityGroup(ULocalVarIdent.create("bar"))
        .testEquals();
  <|file_separator|><nl>
    assertEquals(UTypeParameter.create("T", UClassIdent.create("java.lang.CharSequence")),
        UTypeParameter.create("T", UClassIdent.create("java.lang.CharSequence")));
  <|file_separator|><nl>
    assertEquals(
        UVariableDecl.create("foo", UClassIdent.create("java.lang.String"), ULiteral.stringLit("bar")),
        UVariableDecl.create("foo", UClassIdent.create("java.lang.String"), ULiteral.stringLit("bar")));
  <|file_separator|><nl>
    return length;
  <|file_separator|><nl>
    return ImmutableList.of(1, 2, 3);
  <|file_separator|><nl>
    // ...
  <|file_separator|><nl>
    // ...
  <|file_separator|><nl>
    return String.format("first: %s, second: %s", new Object[]{"first", "second", "third"});
  }

  public String foo4() {
    return String.format("first: %s, second: %s", new Object[]{"first", "second", "third", "fourth"});
  }

  public String foo5() {
    return String.format("first: %s, second: %s", new Object[]{"first", "second", "third", "fourth", "fifth"});
  }

  public String foo6() {
    return String.format("first: %s, second: %s", new Object[]{"first", "second", "third", "fourth", "fifth", "sixth"});
  }

  public String foo7() {
    return String.format("first: %s, second: %s", new Object[]{"first", "second", "third", "fourth", "fifth", "sixth", "seventh"});
  }

  public String foo8() {
    return String.format("first: %s, second: %s", new Object[]{"first", "second", "third", "fourth", "fifth", "sixth", "seventh", "eighth"});
  }

  public String foo9() {
    return String.format("first: %s, second: %s", new Object[]{"first", "second", "third", "fourth", "fifth", "sixth", "seventh", "eighth", "ninth"});
  }

  public String foo10() {
    return String.format("first: %s, second: %s", new Object[]{"first", "second", "third", "fourth", "fifth", "sixth", "seventh", "eighth", "ninth", "tenth"});
  <|file_separator|><nl>
    System.out.println(new AbstractList<Integer>() {
      @Override
      public Integer get(int index) {
        return 17;
      }
    });
  <|file_separator|><nl>
    // ...
  <|file_separator|><nl>
    var lambda = (x: int) => x + 1;
    var result = lambda(1);
  <|file_separator|><nl>
    System.out.println("foo");
  <|file_separator|><nl>
    digest.update(string.getBytes());
  <|file_separator|><nl>
    return new ConditionObject();
  <|file_separator|><nl>
    // ...
  <|file_separator|><nl>
    // ...
  <|file_separator|><nl>
    return str.length();
  <|file_separator|><nl>
    return Collections.singletonList(e);
  <|file_separator|><nl>
    if (cond) {
      x = y;
    } else {
      x = z;
    }
  <|file_separator|><nl>
    for (E e : collection) {
      doSomething(e);
    }
  <|file_separator|><nl>
    return a + b + c;
  <|file_separator|><nl>
    for (int i = 0; i < elements.length; i++) {
      builder.append(elements[i]);
      if (i == elements.length - 1) {
        break;
      }
      builder.append(',');
    }
  <|file_separator|><nl>
    return md.digest(str.getBytes());
  <|file_separator|><nl>
    Logger logger = Logger.getLogger(name);
  <|file_separator|><nl>
    subject.containsExactlyElementsIn(expected);
  <|file_separator|><nl>
      return 1;
    <|file_separator|><nl>
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    AutoValue_ThreadSafety_Violation that = (AutoValue_ThreadSafety_Violation) o;
    return path.equals(that.path);
  <|file_separator|><nl>
    return lhs;
  <|file_separator|>class AutoValue_ConstantExpressions_ConstantNotEquals extends ConstantExpressions.ConstantNotEquals {

  private final ConstantExpressions.ConstantExpression lhs;

  private final ConstantExpressions.ConstantExpression rhs;

  AutoValue_ConstantExpressions_ConstantNotEquals(
      ConstantExpressions.ConstantExpression lhs,
      ConstantExpressions.ConstantExpression rhs) {
    if (lhs == null) {
      throw new NullPointerException("Null lhs");
    }
    this.lhs = lhs;
    if (rhs == null) {
      throw new NullPointerException("Null rhs");
    }
    this.rhs = rhs;
  }

  @Override
  ConstantExpressions.ConstantExpression lhs() {
    return lhs;
  }

  @Override
  ConstantExpressions.ConstantExpression rhs() {
    return rhs;
  }

}<|file_separator|>class AutoValue_ConstantExpressions_ConstantLessThan extends ConstantExpressions.ConstantLessThan {

  private final ConstantExpressions.ConstantExpression lhs;

  private final ConstantExpressions.ConstantExpression rhs;

  AutoValue_ConstantExpressions_ConstantLessThan(
      ConstantExpressions.ConstantExpression lhs,
      ConstantExpressions.ConstantExpression rhs) {
    if (lhs == null) {
      throw new NullPointerException("Null lhs");
    }
    this.lhs = lhs;
    if (rhs == null) {
      throw new NullPointerException("Null rhs");
    }
    this.rhs = rhs;
  }

  @Override
  ConstantExpressions.ConstantExpression lhs() {
    return lhs;
  }

  @Override
  ConstantExpressions.ConstantExpression rhs() {
    return rhs;
  }

}<|file_separator|>class AutoValue_ConstantExpressions_ConstantGreaterThan extends ConstantExpressions.ConstantGreaterThan {

  private final ConstantExpressions.ConstantExpression lhs;

  private final ConstantExpressions<nl>
    return sym;
  <|file_separator|>class AutoValue_GuardedByExpression_LocalVariable_Builder extends GuardedByExpression.LocalVariable.Builder {

  private final GuardedByExpression.Kind kind;

  private final Symbol sym;

  private final Type type;

  AutoValue_GuardedByExpression_LocalVariable_Builder(
      GuardedByExpression.Kind kind,
      Symbol sym,
      Type type) {
    if (kind == null) {
      throw new NullPointerException("Null kind");
    }
    this.kind = kind;
    if (sym == null) {
      throw new NullPointerException("Null sym");
    }
    this.sym = sym;
    if (type == null) {
      throw new NullPointerException("Null type");
    }
    this.type = type;
  }

  @Override
  public GuardedByExpression.Kind kind() {
    return kind;
  }

  @Override
  public Symbol sym() {
    return sym;
  }

  @Override
  public Type type() {
    return type;
  }

  @Override
  public GuardedByExpression.LocalVariable build() {
    return new AutoValue_GuardedByExpression_LocalVariable(kind, sym, type);
  }

  @Override
  public GuardedByExpression.LocalVariable.Builder kind(GuardedByExpression.Kind kind) {
    if (kind == null) {
      throw new NullPointerException("Null kind");
    }
    return new AutoValue_GuardedByExpression_LocalVariable_Builder(kind, sym, type);
  }

  @Override
  public GuardedByExpression.LocalVariable.Builder sym(Symbol sym) {
    if (sym == null) {
      throw new<nl>
    return Objects.hash(name, key);
  <|file_separator|>class AutoValue_RedundantSetterCall_ListField extends RedundantSetterCall.ListField {

  private final String name;

  private final int index;

  AutoValue_RedundantSetterCall_ListField(
      String name,
      int index) {
    if (name == null) {
      throw new NullPointerException("Null name");
    }
    this.name = name;
    if (index < 0) {
      throw new IllegalArgumentException("index < 0");
    }
    this.index = index;
  }

  @Override
  String getName() {
    return name;
  }

  @Override
  int getIndex() {
    return index;
  }

  @Override
  public String toString() {
    return "ListField{"
        + "name=" + name + ", "
        + "index=" + index
        + "}";
  }

  @Override
  public boolean equals(Object o) {
    if (o == this) {
      return true;
    }
    if (o instanceof RedundantSetterCall.ListField) {
      RedundantSetterCall.ListField that = (RedundantSetterCall.ListField) o;
      return this.name.equals(that.getName())
          && this.index == that.getIndex();
    }
    return false;
  }

  @Override
  public int hashCode() {
    return Objects.hash(name, index);
  }

}<|file_separator|>class AutoValue_RedundantSetterCall_SetField extends RedundantSetterCall.SetField {

  private final String name;

  private final Object element;

  AutoValue_RedundantSetterCall_SetField(
      String name<nl>
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    UCatch uCatch = (UCatch) o;
    return parameter.equals(uCatch.parameter) &&
        block.equals(uCatch.block);
  <|file_separator|>class AutoValue_UMethod.java
<|fim_prefix|><|fim_suffix|>

  @Override
  public int hashCode() {
    int h$ = 1;
    h$ *= 1000003;
    h$ ^= name.hashCode();
    h$ *= 1000003;
    h$ ^= parameters.hashCode();
    h$ *= 1000003;
    h$ ^= body.hashCode();
    return h$;
  }

}<|fim_middle|>class AutoValue_UMethod extends UMethod {

  private final String name;

  private final UParameterList parameters;

  private final UBlock body;

  AutoValue_UMethod(
      String name,
      UParameterList parameters,
      UBlock body) {
    if (name == null) {
      throw new NullPointerException("Null name");
    }
    this.name = name;
    if (parameters == null) {
      throw new NullPointerException("Null parameters");
    }
    this.parameters = parameters;
    if (body == null) {
      throw new NullPointerException("Null body");
    }
    this.body = body;
  }

  @Override
  public String getName() {
    return name;
  }

  @Override
  public UParameterList getParameters() {
    return parameters;
  }

  @Override
  public UBlock getBody() {<nl>
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    AutoValue_UVariableDecl that = (AutoValue_UVariableDecl) o;
    return name.equals(that.name)
        && type.equals(that.type)
        && (initializer == null ? that.initializer == null : initializer.equals(that.initializer));
  <|file_separator|><nl>
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    UMethodInvocation that = (UMethodInvocation) o;
    return typeArguments.equals(that.typeArguments)
        && methodSelect.equals(that.methodSelect)
        && arguments.equals(that.arguments);
  <|file_separator|><nl>
    int result = 1;
    result = 31 * result + (this.enclosingExpression == null ? 0 : this.enclosingExpression.hashCode());
    result = 31 * result + this.typeArguments.hashCode();
    result = 31 * result + this.identifier.hashCode();
    result = 31 * result + this.arguments.hashCode();
    result = 31 * result + (this.classBody == null ? 0 : this.classBody.hashCode());
    return result;
  <|file_separator|><nl>
    int result = 1;
    result = 31 * result + this.statement.hashCode();
    result = 31 * result + this.condition.hashCode();
    return result;
  <|file_separator|>class AutoValue_UForLoop extends UForLoop {

  private final USimpleStatement statement;

  private final UExpression condition;

  private final UExpression increment;

  AutoValue_UForLoop(
      USimpleStatement statement,
      UExpression condition,
      UExpression increment) {
    if (statement == null) {
      throw new NullPointerException("Null statement");
    }
    this.statement = statement;
    if (condition == null) {
      throw new NullPointerException("Null condition");
    }
    this.condition = condition;
    if (increment == null) {
      throw new NullPointerException("Null increment");
    }
    this.increment = increment;
  }

  @Override
  public USimpleStatement getStatement() {
    return statement;
  }

  @Override
  public UExpression getCondition() {
    return condition;
  }

  @Override
  public UExpression getIncrement() {
    return increment;
  }

  @Override
  public String toString() {
    return "UForLoop{"
        + "statement=" + statement + ", "
        + "condition=" + condition + ", "
        + "increment=" + increment
        + "}";
  }

  @Override
  public boolean equals(Object o) {
    if (o == this) {
      return true;
    }
    if (o instanceof UForLoop) {
      UForLoop that = (UForLoop) o;
      return this.statement.equals(that.getStatement())
          &&<nl>
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    UBinary that = (UBinary) o;
    if (kind != that.kind) {
      return false;
    }
    if (!leftOperand.equals(that.leftOperand)) {
      return false;
    }
    return rightOperand.equals(that.rightOperand);
  <|file_separator|>class AutoValue_UIntegerLiteral.java
<|fim_prefix|><|fim_suffix|>

  @Override
  public int hashCode() {
    int h$ = 1;
    h$ *= 1000003;
    h$ ^= value.hashCode();
    return h$;
  }

}<|fim_middle|>class AutoValue_UIntegerLiteral extends UIntegerLiteral {

  private final int value;

  AutoValue_UIntegerLiteral(int value) {
    if (value < 0) {
      throw new IllegalArgumentException("value < 0: " + value);
    }
    this.value = value;
  }

  @Override
  public int getValue() {
    return value;
  }

  @Override
  public String toString() {
    return "UIntegerLiteral{"
        + "value=" + value
        + "}";
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    UIntegerLiteral that = (UIntegerLiteral) o;
    return value == that.getValue();
  }<|file_separator|>class AutoValue_UIntegerLiteral_Builder.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>class<nl>
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ULocalVarIdent that = (ULocalVarIdent) o;
    return name == that.name;
  <|file_separator|>class AutoValue_UMethodIdent extends UMethodIdent {

  private final StringName name;

  private final UType returnType;

  private final List<UMethodParam> params;

  private final List<UMethodParam> varargs;

  private final List<UMethodParam> varargsParams;

  private final List<UMethodParam> varargsParamsWithDefaults;

  private final List<UMethodParam> varargsParamsWithDefaultsAndNames;

  private final List<UMethodParam> varargsParamsWithDefaultsAndNamesAndDefaults;

  private final List<UMethodParam> varargsParamsWithDefaultsAndNamesAndDefaultsAndNames;

  private final List<UMethodParam> varargsParamsWithDefaultsAndNamesAndDefaultsAndNamesAndDefaults;

  private final List<UMethodParam> varargsParamsWithDefaultsAndNamesAndDefaultsAndNamesAndDefaultsAndNames;

  private final List<UMethodParam> varargsParamsWithDefaultsAndNamesAndDefaultsAndNamesAndDefaultsAndNamesAndDefaults;

  private final List<UMethodParam> varargsParamsWithDefaultsAndNamesAndDefaultsAndNamesAndDefaultsAndNamesAndDefaultsAndNames;

  private final List<UMethodParam> varargsParamsWithDefaultsAndNamesAndDefaultsAndNamesAndDefaultsAndNamesAndDefaultsAndNamesAndDefaults;

  private final List<UMethodParam> varargsParamsWithDefaultsAndNamesAndDefaultsAndNamesAndDefaultsAndNamesAndDefaultsAndNamesAndDefaultsAndNames;

  private final List<UMethodParam> varargsParams<nl>
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    UBlank uBlank = (UBlank) o;
    return unique.equals(uBlank.unique);
  <|file_separator|>class AutoValue_UInteger.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>class AutoValue_UInteger extends UInteger {

  private final int value;

  AutoValue_UInteger(
      int value) {
    if (value < 0) {
      throw new IllegalArgumentException("value must be non-negative, but was: " + value);
    }
    this.value = value;
  }

  @Override
  public int value() {
    return value;
  }

  @Override
  public String toString() {
    return "UInteger{"
        + "value=" + value
        + "}";
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    UInteger uInteger = (UInteger) o;
    return value == uInteger.value;
  }

  @Override
  public int hashCode() {
    int h$ = 1;
    h$ *= 1000003;
    h$ ^= value;
    return h$;
  }

}<|file_separator|>class AutoValue_UInteger_UInteger_UInteger_UInteger_UInteger_UInteger_UInteger_UInteger_UInteger_UInteger_UInteger_UInteger_UInteger_UInteger_UInteger_UInteger_UInteger_UInteger_<nl>
    System.err.println(err);
    System.err.println();
    System.err.println("Usage: java -jar bugpattern-generator.jar [options]");
    System.err.println();
    System.err.println("Options:");
    new JCommander(new Options()).usage();
    System.exit(1);
  }<|file_separator|><nl>
        ensureArrayCreated(type);
        ArrayExpr memoryArray = memoryMap.get(type);
        return context.mkSelect(memoryArray, targetExpr, arrayIndex);
    <|file_separator|><nl>
        checkers.forEach(c -> c.checkArrayWrite(arrayWrite));
    }

    @Override
    public void checkArrayLength(CtArrayLength<?> arrayLength)
    {
        checkers.forEach(c -> c.checkArrayLength(arrayLength));
    }

    @Override
    public void checkArrayIndex(CtArrayIndex<?> arrayIndex)
    {
        checkers.forEach(c -> c.checkArrayIndex(arrayIndex));
    }

    @Override
    public void checkArrayInitializer(CtArrayInitializer<?> arrayInitializer)
    {
        checkers.forEach(c -> c.checkArrayInitializer(arrayInitializer));
    }

    @Override
    public void checkArrayInitializerElement(CtArrayInitializerElement<?> arrayInitializerElement)
    {
        checkers.forEach(c -> c.checkArrayInitializerElement(arrayInitializerElement));
    }

    @Override
    public void checkArrayInitializerElementResult(CtArrayInitializerElement<?> arrayInitializerElement)
    {
        checkers.forEach(c -> c.checkArrayInitializerElementResult(arrayInitializerElement));
    }

    @Override
    public void checkArrayInitializerResult(CtArrayInitializer<?> arrayInitializer)
    {
        checkers.forEach(c -> c.checkArrayInitializerResult(arrayInitializer));
    }

    @Override
    public void checkArrayInitializerElementResult(CtArrayInitializerElement<?> arrayInitializerElement)
    {
        checkers.forEach(c -> c.checkArrayInitializerElementResult(arrayInitializerElement));
    }

    @Override
    public void checkArrayInitializerResult(CtArrayInitializer<?> arrayInitializer)
    {
        checkers.forEach(c -> c.checkArrayInitializerResult(arrayInitializer));
    <|file_separator|><nl>
		for (TypeTransformer transformer: transformers) {
			if (transformer.accept(type)) {
				return true;
			}
		}
		return false;
	<|file_separator|><nl>
		String resourceName = "test.txt";
		String expected = "Hello World";
		String actual = decompiler.decompileResource(resourceName);
		assertEquals(expected, actual);
	<|file_separator|><nl>
		Set<JavadocSnippetMarkupRegion> regions = new HashSet<>();
		int line = 1;
		StringReader reader = new StringReader(lines);
		while (reader.canRead()) {
			Optional<JavadocSnippetMarkupRegion> region = endRegion(reader, line);
			if (region.isPresent()) {
				regions.add(region.get());
			}
			line++;
		}
		return regions;
	<|file_separator|>class StringReader.java
<|fim_prefix|><|fim_suffix|>

	public String readWhile(Predicate<Character> predicate) {
		StringBuilder builder = new StringBuilder();
		while (canRead() && predicate.test(peek())) {
			builder.append(read());
		}
		return builder.toString();
	}
}<|fim_middle|>import java.util.function.Predicate;

public class StringReader {

	private final String string;
	private int index;

	public StringReader(String string) {
		this.string = string;
		this.index = 0;
	}

	public boolean canRead() {
		return index < string.length();
	}

	public char peek() {
		return string.charAt(index);
	}

	public char read() {
		return string.charAt(index++);
	}<|file_separator|>class JavadocSnippetRegionType.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public enum JavadocSnippetRegionType {
	/**
	 * The region is a parameter.
	 */
	PARAMETER,

	/**
	 * The region is a return value.
	 */
	RETURN_VALUE,

	/**
	 * The region is a type.
	 */
	TYPE,

	/**
	 * The region is a variable.
	 */
	VARIABLE
}<|file_separator|>class InlineTagParser.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>import java.util<nl>
		Set<JavadocSnippetMarkupRegion> regions = new SnippetFileParser(List.of(
			"class Foo { // @highlight",
			"  int p1 = 0; //@highlight substring="p1" type="italic"",
			"  int p2 = 0; //@highlight substring="p3" type="italic" region="foo" :",
			"  int p3 = 0;",
			"  static {  // @end region="foo"",
			"    System.out.println("hey"); // @link substring="System.out" target="System#out"",
			"  }",
			"  int p4 = 0; // @start region="baz"",
			"  int p5 = 0; // @end",
			"}"
		)).parse();
		List<JavadocSnippetMarkupRegion> expected = List.of(
			TestHelper.region(0, 0, Map.of(), HIGHLIGHT),
			TestHelper.region(1, 1, Map.of("substring", "p1", "type", "italic"), HIGHLIGHT),
			TestHelper.region(
				3, 4, Map.of("substring", "p3", "type", "italic", "region", "foo"),
				HIGHLIGHT
			),
			TestHelper.region(5, 5, Map.of("substring", "System.out", "target", "System#out"), LINK),
			TestHelper.region(7, 8, Map.of("region", "baz"), START)
		);

		assertThat(regions).containsExactlyInAnyOrderElementsOf(expected);
	<|file_separator|><nl>
		return getLhs().hashCode() + getRhs().hashCode();
	<|file_separator|>class Or extends BinaryConnective {
	/**
	 * Create a new "OR" logical connective.
	 *
	 * @param lhs First Formula that must hold
	 * @param rhs Second Formula that must hold
	 */
	public Or(Formula lhs, Formula rhs) {
		super(lhs, rhs);
	}

	/**
	 * Implements the Visitor pattern.
	 *
	 * @param visitor Visitor to accept
	 */
	@Override
	public void accept(FormulaVisitor visitor) {
		visitor.visit(this);
	}

	@Override
	public String toString() {
		return "Or(" + getLhs().toString() + ", " + getRhs().toString() + ")";
	}

	@Override
	public int hashCode() {
		return getLhs().hashCode() + getRhs().hashCode();
	}

	@Override
	public boolean equals(Object other) {
		return this == other || (other instanceof Or && other.hashCode() == hashCode());
	}
}<|file_separator|>class Not extends UnaryConnective {
	/**
	 * Create a new "NOT" logical connective.
	 *
	 * @param child Formula that must hold
	 */
	public Not(Formula child) {
		super(child);
	}

	/**
	 * Implements the Visitor pattern.
	 *
	 * @param visitor Visitor to accept
	 */
	@Override
	public void accept(FormulaVisitor visitor) {
		visitor.visit(this);
	}

	@Override
	public String toString() {
		return "Not(" + getChild().toString() + ")";
	}

	@Override
	public int hashCode() {
<nl>
		for (String metavar : metavars.keySet()) {
			if (parameters.containsKey(metavar)) {
				if (metavars.get(metavar).validate(parameters.get(metavar))) {
					parameters.put(metavar, metavars.get(metavar).getConstraint());
				} else {
					return false;
				}
			}
		}
		return true;
	}

	/**
	 * Get the matching (sub-)element.
	 *
	 * @return Matching (sub-)element
	 */
	@Override
	public CtElement getMatchedElement() {
		return matchedElement.peek();
	}

	/**
	 * Set the matching (sub-)element.
	 *
	 * @param element Matching (sub-)element
	 */
	@Override
	public void setMatchedElement(CtElement element) {
		matchedElement.push(element);
	}

	/**
	 * Get the string representation of the predicate.
	 *
	 * @return String representation of the predicate
	 */
	@Override
	public String toString() {
		return "ParameterizedPredicate{" +
				"metavars=" + metavars +
				", matchedElement=" + matchedElement +
				'}';
	<|file_separator|>class MetavariableConstraint.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public interface MetavariableConstraint {
	/**
	 * Validate a given value against the constraint.
	 *
	 * @param value Value to validate
	 * @return True if the value is valid, false otherwise
	 */
	public boolean validate(Object value);

	/**
	 * Get the constraint.
	 *
	 * @return Constraint
	 */
	public Object getConstraint();
}<|file_separator|>class MetavariableConstraintFactory.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class Metavariable<nl>
		return this.innerElement;
	<|file_separator|>class Formula.php
<|fim_prefix|><|fim_suffix|>
	 *
	 * @return The operand
	 */
	public Formula getInnerElement();
}<|fim_middle|><?php
/**
 * A formula is a mathematical expression that can be evaluated to a boolean value.
 */
interface Formula {
	/**
	 * Get the operand.<|file_separator|>class BinaryConnective implements Formula.php
<|fim_prefix|><|fim_suffix|>
	 *
	 * @return The operand
	 */
	public Formula getInnerElement();
}<|fim_middle|><?php
/**
 * A binary connective is a formula that has two operands.
 */
interface BinaryConnective extends Formula {
	/**
	 * Get the left operand.
	 *
	 * @return The left operand
	 */
	public Formula getLeftElement();

	/**
	 * Get the right operand.<|file_separator|>class BinaryConnective.php
<|fim_prefix|><|fim_suffix|>
	 *
	 * @return The left operand
	 */
	public Formula getLeftElement();

	/**
	 * Get the right operand.
	 *
	 * @return The right operand
	 */
	public Formula getRightElement();
}<|fim_middle|><?php
/**
 * A binary connective is a formula that has two operands.
 */
interface BinaryConnective extends Formula {
	/**
	 * Get the left operand.<|file_separator|>class BinaryConnective implements Formula.php
<|fim_prefix|><|fim_suffix|>
	 *
	 * @return The right operand
	 */
	public Formula getRightElement();
}<|fim_middle|><?php
/**
 * A binary connective is a formula that has two operands.
 */
interface BinaryConnective extends Formula {
	/**
	 * Get the left operand.
	 *
	 * @return The left operand
	 */
	public Formula getLeftElement();

	/**
	 * Get the right operand.<nl>
		if (predicate instanceof Branch) {
			return predicate.matches(this);
		}

		return false;
	<|file_separator|><nl>
		if (predicate == null) {
			return false;
		}

		if (matchResults == null) {
			return false;
		}

		for (LabelMatchResult result : matchResults) {
			if (predicate.test(result)) {
				return true;
			}
		}

		return false;
	<|file_separator|><nl>
		return Collections.singletonList(new LabelMatchResult(this));
	}

	/**
	 * Get the most recently matched metavariable bindings.
	 *
	 * @return Map of metavariable bindings
	 */
	@Override
	public Map<String, Object> getMetavarBindings() {
		return metavarBindings;
	<|file_separator|><nl>

		// contract: the patch should match and perform each of the four replacements (lines 5-6, 9-10, 12-13, 15-16) exactly once

		CtMethod<?> outerMethod = ctx.getMethod("me.sheimi.sgit.activities.CommitDiffActivity::viewFileFragment");

		CtInvocation<?> invocation = outerMethod.getBody().getStatement(4);
		CtClass<?> innerClass = ((CtNewClass<?>) invocation.getArguments().get(0)).getAnonymousClass();

		CtMethod<?> innerMethod = innerClass.getMethodsByName("onConsoleMessage").get(0);

		assertTrue(innerMethod.toString().contains("public void onConsoleMessage(java.lang.String message, int lineNumber, java.lang.String sourceID) {"));
		assertTrue(innerMethod.toString().contains("Log.d("MyApplication", (((message + " -- From line ") + lineNumber) + " of ") + sourceID);"));

		ctx.applySmplPatch(innerMethod);
		assertFalse(innerMethod.toString().contains("public void onConsoleMessage(java.lang.String message, int lineNumber, java.lang.String sourceID) {"));
		assertTrue(innerMethod.toString().contains("public void onConsoleMessage(ConsoleMessage cs) {"));

		assertFalse(innerMethod.toString().contains("Log.d("MyApplication", (((message + " -- From line ") + lineNumber) + " of ") + sourceID);"));
		assertTrue(innerMethod.toString().contains("Log.d("MyApplication", (((cs.message() + " -- From line ") + cs.lineNumber()) + " of ") + cs.sourceId());"));
	<|file_separator|><nl>
		ctx.runTest();
	}

	@Test
	public void testCustomWebView2() {
		ctx.runTest();
	}

	@Test
	public void testCustomWebView3() {
		ctx.runTest();
	}

	@Test
	public void testCustomWebView4() {
		ctx.runTest();
	}

	@Test
	public void testCustomWebView5() {
		ctx.runTest();
	}

	@Test
	public void testCustomWebView6() {
		ctx.runTest();
	}

	@Test
	public void testCustomWebView7() {
		ctx.runTest();
	}

	@Test
	public void testCustomWebView8() {
		ctx.runTest();
	}

	@Test
	public void testCustomWebView9() {
		ctx.runTest();
	}

	@Test
	public void testCustomWebView10() {
		ctx.runTest();
	}

	@Test
	public void testCustomWebView11() {
		ctx.runTest();
	}

	@Test
	public void testCustomWebView12() {
		ctx.runTest();
	}

	@Test
	public void testCustomWebView13() {
		ctx.runTest();
	}

	@Test
	public void testCustomWebView14() {
		ctx.runTest();
	}

	@Test
	public void testCustomWebView15() {
		ctx.runTest();
	}

	@Test
	public void testCustomWebView16() {
		ctx.runTest();
	}

	@Test
	public void testCustomWebView17() {
		ctx.runTest();
<nl>

		// contract: the bug in the empty disjunction removal in the SmPLGrep class

		String smpl = "@@ @@" +
					  "int foo() {n" +
					  "  return 42;n" +
					  "}n";

		SmPLGrep.Pattern pattern = getPattern(smpl);

		assertTrue(pattern.matches("int foo"));
	<|file_separator|><nl>
		return new PatternNode(element, params);
	}

	public static PatternNode makePattern(CtElement element, List<String> params, String... args) {
		return new PatternNode(element, params, args);
	<|file_separator|><nl>
		final @NotNull String text = this.spoonCode.getText();
		final @NotNull String selectedText = text.substring(this.startPosition, this.endPosition);
		this.spoonCode.replaceText(selectedText);
	<|file_separator|><nl>
		level++;
		super.enter(elt);
	<|file_separator|><nl>
		for (Processor<T> processor : processors) {
			launcher.addProcessor(processor);
		}
		return this;
	<|file_separator|><nl>
		try (FileOutputStream fileStream = new FileOutputStream(file);
			ObjectOutputStream objectStream = new ObjectOutputStream(new BufferedOutputStream(fileStream))) {
			objectStream.writeObject(cacheInfo);
		} catch (IOException e) {
			throw new SpoonException("unable to save cache info");
		}
	}
<|file_separator|><nl>
		if (!f.exists()) {
			throw new FileNotFoundException(f.toString() + " does not exist");
		}
		if (f.isDirectory()) {
			return createFolder(f);
		}
		if (isArchive(f)) {
			return new ZipFile(f);
		}
		return createFile(f);
	<|file_separator|><nl>
		args.add("-preserveUnusedVars");
		return myself;
	<|file_separator|><nl>
		args.add("-proc:all");
		return myself;
	<|file_separator|><nl>
		Javadoc javadoc = new Javadoc();
		javadoc.description = parseText(commentContent);
		javadoc.blockTags = parseBlockTags(commentContent);
		return javadoc;
	}

	private static List<JavadocBlockTag> parseBlockTags(String commentContent) {
		List<JavadocBlockTag> blockTags = new LinkedList<>();
		Matcher matcher = BLOCK_PATTERN.matcher(commentContent);
		while (matcher.find()) {
			blockTags.add(parseBlockTag(matcher.group()));
		}
		return blockTags;
	<|file_separator|><nl>
		if (this == o) {
			return true;
		}
		if (o == null || getClass() != o.getClass()) {
			return false;
		}
		JavadocBlockTag that = (JavadocBlockTag) o;
		return type == that.type && name.equals(that.name) && content.equals(that.content);
	<|file_separator|>class JavadocDescription.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>class JavadocDescription {
	private String text;
	private String[] lines;

	public JavadocDescription(String text) {
		this.text = text;
		this.lines = text.split("\n");
	}

	public JavadocDescription(String[] lines) {
		this.lines = lines;
	}

	public JavadocDescription(String[] lines, String text) {
		this.lines = lines;
		this.text = text;
	}

	public String getText() {
		return text;
	}

	public String[] getLines() {
		return lines;
	}

	public boolean isEmpty() {
		return text == null || text.isEmpty();
	}

	public String toText() {
		return text;
	}

	@Override
	public boolean equals(Object o) {
		if (this == o) {
			return true;
		}
		if (o == null || getClass() != o.getClass()) {
			return false;
		}
		JavadocDescription that = (JavadocDescription) o;
		return text.equals(that.text) && Arrays.equals(lines, that.lines);
	}

	@Override
	public int hashCode() {
		int result = text.hashCode();
		result = 31 * result + Arrays.hashCode(lines);<nl>
		return elements.isEmpty();
	<|file_separator|><nl>
		return element.getName().equals(name);
	<|file_separator|><nl>
		new DefaultMatcher(factory, modelValueResolver).forEachMatch(input, consumer);
	<|file_separator|>class PatternBuilder.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>/**
 * @author John
 * @since 1.0
 */
public class PatternBuilder {
	private final Factory factory;
	private final ListOfNodes modelValueResolver;
	private final ListOfNodes modelValueResolverCopy;
	private final ListOfNodes modelValueResolverCopy2;
	private final ListOfNodes modelValueResolverCopy3;
	private final ListOfNodes modelValueResolverCopy4;
	private final ListOfNodes modelValueResolverCopy5;
	private final ListOfNodes modelValueResolverCopy6;
	private final ListOfNodes modelValueResolverCopy7;
	private final ListOfNodes modelValueResolverCopy8;
	private final ListOfNodes modelValueResolverCopy9;
	private final ListOfNodes modelValueResolverCopy10;
	private final ListOfNodes modelValueResolverCopy11;
	private final ListOfNodes modelValueResolverCopy12;
	private final ListOfNodes modelValueResolverCopy13;
	private final ListOfNodes modelValueResolverCopy14;
	private final ListOfNodes modelValueResolverCopy15;
	private final ListOfNodes modelValueResolverCopy16;
	private final ListOfNodes modelValueResolverCopy17;
	private final ListOfNodes modelValueResolverCopy18;
	private final ListOfNodes modelValueResolverCopy19;
	private final ListOfNodes modelValueResolverCopy20;
	private final ListOfNodes modelValueResolverCopy21;
	private final ListOfNodes modelValueResolverCopy22;
	private final ListOfNodes modelValueResolverCopy23;
	private final ListOfNodes modelValueResolverCopy24;
	private<nl>
			return result;
		<|file_separator|>class ResultHolder<T> extends ResultHolder<T> {

		private final Class<T> requiredClass;

		public ResultHolder(Class<T> requiredClass) {
			this.requiredClass = requiredClass;
		}

		@Override
		public boolean isMultiple() {
			return false;
		}

		@Override
		public void addResult(T value) {
			if (value == null) {
				throw new IllegalArgumentException("Value cannot be null");
			}
			if (!requiredClass.isInstance(value)) {
				throw new IllegalArgumentException("Value must be of type " + requiredClass.getName());
			}
		}

		@Override
		public List<T> getResults() {
			return Collections.singletonList(result);
		}

		@Override
		public void mapEachResult(Function<T, T> consumer) {
			result = consumer.apply(result);
		}
	<|file_separator|><nl>
		return simplifyGenerated;
	<|file_separator|><nl>
		throw new UnsupportedOperationException();
	<|file_separator|><nl>
		callerMethods.add(method);
	<|file_separator|><nl>
				if (!hasValue) {
					throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + size());
				}
				X oldValue = get(0);
				SingleHandler.this.setValue(element, null);
				hasValue = false;
				return oldValue;
			<|file_separator|><nl>
		if (literal.isBooleanLiteral()) {
			return literal.getBooleanValue() ? "true" : "false";
		}
		if (literal.isCharLiteral()) {
			return "'" + literal.getCharValue() + "'";
		}
		if (literal.isDoubleLiteral()) {
			return Double.toString(literal.getDoubleValue());
		}
		if (literal.isFloatLiteral()) {
			return Float.toString(literal.getFloatValue());
		}
		if (literal.isIntLiteral()) {
			return Integer.toString(literal.getIntValue());
		}
		if (literal.isLongLiteral()) {
			return Long.toString(literal.getLongValue());
		}
		if (literal.isShortLiteral()) {
			return Short.toString(literal.getShortValue());
		}
		if (literal.isByteLiteral()) {
			return Byte.toString(literal.getByteValue());
		}
		if (literal.isCharLiteral()) {
			return "'" + literal.getCharValue() + "'";
		}
		if (literal.isCharLiteral()) {
			return "'" + literal.getCharValue() + "'";
		}
		if (literal.isCharLiteral()) {
			return "'" + literal.getCharValue() + "'";
		}
		if (literal.isCharLiteral()) {
			return "'" + literal.getCharValue() + "'";
		}
		if (literal.isCharLiteral()) {
			return "'" + literal.getCharValue() + "'";
		}
		if (literal.isCharLiteral()) {
			return "'" + literal.getCharValue() + "'";
		}
		if (literal.isCharLiteral()) {
			return "'" + literal.getCharValue() +<nl>
		return this.reference == reference;
	<|file_separator|><nl>
		if (this.listener != null) {
			this.listener.scanParameter(parameter);
		}
		outputConsumer.accept(parameter.getValue());
	<|file_separator|><nl>
		//TODO
	}
}
<|file_separator|><nl>
		return new FileSystemFolder(file.getParentFile());
	<|file_separator|><nl>
		// TODO Auto-generated method stub
		
	<|file_separator|><nl>
		return map;
	<|file_separator|>class MapContext<K, V> extends Context {
	private final Map<K, V> map;
	private  K key;

	public MapContext(CtElement element, CtRole role, Map<K, V> map) {
		super(element, role);
		this.map = map;
	}

	public MapContext(CtElement element, CtRole role, Map<K, V> map, K key) {
		this(element, role, map);
		this.key = key;
	}

	/**
	 * get the changed key
	 * @return the changed key
	 */
	public K getKey() {
		return key;
	}

	/**
	 * the changed map
	 * @return the changed map
	 */
	public Map<K, V> getMap() {
		return map;
	}
}<|file_separator|><nl>
		return getFactory().getEnvironment().getBreakLabelledStatement(this);
	<|file_separator|>class CtContinueImpl extends CtStatementImpl implements CtContinue {
	private static final long serialVersionUID = 1L;

	@MetamodelPropertyField(role = TARGET_LABEL)
	String targetLabel;


	@Override
	public void accept(CtVisitor visitor) {
		visitor.visitCtContinue(this);
	}

	@Override
	public String getTargetLabel() {
		return targetLabel;
	}

	@Override
	public <T extends CtLabelledFlowBreak> T setTargetLabel(String targetLabel) {
		getFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, TARGET_LABEL, targetLabel, this.targetLabel);
		this.targetLabel = targetLabel;
		return (T) this;
	}

	@Override
	public CtStatement getLabelledStatement() {
		return getFactory().getEnvironment().getContinueLabelledStatement(this);
	}


	@Override
	public CtContinue clone() {
		return (CtContinue) super.clone();
	}
}<|file_separator|>class CtLabelledFlowBreakImpl extends CtLabelledFlowBreak {
	private static final long serialVersionUID = 1L;

	@MetamodelPropertyField(role = TARGET_LABEL)
	String targetLabel;


	@Override
	public void accept(CtVisitor visitor) {
		visitor.visitCtLabelledFlowBreak(this);
	}

	@Override
	public String getTargetLabel() {
		return targetLabel;
	}

	@Override
	public <T extends CtLabelledFlowBreak> T setTargetLabel(String targetLabel) {
		getFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, TARGET_LABEL,<nl>
		if (statement != null) {
			statement.setParent(this);
		}
		getFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, BODY, statement, this.body);
		this.body = statement;
		return (T) this;
	<|file_separator|>class CtCodeElementImpl.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>package org.eclipse.emf.codegen.ecore.genmodel;

import org.eclipse.emf.codegen.ecore.genmodel.impl.AbstractCodeElementImpl;

public abstract class CtCodeElementImpl extends AbstractCodeElementImpl implements CtCodeElement {
	private static final long serialVersionUID = 1L;
}<|file_separator|>class CtCodeModelImpl.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>package org.eclipse.emf.codegen.ecore.genmodel;

import org.eclipse.emf.codegen.ecore.genmodel.impl.AbstractCodeModelImpl;

public abstract class CtCodeModelImpl extends AbstractCodeModelImpl implements CtCodeModel {
	private static final long serialVersionUID = 1L;
}<|file_separator|>class CtCodeModel.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>package org.eclipse.emf.codegen.ecore.genmodel;

import org.eclipse.emf.codegen.ecore.genmodel.impl.AbstractCodeModel;

public interface CtCodeModel extends AbstractCodeModel {
	public static final String ECORE_URI = "http://www.eclipse.org/emf/2002/Ecore";
	public static final String ECORE_NS = "http://www.eclipse.org/emf/2002/Ecore";
	public static final String ECORE_NS_URI = "http://www.eclipse.org/emf/2002/Ecore";
	public static final String ECORE_NS_PREFIX = "ecore";
	public static final String ECORE_NS<nl>
		return (CtFieldReference<T>) getVariableReference();
	}

	@Override
	public <C extends CtFieldReference<T>> C setVariable(CtFieldReference<T> variable) {
		return (C) setVariableReference(variable);
	}

	@Override
	public CtFieldAccess<T> setVariable(CtFieldReference<T> variable) {
		return (CtFieldAccess<T>) setVariableReference(variable);
	<|file_separator|>class CtFieldReferenceImpl<T> extends CtVariableReferenceImpl<T> implements CtFieldReference<T> {
	private static final long serialVersionUID = 1L;

	@MetamodelPropertyField(role = TARGET)
	CtExpression<?> target;

	@Override
	public CtExpression<?> getTarget() {
		return target;
	}

	@Override
	public <C extends CtTargetedExpression<T, CtExpression<?>>> C setTarget(CtExpression<?> target) {
		if (target != null) {
			target.setParent(this);
		}
		getFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, TARGET, target, this.target);
		this.target = target;
		return (C) this;
	}

	@Override
	public CtFieldAccess<T> getAccess() {
		return (CtFieldAccess<T>) getAccessReference();
	}

	@Override
	public <C extends CtFieldAccess<T>> C setAccess(CtFieldAccess<T> access) {
		return (C) setAccessReference(access);
	}

	@Override
	public CtFieldReference<T> setAccess(CtFieldAccess<T> access) {
		return (CtFieldReference<T>) setAccessReference(access);
	}

	<nl>
		return new CtFieldReadImpl<T>(this);
	<|file_separator|>class CtFieldWriteImpl<T> extends CtFieldAccessImpl<T> implements CtFieldWrite<T> {
	private static final long serialVersionUID = 1L;

	@Override
	public void accept(CtVisitor visitor) {
		visitor.visitCtFieldWrite(this);
	}

	@Override
	public CtFieldWrite<T> clone() {
		return new CtFieldWriteImpl<T>(this);
	}
<|file_separator|>class CtFieldAccessImpl<T> extends CtFieldAccess<T> {
	private static final long serialVersionUID = 1L;

	@Override
	public void accept(CtVisitor visitor) {
		visitor.visitCtFieldAccess(this);
	}

	@Override
	public CtFieldAccess<T> clone() {
		return new CtFieldAccessImpl<T>(this);
	}
}<|file_separator|>class CtFieldRead.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public interface CtFieldRead<T> extends CtFieldAccess<T> {
	public T read(CtObject object);
}<|file_separator|>class CtFieldWrite.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public interface CtFieldWrite<T> extends CtFieldAccess<T> {
	public void write(CtObject object, T value);
}<|file_separator|>class CtFieldAccess.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public interface CtFieldAccess<T> extends CtField<T> {
	public void accept(CtVisitor visitor);
}<|file_separator|>class CtField.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public interface CtField<T> extends CtElement {
	public T get(CtObject object);
	public void set(CtObject object, T value);
}<|file_separator|>class CtFieldAccess.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public interface CtFieldAccess<T> extends CtField<T> {
<nl>
		visitor.visit(this);
	<|file_separator|>class CtTypeImpl.java
<|fim_prefix|><|fim_suffix|>

	@Override
	public <T extends CtType<T>> T setSuperType(CtType<T> superType) {
		if (superType != null) {
			superType.setParent(this);
		}
		getFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, SUPER_TYPE, superType, this.superType);
		this.superType = superType;
		return (T) this;
	}

	@Override
	public CtType<?> getSuperType() {
		return superType;
	}

	@Override
	public <T extends CtType<T>> T setSuperType(CtType<T> superType, boolean notify) {
		if (superType != null) {
			superType.setParent(this);
		}
		getFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, SUPER_TYPE, superType, this.superType);
		this.superType = superType;
		return (T) this;
	}

	@Override
	public <T extends CtType<T>> T setSuperType(CtType<T> superType, boolean notify, boolean fireEvent) {
		if (superType != null) {
			superType.setParent(this);
		}
		getFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, SUPER_TYPE, superType, this.superType);
		this.superType = superType;
		return (T) this;
	}

	@Override
	public <T extends CtType<T>> T setSuperType(CtType<T> superType, boolean notify, boolean fireEvent, boolean fireEvent2) {
		<nl>
		CtStatementImpl.insertBefore(this, statements);
		return (C) this;
	<|file_separator|>class CtUnaryOperator.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public interface CtUnaryOperator<T> extends CtExpression<T> {
	public static final String OPERATOR_KIND = "operatorKind";
	public static final String LABEL = "label";
	public static final String EXPRESSION = "expression";

	public UnaryOperatorKind getKind();

	public String getLabel();

	public CtExpression<?> getOperand();

	public <C extends CtStatement> C insertAfter(CtStatement statement);

	public <C extends CtStatement> C insertBefore(CtStatement statement);

	public <C extends CtStatement> C insertAfter(CtStatementList statements);

	public <C extends CtStatement> C insertBefore(CtStatementList statements);

	public <C extends CtUnaryOperator> C setOperand(CtExpression<?> expression);

	public <C extends CtUnaryOperator> C setKind(UnaryOperatorKind kind);

	public <C extends CtStatement> C setLabel(String label);
}<|file_separator|>class CtVisitor.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public interface CtVisitor {
	public void visitCtBinaryOperator(CtBinaryOperator<?> operator);

	public void visitCtUnaryOperator(CtUnaryOperator<?> operator);

	public void visitCtExpression(CtExpression<?> expression);

	public void visitCtStatement(CtStatement<?> statement);

	public void visitCtStatementList(CtStatementList statementList);
}<|file_separator|>class CtStatementList.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public interface CtStatementList extends CtStatement {
	public static final String STATEMENTS = "statements";

	public <C extends CtStatement> C add(CtStatement statement);

	public <C extends CtStatement> C add(CtStatementList statements);

	public <C extends CtStatement> C add<nl>
		return bodyEnd;
	<|file_separator|><nl>
		return super.getSourceStart();
	<|file_separator|><nl>
		return Collections.emptySet();
	}

	@Override
	public <M, C extends CtType<T>> C addAnnotationMethod(CtMethod<M> method) {
		return (C) this;
	<|file_separator|>class CtAnnotationMethodImpl<T extends Annotation> extends CtMethodImpl<T> implements CtAnnotationMethod<T> {
	private static final long serialVersionUID = 1L;

	@Override
	public void accept(CtVisitor v) {
		v.visitCtAnnotationMethod(this);
	}

	@Override
	public boolean isAnnotationMethod() {
		return true;
	}

	@Override
	public <C extends CtType<T>> C setAnnotationType(CtTypeReference<?> annotationType) {
		return (C) this;
	}

	@Override
	public <C extends CtType<T>> C setAnnotationType(CtType<?> annotationType) {
		return (C) this;
	}

	@Override
	public <C extends CtType<T>> C setAnnotationType(CtTypeReference<?> annotationType, boolean isStatic) {
		return (C) this;
	}

	@Override
	public <C extends CtType<T>> C setAnnotationType(CtType<?> annotationType, boolean isStatic) {
		return (C) this;
	}

	@Override
	public <C extends CtType<T>> C setAnnotationType(CtTypeReference<?> annotationType, boolean isStatic, boolean isFinal) {
		return (C) this;
	}

	@Override
	public <C extends CtType<T>> C setAnnotationType(CtType<?> annotationType, boolean isStatic, boolean isFinal) {
		return (C) this;
	}

	@Override
<nl>
		return getModifiers().contains(modifier);
	}

	@Override
	public <T extends CtModifiable> T addModifier(Set<ModifierKind> modifiers) {
		modifierHandler.addModifier(modifiers);
		return (T) this;
	}

	@Override
	public <T extends CtModifiable> T removeModifier(Set<ModifierKind> modifiers) {
		modifierHandler.removeModifier(modifiers);
		return (T) this;
	<|file_separator|>class CtAnnotationImpl.java
<|fim_prefix|><|fim_suffix|>

	@Override
	public <T extends CtModifiable> T setModifiers(Set<ModifierKind> modifiers) {
		// unsettable property
		return (T) this;
	}

	@Override
	public <T extends CtModifiable> T setVisibility(ModifierKind visibility) {
		// unsettable property
		return (T) this;
	}

	@Override
	public Set<CtExtendedModifier> getExtendedModifiers() {
		return this.modifierHandler.getExtendedModifiers();
	}

	@Override
	public <T extends CtModifiable> T setExtendedModifiers(Set<CtExtendedModifier> extendedModifiers) {
		this.modifierHandler.setExtendedModifiers(extendedModifiers);
		return (T) this;
	}

	@Override
	public String getSimpleName() {
		return "";
	}

	@Override
	@UnsettableProperty
	public <T extends CtNamedElement> T setSimpleName(String simpleName) {
		// unsettable property
		return (T) this;
	}

	@Override
	public CtAnnotation clone() {
		return (CtAnnotation) super.clone();
	}

	@Override
	public boolean isPublic() {
		return this.modifierHandler.isPublic();<nl>
		return new CtEnumValueImpl<T>(this);
	}

	@Override
	public CtExpression<T> getExpression() {
		return null;
	<|file_separator|>class CtExpressionImpl<T> extends CtFieldImpl<T> implements CtExpression<T> {
	@Override
	public void accept(CtVisitor v) {
		v.visitCtExpression(this);
	}

	@Override
	public CtExpression clone() {
		return new CtExpressionImpl<T>(this);
	}

	@Override
	public CtExpression<T> getExpression() {
		return this;
	}

	@Override
	public CtExpression<T> getAssignment() {
		return null;
	}
}<|file_separator|>class CtFieldImpl<T> extends CtField<T> {
	@Override
	public void accept(CtVisitor v) {
		v.visitCtField(this);
	}

	@Override
	public CtField clone() {
		return new CtFieldImpl<T>(this);
	}

	@Override
	public CtExpression<T> getExpression() {
		return null;
	}

	@Override
	public CtExpression<T> getAssignment() {
		return null;
	}
}<|file_separator|>class CtField.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public abstract class CtField<T> extends CtExpression<T> {
	@Override
	public abstract void accept(CtVisitor v);

	@Override
	public abstract CtField clone();

	@Override
	public abstract CtExpression<T> getExpression();

	@Override
	public abstract CtExpression<T> getAssignment();
}<|file_separator|>class CtExpression.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public abstract class CtExpression<T> extends CtField<T> {
	@Override<nl>
		this.simpleName = simpleName;
		return (T) this;
	<|file_separator|><nl>
		this.type = type;
		return (C) this;
	<|file_separator|><nl>
		if (bounds == null || bounds.isEmpty()) {
			this.bounds = CtElementImpl.emptyList();
		}
		getFactory().getEnvironment().getModelChangeListener().onListAdd(this, BOUND, bounds, bounds.indexOf(bound), bound);
		return (C) this;
	<|file_separator|>class CtIntersectionTypeReference.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public interface CtIntersectionTypeReference<T> extends CtTypeReference<T> {
	List<CtTypeReference<?>> getBounds();

	<C extends CtIntersectionTypeReference> C setBounds(List<CtTypeReference<?>> bounds);

	<C extends CtIntersectionTypeReference> C addBound(CtTypeReference<?> bound);

	boolean removeBound(CtTypeReference<?> bound);

	CtTypeReference<?> getTypeErasure();
}<|file_separator|>class CtIntersectionTypeReferenceImpl.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class CtIntersectionTypeReferenceImpl<T> extends CtTypeReferenceImpl<T> implements CtIntersectionTypeReference<T> {
	@MetamodelPropertyField(role = BOUND)
	List<CtTypeReference<?>> bounds = CtElementImpl.emptyList();

	@Override
	public void accept(CtVisitor visitor) {
		visitor.visitCtIntersectionTypeReference(this);
	}

	@Override
	public List<CtTypeReference<?>> getBounds() {
		return Collections.unmodifiableList(bounds);
	}

	@Override
	public <C extends CtIntersectionTypeReference> C setBounds(List<CtTypeReference<?>> bounds) {
		if (bounds == null || bounds.isEmpty()) {
			this.bounds = CtElementImpl.emptyList();
			return (C) this;
		}
		getFactory().getEnvironment().getModelChangeListener().onListDeleteAll(this, BOUND, this.bounds, new ArrayList<>(this.bounds));
		this.<nl>
		CtTypeParameter typeParam = getDeclaration();
		if (typeParam != null) {
			return typeParam;
		}
		CtTypeParameter typeParam2 = findTypeParamDeclaration(getDeclaration().getSuperclass(), getSimpleName());
		if (typeParam2 != null) {
			return typeParam2;
		}
		return null;
	<|file_separator|>class CtTypeParameterImpl extends CtTypeParameter implements CtTypeParameterImpl {
	private static final long serialVersionUID = 1L;

	private final CtTypeParameterDeclaration declaration;
	private final CtTypeParameterReference reference;
	private final CtTypeParameterType type;
	private final CtTypeParameterTypeErased erased;
	private final CtTypeParameterTypeErased erased2;
	private final CtTypeParameterTypeErased erased3;
	private final CtTypeParameterTypeErased erased4;
	private final CtTypeParameterTypeErased erased5;
	private final CtTypeParameterTypeErased erased6;
	private final CtTypeParameterTypeErased erased7;
	private final CtTypeParameterTypeErased erased8;
	private final CtTypeParameterTypeErased erased9;
	private final CtTypeParameterTypeErased erased10;
	private final CtTypeParameterTypeErased erased11;
	private final CtTypeParameterTypeErased erased12;
	private final CtTypeParameterTypeErased erased13;
	private final CtTypeParameterTypeErased erased14;
	private final CtTypeParameterTypeErased erased15;
	private final CtTypeParameterTypeErased erased16;
	private final CtTypeParameterTypeErased erased17;
	private final CtTypeParameterTypeErased erased18;
	private final CtTypeParameterTypeErased erased19;
	private final<nl>
		try {
			return MethodHandles.lookup().findVirtual(Class.class, "getPermittedSubclasses", MethodType.methodType(Class[].class));
		} catch (Throwable e) {
			return null;
		}
	<|file_separator|><nl>
		ctPackage.addAnnotation(ctAnnotation);
	}

	@Override
	public void addImport(CtImport ctImport) {
		ctPackage.addImport(ctImport);
	}

	@Override
	public void addImport(CtImport ctImport, boolean aForce) {
		ctPackage.addImport(ctImport, aForce);
	}

	@Override
	public void addImport(CtImport ctImport, boolean aForce, boolean aForceAll) {
		ctPackage.addImport(ctImport, aForce, aForceAll);
	}

	@Override
	public void addImport(CtImport ctImport, boolean aForce, boolean aForceAll, boolean aForceAllPublic) {
		ctPackage.addImport(ctImport, aForce, aForceAll, aForceAllPublic);
	}

	@Override
	public void addImport(CtImport ctImport, boolean aForce, boolean aForceAll, boolean aForceAllPublic, boolean aForceAllPublicAll) {
		ctPackage.addImport(ctImport, aForce, aForceAll, aForceAllPublic, aForceAllPublicAll);
	}

	@Override
	public void addImport(CtImport ctImport, boolean aForce, boolean aForceAll, boolean aForceAllPublic, boolean aForceAllPublicAll, boolean aForceAllPublicAllAll) {
		ctPackage.addImport(ctImport, aForce, aForceAll, aForceAllPublic, aForceAllPublicAll, aForceAllPublicAllAll);
	}

	@Override
	public void addImport(CtImport ctImport, boolean aForce, boolean aForceAll, boolean aForceAllPublic, boolean aForceAllPublicAll, boolean aForceAllPublicAllAll, boolean aForceAllPublicAllAllAll)<nl>
		typeReference.setDeclaringType(ctPackage);
	<|file_separator|>class TypeParameterRuntimeBuilderContext extends AbstractRuntimeBuilderContext {
	private CtTypeParameter typeParameter;
	private Type type;

	public TypeParameterRuntimeBuilderContext(Type type, CtTypeParameter typeParameter) {
		super(typeParameter);
		this.typeParameter = typeParameter;
		this.type = type;
	}

	@Override
	public void addPackage(CtPackage ctPackage) {
		typeParameter.setDeclaringType(ctPackage);
	}

	@Override
	public void addTypeReference(CtRole role, CtTypeReference<?> ctTypeReference) {
		switch (role) {
		case DECLARING_TYPE:
			this.typeParameter.setDeclaringType(ctTypeReference);
			return;
		case BOUNDING_TYPE:
		case SUPER_TYPE:
			if (typeParameter instanceof CtWildcardReference) {
				((CtWildcardReference) typeParameter).setBoundingType(ctTypeReference);
			} else {
				//Strange case?
				this.getClass();
			}
			return;
		case TYPE_ARGUMENT:
			typeParameter.addActualTypeArgument(ctTypeReference);
			return;
		}
		super.addTypeReference(role, ctTypeReference);
	}

	@Override
	public void addAnnotation(CtAnnotation<Annotation> ctAnnotation) {
		typeParameter.addAnnotation(ctAnnotation);
	}

	@Override
	public void addFormalType(CtTypeParameter parameterRef) {
		typeParameter.addActualTypeArgument(parameterRef.getReference());
	}

	@Override
	public @Nullable CtTypeParameter getTypeParameter(GenericDeclaration genericDeclaration, String string) {
		return type == genericDeclaration<nl>
		return method == null ? constructor.getDeclaredAnnotations() : method.getDeclaredAnnotations();
	<|file_separator|>class RtMethod.java
<|fim_prefix|><|fim_suffix|>
	public RtMethod(Method method, RtClass declaringClass, RtClass superClass, RtClass[] interfaces, RtParameter[] parameters, RtType[] returnTypes, RtType[] genericReturnTypes, RtType[] genericParameterTypes, RtType[] genericExceptionTypes, RtType[] genericExceptionGenericTypes, RtType[] genericExceptionGenericParameterTypes, RtType[] genericExceptionGenericExceptionTypes, RtType[] genericExceptionGenericExceptionGenericTypes, RtType[] genericExceptionGenericExceptionGenericParameterTypes, RtType[] genericExceptionGenericExceptionGenericExceptionTypes, RtType[] genericExceptionGenericExceptionGenericExceptionGenericTypes, RtType[] genericExceptionGenericExceptionGenericExceptionGenericParameterTypes, RtType[] genericExceptionGenericExceptionGenericExceptionGenericExceptionTypes, RtType[] genericExceptionGenericExceptionGenericExceptionGenericExceptionGenericTypes, RtType[] genericExceptionGenericExceptionGenericExceptionGenericExceptionGenericParameterTypes, RtType[] genericExceptionGenericExceptionGenericExceptionGenericExceptionGenericExceptionTypes, RtType[] genericExceptionGenericExceptionGenericExceptionGenericExceptionGenericExceptionGenericTypes, RtType[] genericExceptionGenericExceptionGenericExceptionGenericExceptionGenericExceptionGenericParameterTypes) {
		this.method = method;
		this.declaringClass = declaringClass;
		this.superClass = superClass;
		this.interfaces = interfaces;
		this.parameters = parameters;
		this.returnTypes = returnTypes;
		this.genericReturnTypes = genericReturnTypes;
		this.genericParameterTypes = genericParameterTypes;
		this.genericExceptionTypes = genericExceptionTypes;
		this.genericExceptionGenericTypes = genericExceptionGenericTypes;
		this.genericExceptionGenericParameterTypes = genericExceptionGenericParameterTypes;
		this.genericExceptionGenericExceptionTypes = genericExceptionGenericExceptionTypes;
		this.<nl>
		return build(filesToBuild, true);
	<|file_separator|><nl>
        // TODO
    <|file_separator|><nl>
        // contract: brackets should be printed when type cast on field read
        // arrange
        Launcher launcher = new Launcher();
        Factory factory = launcher.getFactory();
        CtType<?> x = factory.Type().get("FieldRead");
        String printed = x.toString();
        assertThat(printed, containsString("int[]"));
    }
<|file_separator|><nl>
		CompilationUnit cu1 = new CompilationUnit();
		CompilationUnit cu2 = new CompilationUnit();
		CompilationUnit cu3 = new CompilationUnit();
		CompilationUnit cu4 = new CompilationUnit();
		CompilationUnit cu5 = new CompilationUnit();
		CompilationUnit cu6 = new CompilationUnit();
		CompilationUnit cu7 = new CompilationUnit();
		CompilationUnit cu8 = new CompilationUnit();
		CompilationUnit cu9 = new CompilationUnit();
		CompilationUnit cu10 = new CompilationUnit();
		CompilationUnit cu11 = new CompilationUnit();
		CompilationUnit cu12 = new CompilationUnit();
		CompilationUnit cu13 = new CompilationUnit();
		CompilationUnit cu14 = new CompilationUnit();
		CompilationUnit cu15 = new CompilationUnit();
		CompilationUnit cu16 = new CompilationUnit();
		CompilationUnit cu17 = new CompilationUnit();
		CompilationUnit cu18 = new CompilationUnit();
		CompilationUnit cu19 = new CompilationUnit();
		CompilationUnit cu20 = new CompilationUnit();
		CompilationUnit cu21 = new CompilationUnit();
		CompilationUnit cu22 = new CompilationUnit();
		CompilationUnit cu23 = new CompilationUnit();
		CompilationUnit cu24 = new CompilationUnit();
		CompilationUnit cu25 = new CompilationUnit();
		CompilationUnit cu26 = new CompilationUnit();
		CompilationUnit cu27 = new CompilationUnit();
		CompilationUnit cu28 = new CompilationUnit();
		CompilationUnit cu29 = new CompilationUnit();
		CompilationUnit cu30 = new CompilationUnit();
		CompilationUnit cu31 = new CompilationUnit();
		CompilationUnit cu32 = new CompilationUnit();
		CompilationUnit cu33 = new CompilationUnit();
		CompilationUnit cu34 = new CompilationUnit();
<nl>
        // this is a comment
        foo[0] = 1;
    <|file_separator|><nl>
		return null;
	<|file_separator|><nl>
		return 1;
	<|file_separator|><nl>
    return values;
  <|file_separator|><nl>
		final Factory factory = createFactory();
		final CtClass<Object> topLevel = factory.Class().createTopLevel();
		assertEquals("TopLevel", topLevel.getSimpleName());
	<|file_separator|><nl>
        System.out.println("bar");
    <|file_separator|><nl>
        LOG.info("foo");
    <|file_separator|><nl>
	}

	public void m(int i) {
	}

	public void m(int i, int j) {
	}

	public void m(int i, int j, int k) {
	}

	public void m(int i, int j, int k, int l) {
	}

	public void m(int i, int j, int k, int l, int m) {
	}

	public void m(int i, int j, int k, int l, int m, int n) {
	}

	public void m(int i, int j, int k, int l, int m, int n, int o) {
	}

	public void m(int i, int j, int k, int l, int m, int n, int o, int p) {
	}

	public void m(int i, int j, int k, int l, int m, int n, int o, int p, int q) {
	}

	public void m(int i, int j, int k, int l, int m, int n, int o, int p, int q, int r) {
	}

	public void m(int i, int j, int k, int l, int m, int n, int o, int p, int q, int r, int s) {
	}

	public void m(int i, int j, int k, int l, int m, int n, int o, int p, int q, int r, int s, int t) {
	}

	public void m(int i, int j, int k, int l, int m, int n, int o, int p, int q, int r, int s, int t, int<nl>
		return new Tostada();
	<|file_separator|><nl>
		if (o instanceof Map.Entry) {
			Map.Entry entry = (Map.Entry) o;
			System.out.println(entry.getKey() + " " + entry.getValue());
		}
	<|file_separator|><nl>
		console.log(t);
	<|file_separator|><nl>
			if (theme == "light") {
				System.out.println("Tereza");
			} else {
				System.out.println("Tereza");
			}
		<|file_separator|><nl>
		System.out.println("Hello World");
	<|file_separator|><nl>
		return (Object[] args) -> biFunction.apply(args[0], args[1]);
	<|file_separator|><nl>
		// specifies a bug found by Benoit Cornu on August 7 2014

		Factory factory = createFactory();
		CtClass<?> clazz = factory
				.Code()
				.createCodeSnippetStatement(
						"" + "class X {" + "public void foo() {" + " "
								+ "}};")
				.compile();
		CtMethod<?> foo = (CtMethod<?>) clazz.getMethods().toArray()[0];

		CtBlock<?> body = foo.getBody(); // empty block (immutable EMPTY_LIST())

		List<CtStatement> statements = body.getStatements();
		for (CtStatement statement : statements) {
			System.out.println(statement);
		}
	<|file_separator|><nl>
		return null;
	<|file_separator|><nl>
		CtType<?> parent = createCompatibleParent(toTest);
		CtType<?> child = factory.createType();
		child.setSuperclass(parent);
		child.setFactory(factory);
		
		CtType<?> child2 = factory.createType();
		child2.setSuperclass(parent);
		child2.setFactory(factory);
		
		SetParentTest.set(child, parent);
		SetParentTest.set(child2, parent);
		
		assertEquals(parent, child.getSuperclass());
		assertEquals(parent, child2.getSuperclass());
	}
	
	private static void set(CtType<?> child, CtType<?> parent) {
		CtType<?> parent2 = child.getSuperclass();
		if (parent2 == null) {
			parent2 = createCompatibleParent(child);
			child.setSuperclass(parent2);
		}
		
		if (parent2 != parent) {
			child.setSuperclass(parent);
		}
	<|file_separator|><nl>
		int field3 = 0;
	<|file_separator|><nl>
		label1: while(x) {
			label2: getClass();
		}
	<|file_separator|><nl>
        return in -> in.compareTo(7) > 0;
    <|file_separator|><nl>
    Path inputPath = INPUT_PATH.resolve(path);
    Path outputPath = OUTPUT_PATH.resolve(path);
    FileVisitor<Path> visitor = new SniperJavaPrettyPrinter(inputPath, outputPath);
    Files.walkFileTree(inputPath, visitor);
  <|file_separator|><nl>
		System.out.println("Hello World");
	<|file_separator|><nl>
		int b;
	<|file_separator|><nl>
		if (element instanceof CtClass) {
			CtClass ctClass = (CtClass) element;
			if (ctClass.isInterface()) {
				shouldStayAtFalse = true;
			}
		}
	<|file_separator|><nl>
		super.method1(p1);
	<|file_separator|><nl>
		if (element.isInterface()) {
			return;
		}
		if (element.isAnnotation()) {
			return;
		}
		if (element.isEnum()) {
			return;
		}
		if (element.isAnnotationType()) {
			return;
		}
		if (element.isAnnotationType()) {
			return;
		}
		if (element.isAnnotationType()) {
			return;
		}
		if (element.isAnnotationType()) {
			return;
		}
		if (element.isAnnotationType()) {
			return;
		}
		if (element.isAnnotationType()) {
			return;
		}
		if (element.isAnnotationType()) {
			return;
		}
		if (element.isAnnotationType()) {
			return;
		}
		if (element.isAnnotationType()) {
			return;
		}
		if (element.isAnnotationType()) {
			return;
		}
		if (element.isAnnotationType()) {
			return;
		}
		if (element.isAnnotationType()) {
			return;
		}
		if (element.isAnnotationType()) {
			return;
		}
		if (element.isAnnotationType()) {
			return;
		}
		if (element.isAnnotationType()) {
			return;
		}
		if (element.isAnnotationType()) {
			return;
		}
		if (element.isAnnotationType()) {
			return;
		}
		if (element.isAnnotationType()) {
			return;
		}
		if (element.isAnnotationType()) {
			return;
		}
		if (element.is<nl>
		System.out.println("Tortillas");
	<|file_separator|><nl>
		return null;
	<|file_separator|><nl>
		CtType<?> type = build("spoon.test.serializable.testclasses", "Dummy");
		CtCtStatement ct = new CtCtStatement(type);
		byte[] ser = ByteSerialization.serialize(ct);
		CtCtStatement des = (CtCtStatement) ByteSerialization.deserialize(ser);
	<|file_separator|><nl>
		return 1;
	<|file_separator|><nl>
		try {
			element.insertBefore("if (true) {");
			element.insertAfter("}");
		} catch (CannotCompileException e) {
			e.printStackTrace();
		}
	<|file_separator|><nl>
		this.memberField = p_memberField;
	<|file_separator|><nl>
		return memberField;
	<|file_separator|><nl>
		return this;
	}

	private void superMethod() {
	<|file_separator|><nl>
		if (_field_.length < poolSize_) {
			_field_ = new _Type_[_poolSizeIncrement_];
		}
	}

	public void resize__field_2() {
		if (_field_.length < poolSize_) {
			_field_ = new _Type_[_poolSizeIncrement_];
		}
	}

	public void resize__field_3() {
		if (_field_.length < poolSize_) {
			_field_ = new _Type_[_poolSizeIncrement_];
		}
	}

	public void resize__field_4() {
		if (_field_.length < poolSize_) {
			_field_ = new _Type_[_poolSizeIncrement_];
		}
	}

	public void resize__field_5() {
		if (_field_.length < poolSize_) {
			_field_ = new _Type_[_poolSizeIncrement_];
		}
	}

	public void resize__field_6() {
		if (_field_.length < poolSize_) {
			_field_ = new _Type_[_poolSizeIncrement_];
		}
	}

	public void resize__field_7() {
		if (_field_.length < poolSize_) {
			_field_ = new _Type_[_poolSizeIncrement_];
		}
	}

	public void resize__field_8() {
		if (_field_.length < poolSize_) {
			_field_ = new _Type_[_poolSizeIncrement_];
		}
	}

	public void resize__field_9() {
		if (_field_.length < poolSize_) {
			_field_ = new _Type_[_poolSizeIncrement_];
		}
	}

	public void resize__<nl>
		//contract: the template engine supports replace of return expression by `<CtExpression>`
		Launcher launcher = new Launcher();
		launcher.addTemplateResource(new FileSystemFile("./src/test/java/spoon/test/template/testclasses/ReturnReplaceTemplate.java"));

		launcher.buildModel();
		Factory factory = launcher.getFactory();

		CtExpression<String> model = factory.createLiteral("AStringLiteral");
		
		CtClass<?> resultKlass = factory.Class().create(factory.Package().getOrCreate("spoon.test.template"), "ReturnReplaceResult");
		new ReturnReplaceTemplate(model).apply(resultKlass);
		assertEquals("AStringLiteral", getOptimizedString(resultKlass.getMethod("method").getBody()));
		launcher.setSourceOutputDirectory(new File("./target/spooned/"));
		launcher.getModelBuilder().generateProcessedSourceFiles(OutputType.CLASSES);
		ModelUtils.canBeBuilt(new File("./target/spooned/spoon/test/template/ReturnReplaceResult.java"), 8);
	<|file_separator|><nl>
		return exp.get();
	<|file_separator|><nl>
        if (this._asserted_.getValue()) {
            this._asserted_.getStatement().statement();
        }
    <|file_separator|><nl>
        if(!contextHelper.hasPermission("d")) {
            throw new SecurityException();
        }
        bDao.toString();
    <|file_separator|><nl>
		System.err.println("enter: " + className + "." + methodName);
	<|file_separator|><nl>
		int i = 0;
		i++;
		System.out.println(i);
		out.println("Xxxx");
		System.out.println((String) null);
		System.out.println("last one");
	<|file_separator|><nl>
	}

	private void sample5() throws IOException, FileNotFoundException {
	}

	private void sample6() throws IOException, FileNotFoundException {
	}

	private void sample7() throws IOException, FileNotFoundException {
	}

	private void sample8() throws IOException, FileNotFoundException {
	}

	private void sample9() throws IOException, FileNotFoundException {
	}

	private void sample10() throws IOException, FileNotFoundException {
	}

	private void sample11() throws IOException, FileNotFoundException {
	}

	private void sample12() throws IOException, FileNotFoundException {
	}

	private void sample13() throws IOException, FileNotFoundException {
	}

	private void sample14() throws IOException, FileNotFoundException {
	}

	private void sample15() throws IOException, FileNotFoundException {
	}

	private void sample16() throws IOException, FileNotFoundException {
	}

	private void sample17() throws IOException, FileNotFoundException {
	}

	private void sample18() throws IOException, FileNotFoundException {
	}

	private void sample19() throws IOException, FileNotFoundException {
	}

	private void sample20() throws IOException, FileNotFoundException {
	}

	private void sample21() throws IOException, FileNotFoundException {
	}

	private void sample22() throws IOException, FileNotFoundException {
	}

	private void sample23() throws IOException, FileNotFoundException {
	}

	private void sample24() throws IOException, FileNotFoundException {
	}

	private void sample25() throws IOException, FileNotFoundException {
	}
<nl>
		return new ListPrinter(startPrefixSpace, start, startSufficSpace, nextPrefixSpace, next, nextSuffixSpace, endPrefixSpace, end);
	<|file_separator|><nl>
		
		// TODO: implement
	<|file_separator|><nl>
		return 0;
	<|file_separator|><nl>
        try {
            throw new Exception();
        } catch (Exception e) {
            throw new RuntimeException();
        }
    <|file_separator|><nl>
		for (int i = 0; i < s.length; i++) {
			System.out.println(s[i]);
		}
	<|file_separator|><nl>
        for (int i = 0; i < 10; i++) {
            System.out.println("Hello World");
        }
    <|file_separator|><nl>
		System.out.println(s1);
	<|file_separator|><nl>
		tmp.method();
	<|file_separator|>class NonAccessibleClassFromAccessibleInterf implements AccessibleInterf {

	public void method() {
		System.out.println("method");
	}
}<|file_separator|>class NonAccessibleClassFromNonAccessibleInterf implements NonAccessibleInterf {

	public void method() {
		System.out.println("method");
	}
}<|file_separator|>class NonAccessibleClassFromAccessibleInterf implements AccessibleInterf {

	public void method(NonAccessibleInterf tmp) {
		tmp.method();
	}
}<|file_separator|>class AccessibleClassFromAccessibleInterf implements AccessibleInterf {

	public void method() {
		System.out.println("method");
	}
}<|file_separator|><nl>
		return o instanceof C<T>;
	}
}<|file_separator|><nl>
		assertThat(PATH + "Foo.java").withProcessor(FooToBarProcessor.class).isEqualTo(PATH + "Bar.java");
	<|file_separator|><nl>
		if (this.actual.isFailed()) {
			throw new AssertionError(String.format(errorMessage, arguments));
		}
	<|file_separator|>class CtAbstractInvocationAssertInterface.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public interface CtAbstractInvocationAssertInterface<SELF extends CtAbstractInvocationAssertInterface<SELF, ACTUAL>, ACTUAL> extends CtAbstractInvocationAssertInterface<SELF, ACTUAL> {
	SELF self();

	ACTUAL actual();
}<|file_separator|>class CtAbstractInvocationAssertInterface$1.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>class CtAbstractInvocationAssertInterface$1 extends AbstractObjectAssert<CtAbstractInvocationAssertInterface$1, CtAbstractInvocationAssertInterface<?>> implements CtAbstractInvocationAssertInterface<CtAbstractInvocationAssertInterface$1, CtAbstractInvocationAssertInterface<?>> {
	CtAbstractInvocationAssertInterface$1(CtAbstractInvocationAssertInterface<?> actual) {
		super(actual, CtAbstractInvocationAssertInterface$1.class);
	}

	@Override
	public CtAbstractInvocationAssertInterface$1 self() {
		return this;
	}

	@Override
	public CtAbstractInvocationAssertInterface<?> actual() {
		return this.actual;
	}

	@Override
	public void failWithMessage(String errorMessage, Object... arguments) {
		if (this.actual.isFailed()) {
			throw new AssertionError(String.format(errorMessage, arguments));
		}
	}
}<|file_separator|><nl>
		throw new AssertionError(String.format(errorMessage, arguments));
	<|file_separator|>class CtArrayReadAssertInterface.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public interface CtArrayReadAssertInterface<SELF extends CtArrayReadAssertInterface<SELF, ACTUAL>, ACTUAL> extends AbstractObjectAssertInterface<SELF, ACTUAL> {
	SELF self();
	ACTUAL actual();
}<|file_separator|><nl>
		return this.actual;
	}

	@Override
	public void fail() {
		super.fail();
	}

	@Override
	public void failWithMessage(String errorMessage) {
		super.failWithMessage(errorMessage);
	<|file_separator|>class CtCFlowBreakAssertInterface.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public interface CtCFlowBreakAssertInterface<SELF extends CtCFlowBreakAssertInterface<SELF, ACTUAL>, ACTUAL extends CtCFlowBreak> extends AbstractObjectAssertInterface<SELF, ACTUAL> {
	SELF self();
	ACTUAL actual();
}<|file_separator|><nl>
		return (CtCase<?>) super.actual();
	}

	@Override
	public void fail() {
		super.fail();
	}

	@Override
	public void failWithMessage(String errorMessage) {
		super.failWithMessage(errorMessage);
	<|file_separator|>class CtCaseAssertInterface.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public interface CtCaseAssertInterface<SELF extends CtCaseAssertInterface<SELF, ACTUAL>, ACTUAL> extends AbstractObjectAssertInterface<SELF, ACTUAL> {
	SELF self();
	ACTUAL actual();
	void fail();
	void failWithMessage(String errorMessage);
	void failWithMessage(String errorMessage, Object... arguments);
}<|file_separator|><nl>
		return (CtCatchVariable<?>) super.actual();
	}

	@Override
	public void fail() {
		super.fail();
	}

	@Override
	public void failWithMessage(String errorMessage) {
		super.failWithMessage(errorMessage);
	<|file_separator|>class CtCatchVariableAssertInterface.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public interface CtCatchVariableAssertInterface<SELF extends CtCatchVariableAssertInterface<SELF, ACTUAL>, ACTUAL> extends AbstractObjectAssertInterface<SELF, ACTUAL> {
	SELF self();
}<|file_separator|><nl>
		return this.actual;
	}

	@Override
	public CtCodeElementAssert is() {
		return this;
	}

	@Override
	public CtCodeElementAssert is(CtCodeElement expected) {
		return this;
	}

	@Override
	public CtCodeElementAssert isNot() {
		return this;
	}

	@Override
	public CtCodeElementAssert isNot(CtCodeElement expected) {
		return this;
	}

	@Override
	public void fail() {
		super.fail();
	<|file_separator|>class CtCodeElementAssertInterface.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public interface CtCodeElementAssertInterface<SELF extends CtCodeElementAssertInterface<SELF, ACTUAL>, ACTUAL extends CtCodeElement> extends AbstractObjectAssertInterface<SELF, ACTUAL> {
	SELF is();

	SELF is(CtCodeElement expected);

	SELF isNot();

	SELF isNot(CtCodeElement expected);
}<|file_separator|><nl>
		if (this.actual == null) {
			throw new AssertionError(String.format(errorMessage, arguments));
		}
	<|file_separator|>class CtClassAssert.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>import java.util.List;

public class CtClassAssert extends AbstractObjectAssert<CtClassAssert, CtClass> implements CtClassAssertInterface<CtClassAssert, CtClass> {
	CtClassAssert(CtClass actual) {
		super(actual, CtClassAssert.class);
	}

	@Override
	public CtClassAssert self() {
		return this;
	}

	@Override
	public CtClass actual() {
		return this.actual;
	}

	@Override
	public void failWithMessage(String errorMessage, Object... arguments) {
		if (this.actual == null) {
			throw new AssertionError(String.format(errorMessage, arguments));
		}
	}
}<|file_separator|>class CtClassAssertInterface.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public interface CtClassAssertInterface<SELF extends CtClassAssertInterface<SELF, ACTUAL>, ACTUAL extends CtClass> extends AbstractObjectAssertInterface<SELF, ACTUAL> {
	SELF self();
	ACTUAL actual();
}<|file_separator|>class CtClassAssertFactory.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class CtClassAssertFactory extends AbstractObjectAssertFactory<CtClassAssertFactory, CtClassAssert, CtClass> {
	public CtClassAssertFactory() {
		super(CtClassAssert.class);
	}
}<|file_separator|>class CtCompilationUnitAssertFactory.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class CtCompilationUnitAssertFactory extends AbstractObjectAssertFactory<CtCompilationUnitAssertFactory, CtCompilationUnitAssert, CtCompilationUnit> {
	public CtCompilationUnitAssertFactory() {
		super(CtCompilationUnitAssert.class);
	}
}<|file_separator|>class CtClassAssertFactoryInterface.java
<|fim_prefix|><nl>
		super.failWithMessage(errorMessage, arguments);
	<|file_separator|>class CtImportAssertInterface.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public interface CtImportAssertInterface<SELF extends CtImportAssertInterface<SELF, ACTUAL>, ACTUAL extends CtImport> extends CtAssertInterface<SELF, ACTUAL> {
	SELF self();
	ACTUAL actual();
}<|file_separator|><nl>
		return getActual();
	}

	@Override
	public void fail() {
		super.fail();
	}

	@Override
	public void failWithMessage(String errorMessage) {
		super.failWithMessage(errorMessage);
	<|file_separator|><nl>
		throw new AssertionError(String.format(errorMessage, arguments));
	<|file_separator|>class CtOperatorAssignmentAssertInterface.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public interface CtOperatorAssignmentAssertInterface<SELF extends CtOperatorAssignmentAssertInterface<SELF, ACTUAL>, ACTUAL> extends CtAssertInterface<SELF, ACTUAL> {
	SELF self();
	ACTUAL actual();
}<|file_separator|><nl>
		throw new CtParameterReferenceAssertException(this.actual, errorMessage, arguments);
	<|file_separator|>class CtParameterReferenceAssertException.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class CtParameterReferenceAssertException extends CtParameterReferenceException {
	public CtParameterReferenceAssertException(CtParameterReference<?> actual, String errorMessage, Object... arguments) {
		super(actual, errorMessage, arguments);
	}
}<|file_separator|>class CtParameterReferenceAssertInterface.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public interface CtParameterReferenceAssertInterface<SELF extends CtParameterReferenceAssertInterface<SELF, ACTUAL>, ACTUAL extends CtParameterReference<?>> {
	SELF self();

	ACTUAL actual();
}<|file_separator|>class CtParameterReferenceException.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class CtParameterReferenceException extends CtParameterReferenceExceptionBase {
	public CtParameterReferenceException(CtParameterReference<?> actual, String errorMessage, Object... arguments) {
		super(actual, errorMessage, arguments);
	}
}<|file_separator|>class CtParameterReferenceExceptionBase.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class CtParameterReferenceExceptionBase extends CtParameterReferenceExceptionBase {
	public CtParameterReferenceExceptionBase(CtParameterReference<?> actual, String errorMessage, Object... arguments) {
		super(actual, errorMessage, arguments);
	}
}<|file_separator|><nl>
		throw new AssertionError(String.format(errorMessage, arguments));
	<|file_separator|><nl>
		if (this.actual == null) {
			throw new AssertionError(String.format(errorMessage, arguments));
		}
	<|file_separator|>class CtRHSReceiverAssertInterface.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public interface CtRHSReceiverAssertInterface<SELF extends CtRHSReceiverAssertInterface<SELF, ACTUAL>, ACTUAL> extends AbstractObjectAssertInterface<SELF, ACTUAL> {
	SELF self();
}<|file_separator|><nl>
		throw new AssertionError(String.format(errorMessage, arguments));
	<|file_separator|>class CtReceiverParameterAssertInterface.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public interface CtReceiverParameterAssertInterface<SELF extends CtReceiverParameterAssertInterface<SELF, ACTUAL>, ACTUAL> extends AbstractObjectAssertInterface<SELF, ACTUAL> {
	SELF self();
}<|file_separator|><nl>
		return (CtReturn<?>) super.actual();
	}

	@Override
	public void fail() {
		super.fail();
	}

	@Override
	public void failWithMessage(String errorMessage) {
		super.failWithMessage(errorMessage);
	<|file_separator|><nl>
		throw new AssertionError(String.format(errorMessage, arguments));
	<|file_separator|>class CtSuperAccessAssertInterface.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public interface CtSuperAccessAssertInterface<SELF extends CtSuperAccessAssertInterface<SELF, ACTUAL>, ACTUAL> extends AbstractObjectAssertInterface<SELF, ACTUAL> {
	SELF self();
}<|file_separator|><nl>
		return (CtTypeAccess<?>) super.actual();
	}

	@Override
	public void fail() {
		super.fail();
	}

	@Override
	public void failWithMessage(String errorMessage) {
		super.failWithMessage(errorMessage);
	<|file_separator|>class CtTypeAccessAssertInterface.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public interface CtTypeAccessAssertInterface<SELF extends CtTypeAccessAssertInterface<SELF, ACTUAL>, ACTUAL> extends AbstractObjectAssertInterface<SELF, ACTUAL> {
	SELF self();
	ACTUAL actual();
}<|file_separator|><nl>
		return this;
	<|file_separator|>class CtTypeMemberAssertInterface.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public interface CtTypeMemberAssertInterface<SELF extends CtTypeMemberAssertInterface<SELF, ACTUAL>, ACTUAL extends CtTypeMember> extends AbstractObjectAssertInterface<SELF, ACTUAL> {
	SELF self();
	ACTUAL actual();
}<|file_separator|><nl>
		throw new AssertionError(String.format(errorMessage, arguments));
	<|file_separator|>class CtUnboundVariableReferenceAssertInterface.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public interface CtUnboundVariableReferenceAssertInterface<SELF extends CtUnboundVariableReferenceAssertInterface<SELF, ACTUAL>, ACTUAL> extends CtUnboundVariableReferenceAssertInterface<SELF, ACTUAL> {
	SELF self();
	ACTUAL actual();
}<|file_separator|>class CtUnboundVariableReferenceAssertInterface$1.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>class CtUnboundVariableReferenceAssertInterface$1 extends AbstractObjectAssert<CtUnboundVariableReferenceAssertInterface$1, CtUnboundVariableReferenceAssertInterface<?>> implements CtUnboundVariableReferenceAssertInterface<CtUnboundVariableReferenceAssertInterface$1, CtUnboundVariableReferenceAssertInterface<?>> {
	CtUnboundVariableReferenceAssertInterface$1(CtUnboundVariableReferenceAssertInterface<?> actual) {
		super(actual, CtUnboundVariableReferenceAssertInterface$1.class);
	}

	@Override
	public CtUnboundVariableReferenceAssertInterface$1 self() {
		return this;
	}

	@Override
	public CtUnboundVariableReferenceAssertInterface<?> actual() {
		return this.actual;
	}

	@Override
	public void failWithMessage(String errorMessage, Object... arguments) {
		throw new AssertionError(String.format(errorMessage, arguments));
	}
}<|file_separator|><nl>
		return item.containsAll(elements);
	<|file_separator|><nl>
			System.out.println("Hello World");
		<|file_separator|><nl>
		return x + y;
	<|file_separator|><nl>
        Derived d = new Derived();
        d.print();
    <|file_separator|><nl>
            System.out.println("Hello World");
        <|file_separator|><nl>
		// do something
	<|file_separator|><nl>
        int i = 10;
        int j = 20;
        int k = 30;
        int l = 40;
        int m = 50;
        int n = 60;
        int o = 70;
        int p = 80;
        int q = 90;
        int r = 100;
        int s = 110;
        int t = 120;
        int u = 130;
        int v = 140;
        int w = 150;
        int x = 160;
        int y = 170;
        int z = 180;
        int a = 190;
        int b = 200;
        int c = 210;
        int d = 220;
        int e = 230;
        int f = 240;
        int g = 250;
        int h = 260;
        int i = 270;
        int j = 280;
        int k = 290;
        int l = 300;
        int m = 310;
        int n = 320;
        int o = 330;
        int p = 340;
        int q = 350;
        int r = 360;
        int s = 370;
        int t = 380;
        int u = 390;
        int v = 400;
        int w = 410<nl>
		// do something
	<|file_separator|><nl>
        fieldF.toString();
        super.f.toString();
        //:: error: (dereference.of.nullable)
        this.f.toString();
    <|file_separator|>class Initializer.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>class Initializer {

    String f = "";

    void init1(@UnknownInitialization(Initializer.class) @Raw Initializer this) {
        fieldF.toString();
        super.f.toString();
        //:: error: (dereference.of.nullable)
        this.f.toString();
    }

    void init2(@UnknownInitialization @Raw Initializer this) {
        fieldF.toString();
        super.f.toString();
        //:: error: (dereference.of.nullable)
        this.f.toString();
    }
}<|file_separator|><nl>
        return this.entre;
    <|file_separator|><nl>
        super.readFrom(in);
        this.shardId = ShardId.readFrom(in);
    <|file_separator|><nl>
		return "This method overrides NotInClasspath#toString";
	<|file_separator|><nl>
		return null;
	}

	public IssueStatus getIssueStatus() {
		return null;
	<|file_separator|><nl>
	<|file_separator|><nl>
        System.out.println("Hello World!");
    <|file_separator|><nl>
        System.out.println(this);
    <|file_separator|><nl>
		// Enum from interface
		// Enum from interface
		// Enum from interface
		// Enum from interface
		// Enum from interface
		// Enum from interface
		// Enum from interface
		// Enum from interface
		// Enum from interface
		// Enum from interface
		// Enum from interface
		// Enum from interface
		// Enum from interface
		// Enum from interface
		// Enum from interface
		// Enum from interface
		// Enum from interface
		// Enum from interface
		// Enum from interface
		// Enum from interface
		// Enum from interface
		// Enum from interface
		// Enum from interface
		// Enum from interface
		// Enum from interface
		// Enum from interface
		// Enum from interface
		// Enum from interface
		// Enum from interface
		// Enum from interface
		// Enum from interface
		// Enum from interface
		// Enum from interface
		// Enum from interface
		// Enum from interface
		// Enum from interface
		// Enum from interface
		// Enum from interface
		// Enum from interface
		// Enum from interface
		// Enum from interface
		// Enum from interface
		// Enum from interface
		// Enum from interface
		// Enum from interface
		// Enum from interface
		// Enum from interface
		// Enum from interface
		// Enum from interface
		// Enum from interface
		// Enum from interface
		// Enum from interface
		// Enum from interface
		// Enum from interface
		// Enum from interface
		// Enum from interface
		// Enum from interface
		// Enum from interface
		// Enum from interface
		// Enum from interface
		// Enum from interface
		// Enum from interface
		// Enum from interface
		// Enum from interface
		// Enum from interface
		// Enum from interface
		// Enum<nl>
		return delegate.ID;
	<|file_separator|><nl>
        System.out.println("Printing once");
    <|file_separator|><nl>
        System.out.println("static method");
    <|file_separator|><nl>
        return new TestSuite("LangTestSuite");
    <|file_separator|><nl>
        return new EnumTestSuite();
    <|file_separator|><nl>
		System.out.println("Hello, " + name);
	<|file_separator|><nl>
        System.out.println("bar");
    <|file_separator|><nl>
        return name;
    }

    public void setName(String name) {
        this.name = name;
    <|file_separator|><nl>
        return s2i(props.getProperty(name)).orElse(0);
    <|file_separator|><nl>
        execute("Find Best Price", bestPriceFinder::findBestPrice);
    <|file_separator|><nl>
        return price * (100 - code.percentage) / 100;
    <|file_separator|><nl>
        return type;
    <|file_separator|><nl>
        System.out.println("Hello World");
    <|file_separator|><nl>
        Map<Currency, List<Transaction>> transactionsByCurrencies = new HashMap<>();
        for (Transaction transaction : transactions) {
            List<Transaction> transactionsForCurrency = transactionsByCurrencies.get(transaction.getCurrency());
            if (transactionsForCurrency == null) {
                transactionsForCurrency = new ArrayList<>();
            }
            transactionsForCurrency.add(transaction);
            transactionsByCurrencies.put(transaction.getCurrency(), transactionsForCurrency);
        }
        System.out.println(transactionsByCurrencies);
    <|file_separator|><nl>
        return (list1, list2) -> {
            list1.addAll(list2);
            return list1;
        };
    <|file_separator|><nl>
        ProcessingObject<String> chain = new HeaderTextProcessing();
        chain.setSuccessor(new SpellCheckerProcessing());
        String result = chain.handle("labda is a keyword");
        System.out.println(result);
    <|file_separator|><nl>
        return statusCode;
    <|file_separator|><nl>
        log("Hello, world!");
    <|file_separator|><nl>
        if (auth == null) {
            return null;
        }
        if (attemptCount++ > MaxAttempts) {
            return null;
        }
        return auth.getPasswordAuthentication();
    }

    /**
     * @return true if this handler is enabled.
     */
    boolean isEnabled() {
        return auth != null;
    }

    /**
     * @return true if this handler is enabled and the credentials are valid.
     */
    boolean isValid() {
        return auth != null && auth.isValid();
    }

    /**
     * @return true if this handler is enabled and the credentials are valid.
     */
    boolean isInvalid() {
        return !isValid();
    <|file_separator|><nl>
        <|file_separator|><nl>
        name = name.trim();
        if (!preserveAttributeCase)
            name = lowerCase(name);
        return name;
    <|file_separator|><nl>
        return stripCRs.matcher(text).replaceAll("");
    <|file_separator|><nl>
        long startTime = System.currentTimeMillis();
        long completeBy = startTime + timeout * 1000L;

        for (int i = 0; i < numIters; i++) {
            Document doc = Jsoup.parse(file, "UTF-8", "https://example.com/", Parser.htmlParser());
            assertNotNull(doc);
            if (System.currentTimeMillis() > completeBy)
                Assertions.fail(String.format("Timeout: only completed %d iters of [%s] in %d seconds", i, file.getName(), timeout));
        }
    <|file_separator|><nl>
        res.setContentType("text/plain");
        res.getWriter().println("Hello, world");
    <|file_separator|><nl>
        final Node node = new Node();
        assertFalse(hasAnyAttributes(node));
    <|file_separator|><nl>
        Locale.setDefault(locale);

        ParseSettings parseSettings = new ParseSettings(false, false);
        assertEquals(locale, parseSettings.getLocale());
    <|file_separator|><nl>
        return new Description("Plain SQL");
    <|file_separator|><nl>
        return delegate.getJavaSetterOverride(definition, mode);
    <|file_separator|><nl>
        return Arrays.asList(
            FlywayTest.FLYWAY_TEST
        );
    <|file_separator|><nl>
        return (String) get(2);
    }

    /**
     * Setter for <code>FLYWAY_TEST.BOOK.ISBN</code>.
     */
    public void setIsbn(String value) {
        set(3, value);
    }

    /**
     * Getter for <code>FLYWAY_TEST.BOOK.ISBN</code>.
     */
    public String getIsbn() {
        return (String) get(3);
    }

    /**
     * Setter for <code>FLYWAY_TEST.BOOK.PUBLISHER_ID</code>.
     */
    public void setPublisherId(Integer value) {
        set(4, value);
    }

    /**
     * Getter for <code>FLYWAY_TEST.BOOK.PUBLISHER_ID</code>.
     */
    public Integer getPublisherId() {
        return (Integer) get(4);
    }

    /**
     * Setter for <code>FLYWAY_TEST.BOOK.PUBLISH_DATE</code>.
     */
    public void setPublishDate(Date value) {
        set(5, value);
    }

    /**
     * Getter for <code>FLYWAY_TEST.BOOK.PUBLISH_DATE</code>.
     */
    public Date getPublishDate() {
        return (Date) get(5);
    }

    /**
     * Setter for <code>FLYWAY_TEST.BOOK.PRICE</code>.
     */
    public void setPrice(Double value) {
        set(6, value);
    }

    /**
     * Getter for <code>FLYWAY_TEST.BOOK.PRICE</code>.
     */
    public Double getPrice() {
        return (Double) get(6);
    }

    /**
     * Setter for <code>FLYWAY_TEST.BOOK.DESCRIPTION</code><nl>
        return new FilmActor(name.getQualifiedName(), null);
    }
}<|file_separator|><nl>
        setValue(P_EFFECTIVE_DATE, value);
    <|file_separator|><nl>
        setField(P_INVENTORY_ID, value);
    <|file_separator|>class Inventory.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>class Inventory extends AbstractRoutine<Integer> {

    private static final long serialVersionUID = 1L;

    /**
     * The parameter
     * <code>public.inventory.RETURN_VALUE</code>.
     */
    public static final Parameter<Integer> RETURN_VALUE = Internal.createParameter("RETURN_VALUE", SQLDataType.INTEGER, false, false);

    /**
     * The parameter
     * <code>public.inventory.p_inventory_id</code>.
     */
    public static final Parameter<Integer> P_INVENTORY_ID = Internal.createParameter("p_inventory_id", SQLDataType.INTEGER, false, false);

    /**
     * Create a new routine call instance
     */
    public Inventory() {
        super("inventory", Public.PUBLIC, SQLDataType.INTEGER);

        setReturnParameter(RETURN_VALUE);
        addInParameter(P_INVENTORY_ID);
    }

    /**
     * Set the <code>p_inventory_id</code> parameter IN value to the routine
     */
    public void setPInventoryId(Integer value) {
        setField(P_INVENTORY_ID, value);
    }

    /**
     * Set the <code>p_inventory_id</code> parameter to the function to be used
     * with a {@link org.jooq.Select} statement
     */
    public void setPInventoryId(Field<Integer> field) {
        setField(P_INVENTORY_ID, field);
    }
}<|file_separator|>class InventoryId.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>class InventoryId extends AbstractRoutine<Integer> {

    private static final long serialVersionUID = 1L;

    /**
     * The parameter
     * <nl>
        setField(_2, field);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public _GroupConcat createContext(Context context) {
        return new _GroupConcatContext(context, this);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public String getCommandName() {
        return "group_concat";
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public _GroupConcat setParameters(ParameterSet parameters) {
        return (this);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public _GroupConcat setParameters(Map<String, ? extends Field<?>> fields) {
        return (this);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public _GroupConcat setParameters(Map<String, ? extends Field<?>> fields, Map<String, ? extends Field<?>> with) {
        return (this);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public _GroupConcat setParameters(Map<String, ? extends Field<?>> fields, Map<String, ? extends Field<?>> with, Map<String, ? extends Field<?>> without) {
        return (this);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public _GroupConcat setParameters(Map<String, ? extends Field<?>> fields, Map<String, ? extends Field<?>> with, Map<String, ? extends Field<?>> without, Map<String, ? extends Field<?>> having) {
        return (this);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public _GroupConcat setParameters(Map<String, ?<nl>
        return where(DSL.condition(condition, binds));
    }
}<|file_separator|><nl>
        return Arrays.asList(References.FILM_ACTOR_FILM_ID);
    }

    @Override
    public List<UniqueKey<FilmActorRecord>> getUniqueKeys() {
        return Arrays.asList(Keys.FILM_ACTOR_PKEY);
    }

    @Override
    public List<ForeignKey<FilmActorRecord, ?>> getForeignKeys() {
        return Arrays.asList(References.FILM_ACTOR_FILM_ID);
    }

    @Override
    public List<Index> getIndexes() {
        return Arrays.asList(Indexes.IDX_FK_FILM_ID);
    }<|file_separator|><nl>
        return new PaymentP2007_06(alias.getQualifiedName(), this);
    }
<|file_separator|><nl>
        return (String) get(1);
    <|file_separator|><nl>
		return new DefaultConfigurationCustomizer();
	<|file_separator|><nl>
		// All of these tables were generated by jOOQ's Maven plugin
		Book b = BOOK.as("b");
		Author a = AUTHOR.as("a");
		BookStore s = BOOK_STORE.as("s");
		BookToBookStore t = BOOK_TO_BOOK_STORE.as("t");

		Result<Record3<String, String, Integer>> result = create.select(a.FIRST_NAME, a.LAST_NAME, countDistinct(s.NAME))
				.from(a).join(b).on(b.AUTHOR_ID.equal(a.ID)).join(t).on(t.BOOK_ID.equal(b.ID)).join(s)
				.on(t.BOOK_STORE_NAME.equal(s.NAME)).groupBy(a.FIRST_NAME, a.LAST_NAME).orderBy(countDistinct(s.NAME).desc())
				.fetch();

		assertEquals(2, result.size());
		assertEquals("Paulo", result.getValue(0, a.FIRST_NAME));
		assertEquals("John", result.getValue(1, a.FIRST_NAME));

		assertEquals("Coelho", result.getValue(0, a.LAST_NAME));
		assertEquals("Orwell", result.getValue(1, a.LAST_NAME));

		assertEquals(Integer.valueOf(3), result.getValue(0, countDistinct(s.NAME)));
		assertEquals(Integer.valueOf(2), result.getValue(1, countDistinct(s.NAME)));
	<|file_separator|><nl>
        return this.getAliasedSchema();
    }

    @Override
    public CityPath getAliasedSchema() {
        return new CityPath(this.getQualifiedName(), this);
    }<|file_separator|><nl>
        return Arrays.asList(Keys.RENTAL_FK_INVENTORY_ID, Keys.RENTAL_FK_CUSTOMER_ID);
    }

    @Override
    public List<UniqueKey<RentalRecord>> getUniqueKeys() {
        return Arrays.asList(Keys.RENTAL_UNQ_RENTAL_RENTAL_DATE_INVENTORY_ID_CUSTOMER_ID);
    }

    @Override
    public List<ForeignKey<RentalRecord, ?>> getForeignKeys() {
        return Arrays.asList(Keys.RENTAL_FK_INVENTORY_ID, Keys.RENTAL_FK_CUSTOMER_ID);
    }<|file_separator|><nl>
        return new SalesByFilmCategory(alias.getQualifiedName(), this);
    <|file_separator|><nl>
        return (LocalDateTime) get(2);
    <|file_separator|><nl>
        return (LocalDateTime) get(3);
    <|file_separator|><nl>
        return new Record2<>(getFilmId(), getCategoryId());
    <|file_separator|><nl>
        set(5, value);
    <|file_separator|>class PaymentP2007_01.java
<|fim_prefix|><|fim_suffix|>
    public static final String PAYMENT_ID = "payment_id";

    /**
     * Column <code>public.payment_p2007_01.customer_id</code>.
     */
    public static final String CUSTOMER_ID = "customer_id";

    /**
     * Column <code>public.payment_p2007_01.staff_id</code>.
     */
    public static final String STAFF_ID = "staff_id";

    /**
     * Column <code>public.payment_p2007_01.rental_id</code>.
     */
    public static final String RENTAL_ID = "rental_id";

    /**
     * Column <code>public.payment_p2007_01.amount</code>.
     */
    public static final String AMOUNT = "amount";

    /**
     * Column <code>public.payment_p2007_01.payment_date</code>.
     */
    public static final String PAYMENT_DATE = "payment_date";

    // -------------------------------------------------------------------------
    // Constructors
    // -------------------------------------------------------------------------

    /**
     * Create a new PaymentP2007_01 record
     */
    public PaymentP2007_01() {
        super(PaymentP2007_01.class);
    }

    /**
     * Create a new PaymentP2007_01 record
     */
    public PaymentP2007_01(TableRecordImpl<PaymentP2007_01Record> record) {
        super(record);
    }<nl>
        return (Long) get(0);
    <|file_separator|><nl>
        set(3, value);
    <|file_separator|>class PaymentP2007_03.java
<|fim_prefix|><|fim_suffix|>
    public static final String PAYMENT_ID = "payment_id";

    /**
     * Column <code>public.payment_p2007_03.customer_id</code>.
     */
    public static final String CUSTOMER_ID = "customer_id";

    /**
     * Column <code>public.payment_p2007_03.staff_id</code>.
     */
    public static final String STAFF_ID = "staff_id";

    /**
     * Column <code>public.payment_p2007_03.rental_id</code>.
     */
    public static final String RENTAL_ID = "rental_id";

    /**
     * Column <code>public.payment_p2007_03.amount</code>.
     */
    public static final String AMOUNT = "amount";

    /**
     * Column <code>public.payment_p2007_03.payment_date</code>.
     */
    public static final String PAYMENT_DATE = "payment_date";

    // -------------------------------------------------------------------------
    // Constructors
    // -------------------------------------------------------------------------

    /**
     * Create a new PaymentP2007_03 record.
     */
    public PaymentP2007_03() {
        super(PaymentP2007_03.class);
    }

    /**
     * Create a new PaymentP2007_03 record.
     */
    public PaymentP2007_03(PaymentP2007_03Record record) {
        super(PaymentP2007_0<nl>
        set(5, value);
    <|file_separator|><nl>
        set(1, value);
    <|file_separator|><nl>
        if (_staff == null)
            _staff = new StaffPath(this, Keys.PAYMENT_P2007_01__PAYMENT_P2007_01_STAFF_ID_FKEY, null);

        return _staff;
    }
<|file_separator|><nl>
            return new PaymentP2007_05Path(alias.getQualifiedName(), this);
        <|file_separator|><nl>
        if (_customer == null)
            _customer = new CustomerPath(this, Keys.STORE__STORE_CUSTOMER_ID_FKEY, null);

        return _customer;
    }
<|file_separator|><nl>
        set(4, value);
    <|file_separator|>class PaymentP2007_04.java
<|fim_prefix|><|fim_suffix|>
    public static final String PAYMENT_ID = "payment_id";

    /**
     * Column <code>public.payment_p2007_04.customer_id</code>.
     */
    public static final String CUSTOMER_ID = "customer_id";

    /**
     * Column <code>public.payment_p2007_04.staff_id</code>.
     */
    public static final String STAFF_ID = "staff_id";

    /**
     * Column <code>public.payment_p2007_04.rental_id</code>.
     */
    public static final String RENTAL_ID = "rental_id";

    /**
     * Column <code>public.payment_p2007_04.amount</code>.
     */
    public static final String AMOUNT = "amount";

    /**
     * Column <code>public.payment_p2007_04.payment_date</code>.
     */
    public static final String PAYMENT_DATE = "payment_date";

    // -------------------------------------------------------------------------
    // Constructors
    // -------------------------------------------------------------------------

    /**
     * Create a new PaymentP2007_04 record.
     */
    public PaymentP2007_04() {
        super(PaymentP2007_04.PAYMENT_P2007_04);
    }

    /**
     * Create a new PaymentP2007_04 record.
     */
    public PaymentP2007_04(Long paymentId, Long customerId, Long staffId, Long rentalId, BigDecimal<nl>
        return (BigDecimal) get(1);
    <|file_separator|><nl>
        set(3, value);
    <|file_separator|><nl>
        return JSONB.valueOf(string);
    <|file_separator|><nl>
        return json.toString();
    <|file_separator|><nl>
        if (indexColumns == null) {
            indexColumns = getIndexColumns0();
        }
        return indexColumns;
    <|file_separator|><nl>
        return Class.forName(className);
    <|file_separator|><nl>
        return Collections.singletonList(this);
    <|file_separator|>class AbstractTypedElementDefinition
extends AbstractTypedElementDefinition<SchemaDefinition>
implements TypedElementDefinition {

    private final String name;
    private final int position;
    private final DataTypeDefinition baseType;
    private final String description;

    public AbstractTypedElementDefinition(SchemaDefinition schema, String name, int position, DataTypeDefinition baseType, String description) {
        super(schema, name, position, baseType, description);

        this.name = name;
        this.position = position;
        this.baseType = baseType;
        this.description = description;
    }

    @Override
    public String getName() {
        return name;
    }

    @Override
    public int getPosition() {
        return position;
    }

    @Override
    public DataTypeDefinition getBaseType() {
        return baseType;
    }

    @Override
    public String getDescription() {
        return description;
    }
}<|file_separator|>class AbstractTypedElementDefinition
extends AbstractTypedElementDefinition<SchemaDefinition>
implements TypedElementDefinition {

    private final String name;
    private final int position;
    private final DataTypeDefinition baseType;
    private final String description;

    public AbstractTypedElementDefinition(SchemaDefinition schema, String name, int position, DataTypeDefinition baseType, String description) {
        super(schema, name, position, baseType, description);

        this.name = name;
        this.position = position;
        this.baseType = baseType;
        this.description = description;
    }

    @Override
    public String getName() {
        return name;
    }

    @Override
    public int getPosition() {
        return position;
    }

    @Override
    public<nl>
        return getTableDefinition();
    }

    @Override
    public final TableDefinition getTableDefinition() {
        return new TableDefinition(getColumn().getDatabase(), getColumn().getSchema(), getColumn().getName());
    <|file_separator|><nl>
        return isSynthetic;
    <|file_separator|>class AbstractTypedElementDefinition
    extends AbstractTypedElementDefinition<AbstractTypedElement> {

    private final String comment;
    private final String overload;

    public AbstractTypedElementDefinition(AbstractTypedElement parent, String name, int position, DataTypeDefinition type, String comment, String overload) {
        super(parent, name, position, type);

        this.comment = comment;
        this.overload = overload;
    }

    @Override
    public String getComment() {
        return comment;
    }

    @Override
    public String getOverload() {
        return overload;
    }
}<|file_separator|>class AbstractTypedElement
    extends AbstractElement {

    private final DataTypeDefinition type;

    public AbstractTypedElement(AbstractElement parent, String name, int position, DataTypeDefinition type) {
        super(parent, name, position);

        this.type = type;
    }

    @Override
    public DataTypeDefinition getType() {
        return type;
    }
}<|file_separator|>class AbstractElement
    extends Element {

    public AbstractElement(Element parent, String name, int position) {
        super(parent, name, position);
    }
}<|file_separator|>class AbstractTypedElementDefinition
    extends AbstractTypedElementDefinition<AbstractTypedElement> {

    private final String comment;
    private final String overload;

    public AbstractTypedElementDefinition(AbstractTypedElement parent, String name, int position, DataTypeDefinition type, String comment, String overload) {
        super(parent, name, position, type);

        this.comment = comment;
        this.overload = overload;
    }

    @Override
    public String getComment() {
        return comment;
    }

    @Override
    public String getOverload() {
        return overload<nl>
        return startWith;
    <|file_separator|><nl>
        return patterns.computeIfAbsent(regex, Pattern::compile);
    }

    public final Pattern pattern(String regex, List<RegexFlag> regexFlags) {
        return pattern(regex).flags(regexFlags);
    <|file_separator|><nl>
        return Record.class;
    }

    /**
     * The table <code>system.data_skipping_indices</code>
     */
    public static final DataSkippingIndices SYSTEM_DATA_SKIPPING_INDICES = new DataSkippingIndices();

    /**
     * The table <code>system.data_skipping_indices</code>
     */
    public static final Table<Record> SYSTEM = SYSTEM_DATA_SKIPPING_INDICES;

    /**
     * The column <code>system.data_skipping_indices.id</code>.
     */
    public final TableField<Record, ULong> ID = createField(DSL.name("id"), SQLDataType.BIGINTUNSIGNED.nullable(false), this, "");

    /**
     * The column <code>system.data_skipping_indices.catalog</code>.
     */
    public final TableField<Record, String> CATALOG = createField(DSL.name("catalog"), SQLDataType.VARCHAR.nullable(false), this, "");

    /**
     * The column <code>system.data_skipping_indices.schema</code>.
     */
    public final TableField<Record, String> SCHEMA = createField(DSL.name("schema"), SQLDataType.VARCHAR.nullable(false), this, "");

    /**
     * The column <code>system.data_skipping_indices.table_type</code>.
     */
    public final TableField<Record, String> TABLE_TYPE = createField(DSL.name("table_type"), SQLDataType.VARCHAR.nullable(false), this, "");

    /**
     * The column <code>system.data_skipping_indices.table_type_full</code>.
     */
    public final TableField<Record, String> TABLE_TYPE_FULL = createField(DSL.name("table<nl>
		return new java.util.ArrayList();
	<|file_separator|><nl>
		return null;
	<|file_separator|><nl>
        return routine.getColumns();
    <|file_separator|>class FirebirdRoutineDefinition.java
<|fim_prefix|><|fim_suffix|>

    public List<ParameterDefinition> getInParameters() {
        return inParameters;
    }

    public List<ParameterDefinition> getOutParameters() {
        return outParameters;
    }

    public List<ParameterDefinition> getInOutParameters() {
        return inOutParameters;
    }

    public List<ColumnDefinition> getColumns() {
        return columns;
    }
}<|fim_middle|>import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

public class FirebirdRoutineDefinition {

    private final SchemaDefinition schema;
    private final String name;
    private final List<ParameterDefinition> inParameters = new ArrayList<>();
    private final List<ParameterDefinition> outParameters = new ArrayList<>();
    private final List<ParameterDefinition> inOutParameters = new ArrayList<>();
    private final List<ColumnDefinition> columns = new ArrayList<>();

    public FirebirdRoutineDefinition(SchemaDefinition schema, String name) {
        this.schema = schema;
        this.name = name;
    }

    public void addParameter(ParameterDefinition parameter) {
        if (parameter.isInput()) {
            inParameters.add(parameter);
        } else if (parameter.isOutput()) {
            outParameters.add(parameter);
        } else {
            inOutParameters.add(parameter);
        }
    }

    public void addColumn(ColumnDefinition column) {
        columns.add(column);
    }

    public String getName() {
        return name;
    }<|file_separator|>class FirebirdTableDefinition.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

public<nl>
        return getTable().getSchema();
    <|file_separator|>class TableImpl.java
<|fim_prefix|><|fim_suffix|>
    public static <T extends Record> TableImpl<T> create(String alias, Table<T> aliased) {
        return new TableImpl<T>(alias, aliased);
    }

    /**
     * Create a <code>INFORMATION_SCHEMA.TABLES</code> table reference
     */
    public TableImpl() {
        this(DSL.name("TABLES"), null);
    }

    public <O extends Record> TableImpl(Table<O> child, ForeignKey<O, Record> key) {
        super(child, key, TABLES);
    }

    @Override
    public Schema getSchema() {
        return getTable().getSchema();
    }

    @Override
    public TableImpl as(String alias) {
        return new TableImpl(DSL.name(alias), this);
    }

    @Override
    public TableImpl as(Name alias) {
        return new TableImpl(alias, this);
    }

    /**
     * Rename this table
     */
    @Override
    public TableImpl rename(String name) {
        return new TableImpl(DSL.name(name), null);
    }

    /**
     * Rename this table
     */
    @Override
    public TableImpl rename(Name name) {
        return new TableImpl(name, null);
    }
}<|fim_middle|>package org.jooq.impl;

import org.jooq.ForeignKey;
import org.jooq.Name;
import org.jooq.Record;
import org.jooq.Schema;
import org.jooq.Table;
import org.jooq.TableImpl;
import org.jooq.tables.Tables;

/**
 * This class is generated by jOOQ<nl>
        setFrom(value);
        return this;
    <|file_separator|>class LambdaConverterFactory.java
<|fim_prefix|><|fim_suffix|>
    public LambdaConverterFactory withFrom(String value) {
        setFrom(value);
        return this;
    }

    /**
     * The implementation of {@link org.jooq.ConverterFactory#to(Class)}.
     * 
     */
    public LambdaConverterFactory withTo(String value) {
        setTo(value);
        return this;
    }

    /**
     * Whether to use {@link org.jooq.ConverterFactory#ofNullable(Class, Class, java.util.function.Function, java.util.function.Function)} or {@link org.jooq.ConverterFactory#of(Class, Class, java.util.function.Function, java.util.function.Function)}.
     * 
     */
    public LambdaConverterFactory withNullable(Boolean value) {
        setNullable(value);
        return this;
    }

    @Override
    public final void appendTo(XMLBuilder builder) {
        builder.append("from", from);
        builder.append("to", to);
        builder.append("nullable", nullable);
    }

    @Override
    public String toString() {
        XMLBuilder builder = XMLBuilder.nonFormatting();
        appendTo(builder);
        return builder.toString();
    }

    @Override
    public boolean equals(Object that) {
        if (this == that) {
            return true;
        }
        if (that == null) {
            return false;
        }
        if (getClass()!= that.getClass()) {
            return false;
        }
        LambdaConverterFactory other = ((LambdaConverterFactory) that);
        if (from == null) {
            if (other.from<nl>
        return outputSchemaToDefault;
    <|file_separator|>class SchemaMapping.java
<|fim_prefix|><|fim_suffix|>
    public SchemaMapping withSchemaMappingType(SchemaMappingType value) {
        setSchemaMappingType(value);
        return this;
    }

    @Override
    public final void appendTo(XMLBuilder builder) {
        builder.append("schemaMappingType", schemaMappingType);
    }

    @Override
    public String toString() {
        XMLBuilder builder = XMLBuilder.nonFormatting();
        appendTo(builder);
        return builder.toString();
    }

    @Override
    public boolean equals(Object that) {
        if (this == that) {
            return true;
        }
        if (that == null) {
            return false;
        }
        if (getClass()!= that.getClass()) {
            return false;
        }
        SchemaMapping other = ((SchemaMapping) that);
        if (schemaMappingType == null) {
            if (other.schemaMappingType!= null) {
                return false;
            }
        } else {
            if (!schemaMappingType.equals(other.schemaMappingType)) {
                return false;
            }
        }
        return true;
    }

    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = ((prime*result)+((schemaMappingType == null)? 0 :schemaMappingType.hashCode()));
        return result;
    }

}<|fim_middle|>class SchemaMapping implements Serializable, XMLAppendable
{

    private final static long serialVersionUID = 32000L;
    @XmlElement(required = true)
    protected SchemaMappingType schemaMappingType;

    /**
     * See also {@link Database<nl>
        setReturnType(value);
        return this;
    <|file_separator|>class SyntheticDaoMethod.java
<|fim_prefix|><|fim_suffix|>
    public SyntheticDaoMethod withComment(String value) {
        setComment(value);
        return this;
    }

    /**
     * The return type of the DAO method, defaulting to <code>void</code>.
     * 
     */
    public SyntheticDaoMethod withReturnType(String value) {
        setReturnType(value);
        return this;
    }

    /**
     * The defining SQL query.
     * 
     */
    public SyntheticDaoMethod withSql(String value) {
        setSql(value);
        return this;
    }

    @Override
    public final void appendTo(XMLBuilder builder) {
        builder.append("name", name);
        builder.append("comment", comment);
        builder.append("returnType", returnType);
        builder.append("sql", sql);
    }

    @Override
    public String toString() {
        XMLBuilder builder = XMLBuilder.nonFormatting();
        appendTo(builder);
        return builder.toString();
    }

    @Override
    public boolean equals(Object that) {
        if (this == that) {
            return true;
        }
        if (that == null) {
            return false;
        }
        if (getClass()!= that.getClass()) {
            return false;
        }
        SyntheticDaoMethod other = ((SyntheticDaoMethod) that);
        if (name == null) {
            if (other.name!= null) {
                return false;
            }
        } else {
            if (!name.equals(other.name)) {
                return false;
            }
        }
        if (comment == null<nl>
        if (_pgType == null)
            _pgType = new PgType(this, Keys.PG_SEQUENCE__SYNTHETIC_FK_PG_SEQUENCE__SYNTHETIC_PK_PG_TYPE, null);

        return _pgType;
    <|file_separator|>class PgType.java
<|fim_prefix|><|fim_suffix|>
    public final TableField<Record, Long> TYPACCELERATED = createField(DSL.name("typaccELERATED"), SQLDataType.BIGINT.nullable(false), this, "");

    /**
     * The column <code>pg_catalog.pg_type.typalign</code>.
     */
    public final TableField<Record, String> TYPALIGN = createField(DSL.name("typalign"), SQLDataType.VARCHAR.nullable(false), this, "");

    /**
     * The column <code>pg_catalog.pg_type.typcollation</code>.
     */
    public final TableField<Record, String> TYPCOLLATION = createField(DSL.name("typcollation"), SQLDataType.VARCHAR.nullable(false), this, "");

    /**
     * The column <code>pg_catalog.pg_type.typdefault</code>.
     */
    public final TableField<Record, String> TYPDEFAULT = createField(DSL.name("typdefault"), SQLDataType.VARCHAR.nullable(false), this, "");

    /**
     * The column <code>pg_catalog.pg_type.typnamespace</code>.
     */
    public final TableField<Record, Long> TYPNAMESPACE = createField(DSL.name("typnamespace"), SQLDataType.BIGINT.nullable(false), this, "");

    /**
     * The column <code>pg_catalog.pg_type.typstorage</code>.
     */
    public final TableField<Record, String> TYPSTORAGE = createField(DSL.name("<nl>
		return null;
	<|file_separator|><nl>
        // TODO: Implement
    <|file_separator|><nl>
        return "integer_range";
    <|file_separator|><nl>
        return "ltree";
    <|file_separator|><nl>
        return "offset_datetime_range";
    <|file_separator|><nl>
        if (t == null)
            return empty();
        else
            return construct(t.toString(), true, t.toString(), true);
    <|file_separator|><nl>
        return u == null ? null : u;
    <|file_separator|><nl>
        return u == null ? null : u.toString();
    <|file_separator|><nl>
        return timestampRange(CONVERTER.convert(lower, lowerIncluding), CONVERTER.convert(upper, upperIncluding));<|file_separator|><nl>
        return new BigDecimalRange(lower, lowerIncluding, upper, upperIncluding);
    <|file_separator|><nl>
        return new LocalDateRange(lower, true, upper, false);
    <|file_separator|><nl>
        if (this == obj) {
            return true;
        }
        if (obj == null || getClass() != obj.getClass()) {
            return false;
        }
        Ltree that = (Ltree) obj;
        return data.equals(that.data);
    <|file_separator|><nl>
        return new OffsetDateTimeRange(lower, lowerIncluding, upper, upperIncluding);
    <|file_separator|><nl>
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        FlywayVersion that = (FlywayVersion) o;
        return versionParts != null ? versionParts.equals(that.versionParts) : that.versionParts == null;
    <|file_separator|><nl>
        return obj instanceof JSON && data.equals(((JSON) obj).data);
    <|file_separator|><nl>
    <|file_separator|><nl>
        return this;
    <|file_separator|><nl>
        if (sqlState() != null)
            return sqlState();
        else
            return sqlStateSubclass().code();
    <|file_separator|><nl>
        return or(condition(sql, bindings));
    <|file_separator|><nl>
        delegate.accept(ctx);
    <|file_separator|><nl>
        if (in)
            ctx.visit(K_IN).sql('(').visit(array(values)).sql(')').sql(' ');
        else
            ctx.visit(K_NOT_IN).sql('(').visit(array(values)).sql(')').sql(' ');
    }

    static final RowN row(List<? extends Field<?>> values) {
        return new RowN(padded(null, values, limit(null)), null);
    <|file_separator|><nl>
        return Internal.createForeignKey(key, table, name, fields);
    <|file_separator|><nl>
        return map.values();
    <|file_separator|><nl>
            if (ctx.is(Context.Type.SQL)) {
                ctx.sql().append(AbstractRoutine.this.getQualifiedName());
            } else {
                ctx.append(AbstractRoutine.this.getQualifiedName());
            }
        <|file_separator|><nl>
        accept0(ctx);
    <|file_separator|><nl>
        if (this == that) {
            return true;
        }

        if (that == null || getClass() != that.getClass()) {
            return false;
        }

        Acosh that1 = (Acosh) that;

        return value.equals(that1.value);
    }

    @Override
    public int hashCode() {
        return value.hashCode();
    }

    @Override
    public String toString() {
        return "Acosh(" + value + ")";
    <|file_separator|>class Add.
<|fim_prefix|><|fim_suffix|>------------------------------------------------------------------------
    // XXX: The Object API
    // -------------------------------------------------------------------------

    @Override
    public boolean equals(Object that) {
        if (this == that) {
            return true;
        }

        if (that == null || getClass() != that.getClass()) {
            return false;
        }

        Add that1 = (Add) that;

        return value.equals(that1.value);
    }

    @Override
    public int hashCode() {
        return value.hashCode();
    }

    @Override
    public String toString() {
        return "Add(" + value + ")";
    }
}<|fim_middle|>class Add
extends
    AbstractField<BigDecimal>
implements
    QOM.Add
{

    final Field<? extends Number> value;

    Add(
        Field<? extends Number> value
    ) {
        super(
            N_ADD,
            allNotNull(NUMERIC, value)
        );

        this.value = nullSafeNotNull(value, INTEGER);
    }

    // -------------------------------------------------------------------------
    // XXX: QueryPart API
    // -------------------------------------------------------------------------

    @Override
    final boolean parenthesised(Context<?> ctx<nl>
        ctx.visit(this);
    }

    @Override
    public final void accept(Context<?> ctx, QOM.ArrayMap<T, U> visitor) {
        ctx.visit(this, visitor);
    }

    @Override
    public final void accept(Context<?> ctx, QOM.ArrayMap<T, U> visitor, QOM.ArrayMap<T, U> other) {
        ctx.visit(this, visitor, other);
    <|file_separator|>class ArrayMap<T, U>.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.ArrayMap.<nl>
        if (this == that) {
            return true;
        }
        if (that == null || getClass() != that.getClass()) {
            return false;
        }
        BinaryConcat that_ = (BinaryConcat) that;
        return bytes1.equals(that_.bytes1) && bytes2.equals(that_.bytes2);
    }

    @Override
    public int hashCode() {
        return Objects.hash(bytes1, bytes2);
    }

    @Override
    public String toString() {
        return "BinaryConcat(" + bytes1 + ", " + bytes2 + ")";
    <|file_separator|>class BinaryConcat
extends
    AbstractField<byte[]>
implements
    QOM.BinaryConcat
{

    final Field<byte[]> bytes1;
    final Field<byte[]> bytes2;

    BinaryConcat(
        Field<byte[]> bytes1,
        Field<byte[]> bytes2
    ) {
        super(
            N_BINARY_CONCAT,
            allNotNull(VARBINARY, bytes1, bytes2)
        );

        this.bytes1 = nullSafeNotNull(bytes1, VARBINARY);
        this.bytes2 = nullSafeNotNull(bytes2, VARBINARY);
    }

    // -------------------------------------------------------------------------
    // XXX: QueryPart API
    // -------------------------------------------------------------------------

    @Override
    public final void accept(Context<?> ctx) {
        switch (ctx.family()) {






            default:
                ctx.sql('(').visit(bytes1).sql(" || ").visit(bytes2).sql(')');
                break;
        }
    }














    // -------------------------------------------------------------------------
    // XXX: Query Object Model
    // -------------------------------------------------------------------------

    @Override
    public final<nl>
        ctx.visit(this);
    <|file_separator|>class BitOr<T extends Number>
extends
    AbstractField<T>
implements
    QOM.BitOr<T>
{

    final Field<T> arg1;
    final Field<T> arg2;

    BitOr(
        Field<T> arg1,
        Field<T> arg2
    ) {
        super(
            N_BIT_OR,
            allNotNull((DataType) dataType(INTEGER, arg1, false), arg1, arg2)
        );

        this.arg1 = nullSafeNotNull(arg1, INTEGER);
        this.arg2 = nullSafeNotNull(arg2, INTEGER);
    }

    // -------------------------------------------------------------------------
    // XXX: QueryPart API
    // -------------------------------------------------------------------------

    @Override
    final boolean parenthesised(Context<?> ctx) {
        switch (ctx.family()) {






            case H2:
            case HSQLDB:
                return true;






            case CLICKHOUSE:
                return true;

            case FIREBIRD:
                return true;

            case TRINO:
                return true;

            default:
                return false;
        }
    }

    @Override
    public final void accept(Context<?> ctx) {
        ctx.visit(this);
    }










    // -------------------------------------------------------------------------
    // XXX: Query Object Model
    // -------------------------------------------------------------------------

    @Override
    public final Field<T> $arg1() {
        return arg1;
    }

    @Override
    public final Field<T> $arg2() {
        return arg2;
    }

    @Override
    public final QOM.BitOr<T><nl>
        switch (ctx.family()) {















            default:
                super.accept(ctx);
                break;
        }
    <|file_separator|>class BoolAnd
extends
    AbstractAggregateFunction<Boolean>
implements
    QOM.BoolAnd
{

    BoolAnd(
        Condition condition
    ) {
        super(
            true,
            N_BOOL_AND,
            BOOLEAN,
            DSL.field(condition)
        );
    }

    // -------------------------------------------------------------------------
    // XXX: QueryPart API
    // -------------------------------------------------------------------------



    private static final Set<SQLDialect> EMULATE  = SQLDialect.supportedBy(CLICKHOUSE, CUBRID, DERBY, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, SQLITE);

    @Override
    final void acceptFunctionName(Context<?> ctx) {
        switch (ctx.family()) {















            default:
                super.acceptFunctionName(ctx);
                break;
        }
    }

    @SuppressWarnings("unchecked")
    final Condition condition() {
        return DSL.condition((Field<Boolean>) getArguments().get(0));
    }

    @Override
    public final void accept(Context<?> ctx) {
        switch (ctx.family()) {















            default:
                super.accept(ctx);
                break;
        }
    }



    // -------------------------------------------------------------------------
    // XXX: Query Object Model
    // -------------------------------------------------------------------------

    @Override
    public final Condition $condition() {
        return DSL.condition((Field<Boolean>) getArgument(0));
    }

    @Override
    public final QOM.BoolAnd $condition(Condition newValue) {
        return $constructor().apply(newValue);
    }

    <nl>
        return new Coerce<>(field.as(alias), getDataType());
    }

    @Override
    public final Field<T> as(Name alias, DataType<T> type) {
        return new Coerce<>(field.as(alias, type), getDataType());
    }

    @Override
    public final Field<T> as(Name alias, DataType<T> type, boolean nullable) {
        return new Coerce<>(field.as(alias, type, nullable), getDataType());
    }

    @Override
    public final Field<T> as(Name alias, DataType<T> type, boolean nullable, boolean autoAlias) {
        return new Coerce<>(field.as(alias, type, nullable, autoAlias), getDataType());
    }

    @Override
    public final Field<T> as(Name alias, DataType<T> type, boolean nullable, boolean autoAlias, boolean isNullable) {
        return new Coerce<>(field.as(alias, type, nullable, autoAlias, isNullable), getDataType());
    }

    @Override
    public final Field<T> as(Name alias, DataType<T> type, boolean nullable, boolean autoAlias, boolean isNullable, boolean isAutoAlias) {
        return new Coerce<>(field.as(alias, type, nullable, autoAlias, isNullable, isAutoAlias), getDataType());
    }

    @Override
    public final Field<T> as(Name alias, DataType<T> type, boolean nullable, boolean autoAlias, boolean isNullable, boolean isAutoAlias, boolean isGeneratedCast) {
        return new Coerce<>(field.as(alias, type, nullable, autoAlias, isNullable, isAutoAlias, isGeneratedCast), getDataType());
    }

    @<nl>
        return fields;
    <|file_separator|><nl>
        for (QueryPart<?> part : ctx.parts()) {
            if (part instanceof CommonTableExpressionList) {
                consumer.accept(part);
            }
        }
    <|file_separator|><nl>
        ctx.accept(condition);
    <|file_separator|>class ConditionAsField
extends
    AbstractField<Boolean>
implements
    NamedCheckField<Boolean>,
    QOM.ConditionAsField
{

    final Condition condition;

    ConditionAsField(
        Condition condition
    ) {
        super(
            N_FIELD,
            allNotNull(BOOLEAN)
        );

        this.condition = condition;
    }

    // -------------------------------------------------------------------------
    // XXX: QueryPart API
    // -------------------------------------------------------------------------

    @Override
    public final void accept(Context<?> ctx) {
        ctx.accept(condition);
    }












    @Override
    public final boolean hasName(Context<?> ctx) {
        return Tools.hasName(ctx, condition);
    }

    // -------------------------------------------------------------------------
    // XXX: Query Object Model
    // -------------------------------------------------------------------------

    @Override
    public final Condition $arg1() {
        return condition;
    }

    @Override
    public final QOM.ConditionAsField $arg1(Condition newValue) {
        return new ConditionAsField(newValue);
    }

    @Override
    public final Function1<? super Condition, ? extends QOM.ConditionAsField> $constructor() {
        return (a1) -> new ConditionAsField(a1);
    }

    // -------------------------------------------------------------------------
    // XXX: The Object API
    // -------------------------------------------------------------------------

    @Override
    public boolean equals(Object that) {
        if (that instanceof QOM.ConditionAsField o) {
            return
                StringUtils.equals($condition(), o.$condition())
            ;
        }
        else
            return super.equals(that);
    }<nl>
        ctx.add(this);
    }

    @Override
    public final QOM.Count $constructor() {
        return this;
    }

    @Override
    public final QOM.Count $constructor(Field<?> field, boolean distinct) {
        return new Count(field, distinct);
    }

    @Override
    public final QOM.Count $constructor(Field<?> field) {
        return new Count(field, $distinct());
    }

    @Override
    public final QOM.Count $constructor(boolean distinct) {
        return new Count(distinct);
    }

    @Override
    public final QOM.Count $constructor(Field<?> field, boolean distinct) {
        return new Count(field, distinct);
    }

    @Override
    public final QOM.Count $constructor(Field<?> field) {
        return new Count(field, $distinct());
    }

    @Override
    public final QOM.Count $constructor(boolean distinct) {
        return new Count(distinct);
    }

    @Override
    public final QOM.Count $constructor(Field<?> field) {
        return new Count(field, $distinct());
    }

    @Override
    public final QOM.Count $constructor(Field<?> field, boolean distinct) {
        return new Count(field, distinct);
    }

    @Override
    public final QOM.Count $constructor(Field<?> field) {
        return new Count(field, $distinct());
    }

    @Override
    public final QOM.Count $constructor(boolean distinct) {
        return new Count(distinct);
    }

    @Override
    public final QOM.Count $constructor(Field<?> field, boolean distinct) {
        return new Count(field,<nl>
        if (this == that)
            return true;
        if (that == null || getClass() != that.getClass())
            return false;
        if (!super.equals(that))
            return false;
        CovarPop thatCovarPop = (CovarPop) that;
        return Objects.equals($y(), thatCovarPop.$y()) &&
            Objects.equals($x(), thatCovarPop.$x());
    }

    @Override
    public int hashCode() {
        return Objects.hash(super.hashCode(), $y(), $x());
    }

    @Override
    public String toString() {
        return "CovarPop(" + $y() + ", " + $x() + ")";
    <|file_separator|>class CovarSamp
extends
    AbstractAggregateFunction<BigDecimal>
implements
    QOM.CovarSamp
{

    CovarSamp(
        Field<? extends Number> y,
        Field<? extends Number> x
    ) {
        super(
            false,
            N_COVAR_SAMP,
            NUMERIC,
            nullSafeNotNull(y, INTEGER),
            nullSafeNotNull(x, INTEGER)
        );
    }

    // -------------------------------------------------------------------------
    // XXX: QueryPart API
    // -------------------------------------------------------------------------



    private static final Set<SQLDialect> NO_SUPPORT_NATIVE        = SQLDialect.supportedUntil(CUBRID, DERBY, HSQLDB, IGNITE, MARIADB, MYSQL, SQLITE);





    @Override
    public void accept(Context<?> ctx) {
        if (NO_SUPPORT_NATIVE.contains(ctx.dialect()))
            acceptEmulation(ctx);




        else
            super.accept(ctx);
    }

    @Override
    void acceptFunctionName(<nl>
        if (ctx.dialect().isSupported(NO_SUPPORT_PRECISION)) {
            throw new UnsupportedOperationException("CurrentTimestamp is not supported by this dialect");
        }

        if (ctx.dialect().isSupported(NO_SUPPORT_PRECISION_BIND)) {
            throw new UnsupportedOperationException("CurrentTimestamp is not supported by this dialect");
        }

        if (precision != null) {
            ctx.append("(");
            precision.accept(ctx);
            ctx.append(")");
        }
    <|file_separator|><nl>
        return new DefaultBindingGetResultSetContext<T>(ctx(), resultSet(), index(), converter);
    <|file_separator|><nl>
        return new HashMap<Object, Object>();
    <|file_separator|><nl>
        return new ConnectionFactoryMetadata();
    <|file_separator|><nl>
        EXECUTOR.execute(command);
    <|file_separator|><nl>
        return "DefaultRecordListenerProvider";
    <|file_separator|><nl>
        return true;
    <|file_separator|><nl>
        return new DiagnosticsConnection(configuration, username, password);
    <|file_separator|><nl>
        if (check(ctx, Settings::isDiagnosticsTooManyColumnsFetched))
            for (DiagnosticsListener listener : listeners)
                listener.tooManyColumnsFetched(ctx);
    }

    @Override
    public final void tooManyRowsFetched(DiagnosticsContext ctx, int maxRows) {
        if (check(ctx, Settings::isDiagnosticsTooManyRowsFetched))
            for (DiagnosticsListener listener : listeners)
                listener.tooManyRowsFetched(ctx, maxRows);
    }

    @Override
    public final void tooManyColumnsFetched(DiagnosticsContext ctx, int maxColumns) {
        if (check(ctx, Settings::isDiagnosticsTooManyColumnsFetched))
            for (DiagnosticsListener listener : listeners)
                listener.tooManyColumnsFetched(ctx, maxColumns);
    }

    @Override
    public final void tooManyRowsFetched(DiagnosticsContext ctx, int maxRows, int maxColumns) {
        if (check(ctx, Settings::isDiagnosticsTooManyRowsFetched))
            for (DiagnosticsListener listener : listeners)
                listener.tooManyRowsFetched(ctx, maxRows, maxColumns);
    }

    @Override
    public final void tooManyColumnsFetched(DiagnosticsContext ctx, int maxRows, int maxColumns) {
        if (check(ctx, Settings::isDiagnosticsTooManyColumnsFetched))
            for (DiagnosticsListener listener : listeners)
                listener.tooManyColumnsFetched(ctx, maxRows, maxColumns);
    }

    @Override
    public final void tooManyRowsFetched(DiagnosticsContext ctx, int maxRows, int maxColumns, int maxStatements) {
        if (check(ctx, Settings::isDiagnosticsTooManyRowsFetched))
            for (DiagnosticsListener listener : listeners)
                listener.tooManyRowsFetched(ctx, maxRows, maxColumns, maxStatements<nl>
        return and(condition(c));
    <|file_separator|><nl>
        if (ifExists)
            ctx.append(DDLStatementType.DROP_DOMAIN, "IF EXISTS", domain.name());
        else
            ctx.append(DDLStatementType.DROP_DOMAIN, domain.name());
    <|file_separator|>class DropIndexImpl
<|fim_prefix|><|fim_suffix|>------------------------------------------------------------------------
    // XXX: Query Object Model
    // -------------------------------------------------------------------------

    @Override
    public final Index<?> $index() {
        return index;
    }

    @Override
    public final boolean $ifExists() {
        return ifExists;
    }

    @Override
    public final boolean $cascade() {
        return cascade;
    }

    @Override
    public final QOM.DropIndex $index(Index<?> newValue) {
        return $constructor().apply(newValue, $ifExists(), $cascade());
    }

    @Override
    public final QOM.DropIndex $ifExists(boolean newValue) {
        return $constructor().apply($index(), newValue, $cascade());
    }

    @Override
    public final QOM.DropIndex $cascade(boolean newValue) {
        return $constructor().apply($index(), $ifExists(), newValue);
    }

    public final Function2<? super Index<?>, ? super Boolean, ? extends QOM.DropIndex> $constructor() {
        return (a1, a2) -> new DropIndexImpl(configuration(), a1, a2);
    }























}<|fim_middle|>class DropIndexImpl
extends
    AbstractDDLQuery
implements
    QOM.DropIndex,
    DropIndexCascadeStep,
    DropIndexFinalStep
{

    final Index<?> index;
    final boolean   ifExists;
    final boolean   cascade;

    DropIndexImpl(
        Configuration configuration,
        Index<?> index,
<nl>
        if (temporary)
            ctx.temporary(table);
        else
            ctx.table(table);
    }

    @Override
    public final void accept(Context<?> ctx, boolean temporary) {
        if (temporary)
            ctx.temporary(table);
        else
            ctx.table(table);
    }

    @Override
    public final void accept(Context<?> ctx, boolean temporary, boolean ifExists) {
        if (temporary)
            ctx.temporary(table);
        else
            ctx.table(table);
    }

    @Override
    public final void accept(Context<?> ctx, boolean temporary, boolean ifExists, boolean ifExistsSpecified) {
        if (temporary)
            ctx.temporary(table);
        else
            ctx.table(table);
    }

    @Override
    public final void accept(Context<?> ctx, boolean temporary, boolean ifExists, boolean ifExistsSpecified, boolean ifExistsSpecifiedSpecified) {
        if (temporary)
            ctx.temporary(table);
        else
            ctx.table(table);
    }

    @Override
    public final void accept(Context<?> ctx, boolean temporary, boolean ifExists, boolean ifExistsSpecified, boolean ifExistsSpecifiedSpecified, boolean ifExistsSpecifiedSpecifiedSpecified) {
        if (temporary)
            ctx.temporary(table);
        else
            ctx.table(table);
    }

    @Override
    public final void accept(Context<?> ctx, boolean temporary, boolean ifExists, boolean ifExistsSpecified, boolean ifExistsSpecifiedSpecified, boolean ifExistsSpecifiedSpecifiedSpecified, boolean ifExistsSpecifiedSpecifiedSpecifiedSpecified) {
        if (temporary)
            ctx.temporary(table);
        else
            ctx.table(table);
    }

    @Override
    public final void accept<nl>
        return (Class<? extends Record1<Integer>>) Integer.class;
    <|file_separator|><nl>
        ctx.add(this);
    <|file_separator|>class Eq<T>
extends
    AbstractCondition
implements
    QOM.Eq<T>
{

    final Field<T> arg1;
    final Field<T> arg2;

    Eq(
        Field<T> arg1,
        Field<T> arg2
    ) {

        this.arg1 = nullableIf(false, Tools.nullSafe(arg1, arg2.getDataType()));
        this.arg2 = nullableIf(false, Tools.nullSafe(arg2, arg1.getDataType()));
    }

    // -------------------------------------------------------------------------
    // XXX: QueryPart API
    // -------------------------------------------------------------------------



    @Override
    public final void accept(Context<?> ctx) {
        ctx.add(this);
    }

    @Override
    public final Clause[] clauses(Context<?> ctx) {
        return Eq.CLAUSES;
    }












    // -------------------------------------------------------------------------
    // XXX: Query Object Model
    // -------------------------------------------------------------------------

    @Override
    public final Field<T> $arg1() {
        return arg1;
    }

    @Override
    public final Field<T> $arg2() {
        return arg2;
    }

    @Override
    public final QOM.Eq<T> $arg1(Field<T> newValue) {
        return $constructor().apply(newValue, $arg2());
    }

    @Override
    public final QOM.Eq<T> $arg2(Field<T> newValue) {
        return $constructor().apply($arg1(), newValue);
    }

    @Override
    public final Function2<? super Field<T>, ? super Field<T<nl>
        if (NO_SUPPORT_GROUP_FUNCTIONAL_DEP.contains(ctx.dialect()))
            return t.fields();
        else
            return t.fields(ctx.dialect());
    <|file_separator|><nl>
        return new LeftAntiJoin(table1, table2);
    <|file_separator|>class LeftJoin
extends
    JoinTable<LeftJoin>
implements
    QOM.LeftJoin<Record>
{

    LeftJoin(TableLike<?> lhs, TableLike<?> rhs) {
        super(lhs, rhs, JoinType.LEFT_JOIN, null);
    }

    // -------------------------------------------------------------------------
    // XXX: Query Object Model
    // -------------------------------------------------------------------------

    @Override
    LeftJoin construct(
        Table<?> table1,
        Collection<? extends Field<?>> partitionBy1,
        Collection<? extends Field<?>> partitionBy2,
        Table<?> table2,
        Condition o,
        Collection<? extends Field<?>> u,
        JoinHint h
    ) {
        return new LeftJoin(table1, table2);
    }
}<|file_separator|>class JoinHint
extends
    Hint
{

    JoinHint(
        Table<?> table1,
        Collection<? extends Field<?>> partitionBy1,
        Table<?> table2,
        Collection<? extends Field<?>> partitionBy2
    ) {
        super(table1, partitionBy1, table2, partitionBy2);
    }

    // -------------------------------------------------------------------------
    // XXX: Query Object Model
    // -------------------------------------------------------------------------

    @Override
    JoinHint construct(
        Table<?> table1,
        Collection<? extends Field<?>> partitionBy1,
        Table<?> table2,
        Collection<? extends Field<?>> partitionBy2
    ) {
        return new JoinHint(table1, partitionBy1, table2, partitionBy2);
    }
}<|file_separator|>class JoinType
extends
    Enum<JoinType>
{

    LEFT_JOIN,
    RIGHT_JOIN,
    FULL_<nl>
        return true;
    <|file_separator|>class Log10
.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>package org.yugabyte.duckdb.query.dsl;

import org.yugabyte.duckdb.query.dsl.DSL.Log10;
import org.yugabyte.duckdb.query.dsl.DSL.Log10.Log10Builder;
import org.yugabyte.duckdb.query.dsl.DSL.Log10.Log10Builder.Log10BuilderBuilder;
import org.yugabyte.duckdb.query.dsl.DSL.Log10.Log10Builder.Log10BuilderBuilder.Log10BuilderBuilderBuilder;
import org.yugabyte.duckdb.query.dsl.DSL.Log10.Log10Builder.Log10BuilderBuilder.Log10BuilderBuilderBuilder.Log10BuilderBuilderBuilderBuilder;
import org.yugabyte.duckdb.query.dsl.DSL.Log10.Log10Builder.Log10BuilderBuilder.Log10BuilderBuilderBuilder.Log10BuilderBuilderBuilderBuilder.Log10BuilderBuilderBuilderBuilderBuilder;
import org.yugabyte.duckdb.query.dsl.DSL.Log10.Log10Builder.Log10BuilderBuilder.Log10BuilderBuilderBuilder.Log10BuilderBuilderBuilderBuilder.Log10BuilderBuilderBuilderBuilderBuilder.Log10BuilderBuilderBuilderBuilderBuilderBuilder;
import org.yugabyte.duckdb.query.dsl.DSL.Log10.Log10Builder.Log10BuilderBuilder.Log10BuilderBuilderBuilder.Log10BuilderBuilderBuilderBuilder.Log10BuilderBuilderBuilderBuilderBuilder.Log10BuilderBuilderBuilderBuilderBuilderBuilder.Log10BuilderBuilderBuilderBuilderBuilderBuilderBuilder;
import org<nl>
        return $constructor().apply($arg2(), newValue);
    <|file_separator|>class Ne<T>
extends
    AbstractCondition
implements
    QOM.Ne<T>
{

    final Field<T> arg1;
    final Field<T> arg2;

    Ne(
        Field<T> arg1,
        Field<T> arg2
    ) {

        this.arg1 = nullableIf(false, Tools.nullSafe(arg1, arg2.getDataType()));
        this.arg2 = nullableIf(false, Tools.nullSafe(arg2, arg1.getDataType()));
    }

    // -------------------------------------------------------------------------
    // XXX: QueryPart API
    // -------------------------------------------------------------------------



    @Override
    public final void accept(Context<?> ctx) {







        Eq.acceptCompareCondition(ctx, this, arg1, org.jooq.Comparator.NOT_EQUALS, arg2, RowN::ne, RowN::ne, (c, a1, a2) -> c.visit(a1).sql(" <> ").visit(a2));
    }

    @Override
    public final Clause[] clauses(Context<?> ctx) {
        return Eq.CLAUSES;
    }












    // -------------------------------------------------------------------------
    // XXX: Query Object Model
    // -------------------------------------------------------------------------

    @Override
    public final Field<T> $arg1() {
        return arg1;
    }

    @Override
    public final Field<T> $arg2() {
        return arg2;
    }

    @Override
    public final QOM.Ne<T> $arg1(Field<T> newValue) {
        return $constructor().apply($arg2(), newValue);
    }

    @<nl>
        return new Publisher<>() {
            @Override
            public void subscribe(Consumer<? super Connection> consumer) {
                consumer.accept(new Connection() {
                    @Override
                    public void close() {
                    }
                });
            }
        };
    <|file_separator|><nl>
        return this;
    <|file_separator|>class Field<T>.java
<|fim_prefix|><|fim_suffix|>

    Field<T> $field(Field<T> newField);

    Field<T> $field(Field<T> newField, boolean isNull);

    Field<T> $field(Field<T> newField, boolean isNull, boolean isNullDefault);

    Field<T> $field(Field<T> newField, boolean isNull, boolean isNullDefault, boolean isNullDefaultDefault);

    Field<T> $field(Field<T> newField, boolean isNull, boolean isNullDefault, boolean isNullDefaultDefault, boolean isNullDefaultDefault);

    Field<T> $field(Field<T> newField, boolean isNull, boolean isNullDefault, boolean isNullDefaultDefault, boolean isNullDefaultDefault, boolean isNullDefaultDefault);

    Field<T> $field(Field<T> newField, boolean isNull, boolean isNullDefault, boolean isNullDefaultDefault, boolean isNullDefaultDefault, boolean isNullDefaultDefault, boolean isNullDefaultDefault);

    Field<T> $field(Field<T> newField, boolean isNull, boolean isNullDefault, boolean isNullDefaultDefault, boolean isNullDefaultDefault, boolean isNullDefaultDefault, boolean isNullDefaultDefault, boolean isNullDefaultDefault);

    Field<T> $field(Field<T> newField, boolean isNull, boolean isNullDefault, boolean isNullDefaultDefault, boolean isNullDefaultDefault, boolean isNullDefaultDefault, boolean isNullDefaultDefault, boolean isNullDefaultDefault, boolean isNullDefaultDefault);

    Field<T> $field(Field<T> newField, boolean isNull, boolean isNullDefault, boolean isNullDefaultDefault, boolean isNullDefaultDefault, boolean isNullDefaultDefault, boolean isNull<nl>
        return isDefaulted;
    <|file_separator|><nl>
        retur<|file_separator|><nl>
        return $constructor().apply(newValue, $arg2(), $arg3());
    <|file_separator|>class Position
extends
    AbstractField<Integer>
implements
    QOM.Position
{

    final Field<String>           in;
    final Field<String>           search;
    final Field<? extends Number> startIndex;

    Position(
        Field<String> in,
        Field<String> search
    ) {
        super(
            N_POSITION,
            allNotNull(INTEGER, in, search)
        );

        this.in = nullSafeNotNull(in, VARCHAR);
        this.search = nullSafeNotNull(search, VARCHAR);
        this.startIndex = null;
    }

    Position(
        Field<String> in,
        Field<String> search,
        Field<? extends Number> startIndex
    ) {
        super(
            N_POSITION,
            allNotNull(INTEGER, in, search, startIndex)
        );

        this.in = nullSafeNotNull(in, VARCHAR);
        this.search = nullSafeNotNull(search, VARCHAR);
        this.startIndex = nullSafeNotNull(startIndex, INTEGER);
    }

    // -------------------------------------------------------------------------
    // XXX: QueryPart API
    // -------------------------------------------------------------------------



    @Override
    public final void accept(Context<?> ctx) {








        accept0(ctx, getDataType(), in, search, startIndex, DSL::position, DSL::substring);
    }

    static final <T> void accept0(
        Context<?> ctx,
        DataType<Integer> type,
        Field<T> in,
        Field<T> search,
        Field<? extends Number> startIndex,
        Function2<? super Field<T>, ? super Field<T>, ? extends Field<<nl>
        return wrapped().set(index, element);
    }

    @Override
    public final void add(T e) {
        if (canAdd(e))
            wrapped().add(e);
    }

    @Override
    public final boolean remove(Object o) {
        return wrapped().remove(o);
    }

    @Override
    public final boolean containsAll(Collection<?> c) {
        return wrapped().containsAll(c);
    }

    @Override
    public final boolean addAll(Collection<? extends T> c) {
        boolean modified = false;

        for (T e : c)
            if (canAdd(e) && (modified |= true))
                wrapped().add(e);

        return modified;
    }

    @Override
    public final boolean removeAll(Collection<?> c) {
        boolean modified = false;

        for (Object o : c)
            if (wrapped().remove(o))
                modified = true;

        return modified;
    }

    @Override
    public final boolean retainAll(Collection<?> c) {
        boolean modified = false;

        for (int i = wrapped().size() - 1; i >= 0; i--)
            if (!c.contains(wrapped().get(i)))
                if (wrapped().remove(i))
                    modified = true;

        return modified;
    }

    @Override
    public final void clear() {
        wrapped().clear();
    }

    @Override
    public final boolean isEmpty() {
        return wrapped().isEmpty();
    }

    @Override
    public final int size() {
        return wrapped().size();
    <|file_separator|><nl>
        return RegrIntercept::new;
    <|file_separator|>class RegrSlope
extends
    AbstractAggregateFunction<BigDecimal>
implements
    QOM.RegrSlope
{

    RegrSlope(
        Field<? extends Number> y,
        Field<? extends Number> x
    ) {
        super(
            false,
            N_REGR_SLOPE,
            NUMERIC,
            nullSafeNotNull(y, INTEGER),
            nullSafeNotNull(x, INTEGER)
        );
    }

    // -------------------------------------------------------------------------
    // XXX: QueryPart API
    // -------------------------------------------------------------------------



    private static final Set<SQLDialect> NO_SUPPORT_NATIVE        = SQLDialect.supportedUntil(CLICKHOUSE, CUBRID, DERBY, HSQLDB, IGNITE, MARIADB, MYSQL, SQLITE);





    @Override
    public final void accept(Context<?> ctx) {
        if (NO_SUPPORT_NATIVE.contains(ctx.dialect()))
            acceptEmulation(ctx);




        else
            super.accept(ctx);
    }

    @SuppressWarnings("unchecked")
    private final void acceptEmulation(Context<?> ctx) {
        Field<? extends Number> x = (Field) getArguments().get(0);
        Field<? extends Number> y = (Field) getArguments().get(1);

        ctx.visit(fo(regrAvgY(x, y)).minus(fo(regrAvgX(x, y)).times(fo(regrSlope(x, y)))));
    }



    // -------------------------------------------------------------------------
    // XXX: Query Object Model
    // -------------------------------------------------------------------------

    @SuppressWarnings("unchecked")
    @Override
    public final Field<? extends Number> $y() {
        return (Field<? extends Number<nl>
        if (this == that)
            return true;
        if (that == null || getClass() != that.getClass())
            return false;
        RegrR2 thatR2 = (RegrR2) that;
        return Objects.equals($y(), thatR2.$y()) && Objects.equals($x(), thatR2.$x());
    }

    @Override
    public int hashCode() {
        return Objects.hash($y(), $x());
    }

    @Override
    public String toString() {
        return "RegrR2(" + $y() + ", " + $x() + ")";
    <|file_separator|><nl>
        if (this == that)
            return true;
        if (that == null || getClass() != that.getClass())
            return false;
        if (!super.equals(that))
            return false;
        RegrSlope that1 = (RegrSlope) that;
        return Objects.equals($y(), that1.$y()) && Objects.equals($x(), that1.$x());
    }

    @Override
    public int hashCode() {
        return Objects.hash(super.hashCode(), $y(), $x());
    }

    @Override
    public String toString() {
        return "RegrSlope(" + $y() + ", " + $x() + ")";
    <|file_separator|>class RegrR2
extends
    AbstractAggregateFunction<BigDecimal>
implements
    QOM.RegrR2
{

    RegrR2(
        Field<? extends Number> y,
        Field<? extends Number> x
    ) {
        super(
            false,
            N_REGR_R2,
            NUMERIC,
            nullSafeNotNull(y, INTEGER),
            nullSafeNotNull(x, INTEGER)
        );
    }

    // -------------------------------------------------------------------------
    // XXX: QueryPart API
    // -------------------------------------------------------------------------



    private static final Set<SQLDialect> NO_SUPPORT_NATIVE        = SQLDialect.supportedUntil(CLICKHOUSE, CUBRID, DERBY, HSQLDB, IGNITE, MARIADB, MYSQL, SQLITE);





    @Override
    public final void accept(Context<?> ctx) {
        if (NO_SUPPORT_NATIVE.contains(ctx.dialect()))
            acceptEmulation(ctx);




        else
            super.accept(ctx);
    }

    @SuppressWarnings("unchecked")
    private final<nl>
        return $constructor().apply($y(), newValue);
    <|file_separator|>class RegrSxy.
<|fim_prefix|><|fim_suffix|>------------------------------------------------------------------------
    // XXX: The Object API
    // -------------------------------------------------------------------------

    @Override
    public boolean equals(Object that) {
        if (that instanceof QOM.RegrSxy o) {
            return
                StringUtils.equals($y(), o.$y()) &&
                StringUtils.equals($x(), o.$x())
            ;
        }
        else
            return super.equals(that);
    }
}<|fim_middle|>extends
    AbstractAggregateFunction<BigDecimal>
implements
    QOM.RegrSxy
{

    RegrSxy(
        Field<? extends Number> y,
        Field<? extends Number> x
    ) {
        super(
            false,
            N_REGR_SXY,
            NUMERIC,
            nullSafeNotNull(y, INTEGER),
            nullSafeNotNull(x, INTEGER)
        );
    }

    // -------------------------------------------------------------------------
    // XXX: QueryPart API
    // -------------------------------------------------------------------------



    private static final Set<SQLDialect> NO_SUPPORT_NATIVE        = SQLDialect.supportedUntil(CLICKHOUSE, CUBRID, DERBY, HSQLDB, IGNITE, MARIADB, MYSQL, SQLITE, TRINO);





    @Override
    public final void accept(Context<?> ctx) {
        if (NO_SUPPORT_NATIVE.contains(ctx.dialect()))
            acceptEmulation(ctx);




        else
            super.accept(ctx);
    }

    @Override
    void acceptFunctionName(Context<?> ctx) {





        super.acceptFunctionName(ctx);
    }

    @SuppressWarnings("unchecked")
    private final void acceptEmulation(Context<nl>
        return result.fetchNext(number);
    }

    @Override
    public final Result<R> fetchNext() {
        return result.fetchNext();
    }

    @Override
    public final Result<R> fetchNext(int number, int timeout) {
        return result.fetchNext(number, timeout);
    }

    @Override
    public final Result<R> fetchNext(int number, long timeout) {
        return result.fetchNext(number, timeout);
    }

    @Override
    public final Result<R> fetchNext(int number, TimeUnit unit) {
        return result.fetchNext(number, unit);
    }

    @Override
    public final Result<R> fetchNext(int number, long timeout, TimeUnit unit) {
        return result.fetchNext(number, timeout, unit);
    }

    @Override
    public final Result<R> fetchNext(int number, int timeout, TimeUnit unit) {
        return result.fetchNext(number, timeout, unit);
    }

    @Override
    public final Result<R> fetchNext(int number, long timeout, TimeUnit unit, int timeoutUnit) {
        return result.fetchNext(number, timeout, unit, timeoutUnit);
    }

    @Override
    public final Result<R> fetchNext(int number, long timeout, TimeUnit unit, int timeoutUnit, int timeoutUnitTimeout) {
        return result.fetchNext(number, timeout, unit, timeoutUnit, timeoutUnitTimeout);
    }

    @Override
    public final Result<R> fetchNext(int number, long timeout, TimeUnit unit, int timeoutUnit, int timeoutUnitTimeout, int timeoutUnitTimeoutUnit) {
        return result.fetchNext(number, timeout, unit, timeoutUnit, timeout<nl>
        return row;
    }

    @Override
    public final Field<?> $field() {
        return this;
    }

    @Override
    public final Field<?> $field(Name name) {
        return new RowAsField<>(row, name);
    }

    @Override
    public final Field<?> $field(String name) {
        return new RowAsField<>(row, DSL.name(name));
    }

    @Override
    public final Field<?> $field(int index) {
        return new RowAsField<>(row, DSL.name(index));
    }

    @Override
    public final Field<?> $field(int index, Name name) {
        return new RowAsField<>(row, DSL.name(index, name));
    }

    @Override
    public final Field<?> $field(int index, String name) {
        return new RowAsField<>(row, DSL.name(index, DSL.name(name)));
    }

    @Override
    public final Field<?> $field(int index, int name) {
        return new RowAsField<>(row, DSL.name(index, DSL.name(name)));
    }

    @Override
    public final Field<?> $field(int index, String name, Name alias) {
        return new RowAsField<>(row, DSL.name(index, DSL.name(name), alias));
    }

    @Override
    public final Field<?> $field(int index, String name, String alias) {
        return new RowAsField<>(row, DSL.name(index, DSL.name(name), DSL.name(alias)));
    }

    @Override
    public final Field<?> $field(int index, String name, int alias) {
        return new RowAsField<>(<nl>
        if (lhs.isNullable() && rhsRow != null) {
            throw new UnsupportedOperationException("RowIsDistinctFrom is not supported for nullable rows");
        }
        if (rhsRow != null) {
            rhsRow.accept(ctx);
        }
        if (rhsSelect != null) {
            rhsSelect.accept(ctx);
        }
    }

    @Override
    public final boolean isDistinct() {
        return true;
    }

    @Override
    public final boolean isNot() {
        return not;
    }

    @Override
    public final boolean isDistinctFrom() {
        return true;
    }

    @Override
    public final boolean isDistinctFrom(Row other) {
        return true;
    }

    @Override
    public final boolean isDistinctFrom(Select<?> other) {
        return true;
    }

    @Override
    public final boolean isDistinctFrom(Row other, boolean not) {
        return true;
    }

    @Override
    public final boolean isDistinctFrom(Select<?> other, boolean not) {
        return true;
    }

    @Override
    public final boolean isDistinctFrom(Row other, boolean not, boolean emulateDistinct) {
        return true;
    }

    @Override
    public final boolean isDistinctFrom(Select<?> other, boolean not, boolean emulateDistinct) {
        return true;
    }

    @Override
    public final boolean isDistinctFrom(Row other, boolean not, boolean emulateDistinct, boolean emulateDistinctSelect) {
        return true;
    }

    @Override
    public final boolean isDistinctFrom(Select<?> other, boolean not, boolean emulateDistinct, boolean emulateDistinctSelect) {
        return true;
    }

    @<nl>
        return new Clause[0];
    }

    @Override
    public final String sql(Context<?> ctx) {
        return delegate.sql(ctx);
    }

    @Override
    public final String sql(Context<?> ctx, boolean withLimit) {
        return delegate.sql(ctx, withLimit);
    }

    @Override
    public final String sql(Context<?> ctx, boolean withLimit, boolean withOffset) {
        return delegate.sql(ctx, withLimit, withOffset);
    }

    @Override
    public final String sql(Context<?> ctx, boolean withLimit, boolean withOffset, boolean withOffsetLimit) {
        return delegate.sql(ctx, withLimit, withOffset, withOffsetLimit);
    }

    @Override
    public final String sql(Context<?> ctx, boolean withLimit, boolean withOffset, boolean withOffsetLimit, boolean withOffsetLimitClause) {
        return delegate.sql(ctx, withLimit, withOffset, withOffsetLimit, withOffsetLimitClause);
    }

    @Override
    public final String sql(Context<?> ctx, boolean withLimit, boolean withOffset, boolean withOffsetLimit, boolean withOffsetLimitClause, boolean withOffsetLimitClauseClause) {
        return delegate.sql(ctx, withLimit, withOffset, withOffsetLimit, withOffsetLimitClause, withOffsetLimitClauseClause);
    }

    @Override
    public final String sql(Context<?> ctx, boolean withLimit, boolean withOffset, boolean withOffsetLimit, boolean withOffsetLimitClause, boolean withOffsetLimitClauseClause, boolean withOffsetLimitClauseClauseClause) {
        return delegate.sql(ctx, withLimit, withOffset, withOffsetLimit, withOffsetLimitClause, withOffsetLimitClauseClause, withOffsetLimitClauseClauseClause);
    }

    @Override
    <nl>
        return new FieldsImpl<>(this);
    }

    @Override
    final void accept(Context<Record> ctx) {
        switch (ctx.family()) {
            case SQL:
                ctx.visit(delegate);
                break;
        }
    <|file_separator|>class SQLTable.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class SQLTable extends AbstractTable<Record> implements UEmptyTable<Record> {

    private final SQL delegate;

    SQLTable(SQL delegate) {
        super(TableOptions.expression(), DSL.name(delegate.toString()));

        this.delegate = delegate;
    }

    // ------------------------------------------------------------------------
    // SQLTable API
    // ------------------------------------------------------------------------

    @Override
    public final Class<? extends Record> getRecordType() {
        return RecordImplN.class;
    }

    @Override
    public final void accept(Context<?> ctx) {
        switch (ctx.family()) {






            default:
                ctx.visit(delegate);
                break;
        }
    }

    @Override
    final FieldsImpl<Record> fields0() {
        return new FieldsImpl<>(this);
    }

    @Override
    final void accept(Context<Record> ctx) {
        switch (ctx.family()) {
            case SQL:
                ctx.visit(delegate);
                break;
        }
    }
}<|file_separator|>class SQLTable.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class SQLTable extends AbstractTable<Record> implements UEmptyTable<Record> {

    private final SQL delegate;

    SQLTable(SQL delegate) {
        super(TableOptions.expression(), DSL.name(delegate.toString()));

        this.delegate = delegate;
    }

    // ------------------------------------------------------------------------
    // SQLTable API
<nl>
        ctx.accept(this);
    <|file_separator|>class SavepointManager
extends
    AbstractSavepointManager
implements
    QOM.SavepointManager
{

    final Configuration configuration;

    SavepointManager(
        Configuration configuration
    ) {
        super();

        this.configuration = configuration;
    }

    // -------------------------------------------------------------------------
    // XXX: QueryPart API
    // -------------------------------------------------------------------------

    @Override
    public final void accept(Context<?> ctx) {
        ctx.accept(this);
    }

    // -------------------------------------------------------------------------
    // XXX: Query Object Model
    // -------------------------------------------------------------------------

    @Override
    public final Configuration $configuration() {
        return configuration;
    }

    @Override
    public final QOM.SavepointManager $configuration(Configuration newValue) {
        return $constructor().apply(newValue);
    }

    public final Function1<? super Configuration, ? extends QOM.SavepointManager> $constructor() {
        return (a1) -> new SavepointManager(a1);
    }





















}<|file_separator|>class SavepointManager
extends
    AbstractSavepointManager
implements
    QOM.SavepointManager
{

    final Configuration configuration;

    SavepointManager(
        Configuration configuration
    ) {
        super();

        this.configuration = configuration;
    }

    // -------------------------------------------------------------------------
    // XXX: QueryPart API
    // -------------------------------------------------------------------------

    @Override
    public final void accept(Context<?> ctx) {
        ctx.accept(this);
    }

    // -------------------------------------------------------------------------
    // XXX: Query Object Model
    // -------------------------------------------------------------------------

    @Override
    public final Configuration $configuration() {<nl>
        return new Meta(configuration, sources);
    <|file_separator|>class Source.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class Source {

    private final String name;
    private final String url;
    private final String[] tags;

    Source(String name, String url, String[] tags) {
        this.name = name;
        this.url = url;
        this.tags = tags;
    }

    public final String getName() {
        return name;
    }

    public final String getUrl() {
        return url;
    }

    public final String[] getTags() {
        return tags;
    }
}<|file_separator|>class MetaProvider.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public interface MetaProvider {

    Meta provide();
}<|file_separator|>class Meta.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class Meta {

    private final Configuration configuration;
    private final Source[]      sources;

    Meta(Configuration configuration, Source... sources) {
        this.configuration = configuration;
        this.sources = sources;
    }

    public final Configuration getConfiguration() {
        return configuration;
    }

    public final Source[] getSources() {
        return sources;
    }
}<|file_separator|><nl>
        ctx.visit(N_TO_CHAR).sql('(').visit(value).sql(',').visit(formatMask).sql(')');
    <|file_separator|><nl>
        return udt.getRecordType();
    <|file_separator|><nl>
        ctx.accept(this);
    <|file_separator|>class Select
extends
    AbstractQueryPart
{

    final Select<?> query;

    Select(
        Select<?> query
    ) {

        this.query = query;
    }

    // -------------------------------------------------------------------------
    // XXX: QueryPart API
    // -------------------------------------------------------------------------



    @Override
    final boolean isNullable() {
        return false;
    }

    @Override
    public final void accept(Context<?> ctx) {
        ctx.accept(this);
    }














    // -------------------------------------------------------------------------
    // XXX: Query Object Model
    // -------------------------------------------------------------------------

    @Override
    public final Select<?> $arg1() {
        return query;
    }

    @Override
    public final QOM.Select $arg1(Select<?> newValue) {
        return $constructor().apply(newValue);
    }

    @Override
    public final Function1<? super Select<?>, ? extends QOM.Select> $constructor() {
        return (a1) -> new Select(a1);
    }

    // -------------------------------------------------------------------------
    // XXX: The Object API
    // -------------------------------------------------------------------------

    @Override
    public boolean equals(Object that) {
        if (that instanceof QOM.Select o) {
            return
                StringUtils.equals($query(), o.$query())
            ;
        }
        else
            return super.equals(that);
    }
}<|file_separator|>class Select
extends
    AbstractQueryPart
{

    final Select<?> query;

    Select(
        Select<?> query
    ) {

        this.query = query;
    }

    // -------------------------------------------------------------------------
    // XXX:<nl>
        switch (ctx.family()) {












            case POSTGRES:
                ctx.add(this);
                break;






            case CLICKHOUSE:
                ctx.add(this);
                break;

            case FIREBIRD:
                ctx.add(this);
                break;






            case H2:
                ctx.add(this);
                break;

            case DUCKDB:
            case HSQLDB:
            case IGNITE:
            case MARIADB:
            case MYSQL:
            case TRINO:
                ctx.add(this);
                break;









            case SQLITE:
                ctx.add(this);
                break;









            default:
                ctx.add(this);
                break;
        }
    <|file_separator|><nl>
        return true;
    <|file_separator|><nl>
        if (ctx.family() == DERBY || ctx.family() == DUCKDB || ctx.family() == FIREBIRD || ctx.family() == MARIADB || ctx.family() == MYSQL || ctx.family() == SQLITE)
            acceptStandard(ctx);
        else if (ctx.family() == H2 || ctx.family() == HSQLDB)
            acceptEmulation(ctx);
        else
            throw new IllegalArgumentException("Unsupported family: " + ctx.family());
    <|file_separator|><nl>
        ctx.push(this);
        arg1.accept(ctx);
        arg2.accept(ctx);
        ctx.pop();
    }

    @Override
    public final String toString(Context<?> ctx) {
        return
            "(" +
            arg1.toString(ctx) +
            " XOR " +
            arg2.toString(ctx) +
            ")"
        ;
    }

    @Override
    public final String toSQL(Context<?> ctx) {
        return
            "(" +
            arg1.toSQL(ctx) +
            " XOR " +
            arg2.toSQL(ctx) +
            ")"
        ;
    }

    @Override
    public final String toSQL(Context<?> ctx, boolean withParentheses) {
        return
            "(" +
            arg1.toSQL(ctx, withParentheses) +
            " XOR " +
            arg2.toSQL(ctx, withParentheses) +
            ")"
        ;
    }

    @Override
    public final String toSQL(Context<?> ctx, boolean withParentheses, boolean withAlias) {
        return
            "(" +
            arg1.toSQL(ctx, withParentheses, withAlias) +
            " XOR " +
            arg2.toSQL(ctx, withParentheses, withAlias) +
            ")"
        ;
    }

    @Override
    public final String toSQL(Context<?> ctx, boolean withParentheses, boolean withAlias, boolean withAliasParentheses) {
        return
            "(" +
            arg1.toSQL(ctx, withParentheses, withAlias) +
            " XOR " +
            arg2.toSQL(ctx, withParentheses, withAlias) +
            <nl>
        if (commits == null) {
            commits = new ArrayList<CommitType>();
        }
        return commits;
    <|file_separator|>class MigrationType.java
<|fim_prefix|><|fim_suffix|>
        if (getClass()!= that.getClass()) {
            return false;
        }
        MigrationType other = ((MigrationType) that);
        if (id == null) {
            if (other.id!= null) {
                return false;
            }
        } else {
            if (!id.equals(other.id)) {
                return false;
            }
        }
        if (name == null) {
            if (other.name!= null) {
                return false;
            }
        } else {
            if (!name.equals(other.name)) {
                return false;
            }
        }
        if (type == null) {
            if (other.type!= null) {
                return false;
            }
        } else {
            if (!type.equals(other.type)) {
                return false;
            }
        }
        return true;
    }

    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = ((prime*result)+((id == null)? 0 :id.hashCode()));
        result = ((prime*result)+((name == null)? 0 :name.hashCode()));
        result = ((prime*result)+((type == null)? 0 :type.hashCode()));
        return result;
    }

}<|fim_middle|>class MigrationType implements Serializable, XMLAppendable
{

    private final static long serialVersionUID = 31900L;
    @XmlAttribute(name = "id")
    protected String id;
    @XmlAttribute(<nl>
        throw new UnsupportedOperationException("Not supported yet.");
    <|file_separator|><nl>
        if (list == null)
            return "null";

        StringWriter sw = new StringWriter();
        try {
            writeJSONString(list, sw);
        } catch (IOException e) {
            throw new AssertionError(e);
        }
        return sw.toString();
    <|file_separator|><nl>
        return getDelegate().setStatementTimeout(timeout);
    <|file_separator|><nl>
        return s -> {
            if (log.isDebugEnabled())
                log.debug("Connection::close");

            getDelegate().close().subscribe(s);
        };
    <|file_separator|><nl>
        return fTest.toString();
    <|file_separator|><nl>
        sorter.apply(fRunner);
    <|file_separator|><nl>
        return result.getFailures().size();
    <|file_separator|><nl>
        final List<Class<?>> filtered = new ArrayList<>();
        for (final Class<?> clazz : classes) {
            if (!Modifier.isAbstract(clazz.getModifiers())) {
                filtered.add(clazz);
            }
        }
        return filtered.toArray(new Class<?>[filtered.size()]);
    <|file_separator|><nl>
        objectOutputStream.defaultWriteObject();
    <|file_separator|><nl>
        if (Math.abs(expected - actual) > fDelta) {
            throw new AssertionError("Expected " + expected + " but was " + actual);
        }
    <|file_separator|><nl>
        return new RuleChain(Collections.singletonList(outerRule));
    <|file_separator|><nl>
        for (TestRule rule : rules) {
            result = rule.apply(result, description);
        }
        return result;
    <|file_separator|><nl>
        if (klass == null) {
            return new Class<?>[0];
        }
        SuiteClasses suiteClasses = klass.getAnnotation(SuiteClasses.class);
        if (suiteClasses == null) {
            return new Class<?>[0];
        }
        return suiteClasses.value();
    <|file_separator|><nl>
        junit.textui.TestRunner.run(suite());
    <|file_separator|><nl>
        try {
            assertEquals("woops!", "a", "b");
        } catch (ComparisonFailure e) {
            if (!e.toString().startsWith("junit.framework.ComparisonFailure: woops!")) {
                fail("Unexpected message: " + e);
            }
            return;
        }
        fail();
    <|file_separator|><nl>
        try {
            assertEquals(Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY, 0.0);
        } catch (AssertionFailedError e) {
            return;
        }
        fail();
    <|file_separator|><nl>
        // do nothing
    <|file_separator|><nl>
        TestCase test = new TestCase("noop") {
            @Override
            public void runTest() {
                fail();
            }
        };
        test.run(fResult);
        assertEquals(1, fFailureCount);
        assertEquals(1, fEndCount);
    <|file_separator|><nl>
        return (ArrayComparisonFailure) Class.forName(fileName).newInstance();
    <|file_separator|><nl>
            <|file_separator|><nl>
        return new Statement() {
            public void evaluate() throws Throwable {
                log.append("Starting ").append(name).append("\n");
                try {
                    base.evaluate();
                } finally {
                    log.append("Finished ").append(name).append("\n");
                }
            }
        };
    <|file_separator|><nl>
            assertEquals("testA", name.getMethodName());
        <|file_separator|><nl>
            assumeTrue("test skipped", false);
        }
<|file_separator|><nl>
        UnconstructableExample example = new UnconstructableExample();
    }
<|file_separator|><nl>
        assertTrue(Description.createTestDescription(getClass(), "a").equals(Description.createTestDescription(getClass(), "a")));
    <|file_separator|><nl>
        try {
            Assume.assumeFalse(true);
            fail("should throw AssumptionViolatedException");
        } catch (AssumptionViolatedException e) {
            assertEquals("got: <true>, expected: is <false>", e.getMessage());
        }
    }
}
<|file_separator|><nl>
        Assume.assumeTrue(true);
    }

    /**
     * Simple class that SHOULD fail because no parameters are met.
     */
    public static class TheoryWithNoUnassumedParameters {

        @Theory
        public void theoryWithNoUnassumedParameters(boolean value) {
            Assume.assumeTrue(value);
        }
    <|file_separator|><nl>
        String name = "stringDatapoint";
        Object value = new Object() {
            @Override
            public String toString() {
                throw new RuntimeException();
            }
        };

        PotentialAssignment assignment = PotentialAssignment.forValue(name, value);

        assertEquals("stringDatapoint <from stringDatapoint>", assignment.getDescription());
    <|file_separator|><nl>
        var dataPointMethodsMustBeStatic = new DataPointMethodsMustBeStatic();
        Assert.AreEqual(1, dataPointMethodsMustBeStatic.singleDataPointMethod());
        Assert.AreEqual(new int[] { 1, 2, 3 }, dataPointMethodsMustBeStatic.dataPointArrayMethod());
    }<|file_separator|><nl>
        assertEquals(1, AllJUnit4.suite().countTestCases());
    }<|file_separator|><nl>
        return new ReverseAlphanumericOrdering();
    <|file_separator|><nl>
        log += " methodBlockAfterFireTestStarted";
    }
<|file_separator|><nl>
        assertEquals("Enclosing", JUnitCore.runClasses(Enclosing.class).getNames()[0]);
    }
<|file_separator|><nl>
            Thread.currentThread().interrupt();
        <|file_separator|><nl>
        assertThat(exceptionMessageFrom(BadBeforeMethodWithLegacyRunner.class), containsString("Legacy runner"));
    }
<|file_separator|><nl>
        writeLock.lock();
        try {
            stateCache.put(key, new CacheState(value, timeout));
        } finally {
            writeLock.unlock();
        }
    <|file_separator|><nl>
        return AuthUser.builder()
            .id(authToken.getIdToken())
            .name(authToken.getIdToken())
            .email(authToken.getIdToken())
            .avatar(authToken.getIdToken())
            .build();
    <|file_separator|><nl>
        Map<String, String> params = new HashMap<>(7);
        params.put("app_key", config.getClientId());
        params.put("app_secret", config.getClientSecret());
        params.put("grant_type", "authorization_code");
        params.put("code", authCallback.getCode());
        params.put("redirect_uri", config.getRedirectUri());
        String response = new HttpUtils(config.getHttpConfig()).post(source.token(), params, false).getBody();
        JSONObject object = JSONObject.parseObject(response);

        this.checkResponse(object);

        return AuthToken.builder()
            .accessToken(object.getString("access_token"))
            .expireIn(object.getIntValue("expires_in"))
            .refreshToken(object.getString("refresh_token"))
            .scope(object.getString("scope"))
            .openId(object.getString("open_id"))
            .build();
    <|file_separator|><nl>
        return source.userInfo();
    <|file_separator|><nl>
        try {
            return InetAddress.getLocalHost().getHostAddress();
        } catch (Exception e) {
            return "127.0.0.1";
        }
    <|file_separator|><nl>
        if (codeChallengeMethod == null) {
            codeChallengeMethod = "plain";
        }
        if (codeChallengeMethod.equals("plain")) {
            return codeVerifier;
        } else if (codeChallengeMethod.equals("s256")) {
            return Base64Utils.encodeUrlSafe(MessageDigestUtil.sha256(codeVerifier));
        }
        return null;
    }

    public static String generateCodeChallenge(String codeVerifier) {
        return generateCodeChallenge("plain", codeVerifier);
    }

    public static String newStringUtf8(byte[] bytes) {
        return new String(bytes, StandardCharsets.UTF_8);
    <|file_separator|><nl>
        return UUID.randomUUID().toString();
    }

    /**
     * copy from micahttps://github.com/lets-mica/mica/blob/master/mica-core/src/main/java/net/dreamlu/mica/core/utils/StringUtil.java#L335
     * <p>
     * mica uuidhttps://github.com/lets-mica/mica-jmh/wiki/uuid
     *
     * @return UUID
     */
    public static String getUUID(String prefix) {
        return prefix + UUID.randomUUID().toString();
    }

    /**
     * copy from micahttps://github.com/lets-mica/mica/blob/master/mica-core/src/main/java/net/dreamlu/mica/core/utils/StringUtil.java#L335
     * <p>
     * mica uuidhttps://github.com/lets-mica/mica-jmh/wiki/uuid
     *
     * @return UUID
     */
    public static String getUUID(String prefix, String suffix) {
        return prefix + UUID.randomUUID().toString() + suffix;
    }

    /**
     * copy from micahttps://github.com/lets-mica/mica/blob/master/mica-core/src/main/java/net/dreamlu/mica/core/utils/StringUtil.java#L335
     * <p>
     * mica uuidhttps://github.com/lets-mica/mica-jmh/wiki/uuid
     *
     * @return UUID
     */
    public static String getUUID(String prefix, String suffix, String separator) {
        return prefix + UUID.randomUUID().toString() + separator + suffix;
    }

    /**
     * copy from<nl>
        return super.onUnsecuredContent(jwt);
    <|file_separator|><nl>
        return Encoders.BASE64.decode(encoded);
    <|file_separator|><nl>
        return Encoders.BASE64URL.encode(data);
    <|file_separator|><nl>
        return get(COMPRESSION_ALGORITHM);
    }

    @Override
    public String getDeprecatedCompressionAlgorithm() {
        return get(DEPRECATED_COMPRESSION_ALGORITHM);
    <|file_separator|><nl>
        return new GZIPOutputStream(out);
    <|file_separator|><nl>
        this.deserializer = reader;
        return self();
    <|file_separator|><nl>
        count.addAndGet(n);
    <|file_separator|><nl>
                return copy(in, out, buffer);
            <|file_separator|><nl>
        super.write(idx);
        this.other.write(idx);
    <|file_separator|><nl>
        Assert.notNull(bigInt, "BigInteger cannot be null.");
        Assert.isTrue(bigInt.compareTo(BigInteger.ZERO) >= 0, NEGATIVE_MSG);
        return bigInt.toByteArray();
    <|file_separator|><nl>
        if (value instanceof Collection) {
            return toElementList((Collection<?>) value);
        }
        return null;
    <|file_separator|><nl>
        return value;
    <|file_separator|><nl>
        return String.format(msg, args);
    <|file_separator|><nl>
        return new Function<T, R>() {
            @Override
            public R apply(T t) {
                for (Function<T, R> fn : fns) {
                    try {
                        return fn.apply(t);
                    } catch (Exception e) {
                        // ignore
                    }
                }
                return null;
            }
        };
    <|file_separator|><nl>
        return "RedactedSupplier{" +
                "value=" + value +
                '}';
    <|file_separator|><nl>
        return type.cast(o);
    <|file_separator|><nl>
        return (byte[])Arrays.copy(this.context.getX509Sha256Thumbprint());
    <|file_separator|>class JwkContext<K extends Key>.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class JwkContext<K extends Key> {

    private final K key;
    private final String publicKeyUse;
    private final URI x509Url;
    private final List<X509Certificate> x509Chain;
    private final byte[] x509Sha1Thumbprint;
    private final byte[] x509Sha256Thumbprint;

    JwkContext(K key, String publicKeyUse, URI x509Url, List<X509Certificate> x509Chain, byte[] x509Sha1Thumbprint, byte[] x509Sha256Thumbprint) {
        this.key = key;
        this.publicKeyUse = publicKeyUse;
        this.x509Url = x509Url;
        this.x509Chain = x509Chain;
        this.x509Sha1Thumbprint = x509Sha1Thumbprint;
        this.x509Sha256Thumbprint = x509Sha256Thumbprint;
    }

    public K getKey() {
        return this.key;
    }

    public String getPublicKeyUse() {
        return this.publicKeyUse;
    }

    public URI getX509Url() {
        return this.x509Url;
    }

    public List<X509Certificate> getX509Chain() {
        return this.x509Chain;
    }

    public byte[] getX509Sha1Thumbprint() {
        <nl>
                return fn.apply(instance);
            <|file_separator|><nl>
        return get(JwkConverter.JWK_CLASS);
    <|file_separator|><nl>
        return this.header;
    <|file_separator|><nl>
                if (SPEC == null) {
                    cipher.init(Cipher.WRAP_MODE, kek);
                } else {
                    cipher.init(Cipher.WRAP_MODE, kek, SPEC);
                }
                return cipher.wrap(cek);
            <|file_separator|><nl>
        return "EdDSA";
    }

    @Override
    protected String getJcaName(Key key) {
        return "EdDSA";
    }

    @Override
    protected String getJcaName(Key key, boolean signing) {
        return "EdDSA";
    }

    @Override
    protected String getJcaName(Key key, boolean signing, boolean detached) {
        return "EdDSA";
    }

    @Override
    protected String getJcaName(Key key, boolean signing, boolean detached, boolean unencoded) {
        return "EdDSA";
    }

    @Override
    protected String getJcaName(Key key, boolean signing, boolean detached, boolean unencoded, boolean uncompressed) {
        return "EdDSA";
    }

    @Override
    protected String getJcaName(Key key, boolean signing, boolean detached, boolean unencoded, boolean uncompressed, boolean uncompressedKey) {
        return "EdDSA";
    }

    @Override
    protected String getJcaName(Key key, boolean signing, boolean detached, boolean unencoded, boolean uncompressed, boolean uncompressedKey, boolean uncompressedKeyEncoded) {
        return "EdDSA";
    }

    @Override
    protected String getJcaName(Key key, boolean signing, boolean detached, boolean unencoded, boolean uncompressed, boolean uncompressedKey, boolean uncompressedKeyEncoded, boolean uncompressedKeyEncodedUncompressed) {
        return "EdDSA";
    }

    @Override
    protected String getJcaName(Key key, boolean signing, boolean detached, boolean unencoded, boolean uncompressed, boolean uncompressedKey, boolean uncompressedKeyEncoded, boolean uncompressedKeyEncodedUncompressed, boolean uncompressedKeyEncodedUncompressedUncompressed) {
        return "<nl>
        return new MalformedJsonException("JWK Set", t);
    }

    @Override
    protected JwkSet deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException {
        JwkSet jwkSet = new JwkSet();
        jp.nextToken();
        while (jp.getCurrentToken() != JsonToken.END_OBJECT) {
            String name = jp.getCurrentName();
            jp.nextToken();
            if (name.equals("keys")) {
                jwkSet.setKeys(this.deserializer.deserialize(jp, ctxt));
            } else {
                ctxt.handleUnexpectedToken(JwkSet.class, jp, name);
            }
            jp.nextToken();
        }
        return jwkSet;
    <|file_separator|><nl>
        return this.key;
    <|file_separator|><nl>
        return new SecretKeySpec(super.build().getEncoded(), "AES");
    <|file_separator|><nl>
        return new DefaultSecretJwk(ctx);
    <|file_separator|><nl>
        return Karate.run("classpath:features").relativeTo(getClass());
    <|file_separator|><nl>
        return StringUtils.countMatches(text, "\n");
    }<|file_separator|><nl>
        for (FeatureSection section : sections) {
            for (Step step : section.getSteps()) {
                if (step.getLine() == line) {
                    return step;
                }
            }
        }
        return null;
    <|file_separator|>class FeatureParser.java
<|fim_prefix|><|fim_suffix|>
        if (StringUtils.isBlank(feature.getName())) {
            feature.setName(feature.getNameAndDescription());
        }
        if (StringUtils.isBlank(feature.getDescription())) {
            feature.setDescription(feature.getNameAndDescription());
        }
        if (feature.isBackgroundPresent()) {
            feature.setBackground(Background.read(feature.getResource()));
        }
        for (FeatureSection section : feature.getSections()) {
            section.setIndex(feature.getSections().indexOf(section));
        }
    }

}<|fim_middle|>class FeatureParser {

    public static void parse(Feature feature) {
        if (feature.getTags() == null) {
            feature.setTags(new ArrayList());
        }
        if (feature.getSections() == null) {
            feature.setSections(new ArrayList());
        }
        if (feature.getPackageQualifiedName() == null) {
            feature.setPackageQualifiedName(feature.getResource().getPackageQualifiedName());
        }<|file_separator|>class Background.java
<|fim_prefix|><|fim_suffix|>

    public void setSteps(List<Step> steps) {
        this.steps = steps;
    }

    public int getLine() {
        return line;
    }

    public void setLine(int line) {
        this.line = line;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String<nl>
        return String.format("FeatureCall(%s, %s, %d, %s)", feature, callTag, callLine, callName);
    <|file_separator|>class Feature.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>class Feature {
    
    public final String name;
    public final String description;
    public final List<Scenario> scenarios;
    
    public Feature(String name, String description, List<Scenario> scenarios) {
        this.name = name;
        this.description = description;
        this.scenarios = scenarios;
    }
    
    @Override
    public String toString() {
        return String.format("Feature(%s, %s, %s)", name, description, scenarios);
    }
    
}<|file_separator|>class Scenario.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>class Scenario {
    
    public final String name;
    public final String description;
    public final List<Step> steps;
    
    public Scenario(String name, String description, List<Step> steps) {
        this.name = name;
        this.description = description;
        this.steps = steps;
    }
    
    @Override
    public String toString() {
        return String.format("Scenario(%s, %s, %s)", name, description, steps);
    }
    
}<|file_separator|>class Step.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>class Step {
    
    public final String name;
    public final String description;
    public final String expectedResult;
    
    public Step(String name, String description, String expectedResult) {
        this.name = name;
        this.description = description;
        this.expectedResult = expectedResult;
    }
    
    @Override
    public String toString() {
        return String.format("Step(%s, %s, %<nl>
        return find("select").select(value);
    <|file_separator|><nl>
        int flags = 0;
        if (control) {
            flags |= Keys.CODE_CONTROL;
        }
        if (alt) {
            flags |= Keys.CODE_ALT;
        }
        if (shift) {
            flags |= Keys.CODE_SHIFT;
        }
        if (meta) {
            flags |= Keys.CODE_META;
        }
        return flags;
    }

    public void setRelease(boolean release) {
        this.release = release;
    }

    public boolean isRelease() {
        return release;
    <|file_separator|><nl>
        return Collections.EMPTY_LIST;
    }

    @Override
    public String getAttribute(String name) {
        return null;
    <|file_separator|><nl>
        return JsEngine.execute(this, arg);
    <|file_separator|>class JsEngine.Instantiable.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class JsEngine.Instantiable {
    
    public static void main(String[] args) {
        JsEngine.execute(new JsLambda(new JsString("Hello World")));
    }

}<|file_separator|>class JsEngine.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class JsEngine {

    public static void execute(JsFunction f, Object arg) {
        f.apply(arg);
    }

    public static void execute(JsFunction f) {
        f.run();
    }

}<|file_separator|>class JsFunction.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class JsFunction {

    public static class Instantiable {
        
        public static void main(String[] args) {
            JsFunction f = new JsFunction(new JsString("Hello World"));
            JsEngine.execute(f);
        }

    }

    public static class Consumer {
        
        public void accept(Object arg);

    }

    public static class Runnable {
        
        public void run();

    }

    public static class Function {
        
        public Object apply(Object arg);

    }

    public static class Value {
        
        public Object get();

    }

    public static class String implements Value {
        
        public String(String s) {
            this.s = s;
        }

        public String get() {
            return s;
        }

        private String s;

    }

    public static class Lambda extends JsFunction.Instantiable implements Consumer, Function, Runnable {

        public Lambda(Value v) {
            super(v);
        }

        @Override
        public void accept(Object arg) {
            JsEngine.execute(<nl>
                            c.pipeline().addLast(new WebSocketServerProtocolHandler(config));
                            c.pipeline().addLast(handler);
                        <|file_separator|><nl>
        wrapped.process(templateSpec, context, writer);
    }

    public void process(String template, Writer writer) {
        process(template, TemplateContext.LOCALE_US, writer);
    }

    public void process(String template, IContext context, Writer writer, Map<String, Object> attrs) {
        process(template, context, writer, attrs, null);
    }

    public void process(String template, IContext context, Writer writer, Map<String, Object> attrs, Map<String, Object> globalAttrs) {
        TemplateSpec templateSpec = new TemplateSpec(template, TemplateMode.HTML);
        process(templateSpec, context, writer, attrs, globalAttrs);
    }

    public void process(TemplateSpec templateSpec, IContext context, Writer writer, Map<String, Object> attrs, Map<String, Object> globalAttrs) {
        wrapped.process(templateSpec, context, writer, attrs, globalAttrs);
    }

    public void process(String template, Writer writer, Map<String, Object> attrs) {
        process(template, TemplateContext.LOCALE_US, writer, attrs, null);
    }

    public void process(String template, Writer writer, Map<String, Object> attrs, Map<String, Object> globalAttrs) {
        process(template, TemplateContext.LOCALE_US, writer, attrs, globalAttrs);
    }

    public void process(String template, IContext context, Writer writer, Map<String, Object> attrs, Map<String, Object> globalAttrs, Map<String, Object> localAttrs) {
        process(template, context, writer, attrs, globalAttrs, localAttrs, null);
    }

    public void process(String template, IContext context, Writer writer, Map<String, Object<nl>
        this.config = config;
    <|file_separator|><nl>
        response = handle().get();
        assertEquals(mock.get().getResponses().get(0).getStatus(), response.getStatus());
    <|file_separator|><nl>
        Payments payments = new Payments();
        payments.pay(100);
    <|file_separator|><nl>
        return sb.toString();
    <|file_separator|><nl>
        FeatureResult result = result("multi-scenario.feature");
        assertEquals(0, result.getFailedCount());
        assertEquals(4, result.getScenarioCount());
        String contents = xml(result);

        // skip-pass and skip-fail both should have all steps as skipped
        assertTrue(contents.contains("* karate.abort() .......................................................... passed"));
        assertTrue(contents.contains("* assert a == 1 ........................................................... skipped"));
        assertTrue(contents.contains("* assert a == 2 ........................................................... skipped"));
        assertTrue(contents.contains("* assert a == 5 ........................................................... passed"));

        // noskip should have both steps as passed
        assertTrue(contents.contains("Then assert a != 3 ........................................................ passed"));
        assertTrue(contents.contains("And assert a != 4 ......................................................... passed"));
    <|file_separator|><nl>
        Map<String, Object> result = Runner.runFeature("classpath:com/intuit/karate/core/runner/run-arg.feature", Collections.singletonMap("foo", "hello"), true);
        assertEquals("hello world", result.get("message"));
        assertEquals("classpath:com/intuit/karate/core/runner/run-arg.feature", result.get("configSource"));
    <|file_separator|><nl>
        runtimeHookTracker.get("beforeScenario").compute(sr.scenario.getName(), (key, count) -> count == null ? 1 : count + 1);
        return true;
    <|file_separator|><nl>
        String proxy = "http://localhost:8080";
        String url = "https://www.google.com";
        String result = Karate.run("karate-server-ssl.feature").relativeTo(getClass()).toString();
        logger.info("result: {}", result);
    <|file_separator|><nl>
        assertTrue(JsValue.of(true).truthy());
        assertFalse(JsValue.of(false).truthy());
        assertFalse(JsValue.of(null).truthy());
        assertFalse(JsValue.of(0).truthy());
        assertFalse(JsValue.of("").truthy());
    <|file_separator|><nl>
        final ByteArrayOutputStream outContent = new ByteArrayOutputStream();
        final PrintStream originalOut = System.out;
        Feature oFeature = Feature.read("classpath:com/intuit/karate/report/test.feature");
        Suite oSuite = new Suite(Runner.builder().karateEnv("TestEnv"));
        FeatureRuntime fr = FeatureRuntime.of(oSuite, new FeatureCall(oFeature));
        fr.run();
        Report oReport = SuiteReports.DEFAULT.featureReport(fr.suite, fr.result);
        File oFile = oReport.render("target/report");
        String sHtml = FileUtils.toString(oFile);
        assertTrue(sHtml.contains("<div id="nav-env">"));
        System.setOut(new PrintStream(outContent)); // Capture console output
        fr.suite.buildResults();
        assertTrue(outContent.toString().contains(" | env: TestEnv"));
        System.setOut(originalOut);  // restore console output
    <|file_separator|><nl>
        return scenario.getLine();
    <|file_separator|><nl>
        return new Scenario(feature, section, exampleIndex);
    <|file_separator|><nl>
        List<Map<String, Object>> rows = new ArrayList(this.rows.size());
        for (int i = 0; i < this.rows.size(); i++) {
            Map<String, Object> row = new HashMap();
            row.put("line", this.lineNumbers.get(i));
            row.put("row", this.rows.get(i));
            rows.add(row);
        }
        return rows;
    }
<|file_separator|><nl>
        List<Tag> tags = new ArrayList();
        for (List<Tag> list : lists) {
            tags.addAll(list);
        }
        return new Tags(tags);
    }<|file_separator|><nl>
        synchronized (this) {
            if (condition.test(dtm)) {
                if (dtm.isResultError()) {
                    logger.warn("devtools error: {}", dtm);
                } else {
                    logger.trace(">> notify: {}", dtm);
                }                
                lastSent = dtm;
                notify();
            } else {
                logger.trace(">> ignore: {}", dtm);
            }
        }
        return dtm;
    <|file_separator|>class DevToolsDriver.java
<|fim_prefix|><|fim_suffix|>
    
    public void setLogger(Logger logger) {
        this.logger = logger;
    }

    public void setOptions(DriverOptions options) {
        this.options = options;
    }

    public void setWait(DevToolsWait wait) {
        this.wait = wait;
    }

    public void setSession(DevToolsSession session) {
        this.session = session;
    }

    public void setSession(DevToolsSession session, DevToolsWait wait) {
        this.session = session;
        this.wait = wait;
    }

    public void setSession(DevToolsSession session, DevToolsWait wait, DevToolsDriverOptions options) {
        this.session = session;
        this.wait = wait;
        this.options = options;
    }

    public void setSession(DevToolsSession session, DevToolsWait wait, DevToolsDriverOptions options, Logger logger) {
        this.session = session;
        this.wait = wait;
        this.options = options;
        this.logger = logger;
    }

    public void setSession(DevToolsSession session, DevToolsWait wait, DevToolsDriverOptions options, Logger logger, DevToolsDriverOptions.SessionOptions sessionOptions) {
        <nl>
        return new MissingFinder(this);
    <|file_separator|><nl>
        array[(int) index] = value;
    <|file_separator|><nl>
        return list.removeAll(c);
    <|file_separator|><nl>
        sessionStore = value;
        return this;
    <|file_separator|>class ServerContext.java
<|fim_prefix|><|fim_suffix|>

    public ServerContext(ServerConfig config, Request request) {
        this.config = config;
        this.request = request;
        this.response = new Response();
        this.session = config.isUseGlobalSession() ? ServerConfig.GLOBAL_SESSION : null;
    }

    public ServerConfig getConfig() {
        return config;
    }

    public Request getRequest() {
        return request;
    }

    public Response getResponse() {
        return response;
    }

    public Session getSession() {
        return session;
    }

    public void setSession(Session value) {
        session = value;
    }

    public void setLockNeeded(boolean value) {
        lockNeeded = value;
    }

    public void setHttpGetAllowed(boolean value) {
        httpGetAllowed = value;
    }

    public void setHttpPostAllowed(boolean value) {
        httpPostAllowed = value;
    }

    public void setHttpPutAllowed(boolean value) {
        httpPutAllowed = value;
    }

    public void setHttpDeleteAllowed(boolean value) {
        httpDeleteAllowed = value;
    }

    public void setHttpHeadAllowed(boolean value) {
        httpHeadAllowed = value;
    }

    public void setHttpPatchAllowed(boolean value) {
        httpPatchAllowed = value;
    }

    public void setHttpOptionsAllowed(boolean value) {
        httpOptionsAllowed = value;
    }

    public void setHttpTraceAllowed(boolean value) {
        httpTraceAllowed = value;
    }

    public void setHttpConnectAllowed(boolean value) {
        httpConnectAllowed = value<nl>
        if (src == null) {
            return;
        }
        try {
            String resourcePath = resourceResolver.resolveResource(ctx.getVariableResolver(), src, true).getPath();
            if (resourcePath.startsWith(hostContextPath)) {
                resourcePath = resourcePath.substring(hostContextPath.length());
            }
            sh.setAttribute(SRC, resourcePath);
        } catch (ResourceNotFoundException e) {
            logger.error("Resource not found: " + src, e);
        }
    <|file_separator|><nl>
        if (model instanceof KaSetElem) {
            KaSetElem kaSetElem = (KaSetElem) model;
            if (kaSetElem.getSet() != null) {
                sh.addModel(kaSetElem.getSet());
            }
        }
    <|file_separator|><nl>
        if (name.equals("html")) {
            return new TemplateResolution(
                this.resourceResolver.resolve(
                    this.devMode ? "classpath:/templates/html.ftl" : "classpath:/templates/html.ftl",
                    ec.getLocale(),
                    Collections.emptyMap()
                ),
                Collections.emptyMap()
            );
        }
        return null;
    <|file_separator|><nl>
        ConfigurableApplicationContext context = run(args);
        context.close();
    <|file_separator|><nl>
        registry.addHandler(handler(), "/ws").setAllowedOrigins("*");
    <|file_separator|><nl>
        if ("john".equals(signin.getUsername()) && "secret".equals(signin.getPassword())) {
            return "success";
        } else {
            return "failure";
        }
    <|file_separator|><nl>
        return new ResponseEntity<>(new ErrorResponse(ex.getMessage(), HttpStatus.NOT_FOUND), HttpStatus.NOT_FOUND);
    <|file_separator|><nl>
        Collection<File> jsonFiles = FileUtils.listFiles(new File(karateOutputPath), new String[] {"json"}, true);
        List<String> jsonPaths = new ArrayList(jsonFiles.size());
        jsonFiles.forEach(file -> jsonPaths.add(file.getAbsolutePath()));
        Configuration config = new Configuration(new File("target"), "demo");
        ReportBuilder reportBuilder = new ReportBuilder(jsonPaths, config);
        reportBuilder.generateReports();
    <|file_separator|><nl>
        try {
            HttpURLConnection connection = getConnection("/payment");
            connection.setRequestMethod("POST");
            connection.setDoOutput(true);
            connection.setRequestProperty("Content-Type", "application/json");
            connection.setRequestProperty("Accept", "application/json");
            connection.connect();
            try (OutputStream os = connection.getOutputStream()) {
                os.write(payment.toJson().getBytes());
            }
            try (BufferedReader br = new BufferedReader(new InputStreamReader(connection.getInputStream()))) {
                String line;
                StringBuilder response = new StringBuilder();
                while ((line = br.readLine()) != null) {
                    response.append(line);
                }
                return Payment.fromJson(response.toString());
            }
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    <|file_separator|><nl>
        this.id = id;
    <|file_separator|><nl>
        server.start();
        TestBase.runTest();
    <|file_separator|>class DemoMockProceedRunner.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

public class DemoMockProceedRunner {

    static MockServer server;

    @BeforeAll
    static void beforeAll() {
        int port = TestBase.startServer();
        server = MockServer
                .feature("classpath:mock/proxy/demo-mock-proceed.feature")
                .arg("demoServerPort", port)
                .http(0).build();
    }

    @AfterAll
    static void afterAll() {
        server.stop();
    }

    @Test
    void testParallel() {
        server.start();
        TestBase.runTest();
    }

}<|file_separator|><nl>
        TestService.test(context);
    <|file_separator|><nl>
        return port;
    }

    public void stop() {
        if (monitor != null) {
            monitor.stop();
        }
    }

    public void stopServer() throws Exception {
        stop();
        context.close();
    }

    public static void main(String[] args) throws Exception {
        new ServerStart().start(args, true);
    }

}

class ServerStartedInitializingBean {

    @Value("${local.server.port}")
    int localPort;

    public int getLocalPort() {
        return localPort;
    }

}

class ServerStop {

    @Value("${local.server.port}")
    int localPort;

    public void stopServer() throws Exception {
        HttpClient client = HttpClient.newHttpClient();
        HttpRequest request = HttpRequest.newBuilder()
                .uri(URI.create("http://localhost:" + localPort + "/stop"))
                .build();
        client.send(request, HttpResponse.BodyHandlers.discarding());
    }

}

class MonitorThread extends Thread {

    int port;
    Runnable stop;

    public MonitorThread(int port, Runnable stop) {
        this.port = port;
        this.stop = stop;
    }

    @Override
    public void run() {
        try {
            HttpClient client = HttpClient.newHttpClient();
            while (true) {
                HttpRequest request = HttpRequest.newBuilder()
                        .uri(URI.create("http://localhost:" + port + "/health"))
                        .build();
                HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
                if (response.statusCode() == 200) {
                    break;
                }
                Thread.sleep(1000);<nl>
        
    <|file_separator|><nl>
        
    <|file_separator|><nl>
        try {
            while (true) {
                BufferedImage bi = capture();
                recorder.record(bi);
                Thread.sleep(FRAME_INTERVAL);
            }
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    <|file_separator|><nl>
        OleAuto.INSTANCE.SysFreeString(sysAllocated);
    <|file_separator|>class ComAllocated.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public interface ComAllocated {
    
    Object value();
    void free();
    
}<|file_separator|>class ComAllocatedInt.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public interface ComAllocatedInt {
    
    int value();
    void free();
    
}<|file_separator|>class ComAllocatedInt32.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class ComAllocatedInt32 implements ComAllocatedInt {
    
    private static final Logger logger = LoggerFactory.getLogger(ComAllocatedInt32.class);
    
    private final int value;
    private final int sysAllocated;
    
    public ComAllocatedInt32(int value) {
        this.value = value;
        sysAllocated = OleAuto.INSTANCE.SysAllocInt32(value);
        if (logger.isTraceEnabled()) {
            logger.trace("allocated int32: {}", value);
        }
    }
    
    @Override
    public int value() {
        return sysAllocated;
    }
    
    @Override
    public void free() {
        OleAuto.INSTANCE.SysFreeInt32(sysAllocated);
    }
    
}<|file_separator|>class ComAllocatedInt64.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class ComAllocatedInt64 implements ComAllocatedInt {
    
    private static final Logger logger = LoggerFactory.getLogger(ComAllocatedInt64.class);
    
    private final long value;
    private final long sysAllocated;
    
    public ComAllocatedInt64(long value) {
        this.value = value;
        sysAllocated = OleAuto.INSTANCE.SysAllocInt64(value);
        if (logger.isTraceEnabled()) {
            logger.trace("allocated int64<nl>
        return variant.getValue();
    <|file_separator|>class ComAllocatedVarString implements ComAllocated {

    private final Variant.VARIANT variant;

    public ComAllocatedVarString(String value) {
        this.variant = new Variant.VARIANT.ByValue();
        variant.setValue(Variant.VT_BSTR, value);
    }

    @Override
    public Object value() {
        return variant.getValue();
    }

    @Override
    public void free() {
        // do nothing
    }

}<|file_separator|>class ComAllocatedVarDouble implements ComAllocated {

    private final Variant.VARIANT variant;

    public ComAllocatedVarDouble(double value) {
        this.variant = new Variant.VARIANT.ByValue();
        variant.setValue(Variant.VT_R8, value);
    }

    @Override
    public Object value() {
        return variant.getValue();
    }

    @Override
    public void free() {
        // do nothing
    }

}<|file_separator|>class ComAllocatedVarBool implements ComAllocated {

    private final Variant.VARIANT variant;

    public ComAllocatedVarBool(boolean value) {
        this.variant = new Variant.VARIANT.ByValue();
        variant.setValue(Variant.VT_BOOL, value);
    }

    @Override
    public Object value() {
        return variant.getValue();
    }

    @Override
    public void free() {
        // do nothing
    }

}<|file_separator|>class ComAllocatedVarVariant implements ComAllocated {

    private final Variant.VARIANT variant;

    public ComAllocatedVarVariant(Variant.VARIANT value) {
        this.variant = new Variant.VARIANT.ByValue();
        variant.setValue(Variant.VT_VARIANT, value);
    }

    @Override
    public Object value() {
        <nl>
        return getFunction(functionName, p.getPointer(0));
    <|file_separator|>class ComFunction.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class ComFunction {

    public final String name;
    public final String guid;
    public final String returnType;
    public final String[] parameterTypes;
    public final String[] parameterNames;
    public final String[] parameterGuids;
    public final String[] parameterNamesAndGuids;
    public final String[] parameterNamesAndGuidsAndTypes;
    public final String[] parameterNamesAndGuidsAndTypesAndReturn;
    public final String[] parameterNamesAndGuidsAndTypesAndReturnAndThis;
    public final String[] parameterNamesAndGuidsAndTypesAndReturnAndThisAndThisType;
    public final String[] parameterNamesAndGuidsAndTypesAndReturnAndThisAndThisTypeAndThisType;
    public final String[] parameterNamesAndGuidsAndTypesAndReturnAndThisAndThisTypeAndThisTypeAndThisType;
    public final String[] parameterNamesAndGuidsAndTypesAndReturnAndThisAndThisTypeAndThisTypeAndThisTypeAndThisType;
    public final String[] parameterNamesAndGuidsAndTypesAndReturnAndThisAndThisTypeAndThisTypeAndThisTypeAndThisTypeAndThisType;
    public final String[] parameterNamesAndGuidsAndTypesAndReturnAndThisAndThisTypeAndThisTypeAndThisTypeAndThisTypeAndThisTypeAndThisType;
    public final String[] parameterNamesAndGuidsAndTypesAndReturnAndThisAndThisTypeAndThisTypeAndThisTypeAndThisTypeAndThisTypeAndThisTypeAndThisType;
    public final String[] parameterNamesAndGuidsAndTypesAndReturnAndThisAndThisTypeAndThisTypeAndThisTypeAndThisTypeAndThisTypeAndThisTypeAndThisTypeAndThisType;
    public final String<nl>
        Map<String, Integer> map = LIBRARY.enumValueValues.get(name);
        if (map == null) {
            throw new RuntimeException("no such enum: " + name);
        }
        Integer value = map.get(key);
        if (value == null) {
            throw new RuntimeException("enum: " + name + " does not contain key: " + key);
        }
        return value;
    <|file_separator|><nl>
        return invokeForBool("CurrentVerticallyScrollable");
    <|file_separator|><nl>
        List<Chunk> chunks = new ArrayList<>();
        int pos = 0;
        while (pos < s.length()) {
            int nextSlash = s.indexOf(SLASH, pos);
            if (nextSlash == -1) {
                nextSlash = s.length();
            }
            chunks.add(new Chunk(pos == 0, s.substring(pos, nextSlash)));
            pos = nextSlash + 1;
        }
        return chunks;
    }
<|file_separator|><nl>
        logger.info("Starting WinRobotRunner");
        WinRobot winRobot = new WinRobot();
        winRobot.run();
    <|file_separator|><nl>
        Scanner in = new Scanner(System.in);
        Accumulator acc = new Accumulator();
        while (in.hasNext()) {
            acc.addDataValue(in.nextDouble());
        }
        System.out.println(acc);
    <|file_separator|><nl>
        In in = new In(args[0]);
        EdgeWeightedDigraph G = new EdgeWeightedDigraph(in);
        AcyclicSP sp = new AcyclicSP(G, 0);
        for (int v = 0; v < G.V(); v++) {
            if (sp.hasPathTo(v)) {
                StdOut.printf("%d to %d (%d):  ", 0, v, (int) sp.distTo(v));
                for (DirectedEdge e : sp.pathTo(v)) {
                    StdOut.print(e + " ");
                }
                StdOut.println();
            }
            else {
                StdOut.printf("%d to %d (-):  not connected\n", 0, v);
            }
        }
    <|file_separator|><nl>
        int m = pat.length();
        int n = txt.length();
        int skip;
        for (int i = 0; i <= n - m; i += skip) {
            skip = 0;
            for (int j = m-1; j >= 0; j--) {
                if (pat.charAt(j) != txt.charAt(i+j)) {
                    skip = Math.max(1, j - right[txt.charAt(i+j)]);
                    break;
                }
            }
            if (skip == 0) return i;    // found
        }
        return n;                       // not found
    <|file_separator|><nl>
        Date d1 = new Date(1, 1, 2017);
        Date d2 = new Date(1, 1, 2017);
        Date d3 = new Date(1, 1, 2016);
        System.out.println(d1.equals(d2));
        System.out.println(d1.equals(d3));
        System.out.println(d1.hashCode());
        System.out.println(d1.hashCode());
    <|file_separator|><nl>
        // TODO: Implement
    <|file_separator|><nl>
        int V = StdIn.readInt();
        Digraph G = new Digraph(V);
        while (!StdIn.isEmpty()) {
            int v = StdIn.readInt();
            int w = StdIn.readInt();
            G.addEdge(v, w);
        }
        int s = StdIn.readInt();
        DirectedDFS dfs = new DirectedDFS(G, s);
        for (int v = 0; v < G.V(); v++) {
            if (dfs.marked(v)) StdOut.print(v + " ");
        }
        StdOut.println();
    <|file_separator|>class DepthFirstOrder.java
<|fim_prefix|><|fim_suffix|>
    public Iterable<Integer> reversePost() {
        return reversePost;
    }

    // throw an IllegalArgumentException unless {@code 0 <= v < V}
    private void validateVertex(int v) {
        int V = marked.length;
        if (v < 0 || v >= V)
            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V-1));
    }

    // throw an IllegalArgumentException if vertices is null, has zero vertices,
    // or has a vertex not between 0 and V-1
    private void validateVertices(Iterable<Integer> vertices) {
        if (vertices == null) {
            throw new IllegalArgumentException("argument is null");
        }
        int vertexCount = 0;
        for (Integer v : vertices) {
            vertexCount++;
            if (v == null) {
                throw new IllegalArgumentException("vertex is null");
            }
            validateVertex(v);
        }
        if (vertexCount == 0) {
            throw new IllegalArgumentException("zero vertices");
        }
    }<nl>
        return w;
    <|file_separator|><nl>
        // if (args.length != 1) {
        //     throw new IllegalArgumentException("Usage: java DoublingRatio N");
        // }
        // int N = Integer.parseInt(args[0]);
        // StdOut.println("N\ttime (s)\tN/time");
        // for (int n = 250; n <= N; n += n) {
        //     StdOut.printf("%d\t%f\t%f\n", n, DoublingRatio.timeTrial(n), n / DoublingRatio.timeTrial(n));
        // }
    <|file_separator|><nl>
        Edge e = new Edge(1, 2, 1.0);
        System.out.println(e);
    <|file_separator|><nl>
        double totalWeight = 0.0;
        for (Edge e : edges()) {
            totalWeight += e.weight();
        }
        return weight() == totalWeight &&
                check(G, mst);
    }

    // check optimality conditions (takes time proportional to E lg* V)
    private boolean check(EdgeWeightedGraph G, Iterable<Edge> T) {
        double totalWeight = 0.0;
        for (Edge e : T) {
            totalWeight += e.weight();
        }
        for (Edge e : G.edges()) {
            int v = e.either(), w = e.other(v);
            if (!T.contains(e) && e.weight() > 0) {
                StdOut.printf("Edge %s not in MST\n", e);
                return false;
            }
            if (T.contains(e) && e.weight() != 0) {
                StdOut.printf("Edge %s in MST\n", e);
                return false;
            }
            if (marked[v] && marked[w] && e.weight() < 0) {
                StdOut.printf("Edge %s has negative weight\n", e);
                return false;
            }
        }
        for (int v = 0; v < G.V(); v++) {
            for (Edge e : G.adj(v)) {
                int w = e.other(v);
                if (e.weight() < 0) {
                    StdOut.printf("Edge %s has negative weight\n", e);
                    return false;
                }
            }
        }
        for (int v = 0; v < G.V(); v++)<nl>
        // TODO: Implement
    <|file_separator|><nl>
        int[] index = new int[a.length];
        for (int i = 0; i < a.length; i++) {
            index[i] = i;
        }
        sort(a, index, new int[a.length], 0, a.length-1);
        return index;
    <|file_separator|><nl>
        return new ListIterator();
    }
<|file_separator|><nl>
        out.println(x);
    <|file_separator|><nl>
        Stopwatch stopwatch = new Stopwatch();
        int n = Integer.parseInt(args[0]);
        double sum = 0;
        for (int i = 1; i <= n; i++) {
            sum += Math.sqrt(i);
        }
        System.out.println("Sum of the first " + n + " positive integers is " + sum);
        System.out.println("Elapsed time: " + stopwatch.elapsedTime() + " seconds");
    <|file_separator|><nl>
        return new RetryInterceptor();
    }

    @Bean
    @ConditionalOnMissingBean
    public RetryInterceptorInterceptor retrofitRetryInterceptorInterceptor() {
        return new RetryInterceptorInterceptor();
    }
<|file_separator|><nl>
        return true;
    <|file_separator|><nl>
        System.out.println("Hello World!");
    <|file_separator|><nl>
        return null;
    <|file_separator|><nl>
        SqlSessionFactoryBean sqlSessionFactory = new SqlSessionFactoryBean();
        sqlSessionFactory.setDataSource(dataSource);
        sqlSessionFactory.setTypeAliasesPackage(MODEL_PACKAGE);
        return sqlSessionFactory.getObject();
    <|file_separator|><nl><nl>
        String token = request.getHeader(LOGIN_TOKEN_KEY);
        if (token != null) {
            return token;
        }
        return super.getSessionId(request, response);
    <|file_separator|><nl>
        List<Permission> permissions = new ArrayList<>();
        for (String className : context.getBeanDefinitionNames()) {
            if (className.startsWith(basicPackage)) {
                Class<?> clazz = context.getType(className);
                if (clazz.isAnnotationPresent(Controller.class)) {
                    Permission permission = clazz.getAnnotation(Permission.class);
                    permissions.add(permission);
                }
            }
        }
        return permissions;
    <|file_separator|><nl><nl>
        Object error = validate(brand);
        if (error != null) {
            return error;
        }
        brandService.update(brand);
        return ResponseUtil.ok(brand);
    <|file_separator|><nl>
        return adminOrderService.reply(body);
    <|file_separator|><nl>
        if (file == null) {
            return ResponseUtil.badArgument();
        }
        String key = file.getOriginalFilename();
        String name = file.getOriginalFilename();
        String type = file.getContentType();
        long size = file.getSize();
        String path = storageService.upload(file);
        LitemallStorage litemallStorage = new LitemallStorage();
        litemallStorage.setKey(key);
        litemallStorage.setName(name);
        litemallStorage.setType(type);
        litemallStorage.setSize(size);
        litemallStorage.setPath(path);
        litemallStorage.setAddTime(new Date());
        litemallStorageService.save(litemallStorage);
        return ResponseUtil.ok(litemallStorage);
    <|file_separator|><nl>
        Page<LitemallUser> pageList = userService.list(username, mobile, page, limit, sort, order);
        return ResponseUtil.ok(pageList);
    }
    @RequiresPermissions("admin:user:list")
    @RequiresPermissionsDesc(menu = {"", ""}, button = "")
    @GetMapping("/add")
    public Object userAdd() {
        return ResponseUtil.ok();
    }
    @RequiresPermissions("admin:user:list")
    @RequiresPermissionsDesc(menu = {"", ""}, button = "")
    @PostMapping("/add")
    public Object userAdd(@RequestBody LitemallUser user) {
        return ResponseUtil.ok(userService.save(user));
    <|file_separator|><nl>
        String name = environment.getProperty("name");
        System.out.println(name);
    <|file_separator|><nl>
        CorsConfiguration config = new CorsConfiguration();
        config.setAllowCredentials(true);
        config.addAllowedOrigin("*");
        config.addAllowedHeader("*");
        config.addAllowedMethod("*");
        return config;
    <|file_separator|><nl>
        task.doTask();
    <|file_separator|><nl>
        thrown.expect(IllegalArgumentException.class);
        BCrypt.hashpw("foo", "$2a$100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        try {
            return mapper.readValue(content, Integer[].class);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return new Integer[0];<|file_separator|><nl>
        LitemallCategoryExample example = new LitemallCategoryExample();
        example.or().andIdIn(ids).andDeletedEqualTo(false);
        return categoryMapper.selectByExample(example);
    <|file_separator|><nl>
        issue.setUpdateTime(LocalDateTime.now());
        return issueMapper.updateByPrimaryKeySelective(issue);
    <|file_separator|><nl>
        LitemallNoticeAdminExample example = new LitemallNoticeAdminExample();
        example.or().andTitleLike("%" + title + "%").andTypeEqualTo(type).andAdminIdEqualTo(adminId).andDeletedEqualTo(false);
        return noticeAdminMapper.selectByExample(example);
    <|file_separator|><nl>
        LitemallSystemExample example = new LitemallSystemExample();
        example.or().andKeyNameLike("litemall_mail_%").andDeletedEqualTo(false);
        List<LitemallSystem> systemList = systemMapper.selectByExample(example);
        Map<String, String> data = new HashMap<>();
        for(LitemallSystem system : systemList){
            data.put(system.getKeyName(), system.getKeyValue());
        }
        return data;
    <|file_separator|><nl>
        return statMapper.statUser();
    <|file_separator|><nl>
        String url = environment.getProperty("spring.datasource.url");
        String username = environment.getProperty("spring.datasource.username");
        String password = environment.getProperty("spring.datasource.password");
        System.out.println(url);
        System.out.println(username);
        System.out.println(password);
    <|file_separator|><nl>
        Integer id = 1;
        Short num = 10;
        goodsProductMapper.reduceStock(id, num);
    <|file_separator|><nl>
        Page<LitemallBrand> pageList = brandService.page(new PageRequest(page - 1, limit), new Sort(order, sort));
        return ResponseUtil.ok(pageList);
    <|file_separator|><nl>
        return "index";
    <|file_separator|><nl>
        BigDecimal bigDecimal = new BigDecimal("1.0");
        System.out.println(bigDecimal);
    <|file_separator|><nl>
        Assert.assertEquals(getMethodParamsDesc(TypeDestUtils.class.getDeclaredMethod("test")), "()");
    <|file_separator|><nl>
        System.out.println("before");
        Object result = method.invoke(target, args);
        System.out.println("after");
        return result;
    <|file_separator|><nl>
        return (access & ACC_PUBLIC) != 0
            && (access & ACC_STATIC) != 0
            && (access & ACC_SYNTHETIC) == 0
            && (access & ACC_BRIDGE) == 0
            && (access & ACC_VARARGS) == 0
            && (access & ACC_NATIVE) == 0
            && (access & ACC_ABSTRACT) == 0
            && (access & ACC_STRICT) == 0
            && (access & ACC_SYNTHETIC) == 0
            && (access & ACC_PRIVATE) == 0
            && (access & ACC_PROTECTED) == 0
            && (access & ACC_FINAL) == 0
            && (access & ACC_SUPER) == 0
            && (access & ACC_INTERFACE) == 0
            && (access & ACC_ENUM) == 0
            && (access & ACC_MODULE) == 0
            && (access & ACC_TRANSIENT) == 0
            && (access & ACC_MANDATED) == 0
            && (access & ACC_SYNTHETIC) == 0
            && (access & ACC_ANNOTATION) == 0
            && (access & ACC_ENUM) == 0
            && (access & ACC_MODULE) == 0
            && (access & ACC_TRANSIENT) == 0
            && (access & ACC_MANDATED) == 0
            && (access & ACC_SYNTHETIC) == 0
            && (access & ACC_ANNOTATION) == 0
            && (access & ACC_ENUM) == 0
            && (access & ACC_MODULE) == 0
            && (access & ACC_TRANSIENT) == 0
<nl>
        try {
            bufferedWriter = new BufferedWriter(new FileWriter(file, append));
        } catch (IOException e) {
            Logger.error("AutoRollingFileWriter.createWriter()", e);
        }
    <|file_separator|><nl>
            return new SimpleDateFormat("yyyyMMddHH");
        <|file_separator|><nl>
        return memoryCapacity;
    <|file_separator|><nl>
        long currentTime = System.currentTimeMillis();
        long timeElapsed = currentTime - lastTime;
        lastTime = currentTime;
        return new JvmCompilationMetrics(COMPILATION_MX_BEAN.getTotalCompilationTime(), timeElapsed);
    <|file_separator|><nl>
        final Thread[] threads = getThreads();
        final JvmThreadMetrics threadMetrics = new JvmThreadMetrics();
        threadMetrics.setThreadCount(threads.length);
        threadMetrics.setThreadCountByState(new HashMap<>());
        for (Thread thread : threads) {
            final ThreadState threadState = ThreadUtils.getThreadState(thread);
            threadMetrics.getThreadCountByState().put(threadState, threadMetrics.getThreadCountByState().getOrDefault(threadState, 0) + 1);
        }
        return threadMetrics;
    <|file_separator|><nl>
        //empty
    <|file_separator|><nl>
        //empty
    <|file_separator|><nl>
        final List<JvmClassMetrics> metricsList = metricsMap.get(processId);
        if (metricsList != null) {
            final String metrics = METRICS_FORMATTER.format(metricsList);
            try {
                CLIENT.write(metrics);
            } catch (Exception e) {
                Logger.error("InfluxHttpJvmClassMetricsExporter.afterProcess(" + processId + ", " + startMillis
                        + ", " + stopMillis + "): " + e.getMessage());
            }
        } else {
            Logger.error("InfluxHttpJvmClassMetricsExporter.afterProcess(" + processId + ", " + startMillis
                    + ", " + stopMillis + "): metricsList is null!!!");
        }
    <|file_separator|><nl>
        metricsMap.get(processId).add(metrics);
    <|file_separator|><nl>
        final List<JvmGcMetricsV3> metricsList = metricsMap.get(processId);
        if (metricsList != null) {
            final String metrics = METRICS_FORMATTER.format(metricsList);
            try {
                CLIENT.write(metrics);
            } catch (Exception e) {
                Logger.error("InfluxHttpJvmGcMetricsV3Exporter.afterProcess(" + processId + ", " + startMillis + ", "
                        + stopMillis + "): " + e.getMessage());
            }
        } else {
            Logger.error("InfluxHttpJvmGcMetricsV3Exporter.afterProcess(" + processId + ", " + startMillis + ", "
                    + stopMillis + "): metricsList is null!!!");
        }
    <|file_separator|><nl>
        //empty
    <|file_separator|><nl>
        logger.log(processId, startMillis, stopMillis);
    <|file_separator|><nl>
        metricsList.add(metrics);
    <|file_separator|><nl>
        final long nowNanos = System.nanoTime();
        final long nowMillis = (nowNanos - startNanos) / 1000000L;
        final long nowSeconds = nowMillis / 1000L;
        final long nowMinutes = nowSeconds / 60L;
        final long nowHours = nowMinutes / 60L;
        final long nowDays = nowHours / 24L;
        final long nowMillisOffset = nowMillis % 1000L;
        final long nowSecondsOffset = nowSeconds % 60L;
        final long nowMinutesOffset = nowMinutes % 60L;
        final long nowHoursOffset = nowHours % 24L;
        final long nowDaysOffset = nowDays % 365L;
        final long nowMillisOffsetMillis = nowMillisOffset * 1000L;
        final long nowSecondsOffsetMillis = nowSecondsOffset * 1000L;
        final long nowMinutesOffsetMillis = nowMinutesOffset * 1000L;
        final long nowHoursOffsetMillis = nowHoursOffset * 1000L;
        final long nowDaysOffsetMillis = nowDaysOffset * 1000L;
        final long nowMillisOffsetNanos = nowMillisOffsetMillis * 1000000L;
        final long nowSecondsOffsetNanos = nowSecondsOffsetMillis * 1000000L;
        final long nowMinutesOffsetNanos = nowMinutesOffsetMillis * 1000000L;
        final long nowHoursOffsetNanos = nowHoursOffsetMillis * 1000000L;
        final long nowDaysOffsetNanos = nowDaysOffsetMillis * 1000000L<nl>
        StringBuilder sb = new StringBuilder();
        sb.append(String.format(TITLE_FORMAT, "Name", "Count", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time", "Time",<nl>
        final Calendar cal1 = Calendar.getInstance();
        final Calendar cal2 = Calendar.getInstance();
        cal1.setTime(date1);
        cal2.setTime(date2);
        return cal1.get(YEAR) == cal2.get(YEAR)
                && cal1.get(MONTH) == cal2.get(MONTH)
                && cal1.get(DAY_OF_MONTH) == cal2.get(DAY_OF_MONTH)
                && cal1.get(HOUR_OF_DAY) == cal2.get(HOUR_OF_DAY)
                && cal1.get(MINUTE) == cal2.get(MINUTE);
    <|file_separator|><nl>
        //TODO
    <|file_separator|><nl>
        return new HashSet<>(size);
    <|file_separator|><nl>
        for (int i = 0, len = array.length; i < len; ++i) {
            set(i, 0);
        }
    }

    public void fillSortedKvs(LongBuf longBuf) {
        for (int i = 0, len = array.length; i < len; ++i) {
            final int count = get(i);
            if (count > 0) {
                longBuf.write(i, count);
            }
        }
    <|file_separator|><nl>
        Thread[] threads = new Thread[group.activeCount()];
        int count = group.enumerate(threads, recurse);
        return Arrays.copyOf(threads, count);
    <|file_separator|><nl>
            return new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        <|file_separator|><nl>
        final LongBuf longBuf = LongBuf.allocate(1024);
        Assert.assertEquals(longBuf.pool(), null);
        Assert.assertEquals(longBuf.writerIndex(), 0);
        Assert.assertEquals(longBuf.readerIndex(), 0);
        Assert.assertEquals(longBuf.capacity(), 1024);
        Assert.assertEquals(longBuf.remaining(), 1024);
        Assert.assertEquals(longBuf.position(), 0);
        Assert.assertEquals(longBuf.mark(), -1);
        Assert.assertEquals(longBuf.limit(), 1024);
        Assert.assertEquals(longBuf.get(0), 0);
        Assert.assertEquals(longBuf.get(1), 0);
        Assert.assertEquals(longBuf.get(2), 0);
        Assert.assertEquals(longBuf.get(3), 0);
        Assert.assertEquals(longBuf.get(4), 0);
        Assert.assertEquals(longBuf.get(5), 0);
        Assert.assertEquals(longBuf.get(6), 0);
        Assert.assertEquals(longBuf.get(7), 0);
        Assert.assertEquals(longBuf.get(8), 0);
        Assert.assertEquals(longBuf.get(9), 0);
        Assert.assertEquals(longBuf.get(10), 0);
        Assert.assertEquals(longBuf.get(11), 0);
        Assert.assertEquals(longBuf.get(12), 0);
        Assert.assertEquals(longBuf.get(13), 0);
        Assert.assertEquals(longBuf.get(14), 0);
        Assert.assertEquals(longBuf.get(15), <nl>
        // TODO
    <|file_separator|><nl>
        HttpRequest req0 = new HttpRequest.Builder()
                .url("localhost:8086/write")
                .params(MapUtils.of("k1", singletonList("v1")))
                .get()
                .build();
        Assert.assertEquals("http://localhost:8086/write?k1=v1", req0.getFullUrl());

        HttpRequest req1 = new HttpRequest.Builder()
                .url("localhost:8086/write?")
                .params(MapUtils.of("k1", singletonList("v1")))
                .get()
                .build();
        Assert.assertEquals("http://localhost:8086/write?k1=v1", req1.getFullUrl());

        HttpRequest req2 = new HttpRequest.Builder()
                .url("localhost:8086/write?k1=v1")
                .params(MapUtils.of("k2", singletonList("v2")))
                .post("abcd")
                .build();
        Assert.assertEquals("http://localhost:8086/write?k1=v1&k2=v2", req2.getFullUrl());
    <|file_separator|><nl>
        influxDbClient.write("MyPerf4J", "MyPerf4J", "MyPerf4J", "MyPerf4J", "MyPerf4J", "MyPerf4J", "MyPerf4J", "MyPerf4J", "MyPerf4J", "MyPerf4J", "MyPerf4J", "MyPerf4J", "MyPerf4J", "MyPerf4J", "MyPerf4J", "MyPerf4J", "MyPerf4J", "MyPerf4J", "MyPerf4J", "MyPerf4J", "MyPerf4J", "MyPerf4J", "MyPerf4J", "MyPerf4J", "MyPerf4J", "MyPerf4J", "MyPerf4J", "MyPerf4J", "MyPerf4J", "MyPerf4J", "MyPerf4J", "MyPerf4J", "MyPerf4J", "MyPerf4J", "MyPerf4J", "MyPerf4J", "MyPerf4J", "MyPerf4J", "MyPerf4J", "MyPerf4J", "MyPerf4J", "MyPerf4J", "MyPerf4J", "MyPerf4J", "MyPerf4J", "MyPerf4J", "MyPerf4J", "MyPerf4J", "MyPerf4J", "MyPerf4J", "MyPerf4J", "MyPerf4J", "MyPerf4J", "MyPerf4J", "MyPerf4J", "MyPerf4J", "MyPerf4J", "MyPerf4J", "MyPerf4J", "MyPerf4J", "MyPerf4J", "MyPerf4J", "MyPerf4J", "MyPerf4J", "MyPerf4J", "My<nl>
        List<String> list = StrUtils.splitAsList("a,b,c", ",");
        Assert.assertEquals(list.size(), 3);
        Assert.assertEquals(list.get(0), "a");
        Assert.assertEquals(list.get(1), "b");
        Assert.assertEquals(list.get(2), "c");
    <|file_separator|><nl>
        return recorderCount.get();
    <|file_separator|><nl>
        initProperties();
    <|file_separator|><nl>
        System.out.println("Hello World!");
    <|file_separator|><nl>
        return this.configInfo;
    <|file_separator|><nl>
        return message;
    <|file_separator|><nl>
    <|file_separator|><nl>
    <|file_separator|><nl>
        this.data = data;
    <|file_separator|><nl>
        return password;
    <|file_separator|><nl>
        return CommonResult.error(e.getMessage());
    <|file_separator|><nl><nl>
        return new LoadBalancerRequestTransformer();
    <|file_separator|><nl>
        HttpComponentsClientHttpRequestFactory clientHttpRequestFactory = new HttpComponentsClientHttpRequestFactory();
        clientHttpRequestFactory.setConnectTimeout(10000);
        clientHttpRequestFactory.setReadTimeout(10000);
        return clientHttpRequestFactory;
    <|file_separator|><nl>
    <|file_separator|><nl>
        System.out.println("Hello world!");
    <|file_separator|><nl>
        SpringApplication.run(NacosRibbonServiceApplication.class, args);
    <|file_separator|><nl>
        User user = userService.getByUsername(username);
        LOGGER.info("username{}",user.getUsername());
        return new CommonResult<>(user);
    <|file_separator|><nl>
    <|file_separator|><nl>
        security.allowFormAuthenticationForClients();
    <|file_separator|><nl>
        System.out.println("Hello World!");
    <|file_separator|><nl>
        clients.inMemory()
                .withClient("client")
                .secret(passwordEncoder.encode("secret"))
                .authorizedGrantTypes("password", "authorization_code", "refresh_token")
                .scopes("read", "write");
    <|file_separator|><nl>
        http.authorizeRequests()
                .antMatchers("/api/v1/user/login").permitAll()
                .antMatchers("/api/v1/user/register").permitAll()
                .antMatchers("/api/v1/user/logout").permitAll()
                .antMatchers("/api/v1/user/profile").permitAll()
                .antMatchers("/api/v1/user/changepassword").permitAll()
                .antMatchers("/api/v1/user/changeemail").permitAll()
                .antMatchers("/api/v1/user/changeusername").permitAll()
                .antMatchers("/api/v1/user/changephonenumber").permitAll()
                .antMatchers("/api/v1/user/changeprofilepicture").permitAll()
                .antMatchers("/api/v1/user/changecoverpicture").permitAll()
                .antMatchers("/api/v1/user/changecoverpicture").permitAll()
                .antMatchers("/api/v1/user/changecoverpicture").permitAll()
                .antMatchers("/api/v1/user/changecoverpicture").permitAll()
                .antMatchers("/api/v1/user/changecoverpicture").permitAll()
                .antMatchers("/api/v1/user/changecoverpicture").permitAll()
                .antMatchers("/api/v1/user/changecoverpicture").permitAll()
                .antMatchers("/api/v1/user/changecoverpicture").permitAll()
                .antMatchers("/api/v1/user/changecoverpicture").permitAll()
                .antMatchers("/api/v1/user/changecoverpicture").permitAll()
                .antMatchers("/api/v1/user/changecoverpicture").permitAll()
                .antMatchers("/api/v1/user/changecoverpicture").permitAll()
                .antMatchers("/api/v1/user/changecoverpicture").permitAll()
                .antMatchers("/api/v<nl>
        http.csrf().disable();
        http.authorizeRequests()
                .antMatchers("/api/auth/**").permitAll()
                .antMatchers("/api/user/**").permitAll()
                .antMatchers("/api/admin/**").permitAll()
                .antMatchers("/api/user/register").permitAll()
                .antMatchers("/api/user/login").permitAll()
                .antMatchers("/api/user/logout").permitAll()
                .antMatchers("/api/user/forgotPassword").permitAll()
                .antMatchers("/api/user/resetPassword").permitAll()
                .antMatchers("/api/user/changePassword").permitAll()
                .antMatchers("/api/user/changeEmail").permitAll()
                .antMatchers("/api/user/changeUsername").permitAll()
                .antMatchers("/api/user/changeProfilePicture").permitAll()
                .antMatchers("/api/user/changeCoverPicture").permitAll()
                .antMatchers("/api/user/changeBio").permitAll()
                .antMatchers("/api/user/changeStatus").permitAll()
                .antMatchers("/api/user/changeRole").permitAll()
                .antMatchers("/api/user/changePassword").permitAll()
                .antMatchers("/api/user/changeEmail").permitAll()
                .antMatchers("/api/user/changeUsername").permitAll()
                .antMatchers("/api/user/changeProfilePicture").permitAll()
                .antMatchers("/api/user/changeCoverPicture").permitAll()
                .antMatchers("/api/user/changeBio").permitAll()
                .antMatchers("/api/user/changeStatus").permitAll()
                .antMatchers("/api/user/changeRole").permitAll()
                .antMatchers("/api/user/changePassword").permitAll()
                .antMatchers("/api/user/changeEmail").permitAll()
                .antMatchers("/api/user/changeUsername").permitAll()
                .antMatchers("/api/user/changeProfilePicture").<nl>
    <|file_separator|><nl>
        this.message = message;
    <|file_separator|><nl>
        this.message = message;
    <|file_separator|><nl>
        System.out.println("Hello World!");
    <|file_separator|><nl>
        return new CommonResult("", 200);
    <|file_separator|><nl>
        System.out.println("Hello World!");
    <|file_separator|><nl>
        if (method.getParameterTypes().length != 1) {
            throw new SocketIOException("OnDisconnect method must have one parameter");
        }
        if (method.getParameterTypes()[0] != SocketIOClient.class) {
            throw new SocketIOException("OnDisconnect method must have SocketIOClient as parameter");
        }
    <|file_separator|>class OnConnectScanner.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>package com.github.mrmarble.socket.io.annotation;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface OnConnect {
}<|file_separator|>class OnConnectScanner.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>package com.github.mrmarble.socket.io.annotation;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface OnConnect {
}<|file_separator|>class OnDisconnectScanner.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>package com.github.mrmarble.socket.io.annotation;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface OnDisconnect {
}<|file_separator|>class OnConnectScanner.AnnotationScanner.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>package com.github.mrmarble.socket.io.annotation;

import java.lang.annotation.Annotation;
import java.lang.reflect.Method<nl>
        if (message.isPacket()) {
            try {
                packetListener.onPacket(ctx, decoder.decode(message.getPacket()));
            } catch (Exception e) {
                exceptionListener.exceptionCaught(ctx, e);
            }
        } else {
            namespacesHub.onNamespace(ctx, message.getNamespace());
        }
    <|file_separator|><nl>
        return AuthorizationResult.SUCCESS;
    <|file_separator|><nl>
        this.packetsQueue = packetsQueue;
    }

    public void setChannel(Channel channel) {
        this.channel = channel;
    <|file_separator|><nl>
        
    <|file_separator|><nl>
        listeners.add(listener);
    }

    public void removeListener(DataListener<T> listener) {
        listeners.remove(listener);
    <|file_separator|><nl>
        Timeout timeout = executorService.newTimeout(new TimerTask() {
            @Override
            public void run(Timeout timeout) throws Exception {
                try {
                    runnable.run();
                } finally {
                    scheduledFutures.remove(key);
                }
            }
        }, delay, unit);

        if (!timeout.isExpired()) {
            scheduledFutures.put(key, timeout);
        }
    }

    @Override
    public void schedule(final Runnable runnable, long delay, TimeUnit unit) {
        Timeout timeout = executorService.newTimeout(new TimerTask() {
            @Override
            public void run(Timeout timeout) throws Exception {
                try {
                    runnable.run();
                } finally {
                    scheduledFutures.remove(key);
                }
            }
        }, delay, unit);

        if (!timeout.isExpired()) {
            scheduledFutures.put(key, timeout);
        }
    }

    @Override
    public void scheduleCallback(final SchedulerKey key, final Runnable runnable, long delay, TimeUnit unit) {
        Timeout timeout = executorService.newTimeout(new TimerTask() {
            @Override
            public void run(Timeout timeout) throws Exception {
                try {
                    runnable.run();
                } finally {
                    scheduledFutures.remove(key);
                }
            }
        }, delay, unit);

        if (!timeout.isExpired()) {
            scheduledFutures.put(key, timeout);
        }
    }

    @Override
    public void shutdown() {
        executorService.stop();
    }

}

class HashedWheelScheduler implements CancelableScheduler {

    private final Map<SchedulerKey, Timeout> scheduledFutures = PlatformDependent.newConcurrentHashMap();
    private final HashedWheelTimer executor<nl>
        redisClient.shutdown();
    }

    @Override
    public <K, V> Map<K, V> createMap(String name, int initialCapacity, float loadFactor) {
        return redisClient.getMap(name, initialCapacity, loadFactor);
    <|file_separator|><nl>
        return namespace;
    <|file_separator|><nl>
        return namespace;
    <|file_separator|><nl>
        this.nodeId = nodeId;
    <|file_separator|><nl>
        return new SSLServerSocketFactory(loadedKeyStore, keyManagers);
    }
<|file_separator|><nl>
        StringBuilder requestBuilder = new StringBuilder();
        requestBuilder.append("GET " + HttpServerTest.URI + " HTTP/1.1").append(System.getProperty("line.separator")).append("Cookie: theme=light; sessionToken=abc123");

        ByteArrayInputStream inputStream = new ByteArrayInputStream(requestBuilder.toString().getBytes());
        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
        HTTPSession session = this.testServer.createSession(this.tempFileManager, inputStream, outputStream);
        session.execute();
        CookieHandler cookieHandler = session.getCookies();
        cookieHandler.delete("theme");
    <|file_separator|><nl>
        assertEquals("foo bar", this.testServer.decodePercent("foo%20bar"));
    <|file_separator|><nl>
        // Arrange
        final String remoteAddress = "127.0.0.1";
        final String remotePort = "8080";
        final String remoteHost = "localhost";
        final String remoteName = "localhost";
        final String remoteUser = "user";
        final String remoteHostHeader = "localhost";
        final String remotePortHeader = "8080";
        final String remoteNameHeader = "localhost";
        final String remoteUserHeader = "user";
        final String remoteAddressHeader = "127.0.0.1";
        final String remoteAddressHeaderValue = "127.0.0.1";
        final String remoteAddressHeaderValueWithPort = "127.0.0.1:8080";
        final String remoteAddressHeaderValueWithPortAndHost = "127.0.0.1:8080";
        final String remoteAddressHeaderValueWithPortAndHostAndName = "127.0.0.1:8080";
        final String remoteAddressHeaderValueWithPortAndHostAndNameAndUser = "127.0.0.1:8080";
        final String remoteAddressHeaderValueWithPortAndHostAndNameAndUserAndAddress = "127.0.0.1:8080";
        final String remoteAddressHeaderValueWithPortAndHostAndNameAndUserAndAddressAndPort = "127.0.0.1:8080";
        final String remoteAddressHeaderValueWithPortAndHostAndNameAndUserAndAddressAndPortAndHost = "127.0.0.1:8080";
        final String remoteAddressHeaderValueWithPortAndHostAndNameAndUserAndAddress<nl>
        invokeServer("GET " + HttpServerTest.URI + " HTTP/1.1");
        assertNotNull(this.testServer.parms);
        assertNotNull(this.testServer.parameters);
        assertTrue(this.testServer.header.size() > 0);
        assertNotNull(this.testServer.files);
        assertNotNull(this.testServer.uri);
    <|file_separator|><nl>
            return newFixedLengthResponse("Hello World");
        <|file_separator|><nl>
        return new BucketSelectorPipelineAggregationBuilder(parser.map());
    }

    @Override
    public BucketSelectorPipelineAggregationBuilder copy() {
        return new BucketSelectorPipelineAggregationBuilder(name, bucketsPathsMap, script);
    <|file_separator|><nl>
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        ComperableHitResult that = (ComperableHitResult) o;
        return Objects.equals(comperator, that.comperator);
    <|file_separator|><nl>
		if (sql.contains("explain")) {
			return new ExplainAction(sql);
		}
		return null;
	<|file_separator|><nl>
        return "KVValue{" +
                "key='" + key + '\'' +
                ", value=" + value +
                '}';
    <|file_separator|><nl>
		Map<String, Object> result = new HashMap<>();
		for (Entry<String, DocumentField> entry : fields.entrySet()) {
			result.put(entry.getKey(), entry.getValue().getValue());
		}
		return result;
	<|file_separator|><nl>
        if (castExpr.getCastType() == SQLCastExpr.CastType.CAST_AS_STRING) {
            return "CAST(" + castExpr.getExpr() + " AS " + castExpr.getCastType().toString() + " ) AS " + this.name;
        } else {
            return "CAST(" + castExpr.getExpr() + " AS " + castExpr.getCastType().toString() + " ) AS " + this.name;
        }
    <|file_separator|><nl>
        throw new UnsupportedOperationException();
    <|file_separator|>class SQLIdentifierExpr.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class SQLIdentifierExpr extends SQLExprImpl {

    private String name;

    public SQLIdentifierExpr(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    @Override
    public boolean equals(Object o) {
        throw new UnsupportedOperationException();
    }

    @Override
    public int hashCode() {
        throw new UnsupportedOperationException();
    }

    @Override
    public SQLExpr clone() {
        throw new UnsupportedOperationException();
    }

    @Override
    protected void accept0(SQLASTVisitor visitor) {
        throw new UnsupportedOperationException();
    }
}<|file_separator|>class SQLExprImpl.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public abstract class SQLExprImpl implements SQLExpr {

    @Override
    public SQLExpr clone() {
        throw new UnsupportedOperationException();
    }

    @Override
    protected void accept0(SQLASTVisitor visitor) {
        throw new UnsupportedOperationException();
    }
}<|file_separator|>class SQLExpr.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public interface SQLExpr {

    SQLExpr clone();

    void accept(SQLASTVisitor visitor);
}<|file_separator|><nl>
		if (delete.getIndices() != null && delete.getIndices().length > 0) {
			request.indices(delete.getIndices());
		} else {
			request.indices("*");
		}

		if (delete.getTypes() != null && delete.getTypes().length > 0) {
			request.types(delete.getTypes());
		} else {
			request.types("*");
		}
	<|file_separator|><nl>
        this.originalSelect = originalSelect;
    <|file_separator|><nl>
        return secondSelect;
    <|file_separator|>class Select.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class Select {
    private String selectStatement;

    public Select(String selectStatement) {
        this.selectStatement = selectStatement;
    }

    public String getSelectStatement() {
        return selectStatement;
    }
}<|file_separator|>class SQLUnionOperator.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public enum SQLUnionOperator {
    UNION,
    UNION_ALL
}<|file_separator|><nl>
        return from;
    <|file_separator|><nl>
        this.exceptionClass = exceptionClass;
    <|file_separator|><nl>
        return new FilterImpl(path, acceptType, filter);
    <|file_separator|>class Filter.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public interface Filter {

    /**
     * Invoked when a request is made on this filter's corresponding path e.g. '/hello'
     *
     * @param request  The request object providing information about the HTTP request
     * @param response The response object providing functionality for modifying the response
     */
    void handle(Request request, Response response) throws Exception;

}<|file_separator|>class Request.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public interface Request {

    /**
     * Returns the HTTP method of the request
     */
    String getMethod();

    /**
     * Returns the path of the request
     */
    String getPath();

    /**
     * Returns the query string of the request
     */
    String getQueryString();

    /**
     * Returns the headers of the request
     */
    Map<String, String> getHeaders();

    /**
     * Returns the body of the request
     */
    String getBody();

    /**
     * Returns the body of the request as a byte array
     */
    byte[] getBodyAsBytes();

    /**
     * Returns the body of the request as a string
     */
    String getBodyAsString();

    /**
     * Returns the body of the request as a JSON object
     */
    JSONObject getBodyAsJson();

    /**
     * Returns the body of the request as a JSON array
     */
    JSONArray getBodyAsJsonArray();

    /**
     * Returns the body of the request as a JSON object
     */
    JSONObject getBodyAsJsonObject();

    /**
     * Returns the body of the request as a JSON array
     */
    JSONArray getBodyAsJsonArray();

    /**
     *<nl>
        this.threadPool = threadPool;
        return this;
    <|file_separator|><nl>
        redirected = true;
        delegate.redirect(location, httpStatusCode);
    <|file_separator|><nl>
        this.responseWrapper = responseWrapper;
        return this;
    <|file_separator|>class ResponseWrapper.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class ResponseWrapper {

    private HttpServletResponse httpResponse;
    private Response response;
    private ResponseContext responseContext;

    public ResponseWrapper(HttpServletResponse httpResponse, Response response, ResponseContext responseContext) {
        this.httpResponse = httpResponse;
        this.response = response;
        this.responseContext = responseContext;
    }

    public void send() {
        response.send(httpResponse, responseContext);
    }

}<|file_separator|>class ResponseContext.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class ResponseContext {

    private HttpServletResponse httpResponse;
    private Response response;
    private ResponseWrapper responseWrapper;

    public ResponseContext(HttpServletResponse httpResponse, Response response, ResponseWrapper responseWrapper) {
        this.httpResponse = httpResponse;
        this.response = response;
        this.responseWrapper = responseWrapper;
    }

    public HttpServletResponse httpResponse() {
        return httpResponse;
    }

    public Response response() {
        return response;
    }

    public ResponseWrapper responseWrapper() {
        return responseWrapper;
    }

}<|file_separator|>class RequestWrapper.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class RequestWrapper {

    private HttpServletRequest httpRequest;
    private Request request;
    private RequestContext requestContext;

    public RequestWrapper(HttpServletRequest httpRequest, Request request, RequestContext requestContext) {
        this.httpRequest = httpRequest;
        this.request = request;
        this.requestContext = requestContext;
    }

    public void send() {
        request.send(httpRequest, requestContext);
    }

}<|file_separator|>class RequestContext.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class RequestContext {

    private HttpServletRequest httpRequest;<nl>
        matcherFilter.doFilter(request, response, chain);
    <|file_separator|><nl>
        final JettyServerFactory jettyServerFactory = mock(JettyServerFactory.class);
        final StaticFilesConfiguration staticFilesConfiguration = mock(StaticFilesConfiguration.class);
        final ExceptionMapper exceptionMapper = mock(ExceptionMapper.class);
        final Routes routes = mock(Routes.class);

        Server server = new Server();
        when(jettyServerFactory.create(100, 10, 10000)).thenReturn(server);

        final EmbeddedJettyFactory embeddedJettyFactory = new EmbeddedJettyFactory(jettyServerFactory).withThreadPool(new ThreadPoolExecutor(10, 10, 10000, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>()));
        embeddedServer = embeddedJettyFactory.create(routes, staticFilesConfiguration, exceptionMapper, false);

        embeddedServer.trustForwardHeaders(true);
        embeddedServer.ignite("localhost", 6759, null, 100, 10, 10000);

        verify(jettyServerFactory, times(1)).create(100, 10, 10000);
        verifyNoMoreInteractions(jettyServerFactory);
    <|file_separator|><nl>
        System.out.println("Connection closed with status " + statusCode + ": " + reason);
        closeLatch.countDown();
    }

    @OnWebSocketError
    public void onError(Throwable cause) {
        System.out.println("Error: " + cause);
        closeLatch.countDown();
    <|file_separator|><nl>
        return "Trust but verify";
    <|file_separator|><nl>
        igniteFirstService();
        igniteSecondService();
    <|file_separator|><nl>
		return gson.toJson(model);
	<|file_separator|><nl>
        System.out.println("Hello World");
    <|file_separator|><nl>
        if (routes.size() != expectedRoutes.size()) {
            return false;
        }
        for (int i = 0; i < routes.size(); i++) {
            if (!routes.get(i).equals(expectedRoutes.get(i))) {
                return false;
            }
        }
        return true;
    <|file_separator|><nl>
        return delegate.getInitParameter(name);
    <|file_separator|><nl>
        return mobile_pattern.matcher(src).matches();
    <|file_separator|><nl>
        return "LoginVo{" +
                "mobile='" + mobile + '\'' +
                ", password='" + password + '\'' +
                '}';
    <|file_separator|><nl><nl>
        Orders order = new Orders();
        order.setOrderId(UUID.randomUUID().toString());
        order.setItemId(itemId);
        order.setCreateTime(new Date());
        order.setUpdateTime(new Date());
        int result = ordersMapper.insert(order);
        return result > 0;
    <|file_separator|><nl>
        return merchantOrderNo;
    <|file_separator|><nl>
        if (user == null) {
            return ResultGeekQ.error(CodeMsg.SESSION_ERROR);
        }
        OrderInfo order = orderService.getOrderById(orderId);
        if (order == null) {
            return ResultGeekQ.error(CodeMsg.ORDER_NOT_EXIST);
        }
        long goodsId = order.getGoodsId();
        GoodsVo goods = goodsService.getGoodsVoByGoodsId(goodsId);
        OrderDetailVo vo = new OrderDetailVo();
        vo.setOrder(order);
        vo.setGoods(goods);
        return ResultGeekQ.success(vo);
    <|file_separator|><nl>
        return BindingBuilder.bind(topicQueue2()).to(topicExchage()).with("topic.#");
    <|file_separator|><nl>

        Jedis jedis = null;
        try {
            jedis = RedisManager.getJedis();
        } catch (Exception e) {
            e.printStackTrace();
        }
        String count =
                "local num=redis.call('incr',KEYS[1]) if tonumber(num)==1 " +
                        "then redis.call('expire',KEYS[1],ARGV[1]) " +
                        "return 1 elseif tonumber(num)>" +
                        "tonumber(ARGV[2]) then return 0 else return 1 end";

        List<String> keys = new ArrayList<String>();
        keys.add(key);
        List<String> argves = new ArrayList<String>();
        argves.add("6000");
        argves.add("5");
        jedis.auth("youxin11");
        Object object = jedis.eval(count, keys, argves);
        System.out.println(object);
    <|file_separator|><nl>
        return jedisPool.getResource();
    <|file_separator|><nl>
        if (require && value == null) {
            return false;
        }
        return value.matches("^[0-9]{10}$");
    <|file_separator|><nl>
            return message;
        <|file_separator|><nl>
        return new ResultGeekQ(status, (String) null);
    }

    public static <T> ResultGeekQ<T> error(ResultStatus status, String message) {
        return new ResultGeekQ(status, message);
    }

    public static <T> ResultGeekQ<T> error(String message) {
        return new ResultGeekQ(ResultStatus.ERROR, message);
    }

    public static <T> ResultGeekQ<T> error(String message, T data) {
        return new ResultGeekQ(ResultStatus.ERROR, message).setData(data);
    }

    public static <T> ResultGeekQ<T> error(ResultStatus status, String message, T data) {
        return new ResultGeekQ(status, message).setData(data);
    }

    public static <T> ResultGeekQ<T> error(ResultStatus status, T data) {
        return new ResultGeekQ(status, (String) null).setData(data);
    }

    public static <T> ResultGeekQ<T> error(ResultStatus status, T data, String message) {
        return new ResultGeekQ(status, message).setData(data);
    }

    public static <T> ResultGeekQ<T> error(ResultStatus status, T data, String message, String traceId) {
        return new ResultGeekQ(status, message).setData(data);
    }

    public static <T> ResultGeekQ<T> error(ResultStatus status, T data, String message, String traceId, String stackTrace) {
        return new ResultGeekQ(status, message).setData(data);
    }

    public static <T> ResultGeekQ<T> error(ResultStatus status, T data, String message, String<nl>
        return UUID.randomUUID().toString();
    <|file_separator|><nl>
        return mobile_pattern.matcher(src).matches();
    <|file_separator|><nl>
        this.goods = goods;
    <|file_separator|><nl>
        String msg = RedisService.beanToString(miaoShaMessageVo);
        log.info("send message:" + msg);
        rabbitTemplate.convertAndSend(MQConfig.EXCHANGE_TOPIC, "register_*", msg);
    <|file_separator|><nl>
        return expireSeconds;
    <|file_separator|><nl>
                    return value;
                <|file_separator|><nl>
        return switch (type) {
            case ColumnType.LONG -> ColumnType.sizeOf(ColumnType.LONG);
            case ColumnType.STRING -> ColumnType.sizeOf(ColumnType.STRING);
            default -> throw new IllegalStateException("Unexpected value: " + type);
        };
    <|file_separator|><nl>
        long value = rnd.nextLong(N);
        hll.add(value);
        hllPtr = hll.ptr();
    <|file_separator|><nl>
        Options opt = new OptionsBuilder()
                .include(Log4jBenchmark.class.getSimpleName())
                .forks(1)
                .build();

        new Runner(opt).run();
    <|file_separator|><nl>
        Options opt = new OptionsBuilder()
                .include(MapWriteIntBenchmark.class.getSimpleName())
                .forks(1)
                .build();
        new Runner(opt).run();
    <|file_separator|><nl>
        MapKey key = unordered16map.withKey();
        key.putLong(rnd.nextLong(size));
        MapValue values = key.createValue();
        values.putLong(0, rnd.nextLong());
    <|file_separator|><nl>
        for (int i = 0; i < SIZE; i++) {
            bh.consume(i);
        }
    }

    @Benchmark
    public void testLatch() {
        SOCountDownLatch latch = new SOCountDownLatch(SIZE);
        Thread th = new Thread(() -> {
            for (int i = 0; i < SIZE; i++) {
                latch.countDown();
            }
        });
        th.start();
        latch.await();
    <|file_separator|><nl>
        darr = new double[doubleCount];
        mem = Unsafe.allocate(memSize, MemoryTag.NATIVE_DEFAULT);
        for (int i = 0; i < doubleCount; i++) {
            darr[i] = i;
        }
    <|file_separator|><nl>
        mem1.reset();
        mem2.reset();
        mem3.reset();
    <|file_separator|><nl>
            return httpFrozenClock ? StationaryMillisClock.INSTANCE : MillisecondClockImpl.INSTANCE;
        }

        @Override
        public int getMultipartBodyBufferSize() {
            return multipartBodyBufferSize;
        <|file_separator|><nl>
        assertTimestampColumnSorted(indexAddr, indexSize);
    <|file_separator|><nl>

    <|file_separator|><nl>
        return txFile.getMinTimestamp();
    <|file_separator|><nl>
        if (partitionHi == -1) {
            return null;
        }
        if (partitionLimit == -1) {
            return null;
        }
        if (partitionHi < intervalsHi) {
            skipInterval(intervalsHi, partitionLimit);
        }
        if (partitionHi == intervalsHi) {
            skipPartition(partitionHi);
        }
        return super.next();
    <|file_separator|>class IntervalBwdDataFrameReader.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>import org.apache.spark.sql.DataFrameReader;
import org.apache.spark.sql.Row;
import org.apache.spark.sql.types.StructType;

import java.util.List;

/**
 * Created by jh on 10/11/15.
 */
public class IntervalBwdDataFrameReader extends DataFrameReader {

    public IntervalBwdDataFrameReader(DataFrameReader reader) {
        super(reader);
    }

    @Override
    public IntervalBwdDataFrameReader withSchema(StructType schema) {
        return (IntervalBwdDataFrameReader) super.withSchema(schema);
    }

    @Override
    public IntervalBwdDataFrameReader withHeader(boolean header) {
        return (IntervalBwdDataFrameReader) super.withHeader(header);
    }

    @Override
    public IntervalBwdDataFrameReader withMultiLine(boolean multiLine) {
        return (IntervalBwdDataFrameReader) super.withMultiLine(multiLine);
    }

    @Override
    public IntervalBwdDataFrameReader withDelimiters(String... delimiters) {
        return (IntervalBwdDataFrameReader) super.withDelimiters(delimiters);
    }

    @Override
    public IntervalBwdDataFrameReader withName(String name) {
        <nl>
        return new ListColumnFilter(capacity());
    }

    public ListColumnFilter(ListColumnFilter other) {
        super(other);
    }

    public ListColumnFilter(int[] other) {
        super(other);
    }

    public ListColumnFilter(int[] other, int capacity) {
        super(other, capacity);
    }

    public ListColumnFilter(int[] other, int capacity, int[] other2) {
        super(other, capacity, other2);
    }

    public ListColumnFilter(int[] other, int capacity, int[] other2, int[] other3) {
        super(other, capacity, other2, other3);
    }

    public ListColumnFilter(int[] other, int capacity, int[] other2, int[] other3, int[] other4) {
        super(other, capacity, other2, other3, other4);
    }

    public ListColumnFilter(int[] other, int capacity, int[] other2, int[] other3, int[] other4, int[] other5) {
        super(other, capacity, other2, other3, other4, other5);
    }

    public ListColumnFilter(int[] other, int capacity, int[] other2, int[] other3, int[] other4, int[] other5, int[] other6) {
        super(other, capacity, other2, other3, other4, other5, other6);
    }

    public ListColumnFilter(int[] other, int capacity, int[] other2, int[] other3, int[] other4, int[] other5, int[] other6, int[] other7) {
        super(other, capacity, other2, other3, other4, other5, other6,<nl>
        return tableToken;
    <|file_separator|>class TableToken.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class TableToken {
    private final String name;
    private final int index;

    private TableToken(String name, int index) {
        this.name = name;
        this.index = index;
    }

    public String getName() {
        return name;
    }

    public int getIndex() {
        return index;
    }

    static TableToken of(String name, int index) {
        return new TableToken(name, index);
    }
}<|file_separator|>class TableMap.java
<|fim_prefix|><|fim_suffix|>

    public void add(TableToken tableToken, ReverseTableMapItem reverseTableMapItem) {
        tableMap.put(tableToken, reverseTableMapItem);
    }

    public void remove(TableToken tableToken) {
        tableMap.remove(tableToken);
    }

    public ReverseTableMapItem get(TableToken tableToken) {
        return tableMap.get(tableToken);
    }
}<|fim_middle|>import java.util.HashMap;
import java.util.Map;

public class TableMap {
    private final Map<TableToken, ReverseTableMapItem> tableMap = new HashMap<>();<|file_separator|><nl>
        this.writer.refreshSourceAndIndex(loRow, hiRow);
    }

    @Override
    public void rollback(long maxRow, long minRow) {
        this.writer.rollbackValues(maxRow, minRow);
    <|file_separator|><nl>
        if (clockMs.getTicks() - lastReloadTimestampMs > autoReloadTimeout) {
            reload();
        }
    <|file_separator|><nl>
        if (tableNameToTableTokenMap.putIfAbsent(tableToken.getTableName(), tableToken) == null) {
            nameStore.logAddTable(tableToken);
        }
    <|file_separator|><nl>
        return columnPool.createColumn(columnIndex);
    }

    @Override
    public FrameColumn getColumn(int columnIndex) {
        return columnPool.getColumn(columnIndex);
    }

    @Override
    public long getColumnTop(int columnIndex) {
        return crv.getColumnTop(columnIndex);
    }

    @Override
    public long getPartitionTimestamp() {
        return partitionTimestamp;
    <|file_separator|>class PartitionFramePool.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class PartitionFramePool {
    private final FrameColumnPool columnPool;
    private final RecycleBin<PartitionFrame> frameRecycleBin;
    private final long maxPartitionSize;
    private final long minPartitionSize;
    private final long partitionSize;
    private final long partitionSizeIncrement;
    private final long partitionSizeMax;
    private final long partitionSizeMin;
    private final long partitionSizeStep;
    private final long partitionSizeThreshold;
    private final long partitionSizeThresholdIncrement;
    private final long partitionSizeThresholdMax;
    private final long partitionSizeThresholdMin;
    private final long partitionSizeThresholdStep;
    private final long partitionSizeThresholdValue;
    private final long partitionSizeValue;
    private final long partitionTimestamp;
    private final long partitionTimestampIncrement;
    private final long partitionTimestampMax;
    private final long partitionTimestampMin;
    private final long partitionTimestampStep;
    private final long partitionTimestampValue;
    private final long partitionTimestampValueIncrement;
    private final long partitionTimestampValueMax;
    private final long partitionTimestampValueMin;
    private final long partitionTimestampValueStep;
    private final long partitionValue;
    private final long partitionValueIncrement;
    private final long partitionValueMax;
    private final long partitionValueMin;
    private final long partitionValueStep;
<nl>
        return new RecordValueSink(asm, columnTypes, columnFilter);
    <|file_separator|><nl>
        migrationContext.addSql("ALTER TABLE `user` ADD `name` VARCHAR(255) NOT NULL");
    <|file_separator|><nl>
        try (MemoryMARW rwMemory = metaMem.getMemory()) {
            rwMemory.putLong(readOffset, 0);
            ff.open(path, rwMemory);
        }
    <|file_separator|><nl>
        return tempMemory + size;
    <|file_separator|><nl>
        switch (reason) {
            case CR_IDLE:
                return "Idle";
            case CR_REOPEN:
                return "Reopen";
            case CR_NAME_LOCK:
                return "Name lock";
            case CR_POOL_CLOSE:
                return "Pool close";
            case CR_DISTRESSED:
                return "Distressed";
            default:
                return "Unknown";
        }
    <|file_separator|><nl>
        return 0;
    <|file_separator|><nl>
        return getFunction(col).getLong128Lo(base);
    }

    @Override
    public long getLong128(int col) {
        return getFunction(col).getLong128(base);
    }

    @Override
    public long getLong128HiA(int col) {
        return getFunction(col).getLong128HiA(base);
    }

    @Override
    public long getLong128HiB(int col) {
        return getFunction(col).getLong128HiB(base);
    }

    @Override
    public long getLong128LoA(int col) {
        return getFunction(col).getLong128LoA(base);
    }

    @Override
    public long getLong128LoB(int col) {
        return getFunction(col).getLong128LoB(base);
    <|file_separator|><nl>
        return u8view.of(offset, size, ascii);
    }

    @Override
    public void setFilesFacade(FilesFacade ff) {
        this.ff = ff;
    }

    @Override
    public void setPageAddress(int pageIndex, long pageAddress) {
        this.pageAddress = pageAddress;
    }

    @Override
    public void setPageCount(int pageCount) {
        this.pageAddress = 0;
    }

    @Override
    public void setSize(long size) {
        this.size = size;
    }

    @Override
    public void setShiftAddressRight(long shiftRightOffset) {
        this.shiftAddressRight = shiftRightOffset;
    }

    @Override
    public void setStrA(long offset, CharSequence str) {
        setStr(offset, str, csviewA);
    }

    @Override
    public void setStrB(long offset, CharSequence str) {
        setStr(offset, str, csviewB);
    }

    @Override
    public void setVarcharA(long offset, Utf8Sequence v) {
        setVarchar(offset, v, utf8viewA);
    }

    @Override
    public void setVarcharB(long offset, Utf8Sequence v) {
        setVarchar(offset, v, utf8viewB);
    <|file_separator|>class AbstractMemoryCR.java
<|fim_prefix|><|fim_suffix|>

    @Override
    public void setStrA(long offset, CharSequence str) {
        setStr(offset, str, csviewA);
    }

    @Override
    public void setStrB(long offset, CharSequence str) {
        setStr(offset, str, csviewB);
    }

    <nl>
            return new ByteSequenceView(address, len);
        }

        public ByteSequenceView(long address, long len) {
            this.address = address;
            this.len = len;
        <|file_separator|><nl>
        return true;
    <|file_separator|><nl>
        return new DefaultHttpHeaderParser(bufferLen, pool);
    <|file_separator|><nl>
        return locality.getMap().get(this);
    <|file_separator|><nl>
        this.kqueue.wait(timeout, op);
    <|file_separator|><nl>
        if (pessimisticMode) {
            context.sendResponse(new HttpResponse(HttpStatus.SERVICE_UNAVAILABLE));
        }
    <|file_separator|><nl>
        if (context.getHttpHeader().get(keepAliveHeader) != null) {
            return;
        }
        String tableName = context.getHttpHeader().get("Table");
        if (tableName == null) {
            throw new PeerDisconnectedException("Table name is not specified");
        }
        int existenceCheckResult = TableUtils.checkTableExists(tableName);
        String response = toResponse(existenceCheckResult);
        context.write(response);
    <|file_separator|><nl>
        return new LineTcpSender(new PlainTcpLineChannel(NetworkFacadeImpl.INSTANCE, ip, port, bufferCapacity * 2), bufferCapacity);
    }

    @Override
    public final void atNow() {
        // nanos
        putAsciiInternal(' ').put(System.nanoTime());
    <|file_separator|><nl>
        return tlException.get();
    <|file_separator|><nl>
        while (true) {
            LineTcpMeasurementEvent event = queue.poll();
            if (event == null) {
                return false;
            }
            if (!event.write(path)) {
                return true;
            }
        }
    <|file_separator|><nl>
            if (memory.isOpen()) {
                sortAndClose();
            }
            if (chunkNumber == 0) {
                memory.open(path, Vm.TRUNCATE_TO_POINTER);
            } else {
                memory.open(path, Vm.APPEND_ONLY);
            }
            chunkNumber++;
        <|file_separator|><nl>
        return "AbstractTypeAdapter";
    <|file_separator|><nl>
        return Type.BOOLEAN;
    <|file_separator|><nl>
        if (value == null) {
            return;
        }
        if (value.length() == 0) {
            return;
        }
        if (value.length() == 1) {
            utf16Sink.write(value.get(0));
            return;
        }
        int length = value.length();
        int i = 0;
        while (i < length) {
            utf16Sink.write(value.get(i));
            i++;
        }
    <|file_separator|><nl>
        if (columnName.length() == rootLen) {
            partitionDFile(path, rootLen, columnIndex, 0, 0, columnName, 0);
        } else {
            partitionDFile(path, rootLen, columnIndex, 0, 0, columnName, 0);
        }
    }

    private void dFile(Path path, CharSequence columnName, long columnNameTxn) {
        try {
            ff.deleteFile(path);
        } catch (IOException e) {
            LOG.error("Error deleting file " + path, e);
        }
    <|file_separator|><nl>
        return -1;
    <|file_separator|><nl>
        list.put(descriptor.getName(), new ObjList<>());
    <|file_separator|><nl>
        if (len < 2) {
            throw SqlException.position(position)
                    .put("invalid GEOHASH constant, must be number followed by 'C' or 'B' character");
        }
        int size;
        try {
            size = Numbers.parseInt(tok, 0, len - 1);
        } catch (NumericException e) {
            throw SqlException.position(position)
                    .put("invalid GEOHASH constant, must be number followed by 'C' or 'B' character");
        }
        switch (tok.charAt(len - 1)) {
            case 'C':
            case 'c':
                size *= 5;
                break;
            case 'B':
            case 'b':
                break;
            default:
                throw SqlException.position(position)
                        .put("invalid GEOHASH constant units, must be 'c', 'C' for chars, or 'b', 'B' for bits");
        }
        if (size < 1 || size > ColumnType.GEOLONG_MAX_BITS) {
            throw SqlException.position(position)
                    .put("invalid GEOHASH type precision range, must be [1, 60] bits, provided=")
                    .put(size);
        }
        return new ConstantFunction(size);
    <|file_separator|><nl>
        throw new UnsupportedOperationException();
    }

    @Override
    public final Date getDate(Record rec) {
        throw new UnsupportedOperationException();
    <|file_separator|><nl>
        throw new UnsupportedOperationException();
    }

    @Override
    public final int getSymbolLen(Record rec) {
        throw new UnsupportedOperationException();
    }

    @Override
    public final int getSymbolSize(Record rec) {
        throw new UnsupportedOperationException();
    }

    @Override
    public final int getSymbolType(Record rec) {
        throw new UnsupportedOperationException();
    <|file_separator|><nl>
        throw new UnsupportedOperationException();
    <|file_separator|>class GeoHashFunction.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class GeoHashFunction {
    public static final int GEO_LONG = 1;
    public static final int GEO_SHORT = 2;
    public static final int GEO_INT = 3;
}<|file_separator|>class AbstractGeoHashFunction.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public abstract class AbstractGeoHashFunction {
    protected int type;

    protected AbstractGeoHashFunction(int type) {
        this.type = type;
    }

    public abstract byte getGeoByte(Record rec);

    public abstract int getGeoInt(Record rec);

    public abstract short getGeoShort(Record rec);
}<|file_separator|><nl>
        throw new UnsupportedOperationException();
    }

    @Override
    public final int getStrLenA(Record rec) {
        throw new UnsupportedOperationException();
    }

    @Override
    public final int getStrLenB(Record rec) {
        throw new UnsupportedOperationException();
    }

    @Override
    public final int getStrLenC(Record rec) {
        throw new UnsupportedOperationException();
    }

    @Override
    public final int getStrLenD(Record rec) {
        throw new UnsupportedOperationException();
    }

    @Override
    public final int getStrLenE(Record rec) {
        throw new UnsupportedOperationException();
    }

    @Override
    public final int getStrLenF(Record rec) {
        throw new UnsupportedOperationException();
    }

    @Override
    public final int getStrLenG(Record rec) {
        throw new UnsupportedOperationException();
    }

    @Override
    public final int getStrLenH(Record rec) {
        throw new UnsupportedOperationException();
    }

    @Override
    public final int getStrLenI(Record rec) {
        throw new UnsupportedOperationException();
    }

    @Override
    public final int getStrLenJ(Record rec) {
        throw new UnsupportedOperationException();
    }

    @Override
    public final int getStrLenK(Record rec) {
        throw new UnsupportedOperationException();
    <|file_separator|><nl>
        throw new UnsupportedOperationException();
    <|file_separator|><nl>
            if (entryIndex == -1) {
                return false;
            }

            if (entryIndex == entryIds.size()) {
                return false;
            }

            return true;
        }

        @Override
        public void next() throws DataUnavailableException {
            if (entryIndex == -1) {
                throw new DataUnavailableException("No more entries");
            }

            if (entryIndex == entryIds.size()) {
                throw new DataUnavailableException("No more entries");
            }

            entry = queryRegistry.getEntry(entryIds.getQuick(entryIndex));
            entryIndex++;
        }

        @Override
        public void of(String principal) {
            this.principal = principal;
            toTop();
        }

        @Override
        public void of(String principal, String poolName) {
            this.principal = principal;
            if (poolName != null) {
                queryRegistry.getEntryIds(entryIds, principal, poolName);
            } else {
                queryRegistry.getEntryIds(entryIds, principal);
            }
            toTop();
        }

        @Override
        public void of(String principal, String poolName, boolean isWAL) {
            this.principal = principal;
            if (poolName != null) {
                queryRegistry.getEntryIds(entryIds, principal, poolName, isWAL);
            } else {
                queryRegistry.getEntryIds(entryIds, principal, isWAL);
            }
            toTop();
        <|file_separator|><nl>
            return data;
        <|file_separator|><nl>
        return this.value;
    }

    @Override
    public void setLong(Record rec, long value) {
        this.value = value;
    <|file_separator|><nl>
        isNull = value == Numbers.INT_NaN;
        if (!isNull) {
            utf8Sink.clear();
            utf8Sink.put(value);
        }
    <|file_separator|><nl>
            return to;
        <|file_separator|><nl>
        sink.add(arg.toPlan());
    <|file_separator|><nl>
        sink.add(new CastToShortFunction(arg));
    <|file_separator|>class AbstractCastToLongFunction extends LongFunction implements UnaryFunction {
    protected final Function arg;

    public AbstractCastToLongFunction(Function arg) {
        this.arg = arg;
    }

    @Override
    public Function getArg() {
        return arg;
    }

    @Override
    public void toPlan(PlanSink sink) {
        sink.add(new CastToLongFunction(arg));
    }
}<|file_separator|>class AbstractCastToFloatFunction extends FloatFunction implements UnaryFunction {
    protected final Function arg;

    public AbstractCastToFloatFunction(Function arg) {
        this.arg = arg;
    }

    @Override
    public Function getArg() {
        return arg;
    }

    @Override
    public void toPlan(PlanSink sink) {
        sink.add(new CastToFloatFunction(arg));
    }
}<|file_separator|>class AbstractCastToByteFunction extends ByteFunction implements UnaryFunction {
    protected final Function arg;

    public AbstractCastToByteFunction(Function arg) {
        this.arg = arg;
    }

    @Override
    public Function getArg() {
        return arg;
    }

    @Override
    public void toPlan(PlanSink sink) {
        sink.add(new CastToByteFunction(arg));
    }
}<|file_separator|>class AbstractCastToCharFunction extends CharFunction implements UnaryFunction {
    protected final Function arg;

    public AbstractCastToCharFunction(Function arg) {
        this.arg = arg;
    }

    @Override
    public Function getArg() {
        return arg;
    }

    @Override
    public void toPlan(PlanSink sink)<nl>
        sink.add(this.arg.toPlan(sink));
    <|file_separator|><nl>
            return this.getFunction().apply(rec);
        <|file_separator|><nl>
            return (short) this.getFunction().call(rec);
        <|file_separator|><nl>
            long256a.setAll(arg.getByte(rec), 0, 0, 0);
            long256b.setAll(arg.getByte(rec), 0, 0, 0);
        <|file_separator|><nl>
        return "cast_double_to_double";
    }

    @Override
    public CastFunction create() {
        return new CastDoubleToDoubleFunction();
    <|file_separator|><nl>
        return new Func(args.get(0));
    <|file_separator|><nl>
            final double value = arg.getDouble(rec);
            if (Double.isNaN(value)) {
                return;
            }
            utf16Sink.put(value, scale);
        <|file_separator|><nl>
            return getSymbolB(rec);
        <|file_separator|><nl>
        return new Func(args.get(position));
    <|file_separator|><nl>
        return new Func(args.get(0));
    <|file_separator|><nl>
            return (float) this.getFunction().call(rec);
        <|file_separator|><nl>
            return rec.getIntField(this.arg);
        <|file_separator|><nl>
            final int value = arg.getInt(rec);
            if (value == Numbers.INT_NaN) {
                return null;
            }
            sinkB.clear();
            sinkB.put(value);
            return sinkB;
        <|file_separator|><nl>
            final int value = arg.getInt(rec);
            if (value == Numbers.INT_NaN) {
                return SymbolTable.VALUE_IS_NULL;
            }
            return getSymbol0(value);
        <|file_separator|><nl>
        return "castLongToBoolean(long)";
    }

    @Override
    public boolean isApplicable(Type type) {
        return type.getSort() == Type.LONG;
    }

    @Override
    public Function newFunction(Type[] types, FunctionType functionType) {
        return new CastLongToBooleanFunction(types, functionType);
    <|file_separator|><nl>
        return "cast";
    <|file_separator|><nl>
        return new Func(args.get(position));
    <|file_separator|><nl>
        return new CastStrToBinaryFunction(position, args, argPositions, configuration, sqlExecutionContext);
    <|file_separator|><nl>
            return (byte) this.getFunction().apply(rec);
        <|file_separator|><nl>
            return this.arg.call(rec);
        <|file_separator|><nl>
        return new Func(args.get(0));
    <|file_separator|><nl>
        return "castSymbolToByte";
    <|file_separator|><nl>
            return (float) this.getFunction().call(rec);
        <|file_separator|><nl>
            final CharSequence value = arg.getSymbol(rec);
            if (value == null) {
                return Long256Impl.NULL_LONG256;
            }
            return Numbers.parseLong256(value, long256b);
        <|file_separator|><nl>
        return new Func(args.get(0));
    <|file_separator|><nl>
        return "cast_timestamp_to_timestamp";
    }

    @Override
    public String getSql(String from, String to) {
        return "cast(" + from + " as timestamp)";
    <|file_separator|><nl>
        return new Func(args.get(0));
    <|file_separator|><nl>
        return str.equals("true") || str.equals("1");
    <|file_separator|><nl>
            return (char) rec.get(0);
        }

        @Override
        public void write(Record rec, RecordWriter writer) {
            writer.write(utf16Sink.toString());
        <|file_separator|><nl>
        return INSTANCE;
    <|file_separator|><nl>
        Thread.dumpStack();
    <|file_separator|><nl>
        return value;
    <|file_separator|><nl>
            if (readNextFileFromDisk) {
                readNextFileFromDisk = false;
                if (findFileStruct == 0) {
                    return false;
                }

                if (foundMetadataFile) {
                    return false;
                }

                if (ff.read(findFileStruct, metaMem.getBuffer()) == 0) {
                    return false;
                }

                foundMetadataFile = true;
                readNextFileFromDisk = true;
            }

            if (columnIndex == columnCount) {
                return false;
            }

            int col = columnIndex++;
            int value = metaMem.getInt(col);
            if (value == 0) {
                return false;
            }

            if (value == 1) {
                return false;
            }

            if (value == 2) {
                return false;
            }

            if (value == 3) {
                return false;
            }

            if (value == 4) {
                return false;
            }

            if (value == 5) {
                return false;
            }

            if (value == 6) {
                return false;
            }

            if (value == 7) {
                return false;
            }

            if (value == 8) {
                return false;
            }

            if (value == 9) {
                return false;
            }

            if (value == 10) {
                return false;
            }

            if (value == 11) {
                return false;
            }

            if (value == 12) {
                return false;
            }

            if (value == 13) {
                return false;<nl>
        return true;
    <|file_separator|><nl>
        return true;
    <|file_separator|><nl>
            return charValues[col];
        }

        @Override
        public double getDouble(int col) {
            return doubleValues[col];
        }

        @Override
        public float getFloat(int col) {
            return floatValues[col];
        <|file_separator|><nl>
                    return getLong(col) > 0;
                <|file_separator|><nl>
        sink.add(new GeoLongReadPlan(this));
    <|file_separator|><nl>
        return picker.getCaseFunction(rec).getChar(rec);
    <|file_separator|>class CharFunction.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public abstract class CharFunction {
    public abstract char getChar(Record rec);
}<|file_separator|>class CharFunctionPicker.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class CharFunctionPicker {
    private final ObjList<CharFunction> functions;

    public CharFunctionPicker(ObjList<CharFunction> functions) {
        this.functions = functions;
    }

    public CharFunction getCharFunction(Record rec) {
        return functions.get(rec.getChar());
    }
}<|file_separator|>class CaseFunctionPicker.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class CaseFunctionPicker {
    private final ObjList<CaseFunction> functions;

    public CaseFunctionPicker(ObjList<CaseFunction> functions) {
        this.functions = functions;
    }

    public CaseFunction getCaseFunction(Record rec) {
        return functions.get(rec.getCase());
    }
}<|file_separator|>class CaseFunction.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public interface CaseFunction {
    char getChar(Record rec);
}<|file_separator|><nl>
            long lo0 = args0.getLong128Lo(rec);
            if (lo0 != Numbers.LONG_NaN) {
                return lo0; // if lo is not NaN then we know Long128 is not null
            }
            long hi0 = args0.getLong128Hi(rec);
            if (hi0 != Numbers.LONG_NaN) {
                return lo0; // if hi is not NaN then we know Long128 is not null and we can return lo0 even if it is NaN
            }
            // ok, both hi and lo are NaN, we use the value from the second argument
            return args1.getLong128Lo(rec);
        <|file_separator|><nl>
        return picker.getCaseFunction(args).getGeoInt(rec);
    <|file_separator|>class GeoIntFunction.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public abstract class GeoIntFunction {
    private final int type;

    public GeoIntFunction(int type) {
        this.type = type;
    }

    public int getType() {
        return type;
    }

    public abstract int getGeoInt(Record rec);
}<|file_separator|>class GeoIntCaseFunctionPicker.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class GeoIntCaseFunctionPicker {
    private final ObjList<Function> functions;

    public GeoIntCaseFunctionPicker(ObjList<Function> functions) {
        this.functions = functions;
    }

    public Function getCaseFunction(ObjList<Function> args) {
        for (Function f : functions) {
            if (f.getArgs().equals(args)) {
                return f;
            }
        }
        return null;
    }
}<|file_separator|>class GeoIntFunctionFactory.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class GeoIntFunctionFactory {
    public static GeoIntFunction getFunction(int type, ObjList<Function> args) {
        switch (type) {
            case 1:
                return new GeoIntCaseFunction(type, new GeoIntCaseFunctionPicker(args), args);
            case 2:
                return new GeoIntCaseFunction(type, new GeoIntCaseFunctionPicker(args), args);
            case 3:
                return new GeoIntCaseFunction(type, new GeoIntCaseFunctionPicker(args), args);
            case 4:
                return new GeoIntCaseFunction(type, new GeoIntCaseFunctionPicker(args), args);
            case 5:
                return new GeoIntCaseFunction(type, new GeoIntCaseFunctionPicker(args<nl>
        return picker.pick(rec).getLong(rec);
    <|file_separator|>class LongCaseFunctionPicker.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class LongCaseFunctionPicker extends CaseFunctionPicker {
    private final ObjList<Function> args;

    public LongCaseFunctionPicker(ObjList<Function> args) {
        this.args = args;
    }

    @Override
    public CaseFunction pick(Record rec) {
        return new LongCaseFunction(this, args);
    }
}<|file_separator|>class CaseFunctionPicker.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public abstract class CaseFunctionPicker {
    public abstract CaseFunction pick(Record rec);
}<|file_separator|>class CaseFunction.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public interface CaseFunction {
    ObjList<Function> getArgs();
    long getLong(Record rec);
}<|file_separator|><nl>
        sink.addConstant(hash);
    <|file_separator|><nl>
        sink.addConstant(value);
    <|file_separator|>class IntFunction.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public abstract class IntFunction extends Function {

    public abstract int getInt(Record rec);

    @Override
    public int getHash() {
        return getInt(null);
    }

    @Override
    public boolean equals(Object obj) {
        if (obj instanceof IntFunction) {
            return getInt(null) == ((IntFunction) obj).getInt(null);
        }
        return false;
    }

    @Override
    public int hashCode() {
        return getHash();
    }
}<|file_separator|>class IntConstant.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class IntConstant extends IntFunction implements ConstantFunction {

    public static final IntConstant NULL = new IntConstant(Numbers.INT_NaN);

    private final int value;

    public IntConstant(int value) {
        super();
        this.value = value;
    }

    public static IntConstant newInstance(int value) {
        return value != Numbers.INT_NaN ? new IntConstant(value) : NULL;
    }

    @Override
    public int getInt(Record rec) {
        return value;
    }

    @Override
    public void toPlan(PlanSink sink) {
        sink.addConstant(value);
    }
}<|file_separator|>class IntFunction.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public abstract class IntFunction extends Function {

    public abstract int getInt(Record rec);

    @Override
    public int getHash() {
        return getInt(null);
    }

    @Override
    public boolean equals(Object obj) {
        if (obj instanceof IntFunction) {
            return getInt(null) == ((IntFunction) obj).getInt(null);
        }
        return false;
    }

    <nl>
        return RecordCursorFactory.NULL;
    }

    @Override
    public int getNullConstant() {
        return ColumnType.NULL;
    }

    @Override
    public int getNullConstantLen() {
        return TableUtils.NULL_LEN;
    }

    @Override
    public int getNullConstantType() {
        return ColumnType.NULL;
    }

    @Override
    public int getNullConstantTypeLen() {
        return TableUtils.NULL_LEN;
    }

    @Override
    public int getNullConstantTypeType() {
        return ColumnType.NULL;
    <|file_separator|>class NullBinConstant.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>import java.nio.ByteBuffer;

public class NullBinConstant extends BinConstant {

    public static final NullBinConstant INSTANCE = new NullBinConstant();

    private NullBinConstant() {
    }

    @Override
    public BinarySequence getBin(Record rec) {
        return new BinarySequence(ByteBuffer.allocate(TableUtils.NULL_LEN));
    }

    @Override
    public long getBinLen(Record rec) {
        return TableUtils.NULL_LEN;
    }
}<|file_separator|>class NullBin.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>import java.nio.ByteBuffer;

public class NullBin extends Bin {

    public static final NullBin INSTANCE = new NullBin();

    private NullBin() {
    }

    @Override
    public BinarySequence getBin(Record rec) {
        return new BinarySequence(ByteBuffer.allocate(TableUtils.NULL_LEN));
    }

    @Override
    public long getBinLen(Record rec) {
        return TableUtils.NULL_LEN;
    }
}<|file_separator|>class NullBinConstantFactory.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class NullBinConstantFactory extends BinConstant<nl>
        return Type.REG_CLASS;
    <|file_separator|>class RegClassType.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class RegClassType extends Type {
    public static final RegClassType INSTANCE = new RegClassType();

    @Override
    public int getType() {
        return Type.REG_CLASS;
    }
}<|file_separator|>class RegClassTypeConstant.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class RegClassTypeConstant extends UntypedFunction implements TypeConstant {
    public static final RegClassTypeConstant INSTANCE = new RegClassTypeConstant();

    @Override
    public int getType() {
        return Type.REG_CLASS;
    }
}<|file_separator|>class RegClassType.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class RegClassType extends Type {
    public static final RegClassType INSTANCE = new RegClassType();

    @Override
    public int getType() {
        return Type.REG_CLASS;
    }
}<|file_separator|>class RegClassTypeConstant.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class RegClassTypeConstant extends UntypedFunction implements TypeConstant {
    public static final RegClassTypeConstant INSTANCE = new RegClassTypeConstant();

    @Override
    public int getType() {
        return Type.REG_CLASS;
    }
}<|file_separator|><nl>
        if (args.size() != 1) {
            throw new SqlException("date_trunc() expects 1 argument");
        }

        if (argPositions.size() != 1) {
            throw new SqlException("date_trunc() expects 1 argument");
        }

        if (argPositions.get(0) != position) {
            throw new SqlException("date_trunc() expects argument " + position);
        }

        if (!isTimeUnit(args.get(0).toString(), "second")) {
            throw new SqlException("date_trunc() expects argument to be a time unit");
        }

        return new DateTruncFunction(args.get(0).toString());
    <|file_separator|><nl>
            return context.now();
        <|file_separator|><nl>
        return timestamp.getTimestamp(rec) + offset;
    <|file_separator|><nl>
            sink.add(this);
        <|file_separator|><nl>
        return new ConstChrFunc(args.get(0), args.get(1).getChar(null));
    }

    @Override
    public Function newInstance(int position, ObjList<Function> args, IntList argPositions, CairoConfiguration configuration, SqlExecutionContext sqlExecutionContext) {
        return new ConstStrConstChrFunc(args.get(0).getBool(null));
    }

    @Override
    public Function newInstance(int position, ObjList<Function> args, IntList argPositions, CairoConfiguration configuration, SqlExecutionContext sqlExecutionContext) {
        return new ConstStrFunc(args.get(0), args.get(1).getChar(null));
    }

    @Override
    public Function newInstance(int position, ObjList<Function> args, IntList argPositions, CairoConfiguration configuration, SqlExecutionContext sqlExecutionContext) {
        return new Func(args.get(0), args.get(1));
    }

    @Override
    public Function newInstance(int position, ObjList<Function> args, IntList argPositions, CairoConfiguration configuration, SqlExecutionContext sqlExecutionContext) {
        return new NegatedAwareBooleanConstantFunc();
    <|file_separator|><nl>
            return left.getBool(rec) && right.getBool(rec);
        <|file_separator|><nl>
        return new EqUuidStrFunction(position, args, argPositions, configuration, sqlExecutionContext);
    <|file_separator|>class EqUuidStrFunction.php
<|fim_prefix|><|fim_suffix|>
        return $this->eqUuidStr($this->args[0]->eval($this->sqlExecutionContext), $this->args[1]->eval($this->sqlExecutionContext));
    }
}<|fim_middle|><?php
class EqUuidStrFunction extends Function {
    public function eqUuidStr($uuid1, $uuid2) {
        return $uuid1 == $uuid2;
    }

    public function eval() {<|file_separator|><nl>
        return new ConstStrFunc(strFuncPosition, strFunc, ipv4Func);
    }

    static @NotNull BooleanFunction eqStrIPv4(int strFuncPosition, Function strFunc, Function ipv4Func, Function ipv4Func2) throws SqlException {
        return new ConstStrFunc(strFuncPosition, strFunc, ipv4Func, ipv4Func2);
    }

    static @NotNull BooleanFunction eqStrIPv4(int strFuncPosition, Function strFunc, Function ipv4Func, Function ipv4Func2, Function ipv4Func3) throws SqlException {
        return new ConstStrFunc(strFuncPosition, strFunc, ipv4Func, ipv4Func2, ipv4Func3);
    }

    static @NotNull BooleanFunction eqStrIPv4(int strFuncPosition, Function strFunc, Function ipv4Func, Function ipv4Func2, Function ipv4Func3, Function ipv4Func4) throws SqlException {
        return new ConstStrFunc(strFuncPosition, strFunc, ipv4Func, ipv4Func2, ipv4Func3, ipv4Func4);
    }

    static @NotNull BooleanFunction eqStrIPv4(int strFuncPosition, Function strFunc, Function ipv4Func, Function ipv4Func2, Function ipv4Func3, Function ipv4Func4, Function ipv4Func5) throws SqlException {
        return new ConstStrFunc(strFuncPosition, strFunc, ipv4Func, ipv4Func2, ipv4Func3, ipv4Func4, ipv4Func5);
    }

    static @NotNull BooleanFunction eqStrIPv4(int strFuncPosition, Function strFunc, Function ipv4Func, Function ipv4Func2, Function ipv4Func3, Function ipv4Func4, Function ipv4Func5, Function ipv4Func6) throws SqlException {<nl>
        return true;
    <|file_separator|><nl>
        return new CountDistinctIPv4GroupByFunction(position, args, argPositions, configuration, sqlExecutionContext);
    <|file_separator|><nl>
        return new CountLong256GroupByFunction(position, args, argPositions, configuration, sqlExecutionContext);
    <|file_separator|><nl>
        return new FirstDoubleGroupByFunction(position, args, argPositions, configuration, sqlExecutionContext);
    <|file_separator|><nl>
        if (Double.isNaN(srcValue.getDouble(valueIndex + 1))) {
            computeFirst(destValue, srcValue, -1);
        }
    <|file_separator|><nl>
        destValue.putLong(valueIndex, srcValue.getLong(valueIndex));
        destValue.putTimestamp(valueIndex + 1, srcValue.getTimestamp(valueIndex + 1));
    }

    @Override
    public void setNull(MapValue mapValue, int valueIndex) {
        mapValue.putLong(valueIndex, Numbers.LONG_NaN);
        mapValue.putTimestamp(valueIndex + 1, Numbers.LONG_NaN);
    <|file_separator|><nl>
        mapValue.putLong(valueIndex, rowId);
        mapValue.putLong128(valueIndex + 1, Numbers.LONG_NaN, Numbers.LONG_NaN);
    <|file_separator|><nl>
        mapValue.putLong(valueIndex, Numbers.LONG_NaN);
        mapValue.putLong(valueIndex + 1, 0);
        mapValue.putBool(valueIndex + 2, true);
    }

    @Override
    public void toBottom() {
        UnaryFunction.super.toBottom();
    <|file_separator|><nl>
        return new LastCharGroupByFunction(position, args, argPositions, configuration, sqlExecutionContext);
    <|file_separator|><nl>
        return new LastFloatGroupByFunction(position, args, argPositions, configuration, sqlExecutionContext);
    <|file_separator|><nl>
                        long srcRowId = srcValue.getLong(valueIndex);
                        long destRowId = destValue.getLong(valueIndex);
                        if (srcRowId > destRowId) {
                            destValue.putLong(valueIndex, srcRowId);
                            destValue.putShort(valueIndex + 1, srcValue.getGeoShort(valueIndex + 1));
                        }
                    <|file_separator|><nl>
        if (srcValue.isLast()) {
            destValue.setLast(srcValue.getValue());
        }
    <|file_separator|><nl>
        if (Double.isNaN(arg.getDouble(srcValue))) {
            return;
        }
        computeFirst(destValue, srcValue.getRecord(), srcValue.getRowId());
    <|file_separator|><nl>
            if (srcValue.getGeoShort(srcValue.getRecord()) != GeoHashes.SHORT_NULL) {
                computeFirst(destValue, srcValue.getRecord(), srcValue.getRowId());
            }
        <|file_separator|><nl>
        long rowId = record.getLong(valueIndex);
        if (rowId > mapValue.getLong(valueIndex)) {
            mapValue.putLong(valueIndex, rowId);
            mapValue.putTimestamp(valueIndex + 1, record.getTimestamp(valueIndex + 1));
        }
    <|file_separator|><nl>
        return new LastTimestampGroupByFunction(position, args, argPositions, configuration, sqlExecutionContext);
    <|file_separator|><nl>
        return "last_uuid_group_by";
    <|file_separator|><nl>
        return false;
    <|file_separator|><nl>
        return "max_str_group_by";
    <|file_separator|><nl>
        return new MinBooleanGroupByFunction(position, args, argPositions, configuration, sqlExecutionContext);
    <|file_separator|>class MinBooleanFunctionFactory implements FunctionFactory {
    @Override
    public String getSignature() {
        return "min(T)";
    }

    @Override
    public boolean isGroupBy() {
        return false;
    }

    @Override
    public Function newInstance(int position, ObjList<Function> args, IntList argPositions, CairoConfiguration configuration, SqlExecutionContext sqlExecutionContext) {
        return new MinBooleanFunction(position, args, argPositions, configuration, sqlExecutionContext);
    }
}<|file_separator|>class MinIntegerGroupByFunctionFactory implements FunctionFactory {
    @Override
    public String getSignature() {
        return "min(T)";
    }

    @Override
    public boolean isGroupBy() {
        return true;
    }

    @Override
    public Function newInstance(int position, ObjList<Function> args, IntList argPositions, CairoConfiguration configuration, SqlExecutionContext sqlExecutionContext) {
        return new MinIntegerGroupByFunction(position, args, argPositions, configuration, sqlExecutionContext);
    }
}<|file_separator|>class MinIntegerFunctionFactory implements FunctionFactory {
    @Override
    public String getSignature() {
        return "min(T)";
    }

    @Override
    public boolean isGroupBy() {
        return false;
    }

    @Override
    public Function newInstance(int position, ObjList<Function> args, IntList argPositions, CairoConfiguration configuration, SqlExecutionContext sqlExecutionContext) {
        return new MinIntegerFunction(position, args, argPositions, configuration, sqlExecutionContext);
    }
}<|file_separator|>class MinIntegerFunction.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import<nl>
        mapValue.minLong(valueIndex, arg.getDate(record));
    <|file_separator|><nl>
        double min = arg.getDouble(record);
        mapValue.putDouble(valueIndex, min);
    <|file_separator|><nl>
        int value = arg.getInt(record);
        if (value != Numbers.INT_NaN && (value < mapValue.getInt(valueIndex) || mapValue.getInt(valueIndex) == Numbers.INT_NaN)) {
            mapValue.putInt(valueIndex, value);
        }
    <|file_separator|><nl>
        return new StdDevPopGroupByFunction(position, args, argPositions, configuration, sqlExecutionContext);
    <|file_separator|><nl>
        return new SumIntGroupByFunction(position, args, argPositions, configuration, sqlExecutionContext);
    <|file_separator|><nl>
        return true;
    <|file_separator|><nl>
        return "var_sample";
    <|file_separator|><nl>
            return "asin(" + x.getName() + ")";
        <|file_separator|>class AsinFunction.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class AsinFunction extends DoubleFunction implements ScalarFunction, UnaryFunction {
        final Function x;

        public AsinFunction(Function x) {
            this.x = x;
        }

        @Override
        public Function getArg() {
            return x;
        }

        @Override
        public double getDouble(Record rec) {
            return StrictMath.asin(x.getDouble(rec));
        }

        @Override
        public String getName() {
            return "asin(" + x.getName() + ")";
        }
    }<|file_separator|>class AsinFunction.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class AsinFunction extends DoubleFunction implements ScalarFunction, UnaryFunction {
        final Function x;

        public AsinFunction(Function x) {
            this.x = x;
        }

        @Override
        public Function getArg() {
            return x;
        }

        @Override
        public double getDouble(Record rec) {
            return StrictMath.asin(x.getDouble(rec));
        }

        @Override
        public String getName() {
            return "asin(" + x.getName() + ")";
        }
    }<|file_separator|><nl>
        return new BitNotIntFunction(args.get(argPositions.get(position)));
    <|file_separator|><nl>
        return new CosFunction(args.get(position));
    <|file_separator|><nl>
        return new ExpFunction(args.get(position));
    <|file_separator|><nl>
        return "IPv4MinusIPv4";
    <|file_separator|><nl>
        return "negint";
    <|file_separator|><nl>
        return new Func(args.get(argPositions.get(position - 1)), args.get(argPositions.get(position - 2)));
    <|file_separator|><nl>
            return arg;
        <|file_separator|><nl>
            return arg.getLong(rec);
        }

        @Override
        public String getName() {
            return "func";
        }
    }

    class Sign extends LongUnaryFunction implements UnaryFunction {

        @Override
        public Function getArg() {
            return null;
        }

        @Override
        public long getLong(Record rec) {
            return rec.getSign();
        <|file_separator|><nl>
            return rec.getStr(value).contains(pattern);
        <|file_separator|><nl>
        return "like";
    <|file_separator|><nl>
        return true;
    <|file_separator|><nl>
        return new Func(args.get(0), args.get(1), argPositions.get(1), args.get(2), argPositions.get(2), 1024, position);
    <|file_separator|><nl>
            return (byte) (rnd.nextByte() % range + lo);
        <|file_separator|><nl>
            rnd = new Rnd(executionContext);
        <|file_separator|><nl>
            rnd = new Rnd();
        <|file_separator|><nl>
        return new RndFunction(args.get(0).getInt());
    <|file_separator|><nl>
            return lenFunc.getInt(rec);
        }

        @Override
        public int getStrLenB(Record rec) {
            return lenFunc.getInt(rec);
        }

        @Override
        public int getStrLenA(Record rec) {
            return lenFunc.getInt(rec);
        }

        @Override
        public int getStrLenB(Record rec) {
            return lenFunc.getInt(rec);
        <|file_separator|><nl>
        return new MemoryMetricsFunction(position, args, argPositions, configuration, sqlExecutionContext);
    <|file_separator|><nl>
            super.preparePass2();
        }

        @Override
        public void preparePass3() {
            super.preparePass3();
        <|file_separator|><nl>
        return record;
    <|file_separator|><nl>
        return true;
    <|file_separator|><nl>
        function.setFloat(
                mapValue,
                (float) interpolate(
                        x,
                        x1,
                        Unsafe.getUnsafe().getFloat(y1Address),
                        x2,
                        Unsafe.getUnsafe().getFloat(y2Address)
                )
        );
    <|file_separator|><nl>
        cursor.toPlan(sink);
    <|file_separator|><nl>
        base.toPlan(sink);
        sink.add(cursor);
    <|file_separator|><nl>
        return getFunction(col).getRecord(base);
    }

    @Override
    public long getTimestamp(int col, long time) {
        return getFunction(col).getTimestamp(base, time);
    <|file_separator|><nl>
        this.ptr = ptr;
        direct = (ptr & 0x8000000000000000L) != 0;
        return this;
    }

    @Override
    public void writeTo(long ptr, int offset, int length) {
        if (direct) {
            // we could cache the direct pointer, but then we would need to invalidate it when the pointer changes
            // and we assume of() is called more frequently than charAt()
            long directPtr = Unsafe.getUnsafe().getLong(ptr + HEADER_SIZE);
            assert directPtr != 0;
            Unsafe.getUnsafe().putByte(directPtr + offset, (byte) length);
        } else {
            Unsafe.getUnsafe().putByte(ptr + HEADER_SIZE + offset, (byte) length);
        }
    <|file_separator|><nl>
        return sum.sum() / count.sum();
    <|file_separator|><nl>
        return true;
    <|file_separator|><nl>
        if (columnIndex < masterSlaveSplit) {
            return masterCursor.newSymbolTable(columnIndex);
        }
        int slaveCol = columnIndex - masterSlaveSplit;
        if (slaveCol >= slaveWrappedOverMaster) {
            slaveCol -= slaveWrappedOverMaster;
            int masterCol = masterTableKeyColumns.getColumnIndexFactored(slaveCol);
            return masterCursor.newSymbolTable(masterCol);
        }
        slaveCol = slaveColumnIndex.getQuick(slaveCol);
        return slaveCursor.newSymbolTable(slaveCol);
    <|file_separator|><nl>
            if (slaveChainCursor != null) {
                slaveChainCursor.toTop();
            }
        }

        @Override
        public void toBottom() {
            if (slaveChainCursor != null) {
                slaveChainCursor.toBottom();
            }
        <|file_separator|><nl>
            if (masterRecord == null) {
                if (useSlaveCursor) {
                    if (slaveCursor.hasNext()) {
                        slaveRecord = slaveCursor.getRecord();
                        recordA.of(masterRecord, slaveRecord);
                        return true;
                    }
                } else {
                    if (masterCursor.hasNext()) {
                        masterRecord = masterCursor.getRecord();
                        return true;
                    }
                }
            }
            return false;
        }

        @Override
        public void open() {
            if (isOpen) {
                return;
            }
            if (masterCursor == null) {
                throw new IllegalStateException("masterCursor is null");
            }
            if (slaveCursor == null) {
                throw new IllegalStateException("slaveCursor is null");
            }
            of(masterCursor, slaveCursor, circuitBreaker);
        }

        @Override
        public void open(RecordCursor masterCursor, RecordCursor slaveCursor, SqlExecutionCircuitBreaker circuitBreaker) {
            of(masterCursor, slaveCursor, circuitBreaker);
        }

        @Override
        public void open(RecordCursor masterCursor, RecordCursor slaveCursor) {
            of(masterCursor, slaveCursor, circuitBreaker);
        }

        @Override
        public void open(RecordCursor masterCursor, RecordCursor slaveCursor, SqlExecutionCircuitBreaker circuitBreaker, boolean useSlaveCursor) {
            of(masterCursor, slaveCursor, circuitBreaker);
            this.useSlaveCursor = useSlaveCursor;
        <|file_separator|><nl>
            if (useSlaveCursor) {
                return slaveCursor.hasNext();
            }
            if (masterRecord == null) {
                return false;
            }
            if (isMapBuilt) {
                return filter.hasNext();
            }
            if (joinKeyMap.hasNext()) {
                isMapBuilt = true;
                return true;
            }
            return false;
        }

        @Override
        public void next() {
            if (useSlaveCursor) {
                slaveCursor.next();
                return;
            }
            if (masterRecord == null) {
                return;
            }
            if (isMapBuilt) {
                filter.next();
                return;
            }
            if (joinKeyMap.next()) {
                isMapBuilt = true;
                return;
            }
        }

        @Override
        public void setFilter(RecordFilter filter) {
            if (useSlaveCursor) {
                slaveCursor.setFilter(filter);
                return;
            }
            if (masterRecord == null) {
                return;
            }
            if (isMapBuilt) {
                filter.init(this, circuitBreaker);
                return;
            }
            if (joinKeyMap.next()) {
                isMapBuilt = true;
                return;
            }
        <|file_separator|><nl>
            return base.size();
        }

        @Override
        public void toBottom() {
            base.toBottom();
        <|file_separator|><nl>
        isOpen = false;
    <|file_separator|><nl>
            return columnPageAddress.getQuick(columnIndex * 2 + 1) - columnPageAddress.getQuick(columnIndex * 2);
        <|file_separator|><nl>
        this.record = record;
        base.recordAt(record, atRowId);
    }

    @Override
    public void recordAt(Record record, long atRowId, int columnIndex) {
        this.record = record;
        base.recordAt(record, atRowId, columnIndex);
    }

    @Override
    public void recordAt(Record record, long atRowId, int columnIndex, int columnType) {
        this.record = record;
        base.recordAt(record, atRowId, columnIndex, columnType);
    }

    @Override
    public void recordAt(Record record, long atRowId, int columnIndex, int columnType, int columnSize) {
        this.record = record;
        base.recordAt(record, atRowId, columnIndex, columnType, columnSize);
    }

    @Override
    public void recordAt(Record record, long atRowId, int columnIndex, int columnType, int columnSize, int columnScale) {
        this.record = record;
        base.recordAt(record, atRowId, columnIndex, columnType, columnSize, columnScale);
    }

    @Override
    public void recordAt(Record record, long atRowId, int columnIndex, int columnType, int columnSize, int columnScale, int columnPrecision) {
        this.record = record;
        base.recordAt(record, atRowId, columnIndex, columnType, columnSize, columnScale, columnPrecision);
    }

    @Override
    public void recordAt(Record record, long atRowId, int columnIndex, int columnType, int columnSize, int columnScale, int columnPrecision, int columnRadix) {
        this.record = record;
        base.recordAt(record,<nl>
        sink.add(new LatestByAllSymbolsFilteredRecordCursorPlan(this));
    }

    @Override
    public void toPlan(PlanSink sink, @NotNull String name) {
        sink.add(new LatestByAllSymbolsFilteredRecordCursorPlan(this));
    }

    @Override
    public void toPlan(PlanSink sink, @NotNull String name, @NotNull String description) {
        sink.add(new LatestByAllSymbolsFilteredRecordCursorPlan(this));
    }

    @Override
    public void toPlan(PlanSink sink, @NotNull String name, @NotNull String description, @NotNull String description2) {
        sink.add(new LatestByAllSymbolsFilteredRecordCursorPlan(this));
    <|file_separator|>class LatestByAllSymbolsFilteredRecordCursorPlan.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class LatestByAllSymbolsFilteredRecordCursorPlan extends RecordCursorPlan {

    public LatestByAllSymbolsFilteredRecordCursorPlan(LatestByAllSymbolsFilteredRecordCursorFactory factory) {
        super(factory);
    }

    @Override
    public void toPlan(PlanSink sink) {
        sink.add(new LatestByAllSymbolsFilteredRecordCursorPlan(this));
    }

    @Override
    public void toPlan(PlanSink sink, @NotNull String name) {
        sink.add(new LatestByAllSymbolsFilteredRecordCursorPlan(this));
    }

    @Override
    public void toPlan(PlanSink sink, @NotNull String name, @NotNull String description) {
        sink.add(new LatestByAllSymbolsFilteredRecordCursorPlan(this));
    }

    @Override
    public void toPlan(PlanSink sink, @NotNull String name, @NotNull String description, @NotNull String description2) {
        sink.add(new LatestByAllSymbolsFilteredRecordCursorPlan(this<nl>
            while (baseCursor.hasNext()) {
                circuitBreaker.statefulThrowExceptionIfTripped();
                final MapKey key = latestByMap.withKey();
                recordSink.copy(baseRecord, key);
                key.putTimestamp(TIMESTAMP_VALUE_IDX, baseRecord.getTimestamp(timestampIndex));
            }
        <|file_separator|><nl>
        return cursor;
    }

    @Override
    public boolean isCached() {
        return cachedIndexReaderCursor;
    <|file_separator|><nl>
                switch (col) {
                    case 0:
                        return isPartition;
                    default:
                        throw new UnsupportedOperationException();
                }
            <|file_separator|><nl>
        this.symbolKey = symbolKey;
    <|file_separator|><nl>
        super._close();
        if (cursor != null) {
            cursor.close();
        }
    <|file_separator|>class AbstractSetRecordCursor.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public abstract class AbstractSetRecordCursor extends AbstractRecordCursor {
    protected final RecordCursor cursorA;
    protected final RecordCursor cursorB;
    protected final CircuitBreaker circuitBreaker;
    protected final boolean isSecondFactoryHashed;

    public AbstractSetRecordCursor(
            RecordCursor cursorA,
            RecordCursor cursorB,
            CircuitBreaker circuitBreaker,
            boolean isSecondFactoryHashed
    ) {
        this.cursorA = cursorA;
        this.cursorB = cursorB;
        this.circuitBreaker = circuitBreaker;
        this.isSecondFactoryHashed = isSecondFactoryHashed;
    }

    @Override
    public void of(RecordCursor cursorA, RecordCursor cursorB, CircuitBreaker circuitBreaker) {
        this.cursorA.of(cursorA);
        this.cursorB.of(cursorB);
        this.circuitBreaker.of(circuitBreaker);
    }

    @Override
    public void close() {
        cursorA.close();
        cursorB.close();
    }

    @Override
    public boolean isSecondFactoryHashed() {
        return isSecondFactoryHashed;
    }
}<|file_separator|>class AbstractRecordCursorFactory.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public abstract class AbstractRecordCursorFactory implements RecordCursorFactory {
    protected final RecordMetadata metadata;

    public AbstractRecordCursorFactory(RecordMetadata metadata) {
        this.metadata = metadata;
    }

    @Override
    public RecordMetadata getMetadata() {
        return metadata;
    }

    @Override
    public void toPlan(PlanSink sink) {
        sink.type(get<nl>
        if (cursorA.hasNext()) {
            if (!isCursorBHashed) {
                hashCursorB();
                isCursorBHashed = true;
            }
            return true;
        }
        return false;
    }

    @Override
    public void next() {
        if (cursorA.hasNext()) {
            if (!isCursorBHashed) {
                hashCursorB();
                isCursorBHashed = true;
            }
            cursorA.next();
            recordA = cursorA.getRecord();
            recordB = cursorB.getRecord();
        }
    <|file_separator|><nl>
        cursor.close();
    <|file_separator|><nl>
        return symbolCapacity;
    <|file_separator|>class ColumnCast.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class ColumnCast {
    public static final ObjectFactory<ColumnCast> FACTORY = ColumnCast::new;
    private int columnType;
    private int columnNamePos;
    private int columnTypePos;
    private int indexValueBlockSize;
    private boolean indexed;
    private ExpressionNode name;
    private boolean symbolCacheFlag;
    private int symbolCapacity;

    private ColumnCast() {
    }

    public int getColumnType() {
        return columnType;
    }

    public int getColumnNamePos() {
        return columnNamePos;
    }

    public int getColumnTypePos() {
        return columnTypePos;
    }

    public int getIndexValueBlockSize() {
        return indexValueBlockSize;
    }

    public ExpressionNode getName() {
        return name;
    }

    public boolean getSymbolCacheFlag() {
        return symbolCacheFlag;
    }

    public int getSymbolCapacity() {
        return symbolCapacity;
    }

    public boolean isIndexed() {
        return indexed;
    }

    public void setIndexValueBlockSize(int indexValueBlockSize) {
        this.indexValueBlockSize = indexValueBlockSize;
    }

    public void setIndexed(boolean indexed) {
        this.indexed = indexed;
    }

    public void setName(ExpressionNode name) {
        this.name = name;
    }

    public void setSymbolCacheFlag(boolean symbolCacheFlag) {
        this.symbolCacheFlag = symbolCacheFlag;
    }

    public void setSymbolCapacity(int symbolCapacity) {
        this.symbolCapacity = symbolCapacity;
    }

    public void setType(int columnType, int columnNamePos, int columnTypePos<nl>
        if (aNodes.size() == 0 && bNodes.size() == 0) {
            return;
        }
        sink.add(aNames);
        sink.add(aNodes);
        sink.add(bNames);
        sink.add(bNodes);
    <|file_separator|>class JoinClause.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class JoinClause {
    public final JoinContext context;
    public final int index;
    public final int type;
    public final int typeIndex;
    public final int typeIndex2;
    public final int typeIndex3;
    public final int typeIndex4;
    public final int typeIndex5;
    public final int typeIndex6;
    public final int typeIndex7;
    public final int typeIndex8;
    public final int typeIndex9;
    public final int typeIndex10;
    public final int typeIndex11;
    public final int typeIndex12;
    public final int typeIndex13;
    public final int typeIndex14;
    public final int typeIndex15;
    public final int typeIndex16;
    public final int typeIndex17;
    public final int typeIndex18;
    public final int typeIndex19;
    public final int typeIndex20;
    public final int typeIndex21;
    public final int typeIndex22;
    public final int typeIndex23;
    public final int typeIndex24;
    public final int typeIndex25;
    public final int typeIndex26;
    public final int typeIndex27;
    public final int typeIndex28;
    public final int typeIndex29;
    public final int typeIndex30;
    public final int<nl>
    <|file_separator|>class RenameTableModelFactory.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class RenameTableModelFactory implements MutableFactory<RenameTableModel> {
    public static final ObjectFactory<RenameTableModelFactory> FACTORY = RenameTableModelFactory::new;

    private RenameTableModelFactory() {
    }

    @Override
    public RenameTableModel create() {
        return new RenameTableModel();
    }
}<|file_separator|>class RenameTableModelFactory$1.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>class RenameTableModelFactory$1 implements ObjectFactory<RenameTableModelFactory> {
    public static final ObjectFactory<RenameTableModelFactory> FACTORY = RenameTableModelFactory::new;

    private RenameTableModelFactory$1() {
    }

    @Override
    public RenameTableModelFactory create() {
        return new RenameTableModelFactory();
    }
}<|file_separator|>class RenameTableModelFactory$2.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>class RenameTableModelFactory$2 implements ObjectFactory<RenameTableModelFactory> {
    public static final ObjectFactory<RenameTableModelFactory> FACTORY = RenameTableModelFactory::new;

    private RenameTableModelFactory$2() {
    }

    @Override
    public RenameTableModelFactory create() {
        return new RenameTableModelFactory();
    }
}<|file_separator|>class RenameTableModelFactory$3.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>class RenameTableModelFactory$3 implements ObjectFactory<RenameTableModelFactory> {
    public static final ObjectFactory<RenameTableModelFactory> FACTORY = RenameTableModelFactory::new;

    private RenameTableModelFactory$3() {
    }

    @Override
    public RenameTableModelFactory create() {
        return new RenameTableModelFactory();
    }
}<|file_separator|>class RenameTableModelFactory$4.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>class RenameTableModelFactory$4 implements ObjectFactory<RenameTableModelFactory> {
    public static final ObjectFactory<RenameTableModelFactory> FACTORY = RenameTableModelFactory::new;

    private RenameTableModelFactory$4() {<nl>
        return true;
    }

    @Override
    public void setLevel(int level) {
        this.level = level;
    }

    @Override
    public void setSubSeq(SCSequence subSeq) {
        this.subSeq = subSeq;
    <|file_separator|><nl>
        return (flags[lo & mask] == -1);
    <|file_separator|><nl>
        Unsafe.getUnsafe().putLong(this, CACHE_OFFSET, cache);
    <|file_separator|><nl>
        this.waiter = Thread.currentThread();
        while (getCount() > 0) {
            // Don't use LockSupport.park() here.
            // Once in a while there can be a delay between check of this.count > -count
            // and parking and unparkWaiter() will be called before park().
            // Limit the parking time by using Os.park() instead of LockSupport.park()
            if (Os.parkNanos(nanos)) {
                return false;
            }
        }
        return true;
    <|file_separator|><nl>
        this.count = count;
        this.awaitedCount = count;
        unparkWaiter();
    }

    public void await() {
        await(1);
    }

    public void await(long timeout, TimeUnit unit) {
        await(1);
    }

    public void awaitUninterruptibly() {
        await(1);
    }

    public void awaitUninterruptibly(long timeout, TimeUnit unit) {
        await(1);
    }

    public void countDown(int count) {
        this.awaitedCount -= count;
    }

    public void countDown() {
        countDown(1);
    <|file_separator|><nl>
        barrier.done(cursor);
    <|file_separator|>class AbstractSSequence.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public abstract class AbstractSSequence implements SSequence {
    protected final WaitStrategy waitStrategy;
    protected long value;
    protected long cache;
    protected final Barrier barrier;

    protected AbstractSSequence(WaitStrategy waitStrategy) {
        this.waitStrategy = waitStrategy;
        this.barrier = new Barrier(this);
    }

    public long available() {
        return cache + 1;
    }

    public long availableIndex(long lo) {
        return value;
    }

    public long current() {
        return value;
    }

    public void done(long cursor) {
        barrier.done(cursor);
    }

    public long next() {
        long next = getValue() + 1;
        long lo = next - 1;
        return lo > cache && lo > (cache = barrier.availableIndex(lo)) ? -1 : next;
    }

    public void setCurrent(long value) {
        this.value = value;
    }
}<|file_separator|>class SSequence.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public interface SSequence {
    long available();

    long availableIndex(long lo);

    long current();

    void done(long cursor);

    long next();

    void setCurrent(long value);
}<|file_separator|>class Barrier.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class Barrier {
    private final SSequence sequence;
    private final long[] cursor;
    private final long[] value;

    public Barrier(SSequence sequence) {
        this.sequence = sequence;
        this.cursor = new long[sequence.available()];
        this.value = new long[sequence.available()];
    }

    public void done(long<nl>
        if (locked == 0) {
            locked = workerId;
            try {
                return runSerially();
            } finally {
                locked = 0;
            }
        } else {
            return false;
        }
    <|file_separator|><nl>
        lock.lock();
        try {
            alerted = true;
            condition.signal();
        } finally {
            lock.unlock();
        }
    <|file_separator|><nl>
        flag = true;
    <|file_separator|><nl>
        return EpollAccessor.readEventFd(fd);
    <|file_separator|><nl>
        return HeartBeatException.INSTANCE;
    <|file_separator|><nl>
        return KqueueAccessor.writePipe(fd);
    <|file_separator|><nl>
        return deadline;
    <|file_separator|><nl>
        super.clear();
        list.clear();
    }

    @Override
    public void clear(int lo, int hi) {
        super.clear(lo, hi);
        list.clear(lo, hi);
    }

    @Override
    public void clear(int lo, int hi, int lo2, int hi2) {
        super.clear(lo, hi, lo2, hi2);
        list.clear(lo, hi, lo2, hi2);
    }

    @Override
    public void clear(int lo, int hi, int lo2, int hi2, int lo3, int hi3) {
        super.clear(lo, hi, lo2, hi2, lo3, hi3);
        list.clear(lo, hi, lo2, hi2, lo3, hi3);
    }

    @Override
    public void clear(int lo, int hi, int lo2, int hi2, int lo3, int hi3, int lo4, int hi4) {
        super.clear(lo, hi, lo2, hi2, lo3, hi3, lo4, hi4);
        list.clear(lo, hi, lo2, hi2, lo3, hi3, lo4, hi4);
    }

    @Override
    public void clear(int lo, int hi, int lo2, int hi2, int lo3, int hi3, int lo4, int hi4, int lo5, int hi5) {
        super.clear(lo, hi, lo2, hi2, lo3, hi3, lo4, hi4, lo5, hi5);
        list.clear(lo, hi, lo2, hi2, lo3, hi3,<nl>
        do {
            index = (index + 1) & mask;
            if (keys[index] == noEntryKey) {
                return index;
            }
            if (hashCode == hashCodes[index] && Utf8s.equalsIgnoreCaseAscii(key, lo, hi, keys[index], 0, keys[index].size())) {
                return -index - 1;
            }
        } while (true);
    <|file_separator|><nl>
        int[] data = this.data;
        if (index >= data.length) {
            throw new IndexOutOfBoundsException("Index out of range: " + index);
        }
        Unsafe.arrayPutOrdered(data, index, value);
    }

    public void remove(int index) {
        int[] data = this.data;
        int pos = this.pos;
        if (index >= pos) {
            throw new IndexOutOfBoundsException("Index out of range: " + index);
        }
        Unsafe.arrayPutOrdered(data, index, NO_ENTRY_VALUE);
        if (pos > index) {
            this.pos = index;
        }
    <|file_separator|><nl>
        if (this == obj) {
            return true;
        }
        if (obj instanceof CharSequenceBoolHashMap) {
            CharSequenceBoolHashMap other = (CharSequenceBoolHashMap) obj;
            if (keys.length == other.keys.length) {
                for (int i = 0, n = keys.length; i < n; i++) {
                    if (keys[i] != other.keys[i]) {
                        return false;
                    }
                }
                return true;
            }
        }
        return false;
    }

    public boolean get(CharSequence key, boolean defaultValue) {
        int index = keyIndex(key);
        return index > -1 ? valueAt(index) : defaultValue;
    <|file_separator|>class CharSequenceHashSet.java
<|fim_prefix|><|fim_suffix|>

    public boolean put(CharSequence key) {
        return putAt(keyIndex(key), key);
    }

    public void putAll(CharSequenceHashSet other) {
        CharSequence[] otherKeys = other.keys;
        for (int i = 0, n = otherKeys.length; i < n; i++) {
            if (otherKeys[i] != null) {
                put(otherKeys[i]);
            }
        }
    }

    public boolean putAt(int index, CharSequence key) {
        if (index < 0) {
            keys[-index - 1] = key;
            return false;
        }
        final String keyString = Chars.toString(key);
        putAt0(index, keyString);
        list.add(keyString);
        return true;
    }

    public void putIfAbsent(CharSequence key) {
        int index = keyIndex(key);
        if (index > -1) {
            <nl>
        if (key == null) {
            return addNull();
        }
        int keyIndex = keyIndex(key);
        if (keyIndex < 0) {
            addAt(keyIndex, key);
            return true;
        }
        return false;
    <|file_separator|>class CharSequenceHashSet.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>import java.util.AbstractSet;
import java.util.Collection;
import java.util.Iterator;
import java.util.Objects;
import java.util.Set;
import java.util.function.Predicate;
import java.util.stream.Stream;

import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

/**
 * A set of immutable sequences of characters.
 *
 * @author John
 */
public abstract class CharSequenceHashSet extends AbstractSet<CharSequence> implements CharSequenceSet {

    private static final CharSequence[] EMPTY_ARRAY = new CharSequence[0];
    private static final CharSequence[] NULL_ARRAY = new CharSequence[1];
    private static final CharSequence[] NO_ENTRY_ARRAY = new CharSequence[0];
    private static final CharSequence[] NO_NULL_ARRAY = new CharSequence[1];
    private static final CharSequence[] NO_ARRAY = new CharSequence[0];
    private static final CharSequence[] NULL_NULL_ARRAY = new CharSequence[2];
    private static final CharSequence[] NULL_NO_ARRAY = new CharSequence[2];
    private static final CharSequence[] NO_NULL_NO_ARRAY = new CharSequence[3];
    private static final CharSequence[] NO_ARRAY_NO_ARRAY = new CharSequence[2];
    private static final CharSequence[] NULL_ARRAY_NO_ARRAY = new CharSequence[2];
    private static final CharSequence[] NULL_NO_ARRAY_NO_ARRAY = new CharSequence[3];
    private static final CharSequence<nl>
        int l = 0;
        int r = pos;
        while (l < r) {
            int m = (l + r) >> 1;
            long f = get(m, index);
            if (f == v) {
                return m;
            }
            if (f > v) {
                r = m;
            } else {
                l = m + 1;
            }
        }
        return -(l + 1);
    }

    public int binarySearch(long v) {
        int l = 0;
        int r = pos;
        while (l < r) {
            int m = (l + r) >> 1;
            long f = get(m, 0);
            if (f == v) {
                return m;
            }
            if (f > v) {
                r = m;
            } else {
                l = m + 1;
            }
        }
        return -(l + 1);
    }

    public int binarySearch(long v, int index, int start) {
        int l = start;
        int r = pos;
        while (l < r) {
            int m = (l + r) >> 1;
            long f = get(m, index);
            if (f == v) {
                return m;
            }
            if (f > v) {
                r = m;
            } else {
                l = m + 1;
            }
        }
        return -(l + 1);
    }

    public int binarySearch(long v, int index, int start, int end) {
        int l = start;
        int r = end<nl>
        int newCapacity = (int) (keys.length * loadFactor);
        if (newCapacity < MIN_INITIAL_CAPACITY) {
            newCapacity = MIN_INITIAL_CAPACITY;
        }

        CharSequence[] newKeys = new CharSequence[newCapacity];
        int newFree = free;
        for (int i = 0; i < keys.length; i++) {
            CharSequence key = keys[i];
            if (key != noEntryKey) {
                int index = keyIndex(key);
                if (index >= 0) {
                    addAt(index, key);
                } else {
                    newKeys[newFree++] = key;
                }
            }
        }

        keys = newKeys;
        free = newFree;
    }

    private int keyIndex(CharSequence key) {
        int index = key.hashCode() & (keys.length - 1);
        while (keys[index] != noEntryKey && !Chars.equals(keys[index], key)) {
            index = (index + 1) & (keys.length - 1);
        }
        return index;
    <|file_separator|><nl>
        int newCapacity = keys.length * 2;
        long[] newValues = new long[newCapacity];
        int newFree = 0;
        for (int i = 0; i < keys.length; i++) {
            if (keys[i] != noEntryKey) {
                putAt0(newFree++, keys[i], values[i]);
            }
        }
        keys = newKeys(newCapacity);
        values = newValues;
        free = newFree;
    }

    @Override
    protected int keyIndex(CharSequence key) {
        return super.keyIndex(Chars.toLowerCaseAscii(key));
    <|file_separator|>class LowerCaseAsciiCharSequenceHashSet.java
<|fim_prefix|><|fim_suffix|>

    protected int keyIndex(CharSequence key) {
        int index = key.hashCode() & (keys.length - 1);
        if (index < 0) {
            index += keys.length;
        }
        return index;
    }

    protected void erase(int index) {
        keys[index] = noEntryKey;
    }

    protected void move(int from, int to) {
        keys[to] = keys[from];
        erase(from);
    }
}<|fim_middle|>import java.util.AbstractSet;
import java.util.Arrays;
import java.util.Collection;
import java.util.Iterator;
import java.util.Objects;
import java.util.Set;

public abstract class LowerCaseAsciiCharSequenceHashSet extends AbstractSet<CharSequence> {
    private static final CharSequence noEntryKey = new NoEntryKey();
    private static final class NoEntryKey extends CharSequence {
        private static final CharSequence INSTANCE = new NoEntryKey();
        private NoEntryKey() {
        }
        public int length<nl>
        super.clear();
        Arrays.fill(values, noEntryValue);
    }

    @Override
    public int size() {
        int size = super.size();
        if (size < 0) {
            return 0;
        }
        return size;
    }

    @Override
    public boolean isEmpty() {
        return size() == 0;
    }

    @Override
    public boolean containsKey(CharSequence key) {
        return key != null && get(key) != noEntryValue;
    }

    @Override
    public boolean containsValue(int value) {
        for (int i = 0, n = keys.length; i < n; i++) {
            if (keys[i] != noEntryKey && values[i] == value) {
                return true;
            }
        }
        return false;
    <|file_separator|>class LowerCaseCharSequenceHashMap.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>import java.util.AbstractMap;
import java.util.AbstractSet;
import java.util.Arrays;
import java.util.Collection;
import java.util.Map;
import java.util.Set;

public class LowerCaseCharSequenceHashMap extends AbstractMap<CharSequence, Integer> {
    private static final int NO_ENTRY_VALUE = -1;
    private final int noEntryValue;
    private int[] values;

    public LowerCaseCharSequenceHashMap() {
        this(8);
    }

    public LowerCaseCharSequenceHashMap(int initialCapacity) {
        this(initialCapacity, 0.5, NO_ENTRY_VALUE);
    }

    public LowerCaseCharSequenceHashMap(int initialCapacity, double loadFactor, int noEntryValue) {
        super();
        this.noEntryValue = noEntryValue;<nl>
        if (index < 0) {
            return;
        }

        int keyIndex = keyIndex(key);
        if (keyIndex < 0) {
            return;
        }

        if (keys[keyIndex] == null) {
            list.add(key);
        }
        keys[keyIndex] = key;
        hashCodes[keyIndex] = key.hashCode();
    <|file_separator|>class Utf8SequenceHashSet.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>import java.util.AbstractSet;
import java.util.Collection;
import java.util.Iterator;
import java.util.Objects;
import java.util.Set;
import java.util.function.Consumer;
import java.util.function.Predicate;
import java.util.function.UnaryOperator;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;

import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

/**
 * A hash set that stores {@link Utf8Sequence} objects.
 *
 * @author John
 */
public abstract class Utf8SequenceHashSet extends AbstractSet<Utf8Sequence> implements Set<Utf8Sequence> {

    protected static final Utf8Sequence noEntryKey = new Utf8Sequence(0);
    protected static final Utf8Sequence nullKey = new Utf8Sequence(1);
    protected static final Utf8Sequence[] noEntryKeys = new Utf8Sequence[0];
    protected static final Utf8Sequence[] nullKeys = new Utf8Sequence[1];
    protected static final Utf8Sequence[] noEntryNullKeys = new Utf8Sequence[0];
    protected static final Utf8Sequence[] nullNullKeys = new Utf8Sequence[1];
    protected static final Utf8Sequence[] noEntryNullNullKeys<nl>
        return factory.create();
    <|file_separator|><nl>
        return new DateLocale(val.getSymbols(), timeZoneRuleFactory.getRule(key));
    <|file_separator|><nl>
        return integerAllValuesIterator.hasNext();
    <|file_separator|>class DoubleHistogramIterationValue.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>/**
 * A class to represent a single iteration of a DoubleHistogram.
 */
public class DoubleHistogramIterationValue {
    public final Double integerValue;
    public final Double doubleValue;

    /**
     * @param integerValue The integer value of the iteration
     * @param doubleValue The double value of the iteration
     */
    public DoubleHistogramIterationValue(final Double integerValue, final Double doubleValue) {
        this.integerValue = integerValue;
        this.doubleValue = doubleValue;
    }

    /**
     * @param integerValue The integer value of the iteration
     */
    public DoubleHistogramIterationValue(final Double integerValue) {
        this.integerValue = integerValue;
        doubleValue = null;
    }
}<|file_separator|>class DoubleHistogram.java
<|fim_prefix|><|fim_suffix|>
    public DoubleHistogram(final int[] integerValues) {
        this.integerValuesHistogram = new Histogram(integerValues);
        this.doubleValuesHistogram = new Histogram(integerValues);
    }

    /**
     * @param integerValues The integer values to be added to the histogram
     * @param doubleValues The double values to be added to the histogram
     */
    public DoubleHistogram(final int[] integerValues, final double[] doubleValues) {
        this.integerValuesHistogram = new Histogram(integerValues);
        this.doubleValuesHistogram = new Histogram(doubleValues);
    }
}<|fim_middle|>/**
 * A class to represent a histogram of double values.
 */
public class DoubleHistogram {
    public final Histogram integerValuesHistogram;
    public final Histogram doubleValuesHistogram;

    /**
     * @param integerValues The integer values to be added to the histogram
     */<|file_separator|>class Histogram<nl>
        iterationValue.value = integerPercentileIterator.currentIterationValue;
        return iterationValue;
    <|file_separator|><nl>
        if (cs != null) {
            ascii &= cs.isAscii();
            final int size = cs.length();
            final long dest = sink.checkCapacity(size);
            for (int i = 0; i < size; i++) {
                Unsafe.getUnsafe().putByte(dest + i, cs.charAt(i));
            }
            sink.advance(size);
        }
        return this;
    }

    @Override
    public DirectUtf8Sink putAscii(long lo, long hi) {
        MutableUtf8Sink.super.putAscii(lo, hi);
        return this;
    }

    @Override
    public DirectUtf8Sink putUtf8(char c) {
        ascii = false;
        sink.put(c);
        return this;
    }

    @Override
    public DirectUtf8Sink putUtf8(@Nullable CharSequence cs) {
        if (cs != null) {
            ascii &= cs.isAscii();
            final int size = cs.length();
            final long dest = sink.checkCapacity(size);
            for (int i = 0; i < size; i++) {
                Unsafe.getUnsafe().putByte(dest + i, cs.charAt(i));
            }
            sink.advance(size);
        }
        return this;
    <|file_separator|><nl>
        return circuitBreaker;
    <|file_separator|><nl>
        TestUtils.unchecked(() -> ServerMain.main(new String[]{}));
    <|file_separator|><nl>
        LOG.infoW().$("<<<< ").$(failure.getTestClass().getName()).$('.').$(failure.getTestMethod().getName()).$(" duration_ms=").$(getTestDuration()).$();
    <|file_separator|><nl>
            return false;
        <|file_separator|><nl>
        EmptySymbolMapReader reader = new EmptySymbolMapReader();
        assertNotNull(reader);
    <|file_separator|><nl>
        SecurityContext sc = ReadOnlySecurityContext.INSTANCE;
        for (Method method : SecurityContext.class.getMethods()) {
            String name = method.getName();
            if (name.startsWith("authorize")) {
                Class<?>[] parameters = method.getParameterTypes();
                if (name.equals("authorizeCopyCancel")) {
                    method.invoke(sc, sc);
                } else {
                    method.invoke(sc, ONE_PARAM_ARGS);
                }
            }
        }
    <|file_separator|><nl>
        Sender sender = new Sender();
        sender.send();
    <|file_separator|><nl>
    <|file_separator|><nl>
        assertGet(expectedResponse, sql, queryParams);
    <|file_separator|><nl>
        initLoadParameters(100, Os.isWindows() ? 3 : 5, 5, 5, 50);
        initFuzzParameters(-1, -1, -1, -1, -1, false, false, true, false);
        runTest();
    <|file_separator|><nl>
        LineTcpConnectionContext context = new LineTcpConnectionContext(
                new LineTcpConnectionContext.Builder()
                        .setHost("localhost")
                        .setPort(1234)
                        .setSymbol("invalid")
                        .setDisconnectOnError(disconnectOnError)
                        .build());
        context.start();
        context.stop();
    <|file_separator|><nl>
        return engine;
    }

    @Override
    public @NotNull SqlExecutionCircuitBreaker getCircuitBreaker(int circuitBreakerId) {
        return SqlExecutionCircuitBreaker.NOOP_CIRCUIT_BREAKER;
    <|file_separator|><nl>
        assertQuery(
                "in" +
                        "1n" +
                        "2n" +
                        "3n" +
                        "4n" +
                        "5n" +
                        "6n" +
                        "7n" +
                        "8n" +
                        "9n" +
                        "10n",
                "select DISTINCT i from tab WHERE ts in '2020-03' order by 1 LIMIT 10",
                "create table tab as (select timestamp_sequence('2020-01-01', 10 * 60 * 1000000L) ts, (2 * (x % 10))::int i from long_sequence(10000))" +
                        " timestamp(ts) PARTITION BY MONTH",
                null,
                true,
                true
        );
    <|file_separator|>class DistinctIntKeyTestWithLongSequence.java
<|fim_prefix|><|fim_suffix|>
        assertQuery(
                "in" +
                        "1n" +
                        "2n" +
                        "3n" +
                        "4n" +
                        "5n" +
                        "6n" +
                        "7n" +
                        "8n" +
                        "9n" +
                        "10n",
                "select DISTINCT i from tab WHERE ts in '2020-03' order by 1 LIMIT 10",
                "create table tab as (select timestamp_sequence('2020-01-01', 10 * 60 * 1000000L) ts, (2 * (x % 10))::int i from long_sequence(10000))<nl>
        sink.clear();
        return sink;
    <|file_separator|><nl>
        function.getVarcharB(null);
    <|file_separator|><nl>
        assertQuery(
                "xn" +
                        "1n" +
                        "2n" +
                        "3n",
                "select * from x where x in (1,2,3)",
                "create table x as (" +
                        "select x from long_sequence(10)" +
                        ")",
                null,
                true,
                false
        );
    <|file_separator|><nl>
        assertQuery(
                "current_databasen" +
                        "questdbn",
                "select current_database();",
                null,
                null,
                true,
                true
        );
    <|file_separator|><nl>
        assertMemoryLeak(() -> {
            ddl("create table " + TelemetryConfigLogger.TELEMETRY_CONFIG_TABLE_NAME + " (i int)");
            ddl("create table " + TelemetryTask.TABLE_NAME + " (i int)");

            assertQuery("table_catalogttable_schemattable_namettable_typetself_referencing_column_nametreference_generationtuser_defined_type_catalogtuser_defined_type_schematuser_defined_type_nametis_insertable_intotis_typedtcommit_actionn",
                    "select * from information_schema.tables() order by table_name",
                    null, true, false);
        });
    <|file_separator|><nl>
        assertQuery("adrelidtadnumtadbinn" +
                        "1t1tn", "pg_catalog.pg_attrdef order by 1, 2;", "create table x(a int)", null, "create table y(a int)", "adrelidtadnumtadbinn" +
                        "1t1tn" +
                        "2t1tn", true, false, false);
    <|file_separator|>class PgAttrDefTest.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>package org.postgresql.test.pg_catalog;

import org.postgresql.test.AbstractCairoTest;
import org.postgresql.test.PgTest;
import org.postgresql.test.PgTest.Test;
import org.postgresql.test.PgTest.Test.Type;
import org.postgresql.test.PgTest.Test.Type.Type;
import org.postgresql.test.PgTest.Test.Type.Type;
import org.postgresql.test.PgTest.Test.Type.Type;
import org.postgresql.test.PgTest.Test.Type.Type;
import org.postgresql.test.PgTest.Test.Type.Type;
import org.postgresql.test.PgTest.Test.Type.Type;
import org.postgresql.test.PgTest.Test.Type.Type;
import org.postgresql.test.PgTest.Test.Type.Type;
import org.postgresql.test.PgTest.Test.Type.Type;
import org.postgresql.test.PgTest.Test.Type.Type;
import org.postgresql.test.PgTest.Test.Type.Type;
import org.postgresql.test.PgTest.Test.Type.Type;
import org.postgresql.test.PgTest.Test.Type.Type;
import org.postgresql.test.PgTest.Test.<nl>
        assertMemoryLeak(() -> assertQuery("oidtextnametextownertextnamespacetextrelocatabletextversiontextconfigtextconditionn" +
                        "1tquestdbt1t1tfalset[DEVELOPMENT]ttn",
                "select * from pg_catalog.pg_extension",
                null, false, true));
    <|file_separator|><nl>
        PrefixedVersionFunctionFactory factory = new PrefixedVersionFunctionFactory("test");
        Function f = factory.createFunction("currentSchema");
        assertEquals("test.currentSchema", f.getName());
    <|file_separator|><nl>
        assertSql("typeOfn" + "GEOHASHn", "select typeOf(cast(null as geohash))");
    }

    @Test
    public void testTypeOfLong128() throws SqlException {
        assertSql("typeOfn" + "LONG128n", "select typeOf(cast(null as long128))");
    }

    @Test
    public void testTypeOfRecord() throws SqlException {
        assertSql("typeOfn" + "RECORDn", "select typeOf(cast(null as record))");
    }

    @Test
    public void testTypeOfArrayString() throws SqlException {
        assertSql("typeOfn" + "ARRAY_STRINGn", "select typeOf(cast(null as array_string))");
    }

    @Test
    public void testTypeOfParameter() throws SqlException {
        assertSql("typeOfn" + "PARAMETERn", "select typeOf(cast(null as parameter))");
    }

    @Test
    public void testTypeOfCursor() throws SqlException {
        assertSql("typeOfn" + "CURSORn", "select typeOf(cast(null as cursor))");
    }

    @Test
    public void testTypeOfVarArg() throws SqlException {
        assertSql("typeOfn" + "VAR_ARGn", "select typeOf(cast(null as var_arg))");
    }

    @Test
    public void testTypeOfUnknown() throws SqlException {
        assertSql("typeOfn" + "UNKNOWNn", "select typeOf(cast(null as unknown))");
    }

    @Test
    public void testTypeOfUnknown2() throws SqlException {
        assertSql("typeOfn" + "UNKNOWNn", "select typeOf(cast(null as unknown))<nl>
        Assert.assertTrue(BooleanConstant.of(true).valueOf());
    <|file_separator|><nl>
        byte b = 127;
        byte b1 = 128;
    <|file_separator|><nl>
        NullConstant.NULL.getRecordCursorFactory(null);
    }

    @Test(expected = UnsupportedOperationException.class)
    public void testGetByteWithIndex() {
        NullConstant.NULL.getByte(null, 0);
    }

    @Test(expected = UnsupportedOperationException.class)
    public void testGetCharWithIndex() {
        NullConstant.NULL.getChar(null, 0);
    }

    @Test(expected = UnsupportedOperationException.class)
    public void testGetDoubleWithIndex() {
        NullConstant.NULL.getDouble(null, 0);
    }

    @Test(expected = UnsupportedOperationException.class)
    public void testGetFloatWithIndex() {
        NullConstant.NULL.getFloat(null, 0);
    }

    @Test(expected = UnsupportedOperationException.class)
    public void testGetIntWithIndex() {
        NullConstant.NULL.getInt(null, 0);
    }

    @Test(expected = UnsupportedOperationException.class)
    public void testGetLongWithIndex() {
        NullConstant.NULL.getLong(null, 0);
    }

    @Test(expected = UnsupportedOperationException.class)
    public void testGetShortWithIndex() {
        NullConstant.NULL.getShort(null, 0);
    }

    @Test(expected = UnsupportedOperationException.class)
    public void testGetSymbolWithIndex() {
        NullConstant.NULL.getSymbol(null, 0);
    }

    @Test(expected = UnsupportedOperationException.class)
    public void testGetSymbolBWithIndex() {
        NullConstant.NULL.getSymbolB(null, 0);
    <|file_separator|><nl>
        StrConstant constant = new StrConstant("abc");
        Assert.assertTrue(constant.isConstant());
        TestUtils.assertEquals("abc", constant.getStrA(null));
        TestUtils.assertEquals("abc", constant.getStrB(null));
        Assert.assertEquals(3, constant.getStrLen(null));

        Utf16Sink sink = new StringSink();
        constant.getStr(null, sink);
        TestUtils.assertEquals("abc", (CharSequence) sink);
    <|file_separator|><nl>
        assertQuery(
                "rnd_long256n0x9f9b2131d49fcd1d6b8139815c50d3410010cde812ce60ee0010a928bb8b9650n",
                "xxxx where rnd_long256='0x056'",
                "create table xxxx as (select rnd_long256() from long_sequence(1));",
                null,
                true
        );
    <|file_separator|><nl>
        super.testAll();
    <|file_separator|><nl>
        TableModel tm = new TableModel(configuration, "tab", PartitionBy.DAY);
        tm.timestamp("ts").col("ch", ColumnType.CHAR);
        createPopulateTable(tm, 100, "2020-01-01", 2);

        String expected = "tstmintmaxtfirsttlasttcountn" +
                "2020-01-01T00:28:47.990000Ztu0001t3tu0001t3t51n" +
                "2020-01-02T00:28:47.990000Zt4tdt4tdt49n";
        assertSql(expected, "select ts, min(ch), max(ch), first(ch), last(ch), count() from tab");
    <|file_separator|><nl>
        assertQuery(
                "atcount_distinctn" +
                        "0t1n",
                "select count_distinct(cast(null as symbol)) from x",
                "create table x as (select * from (select rnd_symbol('a','b','c') a from long_sequence(20)))",
                null,
                true,
                true
        );
    <|file_separator|>class CountDistinctGroupByFunctionFactoryTest.java
<|fim_prefix|><|fim_suffix|>
        assertQuery(
                "atcount_distinctn" +
                        "0t1n" +
                        "1t1n" +
                        "3t1n" +
                        "4t2n" +
                        "5t2n" +
                        "6t2n" +
                        "7t3n" +
                        "8t2n",
                "select a, count_distinct(s) from x order by a",
                "create table x as (select * from (select rnd_int(0, 9, 0) a, rnd_symbol('a','b','c','d','e','f') s from long_sequence(20)))",
                null,
                true,
                true
        );
    }

    @Test
    public void testGroupNotKeyed() throws Exception {
        assertQuery(
                "count_distinctn" +
                        "922n",
                "select count_distinct(s) from x",
                "create table x as (select * from (select rnd_symbol(1000, 1, 10, 0) s, timestamp_sequence(0, 100000) ts from long_sequence(10000)) timestamp(ts))",
                null,
                false<nl>
        sqlExecutionContext.setRandom(new Rnd());
        TableModel tm = new TableModel(configuration, "tab", PartitionBy.DAY);
        tm.timestamp("ts").col("ch", ColumnType.FLOAT);
        createPopulateTable(tm, 100, "2020-01-01", 2);

        assertSql("tstmintmaxtfirsttlasttcountn" +
                "2020-01-01T00:28:47.990000Zt0.0010t0.0510t0.0010t0.0510t51n" +
                "2020-01-02T00:28:47.990000Zt0.0520t0.1000t0.0520t0.1000t49n", "select ts, min(ch), max(ch), first(ch), last(ch), count() from tab sample by d align to first observation"
        );

        assertSql("tstmintmaxtfirsttlasttcountn" +
                "2020-01-01T00:00:00.000000Zt0.0010t0.0500t0.0010t0.0500t50n" +
                "2020-01-02T00:00:00.000000Zt0.0510t0.1000t0.0510t0.1000t50n", "<nl>
        final int[] data = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        final int[] expected = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        final int[] actual = LastByteGroupByFunctionFactory.lastByte(data);
        assertArrayEquals(expected, actual);
    <|file_separator|><nl>
        call(-1.0).andAssert(Math.PI, DELTA);
    <|file_separator|><nl>
        call(10, 10).andAssert(Numbers.INT_MAX);
    <|file_separator|><nl>
        assertEquals(0.0, getFunction().apply(0.0, -1.0));
    <|file_separator|><nl>
        assertQuery(
                "round_downn" +
                        "NaNn",
                "select round_down(100.9999, 18) from long_sequence(1)",
                null,
                true,
                true
        );
    <|file_separator|>class RoundDownDoubleFunctionFactoryTest.java
<|fim_prefix|><|fim_suffix|>

    @Test
    public void testPosScaleHigherThanNumber() throws SqlException {
        assertQuery(
                "round_downn" +
                        "NaNn",
                "select round_down(100.9999, 18) from long_sequence(1)",
                null,
                true,
                true
        );
    }

    @Test
    public void testPosScaleNegValue() throws SqlException {
        assertQuery(
                "round_downn" +
                        "-100.9n",
                "select round_down(-100.9999, 1) from long_sequence(1)",
                null,
                true,
                true
        );
    }

    @Test
    public void testPosScalePosValue() throws SqlException {
        assertQuery(
                "round_downn" +
                        "100.0n",
                "select round_down(100.01, 1) from long_sequence(1)",
                null,
                true,
                true
        );
    }

}<|fim_middle|>class RoundDownDoubleFunctionFactoryTest extends AbstractCairoTest {


    @Test
    public void testLargeNegScale() throws SqlException {
        assertQuery(
                "round_downn" +
                        "NaNn",
                "select round_down(14.7778, -<nl>
        call(14.7778, 18).andAssert(Double.NaN, 0.0000000001);
    <|file_separator|>class RoundUpDoubleFunctionFactory.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class RoundUpDoubleFunctionFactory extends FunctionFactory {

    @Override
    public Function createFunction(double scale, int precision) {
        return new RoundUpDoubleFunction(scale, precision);
    }
}<|file_separator|>class RoundUpDoubleFunction.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class RoundUpDoubleFunction extends Function {

    public RoundUpDoubleFunction(double scale, int precision) {
        super(scale, precision);
    }

    @Override
    public double apply(double x) {
        return Math.round(x * scale) / scale;
    }
}<|file_separator|><nl>
        call(new Utf8String("AbCdeFghiJKLm...() { _; } >_[$($())] { <<< (=) noPQRstuVXZ")).andAssert("abcdefghijklm...() { _; } >_[$($())] { <<< (=) nopqrstuvxz");
    <|file_separator|><nl>
        call("abc").andAssert("abc");
        call("abc ").andAssert("abc");
        call(" a b c ").andAssert(" a b c");
    <|file_separator|><nl>
        call(new Utf8String("abcABC123")).andAssert("ABCABC123");
    <|file_separator|><nl>
        assertMemoryLeak(() -> {
            try (GroupByAllocator allocator = new GroupByAllocatorArena(64, Numbers.SIZE_1GB)) {
                StableAwareUtf8StringHolder holder = new StableAwareUtf8StringHolder();
                holder.setAllocator(allocator);
                holder.clearAndSet(new Utf8String("foobar"));
                TestUtils.assertEquals("foobar", holder);
            }
        });
    <|file_separator|>class StableAwareUtf8StringHolder.java
<|fim_prefix|><|fim_suffix|>

    @Override
    public void clearAndSet(Utf8String utf8String) {
        if (utf8String == null) {
            clear();
        } else {
            if (utf8String.isAscii()) {
                if (utf8String.size() == 0) {
                    clear();
                } else {
                    if (utf8String.size() == 1) {
                        if (utf8String.byteAt(0) == 0) {
                            clear();
                        } else {
                            set(utf8String);
                        }
                    } else {
                        set(utf8String);
                    }
                }
            } else {
                if (utf8String.size() == 0) {
                    clear();
                } else {
                    if (utf8String.size() == 1) {
                        if (utf8String.byteAt(0) == 0) {
                            clear();
                        } else {
                            set(utf8String);
                        }
                    } else {
                        set(utf8String);
                    }
                }
            }
        }
    }

    @Override
    public void clearAndSet(Utf8Sequence utf8Sequence) {
        if (utf8Sequence == null) {
            clear();
        } else<nl>
        double error = Math.abs(exact - estimated) / exact;
        if (error > precision) {
            throw new RuntimeException("Cardinality error: " + error);
        }
    <|file_separator|><nl>
        ExpressionNode node = new ExpressionNode(new LiteralNode(null));
        assertEquals(null, node.evaluate());
    <|file_separator|><nl>
        final int N = 1000000;
        final int M = 1000;
        final int T = 1000;
        final int P = 1000;
        final int Q = 1000;
        final int R = 1000;
        final int S = 1000;
        final int W = 1000;
        final int X = 1000;
        final int Y = 1000;
        final int Z = 1000;
        final int A = 1000;
        final int B = 1000;
        final int C = 1000;
        final int D = 1000;
        final int E = 1000;
        final int F = 1000;
        final int G = 1000;
        final int H = 1000;
        final int I = 1000;
        final int J = 1000;
        final int K = 1000;
        final int L = 1000;
        final int M = 1000;
        final int N = 1000;
        final int O = 1000;
        final int P = 1000;
        final int Q = 1000;
        final int R = 1000;
        final int S = 1000;
        final int T = 1000;
        final int U = 1000;
        final int V = 1000;
<nl>
            try {
                while (true) {
                    int value = list.get();
                    if (value == -1) {
                        break;
                    }
                    if (value > maxSize) {
                        anomalies.incrementAndGet();
                    }
                    barrier.await();
                }
            } catch (InterruptedException | BrokenBarrierException e) {
                e.printStackTrace();
            } finally {
                latch.countDown();
            }
        <|file_separator|><nl>
        int[] keys = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        int[] values = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        int[] expected = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        int[] actual = new LowerCaseAsciiCharSequenceIntHashMap(keys, values).getKeys();
        assertArrayEquals(expected, actual);
    <|file_separator|><nl>
        final LowerCaseCharSequenceObjHashMap<Integer> lowerCaseMap = new LowerCaseCharSequenceObjHashMap<>();
        final int items = 1000;

        for (int i = 0; i < items; i++) {
            lowerCaseMap.put(Integer.toString(i), i);
        }

        Assert.assertEquals(items, lowerCaseMap.keys().size());
    <|file_separator|><nl>
        final int N = 256;
        final int memSize = 2 * N;
        long mem = Unsafe.malloc(memSize, MemoryTag.NATIVE_DEFAULT);
        final DirectUtf8String dus = new DirectUtf8String();
        LowerCaseUtf8SequenceObjHashMap<Integer> map = new LowerCaseUtf8SequenceObjHashMap<>();
        try {
            final String utf16Str = "";
            final byte[] utf8Bytes = utf16Str.getBytes(StandardCharsets.UTF_8);
            assert utf8Bytes.length == 2;
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < 2; j++) {
                    Unsafe.getUnsafe().putByte(mem + (long) 2 * i + j, utf8Bytes[j]);
                }
            }

            for (int i = 0; i < N; i++) {
                dus.of(mem, mem + (long) 2 * i);
                Assert.assertNull(map.get(dus));

                final Utf8String bcs = Utf8String.newInstance(dus);
                map.put(Utf8String.newInstance(dus), i);
                Assert.assertEquals(i, (int) map.get(dus));
                Assert.assertEquals(i, (int) map.get(bcs));
            }
        } finally {
            Unsafe.free(mem, memSize, MemoryTag.NATIVE_DEFAULT);
        }
    <|file_separator|><nl>
        ObjStack<Integer> q = new ObjStack<>(3);
        for (int i = 0; i < 10; i++) {
            q.push(2 * i);
        }
        Assert.assertEquals(10, q.size());
    }

    @Test
    public void fifoTest() {
        ObjStack<Integer> q = new ObjStack<>();
        for (int i = 0; i < 10; i++) {
            q.push(2 * i);
        }
        Assert.assertEquals(10, q.size());
        for (int i = 0; i < 10; i++) {
            Integer r = q.pop();
            Assert.assertEquals((Integer) (2 * i), r);
        }
        Assert.assertNull(q.pop());
    }

    @Test
    public void fifo10ElementsInOut() {
        ObjStack<Integer> q = new ObjStack<>();
        for (int i = 0; i < 10; i++) {
            q.push(2 * i);
        }
        Assert.assertEquals(10, q.size());
        for (int i = 0; i < 10; i++) {
            Integer r = q.pop();
            Assert.assertEquals((Integer) (2 * i), r);
        }
        Assert.assertNull(q.pop());
    }

    @Test
    public void fifo120ElementsInOut() {
        ObjStack<Integer> q = new ObjStack<>();
        for (int i = 0; i < 20; i++) {
            q.push(2 * i);
        }
        Assert.assertEquals(20, q.size());
        <nl>
        Utf8SequenceHashSet set = new Utf8SequenceHashSet();
        Assert.assertEquals(0, set.size());
        Assert.assertFalse(set.contains("a"));
        Assert.assertEquals(-1, set.remove("a"));
        Assert.assertEquals(0, set.size());
    <|file_separator|><nl>
        Random rng = new Random(SEED);
        LexicalGenerator gen = new LexicalGenerator(false, true);
        IntStream.range(0, 100).forEach(i -> {
                    String str = gen.produceRandomInputStringFromLexicalRuleWithoutWhitespace(10, rng);
                    testAgainstJdk(str);
                }
        );
    <|file_separator|><nl>
        createAllTestDataForFloat().stream()
                .filter(t -> t.byteLength() == t.input().length()
                        && t.byteOffset() == 0)
                .forEach(t -> test(t, u -> {
                    try {
                        return FastFloatParser.parseFloat(u.input().getBytes(StandardCharsets.UTF_8), false);
                    } catch (NumericException e) {
                        throw new NumberFormatException();
                    }
                }));
    <|file_separator|><nl>
        try {
            Class[] argTypes = {int.class};
            return (AbstractHistogram) c.getDeclaredConstructor(argTypes).newInstance(constructorArgs);
        } catch (InvocationTargetException ex) {
            if (ex.getTargetException() instanceof IllegalArgumentException) {
                throw new IllegalArgumentException(ex.getTargetException().getMessage(), ex);
            } else {
                throw new RuntimeException("Re-throwing: ", ex);
            }
        } catch (NoSuchMethodException | InstantiationException |
                 IllegalAccessException ex) {
            throw new RuntimeException("Re-throwing: ", ex);
        }
    <|file_separator|><nl>
        return micros / increment;
    }

    @Override
    public void setTicks(long ticks) {
        micros = ticks * increment;
    <|file_separator|><nl>
        return new Statement() {
            @Override
            public void evaluate() throws Throwable {
                try {
                    TlsProxyRule.this.start();
                    base.evaluate();
                } finally {
                    TlsProxyRule.this.killAfterAccepting();
                }
            }
        };
    }

    private void start() {
        if (tlsProxy != null) {
            throw new IllegalStateException("already started");
        }
        tlsProxy = new TlsProxy(dstHost, dstPort, keystore, keystorePassword);
        tlsProxy.start();
        srcPort = tlsProxy.getListeningPort();
    <|file_separator|><nl>
        if (args.length < 1) {
            printUsage(command);
            System.exit(1);
        }

        RebuildColumnCommandArgs args = new RebuildColumnCommandArgs();
        args.tablePath = args[0];
        if (args.length > 1 && args[1].equals("-p")) {
            args.partition = args[2];
            args.column = args[3];
        }
        return args;
    <|file_separator|><nl>
        RebuildColumnCommandArgs params = parseCommandArgs(
                new String[]{"tablePath", "-c", "9393", "-p", "2222"},
                RebuildIndex.class.getName()
        );
        Assert.assertNotNull(params);
        Assert.assertEquals("tablePath", params.tablePath);
        Assert.assertEquals("9393", params.column);
        Assert.assertEquals("2222", params.partition);
    <|file_separator|><nl>
        for (int i = 0, n = metadataExpected.getColumnCount(); i < n; i++) {
            String expected = metadataExpected.getColumnName(i);
            String actual = metadataActual.getColumnName(i);
            Assert.assertEquals("Column name " + i, expected, actual);
            int expectedType = metadataExpected.getColumnType(i);
            int actualType = metadataActual.getColumnType(i);
            Assert.assertEquals("Column type " + i, expectedType, actualType);
            if (expectedType == ColumnType.STRING) {
                Assert.assertEquals("Column value " + i, expected, rr.getString(i));
                Assert.assertEquals("Column value " + i, expected, lr.getString(i));
            } else {
                Assert.assertEquals("Column value " + i, expected, rr.get(i));
                Assert.assertEquals("Column value " + i, expected, lr.get(i));
            }
        }
    <|file_separator|><nl>
        return createConnection(connCls);
    <|file_separator|><nl>
        throw new UnsupportedOperationException("Not used, use RTMPEIoFilter filter");
    <|file_separator|><nl>
        out.put(command.getCommand());
    <|file_separator|><nl>
        try {
            // START OF NATIVE SSL STUFF
            SSLContext sslContext = BogusSslContextFactory.getInstance(false);
            SslFilter sslFilter = new SslFilter(sslContext);
            sslFilter.setUseClientMode(true);
            if (sslFilter != null) {
                ioHandler.setSslContext(sslContext);
                ioHandler.setSslFilter(sslFilter);
            }
            // END OF NATIVE SSL STUFF
            super.startConnector(server, port);
        } catch (Exception e) {
            log.error("Exception while starting connector", e);
        }
    <|file_separator|><nl>
        pendingMessages.add(new PendingData(buffer, packet));
    }
<|file_separator|><nl>
        RTMPTClientTest client = new RTMPTClientTest();
        client.connect();
        synchronized (RTMPTClientTest.class) {
            while (!finished) {
                RTMPTClientTest.class.wait();
            }
        }
    <|file_separator|><nl>
        log.debug("onSharedObjectUpdate - map: {}", map);
    }

    @Override
    public void onSharedObjectUpdate(ISharedObjectBase so, String arg1, Object arg2) {
        log.debug("onSharedObjectUpdate - arg1: {} arg2: {}", arg1, arg2);
    }

    @Override
    public void onSharedObjectUpdate(ISharedObjectBase so, String arg1, Object arg2, Object arg3) {
        log.debug("onSharedObjectUpdate - arg1: {} arg2: {} arg3: {}", arg1, arg2, arg3);
    }

    @Override
    public void onSharedObjectUpdate(ISharedObjectBase so, String arg1, Object arg2, Object arg3, Object arg4) {
        log.debug("onSharedObjectUpdate - arg1: {} arg2: {} arg3: {} arg4: {}", arg1, arg2, arg3, arg4);
    }

    @Override
    public void onSharedObjectUpdate(ISharedObjectBase so, String arg1, Object arg2, Object arg3, Object arg4, Object arg5) {
        log.debug("onSharedObjectUpdate - arg1: {} arg2: {} arg3: {} arg4: {} arg5: {}", arg1, arg2, arg3, arg4, arg5);
    }

    @Override
    public void onSharedObjectUpdate(ISharedObjectBase so, String arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6) {
        log.debug("onSharedObjectUpdate - arg1: {} arg2: {} arg3: {} arg4: {} arg5: {} arg6: {}", arg1, arg2, arg3, arg4,<nl>
                try {
                    client.connect("rtmp://127.0.0.1:1935/live/test");
                } catch (IOException e) {
                    e.printStackTrace();
                }
            <|file_separator|><nl>
        this.correlationID = id;
    <|file_separator|><nl>
        decoderState = State.OK;
        decoderBufferAmount = 0;
    <|file_separator|><nl>
        // Get service method
        String methodName = call.getMethodName();
        log.trace("Method name {}", methodName);
        Object[] args = call.getArguments();
        log.trace("Arguments {}", args);
        // Invoke service method
        try {
            Object result = service.getClass().getMethod(methodName,
                    new Class[] { call.getArgumentsType() }).invoke(service,
                    args);
            // Set result
            call.setResult(result);
            // Set call status
            call.setStatus(Call.STATUS_OK);
            log.debug("Service method {} invoked", methodName);
            return true;
        } catch (Exception e) {
            // Exception must be thrown if service method was not found
            call.setException(e);
            // Set call status
            call.setStatus(Call.STATUS_METHOD_NOT_FOUND);
            log.warn("Service method not found: {} in service {}", methodName,
                    service);
            return false;
        }
    <|file_separator|><nl>
        IRTMPEvent packet = message.getBody();
        // Only check video packets.
        if (packet instanceof VideoData) {
            VideoData video = (VideoData) packet;
            FrameType type = video.getFrameType();
            switch (state) {
                case SEND_ALL:
                    if (type == FrameType.DISPOSABLE_INTERFRAME) {
                        // Remain in state, packet is safe to drop.
                        return true;
                    } else if (type == FrameType.INTERFRAME) {
                        // Drop all frames until the next keyframe.
                        state = SEND_KEYFRAMES;
                        return true;
                    } else if (type == FrameType.KEYFRAME) {
                        // Drop all frames until the next keyframe.
                        state = SEND_KEYFRAMES;
                        return true;
                    }
                    break;
                case SEND_INTERFRAMES:
                    if (type == FrameType.INTERFRAME) {
                        // Drop all frames until the next keyframe.
                        state = SEND_KEYFRAMES_CHECK;
                        return true;
                    } else if (type == FrameType.KEYFRAME) {
                        // Drop all frames until the next keyframe.
                        state = SEND_KEYFRAMES;
                        return true;
                    }
                    break;
                case SEND_KEYFRAMES:
                    // Remain in state.
                    break;
                case SEND_KEYFRAMES_CHECK:
                    if (type == FrameType.KEYFRAME) {
                        // Switch back to sending keyframes, but don't move to
                        // SEND_INTERFRAMES afterwards.
                        state = SEND_KEYFRAMES;
                        return true;
                    }
                    break;
                default:
            }
        }
        return false;<nl>
        this.audio = value;
    <|file_separator|><nl>
        if (parameters != null) {
            for (Object param : parameters) {
                result.append(param);
            }
        }
    <|file_separator|><nl>
        return new SctpChannel(association.bind(address));
    <|file_separator|><nl>
        ByteBuffer byteBuffer = ByteBuffer.allocate(HEADER_SIZE);
        byteBuffer.putShort((short) sourcePort);
        byteBuffer.putShort((short) destinationPort);
        byteBuffer.putInt(verificationTag);
        byteBuffer.putInt(checksum);
        return byteBuffer.array();
    <|file_separator|><nl>
        if (mac == null) {
            return false;
        }

        return mac.doFinal(getBytes(null)) == null;
    }

    public long getCreationTimestamp() {
        return creationTimestamp;
    }

    public int getAdvertisedReceiverWindowCredit() {
        return advertisedReceiverWindowCredit;
    }

    public int getNumberOfOutboundStreams() {
        return numberOfOutboundStreams;
    }

    public int getNumberOfInboundStreams() {
        return numberOfInboundStreams;
    <|file_separator|><nl>
        // TODO: Implement
    <|file_separator|><nl>
        log.debug("contextInitialized - sce: {}", sce);
    <|file_separator|><nl>
        log.info("Registering a new MBean");
        MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();
        ObjectName name = null;
        try {
            name = new ObjectName("com.example.jmx:type=Test");
        } catch (Exception e) {
            log.error("Could not create ObjectName object for Test", e);
            return false;
        }
        try {
            mbs.registerMBean(new Test(), name);
        } catch (Exception e) {
            log.error("Could not register MBean", e);
            return false;
        }
        return true;
    <|file_separator|><nl>
        this.properties = properties;
    <|file_separator|><nl>
        log.debug("Setting session max lifetime {}", maxLifetime);
        SessionManager.maxLifetime = Long.parseLong(maxLifetime);
    <|file_separator|><nl>
        MetaData<?, ?> meta = createMeta();

        // Write meta data
        service.write(meta);
    }

    /**
     * Test reading meta data
     *
     * @throws IOException
     *             if io exception
     */
    public void testRead() throws IOException {
        MetaData<?, ?> meta = createMeta();

        // Write meta data
        service.write(meta);

        // Read meta data
        MetaData<?, ?> readMeta = service.read();

        // Check if read meta data is equal to written meta data
        assertEquals(readMeta, meta);
    <|file_separator|><nl>
        decoder = new RemotingProtocolDecoder();
        encoder = new RemotingProtocolEncoder();
    <|file_separator|><nl>
        int count = in.getUnsignedShort();
        log.debug("Read calls - count: {}", count);
        List<RemotingCall> result = new ArrayList<RemotingCall>(count);
        for (int i = 0; i < count; i++) {
            int id = in.getInt();
            int methodId = in.getUnsignedShort();
            int methodVersion = in.getUnsignedShort();
            int methodCount = in.getUnsignedShort();
            log.debug("Call: {} MethodId: {} MethodVersion: {} MethodCount: {}", new Object[] { id, methodId, methodVersion, methodCount });
            List<RemotingMethod> methods = new ArrayList<RemotingMethod>(methodCount);
            for (int j = 0; j < methodCount; j++) {
                String name = in.getString();
                int type = in.getUnsignedShort();
                int size = in.getUnsignedShort();
                log.debug("Method: {} Type: {} Size: {}", new Object[] { name, type, size });
                methods.add(new RemotingMethod(name, type, size));
            }
            result.add(new RemotingCall(id, methodId, methodVersion, methodCount, methods));
        }
        return result;
    <|file_separator|><nl>
        return isMessaging ? getResponse() : getResult();
    <|file_separator|><nl>
        return scopePath;
    }

    /**
     * Getter for request object.
     *
     * @return request
     */
    public HttpServletRequest getRequest() {
        return request;
    }

    /**
     * Setter for request object.
     *
     * @param request
     *            Value to set for property 'request'.
     */
    public void setRequest(HttpServletRequest request) {
        this.request = request;
    }

    /**
     * Getter for data.
     *
     * @return data
     */
    public ByteBuffer getData() {
        return data;
    }

    /**
     * Setter for data.
     *
     * @param data
     *            Value to set for property 'data'.
     */
    public void setData(ByteBuffer data) {
        this.data = data;
    <|file_separator|><nl>
        //get the request type
        String requestType = req.getHeader("Content-Type");
        if (requestType == null || !requestType.equals(REQUEST_TYPE)) {
            resp.sendError(HttpServletResponse.SC_NOT_ACCEPTABLE);
            return;
        }
        //get the request body
        String requestBody = IOUtils.toString(req.getInputStream());
        //post the request to the acceptor
        String responseBody = post(postAcceptorURL, requestBody);
        //set the response type
        resp.setContentType(REQUEST_TYPE);
        //set the response body
        resp.getWriter().write(responseBody);
    }

    private String post(String url, String requestBody) throws IOException {
        URL obj = new URL(url);
        HttpURLConnection con = (HttpURLConnection) obj.openConnection();
        con.setRequestMethod("POST");
        con.setRequestProperty("Content-Type", REQUEST_TYPE);
        con.setRequestProperty("Content-Length", String.valueOf(requestBody.length()));
        con.setConnectTimeout(connectionTimeout);
        con.setDoOutput(true);
        con.setDoInput(true);
        con.connect();
        try (OutputStream os = con.getOutputStream()) {
            os.write(requestBody.getBytes());
        }
        try (BufferedReader br = new BufferedReader(new InputStreamReader(con.getInputStream()))) {
            StringBuilder response = new StringBuilder();
            String responseLine = null;
            while ((responseLine = br.readLine()) != null) {
                response.append(responseLine.trim());
            }
            return response.toString();
        }
    <|file_separator|><nl>
    return super.getResource();
  }

  @Override
  public void returnResource(Connection resource) {
    super.returnResource(resource);
  }

  @Override
  public void destroyObject(Connection resource) {
    super.destroyObject(resource);
  <|file_separator|><nl>
    this.client = client;
  <|file_separator|><nl>
    connection.sendCommand(DISCARD);
    String status = connection.getStatusCodeReply();
    if (!"OK".equals(status)) {
      throw new JedisException("DISCARD command failed. Received response: " + status);
    }
    return status;
  <|file_separator|><nl>
    return targetNode;
  <|file_separator|><nl>
    int attemptsLeft = maxAttempts;
    int consecutiveConnectionFailures = 0;
    Instant doneDeadline = Instant.now().plus(maxTotalRetriesDuration);

    while (attemptsLeft > 0) {
      try (Connection connection = provider.getConnection()) {
        return execute(connection, commandObject);
      } catch (JedisException e) {
        if (handleConnectionProblem(attemptsLeft, consecutiveConnectionFailures, doneDeadline)) {
          attemptsLeft--;
          consecutiveConnectionFailures++;
          continue;
        }

        throw e;
      }
    }

    throw new JedisException("Retry deadline exceeded.");
  <|file_separator|><nl>
      return (List<FunctionStreamInfo>) data;
    <|file_separator|><nl>
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        if (!super.equals(o)) return false;
        Node node = (Node) o;
        return labels.equals(node.labels);
    <|file_separator|>class GraphEntity.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>import java.util.HashMap;
import java.util.Map;
import java.util.Objects;

public class GraphEntity {
    //members
    protected long id;
    protected Map<String, Object> propertyMap;

    //constructors
    public GraphEntity() {
        id = -1;
        propertyMap = new HashMap<>();
    }

    public GraphEntity(int propertiesCapacity) {
        id = -1;
        propertyMap = new HashMap<>(propertiesCapacity);
    }

    //methods
    /**
     * @param key - the key of the property
     * @return the property value
     * @throws NullPointerException if the key is null
     */
    public Object getProperty(String key) {
        if (key == null) {
            throw new NullPointerException("key is null");
        }
        return propertyMap.get(key);
    }

    /**
     * @param key - the key of the property
     * @return the property value
     * @throws NullPointerException if the key is null
     */
    public Object getProperty(String key, Object defaultValue) {
        if (key == null) {
            throw new NullPointerException("key is null");
        }
        return propertyMap.getOrDefault(key, defaultValue);
    }

    /**
     * @param key - the key of the property
     * @return the property value
     * @throws NullPointerException if the key is<nl>
    return gson.fromJson(value, valueType);
  <|file_separator|><nl>
    return this.toString().hashCode();
  <|file_separator|><nl>
    return addParam(Keyword.LADDR, ip + ':' + port);
  }

  public ClientKillParams laddr(byte[] ipPort) {
    return addParam(Keyword.LADDR, ipPort);
  }

  public ClientKillParams rport(int rport) {
    return addParam(Keyword.RPORT, rport);
  }

  public ClientKillParams rport(byte[] rport) {
    return addParam(Keyword.RPORT, rport);
  }

  public ClientKillParams rport(int rport, int rport2) {
    return addParam(Keyword.RPORT, rport + ':' + rport2);
  }

  public ClientKillParams rport(byte[] rport, byte[] rport2) {
    return addParam(Keyword.RPORT, rport + ':' + rport2);
  }

  public ClientKillParams rport(int rport, int rport2, int rport3) {
    return addParam(Keyword.RPORT, rport + ':' + rport2 + ':' + rport3);
  }

  public ClientKillParams rport(byte[] rport, byte[] rport2, byte[] rport3) {
    return addParam(Keyword.RPORT, rport + ':' + rport2 + ':' + rport3);
  }

  public ClientKillParams rport(int rport, int rport2, int rport3, int rport4) {
    return addParam(Keyword.RPORT, rport + ':' + rport2 + ':' + rport3 + ':' + rport4);
  }

  public ClientKillParams rport(byte[] rport, byte[] rport2, byte[] rport3,<nl>
    return existance != null ? existance.hashCode() : 0;
  <|file_separator|>class ZIncrByParams implements IParams {

  private Keyword existance;

  public ZIncrByParams() {
  }

  public static ZIncrByParams zIncrByParams() {
    return new ZIncrByParams();
  }

  /**
   * Only set the key if it does not already exist.
   * @return ZIncrByParams
   */
  public ZIncrByParams nx() {
    this.existance = Keyword.NX;
    return this;
  }

  /**
   * Only set the key if it already exist.
   * @return ZIncrByParams
   */
  public ZIncrByParams xx() {
    this.existance = Keyword.XX;
    return this;
  }

  @Override
  public void addParams(CommandArguments args) {
    if (existance != null) {
      args.add(existance);
    }

    args.add(Keyword.INCR);
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;
    ZIncrByParams that = (ZIncrByParams) o;
    return existance == that.existance;
  }

  @Override
  public int hashCode() {
    return existance != null ? existance.hashCode() : 0;
  }
}<|file_separator|>class ZIncrByParams implements IParams {

  private Keyword existance;

  public ZIncrByParams() {
  }

  public static ZIncrByParams zIncr<nl>
      return new CommandDocument((Map) data);
    <|file_separator|><nl>
    return runningScript;
  <|file_separator|><nl>
    return SafeEncoder.encode(cursor);
  <|file_separator|><nl>
    return streamFullInfo;
  <|file_separator|>class StreamEntryID.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class StreamEntryID {

  private final long id;

  public StreamEntryID(long id) {
    this.id = id;
  }

  public long getId() {
    return id;
  }
}<|file_separator|>class StreamGroupFullInfo.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class StreamGroupFullInfo {

  public static final String ID = "id";
  public static final String NAME = "name";
  public static final String ENTRIES = "entries";

  private final long id;
  private final String name;
  private final List<StreamEntry> entries;
  private final Map<String, Object> streamGroupFullInfo;

  /**
   * @param map contains key-value pairs with stream group info
   */
  @SuppressWarnings("unchecked")
  public StreamGroupFullInfo(Map<String, Object> map) {

    streamGroupFullInfo = map;
    id = (Long) map.get(ID);
    name = (String) map.get(NAME);
    entries = (List<StreamEntry>) map.get(ENTRIES);

  }

  public long getId() {
    return id;
  }

  public String getName() {
    return name;
  }

  public List<StreamEntry> getEntries() {
    return entries;
  }

  public Map<String, Object> getStreamGroupFullInfo() {
    return streamGroupFullInfo;
  }
}<|file_separator|>class StreamEntry.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class StreamEntry {

  public static final String ID = "id";
  public static final String NAME = "name";
  public static final String TYPE = "type";
  public static final String VALUE =<nl>
    this.languageField = languageField;
    return this;
  <|file_separator|><nl>
    return "Optional(" + this.left + ")";
  <|file_separator|>class IntersectNode extends Node {

  @Override
  public String toString(Parenthesize mode) {
    return "Intersect(" + this.left + ", " + this.right + ")";
  }
}<|file_separator|>class Node.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public abstract class Node {

  public abstract String toString(Parenthesize mode);
}<|file_separator|>class Parenthesize.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public enum Parenthesize {
  NONE,
  LEFT,
  RIGHT
}<|file_separator|>class AndNode extends Node {

  @Override
  public String toString(Parenthesize mode) {
    return "And(" + this.left + ", " + this.right + ")";
  }
}<|file_separator|>class OrNode extends Node {

  @Override
  public String toString(Parenthesize mode) {
    return "Or(" + this.left + ", " + this.right + ")";
  }
}<|file_separator|><nl>
    StringBuilder sb = new StringBuilder();
    for (Node child : children) {
      if (sb.length() > 0) {
        sb.append(" ");
      }
      sb.append(child.toString(parenMode));
    }
    return sb.toString();
  <|file_separator|><nl>
    if (isIterationCompleted()) {
      return null;
    }
    if (connection == null) {
      connection = connections.poll();
      if (connection == null) {
        roundRobinCompleted = true;
        return null;
      }
    }
    B reply = null;
    try {
      reply = connection.getValue().sendCommand(initCommandArguments());
    } catch (JedisException e) {
      if (e.isConnectionException()) {
        connection = connections.poll();
        if (connection == null) {
          roundRobinCompleted = true;
          return null;
        }
      }
    }
    if (reply == null) {
      return null;
    }
    lastReply = reply;
    if (isNodeCompleted(reply)) {
      return reply;
    }
    return nextBatch();
  <|file_separator|><nl>
    return raw;
  <|file_separator|><nl>
    if (data == null) {
      throw new IllegalArgumentException("null value cannot be sent to redis");
    }
    return new String(data, DEFAULT_CHARSET);
  <|file_separator|><nl>
    try (JedisSentineled jedis = new JedisSentineled(MASTER_NAME,
        DefaultJedisClientConfig.builder().timeoutMillis(1000).password("foobared").database(2).build(),
        new ConnectionPoolConfig(), sentinels, DefaultJedisClientConfig.builder().build())) {
    }
  <|file_separator|><nl>
    List<Tuple> array = new ArrayList<Tuple>();

    jedis.zadd(bfoo, 0d, ba);
    array.add(new Tuple(ba, 0d));

    jedis.zadd(bfoo, 1d, bb);
    array.add(new Tuple(bb, 1d));

    List<Tuple> zrange = jedis.zrangeWithScores(bfoo, 0, -1);
    assertEquals(zrange, sorted(array));

    jedis.zadd(bfoo, -0.3, bc);
    array.add(new Tuple(bc, -0.3));

    jedis.zadd(bfoo, 0.3, bf);
    array.add(new Tuple(bf, 0.3));

    jedis.zadd(bfoo, 0.3, be);
    array.add(new Tuple(be, 0.3));

    jedis.zadd(bfoo, 0.3, bd);
    array.add(new Tuple(bd, 0.3));

    zrange = jedis.zrangeWithScores(bfoo, 0, -1);
    assertEquals(zrange, sorted(array));
  <|file_separator|><nl>
    String key = "testCf";

    String[] items = { "item1", "item2", "item3" };

    List<Boolean> insert = exec(commandObjects.cfInsert(key, items));
    assertThat(insert, not(empty()));
    assertThat(insert, everyItem(equalTo(true)));

    long count = exec(commandObjects.cfCount(key, "item1"));
    assertThat(count, greaterThanOrEqualTo(1L));
  <|file_separator|><nl>
    cluster.functionDelete("xyz");
  <|file_separator|><nl>
    JedisCluster jedisCluster = getCleanCluster(RedisProtocol.TCP);
    jedisCluster.flushAll();
  <|file_separator|><nl>
    // TODO: Implement
  <|file_separator|><nl>
    GeoRadiusResponse response = new GeoRadiusResponse();
    response.setRadius(100);
    response.setResults(new ArrayList<GeoRadiusResult>());
    response.setResults(new ArrayList<GeoRadiusResult>());
    response.setResults(new ArrayList<GeoRadiusResult>());
    response.setResults(new ArrayList<GeoRadiusResult>());
    response.setResults(new ArrayList<GeoRadiusResult>());
    response.setResults(new ArrayList<GeoRadiusResult>());
    response.setResults(new ArrayList<GeoRadiusResult>());
    response.setResults(new ArrayList<GeoRadiusResult>());
    response.setResults(new ArrayList<GeoRadiusResult>());
    response.setResults(new ArrayList<GeoRadiusResult>());
    response.setResults(new ArrayList<GeoRadiusResult>());
    response.setResults(new ArrayList<GeoRadiusResult>());
    response.setResults(new ArrayList<GeoRadiusResult>());
    response.setResults(new ArrayList<GeoRadiusResult>());
    response.setResults(new ArrayList<GeoRadiusResult>());
    response.setResults(new ArrayList<GeoRadiusResult>());
    response.setResults(new ArrayList<GeoRadiusResult>());
    response.setResults(new ArrayList<GeoRadiusResult>());
    response.setResults(new ArrayList<GeoRadiusResult>());
    response.setResults(new ArrayList<GeoRadiusResult>());
    response.setResults(new ArrayList<GeoRadiusResult>());
    response.setResults(new ArrayList<GeoRadiusResult>());
    response.setResults(new ArrayList<GeoRadiusResult>());
    response.setResults(new ArrayList<GeoRadiusResult>());
    response.setResults(new ArrayList<GeoRadiusResult>());
    response.setResults(new ArrayList<GeoRadiusResult>());
    response.setResults(new ArrayList<GeoRadiusResult<nl>
    CFInsertNxParams insertNxParams = new CFInsertNxParams().capacity(10000L).noCreate();

    when(commandObjects.cfInsertNx("myCuckooFilter", insertNxParams, "item1", "item2")).thenReturn(listBooleanCommandObject);

    Response<List<Boolean>> response = pipeliningBase.cfInsertNx("myCuckooFilter", insertNxParams, "item1", "item2");

    assertThat(commands, contains(listBooleanCommandObject));
    assertThat(response, is(predefinedResponse));
  <|file_separator|><nl>
    client.ftSugAdd(key, "COUNT_ME TOO", 1);
    client.ftSugAdd(key, "COUNT", 1);
    client.ftSugAdd(key, "COUNT_ANOTHER", 1);

    assertEquals(3, client.ftSugGet(key, "COU").size());
    assertEquals(3, client.ftSugGet(key, "COU", true).size());
    assertEquals(3, client.ftSugGet(key, "COU", false).size());
    assertEquals(3, client.ftSugGet(key, "COU", true, 10).size());
    assertEquals(3, client.ftSugGet(key, "COU", false, 10).size());

    client.ftSugDel(key, "COUNT_ME TOO");
    assertEquals(2, client.ftSugGet(key, "COU").size());
    assertEquals(2, client.ftSugGet(key, "COU", true).size());
    assertEquals(2, client.ftSugGet(key, "COU", false).size());
    assertEquals(2, client.ftSugGet(key, "COU", true, 10).size());
    assertEquals(2, client.ftSugGet(key, "COU", false, 10).size());
  }

  @Test
  public void getSuggestionNoHitWithScore() {
    client.ftSugAdd(key, "NO WORD", 0.4);

    assertEquals(emptyList(), client.ftSugGetWithScores(key, "DIF"));
    assertEquals(emptyList(), client.ftSugGetWithScores(key, "DIF", true));
  <|file_separator|><nl>
        MigrateParams firstParam = getDefaultValue();
        firstParam.auth("123");
        MigrateParams secondParam = getDefaultValue();
        secondParam.auth("234");
        assertNotEquals(firstParam.hashCode(), secondParam.hashCode());
    <|file_separator|><nl>
        ScanParams firstParam = getDefaultValue();
        firstParam.count(15);
        ScanParams secondParam = getDefaultValue();
        secondParam.count(16);
        assertNotEquals(firstParam.hashCode(), secondParam.hashCode());
    <|file_separator|><nl>
        ZParams firstParam = getDefaultValue();
        firstParam.aggregate(ZParams.Aggregate.MIN);
        ZParams secondParam = getDefaultValue();
        secondParam.aggregate(ZParams.Aggregate.MAX);
        assertNotEquals(firstParam.hashCode(), secondParam.hashCode());
    <|file_separator|><nl>
    boolean modified = false;
    for (byte[] e : all) {
      if (Arrays.equals(e, element)) {
        all.remove(e);
        modified = true;
        break;
      }
    }
    return modified;
  <|file_separator|><nl>
    readMethodCallCount++;
    return super.read(b, off, len);
  <|file_separator|><nl>
        return new TestSuite(AppTest.class);
    <|file_separator|><nl>
        log.info("jmxInfo:{}", KafkaClusterFetcher.getKafkaJmxInfo("127.0.0.1", 19093));
    <|file_separator|><nl>
        response.setContentType("application/json");
        response.setCharacterEncoding("UTF-8");
        response.getWriter().write(new String(output));
    <|file_separator|><nl>
        // get all topic
        List<Topic> topicList = this.topicRankDaoService.getAllTopic();
        // get all cluster
        List<Cluster> clusterList = this.clusterDaoService.getAllCluster();
        // get all broker
        List<Broker> brokerList = this.brokerDaoService.getAllBroker();
        // get all topic byte in rank
        List<TopicByteInRank> topicByteInRankList = this.topicRankDaoService.getAllTopicByteInRank();
        // get all topic byte in rank
        List<TopicByteInRank> topicByteInRankList = this.topicRankDaoService.getAllTopicByteInRank();
        // get all topic byte in rank
        List<TopicByteInRank> topicByteInRankList = this.topicRankDaoService.getAllTopicByteInRank();
        // get all topic byte in rank
        List<TopicByteInRank> topicByteInRankList = this.topicRankDaoService.getAllTopicByteInRank();
        // get all topic byte in rank
        List<TopicByteInRank> topicByteInRankList = this.topicRankDaoService.getAllTopicByteInRank();
        // get all topic byte in rank
        List<TopicByteInRank> topicByteInRankList = this.topicRankDaoService.getAllTopicByteInRank();
        // get all topic byte in rank
        List<TopicByteInRank> topicByteInRankList = this.topicRankDaoService.getAllTopicByteInRank();
        // get all topic byte in rank
        List<TopicByteInRank> topicByteInRankList = this.topicRankDaoService.getAllTopicByteInRank();
        // get all topic byte in rank
        List<TopicByteInRank> topicByteInRankList = this.topicRankDaoService.<nl>
        try {
            // get all topic
            List<Topic> topicList = this.topicRankDaoService.getAllTopic();
            // get all cluster
            List<Cluster> clusterList = this.clusterDaoService.getAllCluster();
            // get all broker
            List<Broker> brokerList = this.brokerDaoService.getAllBroker();
            // get all cluster create
            List<ClusterCreate> clusterCreateList = this.clusterCreateDaoService.getAllClusterCreate();
            // get all topic rank
            List<TopicRank> topicRankList = this.topicRankDaoService.getAllTopicRank();
            // get all topic byte in rank
            List<TopicByteInRank> topicByteInRankList = this.topicRankDaoService.getAllTopicByteInRank();
            // get all topic byte out rank
            List<TopicByteOutRank> topicByteOutRankList = this.topicRankDaoService.getAllTopicByteOutRank();
            // get all topic byte in rank
            List<TopicByteInRank> topicByteInRankList = this.topicRankDaoService.getAllTopicByteInRank();
            // get all topic byte out rank
            List<TopicByteOutRank> topicByteOutRankList = this.topicRankDaoService.getAllTopicByteOutRank();
            // get all topic byte in rank
            List<TopicByteInRank> topicByteInRankList = this.topicRankDaoService.getAllTopicByteInRank();
            // get all topic byte out rank
            List<TopicByteOutRank> topicByteOutRankList = this.topicRankDaoService.getAllTopicByteOutRank();
            // get all topic byte in rank
            List<TopicByteInRank> topicByteInRankList = this.topicRankDaoService.getAllTopicByteInRank();
            // get all topic<nl>
        super.onAuthenticationSuccess(request, response, authentication);
        String username = authentication.getName();
        if (username != null) {
            clusterDaoService.updateLastLogin(username);
        }<|file_separator|><nl>
        String workingDir = System.getProperty("user.dir");
        if (workingDir == null) {
            workingDir = System.getenv("user.dir");
        }
        if (workingDir == null) {
            workingDir = System.getenv("PWD");
        }
        if (workingDir == null) {
            workingDir = System.getProperty("user.dir");
        }
        if (workingDir == null) {
            workingDir = System.getProperty("user.dir");
        }
        if (workingDir == null) {
            workingDir = System.getProperty("user.dir");
        }
        if (workingDir == null) {
            workingDir = System.getProperty("user.dir");
        }
        if (workingDir == null) {
            workingDir = System.getProperty("user.dir");
        }
        if (workingDir == null) {
            workingDir = System.getProperty("user.dir");
        }
        if (workingDir == null) {
            workingDir = System.getProperty("user.dir");
        }
        if (workingDir == null) {
            workingDir = System.getProperty("user.dir");
        }
        if (workingDir == null) {
            workingDir = System.getProperty("user.dir");
        }
        if (workingDir == null) {
            workingDir = System.getProperty("user.dir");
        }
        if (workingDir == null) {
            workingDir = System.getProperty("user.dir");
        }
        if (workingDir == null) {
            workingDir = System.getProperty("user.dir");
        }
        if (workingDir == null) {
            workingDir = System.getProperty("user.dir");
<nl>
        return cmdGroupInfo + "n";
    <|file_separator|><nl>
        System.out.println("test");
    <|file_separator|><nl>
        LOG.info("Received signal: " + signalName);
        if (signalName.equals("thread.pool.metrics")) {
            try {
                final String fileName = DIR + File.separator + BASE_NAME;
                final File file = new File(fileName);
                if (file.exists()) {
                    LOG.info("Sending file: " + fileName);
                    final FileOutputStream fos = new FileOutputStream(file);
                    final BufferedOutputStream bos = new BufferedOutputStream(fos);
                    final ObjectOutputStream oos = new ObjectOutputStream(bos);
                    oos.writeObject(Thread.getAllStackTraces());
                    oos.flush();
                    oos.close();
                }
            } catch (final Exception e) {
                LOG.error("Error while sending thread pool metrics", e);
            }
        }
    <|file_separator|><nl>
        if (status.isOk()) {
            this.setResult(this.index, this.requestContext);
        }
    <|file_separator|><nl>
        return this.conf.contains(peer) || this.oldConf.contains(peer);
    }

    public boolean contains(final Set<PeerId> peers) {
        return this.conf.contains(peers) || this.oldConf.contains(peers);
    }

    public boolean contains(final Set<PeerId> peers, final Set<PeerId> oldPeers) {
        return this.conf.contains(peers) && this.oldConf.contains(oldPeers);
    }

    public boolean contains(final Set<PeerId> peers, final Set<PeerId> oldPeers, final Set<PeerId> newPeers) {
        return this.conf.contains(peers) && this.oldConf.contains(oldPeers) && this.conf.contains(newPeers);
    }

    public boolean contains(final Set<PeerId> peers, final Set<PeerId> oldPeers, final Set<PeerId> newPeers, final Set<PeerId> oldNewPeers) {
        return this.conf.contains(peers) && this.oldConf.contains(oldPeers) && this.conf.contains(newPeers) && this.oldConf.contains(oldNewPeers);
    }

    public boolean contains(final Set<PeerId> peers, final Set<PeerId> oldPeers, final Set<PeerId> newPeers, final Set<PeerId> oldNewPeers, final Set<PeerId> newOldPeers) {
        return this.conf.contains(peers) && this.oldConf.contains(oldPeers) && this.conf.contains(newPeers) && this.oldConf.contains(oldNewPeers) && this.conf.contains(newOldPeers);
    }

    public boolean contains(final Set<PeerId> peers, final Set<PeerId<nl>
        if (this.configurations.isEmpty()) {
            return snapshot;
        } else {
            return this.configurations.stream()
                                     .filter(entry -> entry.getId().getIndex() <= lastIncludedIndex)
                                     .max(Comparator.comparing(ConfigurationEntry::getId))
                                     .orElse(snapshot);
        }
    <|file_separator|><nl>
        return joinAll(tasks, -1);
    <|file_separator|><nl>
        log.setVersion(content[1]);
        log.setTimestamp(content[2]);
        log.setSequence(content[3]);
        log.setPayload(content);
    <|file_separator|><nl>
        final RpcRequestCommand cmd = (RpcRequestCommand) request;
        final String className = cmd.getRequestClass();
        if (className.equals(RpcRequests.AppendEntriesRequest.class.getName())) {
            final Message msg = (Message) cmd.getRequestHeader();
            cmd.setHeader(msg.toByteArray());
            return true;
        }
        return false;
    <|file_separator|><nl>
        this.resp = resp;
    <|file_separator|><nl>
        executor.execute(() -> {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            rpcCtx.sendResponse(new PingResponse(request.getPing()));
        });
    <|file_separator|><nl>
        final ReadIndexResponse response = service.readIndex(request);
        return RpcResponses.ReadIndexResponse.newBuilder()
                .setResponse(response)
                .build();
    <|file_separator|><nl>
        final long readerId = request.getReaderId();
        final FileReader reader = this.fileReaderMap.get(readerId);
        if (reader == null) {
            LOG.error("No reader found for readerId {}", readerId);
            done.setDone(new RpcResponse(RpcResponse.Code.NOT_FOUND));
        } else {
            final long fileSize = reader.getFileSize();
            final long offset = request.getOffset();
            final long length = request.getLength();
            if (offset < 0 || length < 0 || offset + length > fileSize) {
                LOG.error("Invalid request for readerId {} with offset {} and length {}", readerId, offset, length);
                done.setDone(new RpcResponse(RpcResponse.Code.INVALID_ARGUMENT));
            } else {
                final byte[] data = reader.read(offset, length);
                if (data == null) {
                    LOG.error("No data found for readerId {} with offset {} and length {}", readerId, offset, length);
                    done.setDone(new RpcResponse(RpcResponse.Code.NOT_FOUND));
                } else {
                    final RpcResponse response = new RpcResponse(RpcResponse.Code.OK);
                    response.setData(data);
                    done.setDone(response);
                }
            }
        }
    <|file_separator|><nl>
        final File file = new File(getPath(), fileName);
        if (!file.exists()) {
            return 0;
        }
        final long size = file.length();
        if (size == 0) {
            return 0;
        }
        final long start = offset;
        final long end = Math.min(offset + maxCount, size);
        final long count = end - start;
        final long snapshotId = Long.parseLong(fileName.substring(0, fileName.lastIndexOf(".")));
        final LocalSnapshotMetaTable snapshotMetaTable = this.metaTable;
        if (snapshotMetaTable == null) {
            throw new IllegalStateException("Meta table is not set");
        }
        final LocalSnapshotMetaTable.Entry entry = snapshotMetaTable.getEntry(snapshotId);
        if (entry == null) {
            throw new IllegalStateException("Snapshot meta table does not contain entry for snapshot " + snapshotId);
        }
        final long snapshotOffset = entry.getOffset();
        final long snapshotSize = entry.getSize();
        if (snapshotOffset < start || snapshotOffset + snapshotSize > end) {
            throw new IllegalStateException("Snapshot " + snapshotId + " is out of range");
        }
        final long snapshotEnd = snapshotOffset + snapshotSize;
        if (snapshotEnd > size) {
            throw new IllegalStateException("Snapshot " + snapshotId + " is truncated");
        }
        final long snapshotCount = snapshotEnd - snapshotOffset;
        if (snapshotCount < count) {
            throw new IllegalStateException("Snapshot " + snapshotId + " is truncated");
        }
        final long snapshotStart = snapshotOffset;
        final long snapshotRead = snapshotThrottle.read(metaBufferCollector, snapshotStart, snapshotCount);
        if (snapshot<nl>
        return HeapByteBufUtil.getLong(b, off);
    }

    public static void putByte(final byte[] b, final int off, final byte val) {
        HeapByteBufUtil.setByte(b, off, val);
    }

    public static byte getByte(final byte[] b, final int off) {
        return HeapByteBufUtil.getByte(b, off);
    }

    public static void putShort(final byte[] b, final int off, final short val) {
        HeapByteBufUtil.setShort(b, off, val);
    }

    public static short getShort(final byte[] b, final int off) {
        return HeapByteBufUtil.getShort(b, off);
    }

    public static void putLong(final byte[] b, final int off, final long val) {
        HeapByteBufUtil.setLong(b, off, val);
    }

    public static int getInt(final byte[] b, final int off) {
        return HeapByteBufUtil.getInt(b, off);
    }

    public static void putInt(final byte[] b, final int off, final int val) {
        HeapByteBufUtil.setInt(b, off, val);
    }

    public static void putShort(final byte[] b, final int off, final short val) {
        HeapByteBufUtil.setShort(b, off, val);
    }

    public static short getShort(final byte[] b, final int off) {
        return HeapByteBufUtil.getShort(b, off);
    }

    public static void putLong(final byte[] b, final int off, final long val) {
        HeapByteBufUtil.setLong(b, off, val);
    }

    public static int getInt(final byte<nl>
        return "DebugStatistics{" +
                "count=" + count +
                ", sum=" + sum +
                ", min=" + min +
                ", max=" + max +
                ", average=" + average +
                '}';
    <|file_separator|><nl>
        if (element == null) {
            throw new NullPointerException("element");
        }
        this.capacity += element.remaining();
        return super.add(element);
    <|file_separator|><nl>
        if (this.destroyed) {
            return;
        }
        this.lock.unlock();
    <|file_separator|><nl>
        this.ballot.grant(1);
    <|file_separator|><nl>
        return new LogEntryCodecFactoryV1();
    <|file_separator|><nl>
        return new AddPeerRequest(groupId, peerId);
    <|file_separator|><nl>
        final ArgumentCaptor<GetPeersResponse> responseArg = ArgumentCaptor.forClass(GetPeersResponse.class);
        verify(node).send(interest, responseArg.capture(), doneArg.capture());
        final GetPeersResponse response = responseArg.getValue();
        assertEquals(1, response.getPeersCount());
        assertEquals(peerId, response.getPeers(0).getPeerId());
    <|file_separator|><nl>
        return new ResetPeerRequest(groupId, peerId);
    <|file_separator|><nl>
        Bits bits = new Bits();
        bits.set(1);
        bits.set(2);
        bits.set(3);
        bits.set(4);
        bits.set(5);
        bits.set(6);
        bits.set(7);
        bits.set(8);
        bits.set(9);
        bits.set(10);
        bits.set(11);
        bits.set(12);
        bits.set(13);
        bits.set(14);
        bits.set(15);
        bits.set(16);
        bits.set(17);
        bits.set(18);
        bits.set(19);
        bits.set(20);
        bits.set(21);
        bits.set(22);
        bits.set(23);
        bits.set(24);
        bits.set(25);
        bits.set(26);
        bits.set(27);
        bits.set(28);
        bits.set(29);
        bits.set(30);
        bits.set(31);
        bits.set(32);
        bits.set(33);
        bits.set(34);
        bits.set(35);
        bits.set(36);
        bits.set(37);
        bits.set(38);
        bits.set(39);
        bits.set(40);
        bits.set(41);
        bits.set(42);
        bits.set(43);
        bits.set(44);
        bits.set<nl>
        final RecyclableByteBufferList object = RecyclableByteBufferList.newInstance();
        final byte[] buffer = new byte[1024];
        object.recycle(buffer);
        assertSame(object, RecyclableByteBufferList.newInstance());
    <|file_separator|><nl>
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                cost.set(System.currentTimeMillis());
                latch.countDown();
            <|file_separator|><nl>
        LOG.info("Hello World");
    <|file_separator|><nl>
        this.rheaKVStore.init();
    <|file_separator|><nl>
        final List<String> keys = new ArrayList<>();
        keys.add("key1");
        keys.add("key2");
        keys.add("key3");
        final List<String> values = rheaKVStore.multiGet(keys);
        LOG.info("MultiGet: " + values);
    <|file_separator|><nl>
        return InetAddress.getLocalHost().getHostAddress();
    <|file_separator|><nl>
        final boolean mac = SystemPropertyUtil.get("os.name", "") //
            .toLowerCase(Locale.US) //
            .contains("mac");
        if (mac) {
            LOG.debug("Platform: Mac");
        }
        return mac;
    <|file_separator|><nl>
        final List<LogEntry> entries = TestUtils.mockEntries(15);
        this.logStorage.appendEntries(entries);
        // Append more index into indexDB
        final IndexDB indexDB = ((LogitLogStorage) this.logStorage).getIndexDB();
        long maxFlushPosition = 0;
        for (int i = 15; i <= 20; i++) {
            final Pair<Integer, Long> flushPair = indexDB.appendIndexAsync(i, 0, IndexType.IndexSegment);
            maxFlushPosition = Math.max(maxFlushPosition, flushPair.getSecond());
        }
        indexDB.waitForFlush(maxFlushPosition, 100);
        // Recover
        this.logStorage.shutdown();
        this.logStorage.init(newLogStorageOptions());

        // In this case, logitLogStorage will truncate indexdb to the index of 14
        final IndexDB indexDB1 = ((LogitLogStorage) this.logStorage).getIndexDB();
        assertEquals(14, indexDB1.getLastLogIndex());

        for (int i = 0; i <= 14; i++) {
            final LogEntry entry = this.logStorage.getEntry(i);
            assertEquals(entry.getId().getIndex(), i);
        }
    <|file_separator|><nl>
        // Write 32 bytes data
        final byte[] data = genData(0, 0, 32);
        int firstWritePos = FileHeader.HEADER_SIZE;
        assertFalse(this.segmentFile.reachesFileEndBy(SegmentFile.getWriteBytes(data)));
        assertEquals(firstWritePos, this.segmentFile.appendData(0, data));
        // Can't read before sync
        this.segmentFile.flush();
        assertArrayEquals(data, this.segmentFile.lookupData(0, firstWritePos));

        // Write 20 bytes data, length = 6 + 14 = 20
        final byte[] data2 = genData(1, 0, 20);
        int nextWrotePos = FileHeader.HEADER_SIZE + 38;
        assertFalse(this.segmentFile.reachesFileEndBy(SegmentFile.getWriteBytes(data2)));
        assertEquals(nextWrotePos, this.segmentFile.appendData(1, data2));
        // Can't read before sync
        this.segmentFile.flush();
        assertArrayEquals(data2, this.segmentFile.lookupData(1, nextWrotePos));

        // Truncate
        int truncatePos = FileHeader.HEADER_SIZE + 38;
        this.segmentFile.truncate(1, truncatePos);

        // Recover
        this.segmentFile.shutdown(1000);
        this.init();
        this.segmentFile.recover();

        assertEquals(this.segmentFile.getLastLogIndex(), 0);
    <|file_separator|>class SegmentFile.java
<|fim_prefix|><|fim_suffix|>
    public static byte[] getWriteBytes(byte[] data) {
        return data;
    }

    /**
     * @<nl>
        return STREAM_GETTER.get(call);
    }

    public static ServerCall<?, ?> getServerCall(final ServerStream stream) {
        return SERVER_CALL_GETTER.get(stream);
    <|file_separator|><nl>
        final NettyConnection connection = new NettyConnection(channel, listeners);
        channel.attr(NETTY_CONN_KEY).set(connection);
        return connection;
    <|file_separator|><nl>
        this.regionOpts = Requires.requireNonNull(opts, "opts");
        this.node = new Node(this.regionOpts);
        this.fsm = new KVStoreStateMachine(this.regionOpts);
        this.raftRawKVStore = new RaftRawKVStore(this.regionOpts, this.fsm);
        this.metricsRawKVStore = new MetricsRawKVStore(this.regionOpts);
        this.raftGroupService = new RaftGroupService(this.regionOpts, this.node, this.raftRawKVStore);
        this.raftGroupService.start();
        this.started = true;
        this.regionMetricsReporter = new ScheduledReporter(this.regionOpts, this.regionOpts.getRegionMetricsReporterInterval(),
            this.regionOpts.getRegionMetricsReporterTimeout(), this.regionOpts.getRegionMetricsReporterPeriod(),
            this.regionOpts.getRegionMetricsReporterName(), this.regionOpts.getRegionMetricsReporterDescription(),
            this.regionOpts.getRegionMetricsReporterTags(), this.regionOpts.getRegionMetricsReporterTags(),
            this.regionOpts.getRegionMetricsReporterTags(), this.regionOpts.getRegionMetricsReporterTags(),
            this.regionOpts.getRegionMetricsReporterTags(), this.regionOpts.getRegionMetricsReporterTags(),
            this.regionOpts.getRegionMetricsReporterTags(), this.regionOpts.getRegionMetricsReporterTags(),
            this.regionOpts.getRegionMetricsReporterTags(), this.regionOpts.getRegionMetricsReporterTags(),
            this.regionOpts.getRegionMetricsReporterTags(), this.regionOpts.getRegionMetricsReporterTags(),
            this.regionOpts.getRegionMetricsReporterTags(), this.regionOpts.getRegionMetricsReporterTags(),
            this.regionOpts.getRegionMetricsReporterTags(), this.regionOpts.get<nl>
        return get(future, timeoutMillis, TimeUnit.MILLISECONDS);
    }

    public static <V> V get(final CompletableFuture<V> future, final long timeoutMillis, final TimeUnit unit) {
        try {
            return future.get(timeoutMillis, unit);
        } catch (final InterruptedException e) {
            throw new RuntimeException(e);
        } catch (final ExecutionException e) {
            throw new RuntimeException(e);
        } catch (final TimeoutException e) {
            throw new RuntimeException(e);
        }
    }

    public static <V> CompletableFuture<V> join(final FutureGroup<V> futureGroup) {
        return join(futureGroup, new CompletableFuture<>());
    }

    public static <V> CompletableFuture<V> join(final FutureGroup<V> futureGroup, final CompletableFuture<V> future) {
        CompletableFuture.allOf(futureGroup.toArray()).whenComplete((ignored, throwable) -> {
            if (throwable == null) {
                for (final CompletableFuture<V> partOf : futureGroup.futures()) {
                    if (!partOf.join()) {
                        future.complete(null);
                        return;
                    }
                }
                future.complete(futureGroup.get());
            } else {
                future.completeExceptionally(throwable);
            }
        });
        return future;
    <|file_separator|><nl>
        super.init(opts);
        LOG.info("[FakePlacementDriverClient] init successfully.");
        return true;
    }

    @Override
    public synchronized void start() {
        super.start();
        LOG.info("[FakePlacementDriverClient] start successfully.");
    <|file_separator|><nl>
        this.clusterId = clusterId;
    <|file_separator|><nl>
        return BatchPutRequest.MAGIC;
    }

    @Override
    public int size() {
        return 1 + kvEntries.size() * KVEntry.size();
    }

    @Override
    public void write(ByteBuffer buffer) {
        buffer.put(magic());
        buffer.putInt(size());
        for (KVEntry kvEntry : kvEntries) {
            kvEntry.write(buffer);
        }
    }

    @Override
    public void read(ByteBuffer buffer) {
        kvEntries = new ArrayList<>();
        int size = buffer.getInt();
        for (int i = 0; i < size; i++) {
            kvEntries.add(new KVEntry());
            kvEntries.get(i).read(buffer);
        }
    <|file_separator|><nl>
        return acquirer;
    <|file_separator|><nl>
        return this;<|file_separator|><nl>
        return new RpcOptionsConfigured(new RpcOptions());
    <|file_separator|>class RpcOptions.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class RpcOptions {
    public RpcOptions() {
    }
}<|file_separator|>class RpcOptionsBuilder.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class RpcOptionsBuilder {
    public RpcOptionsBuilder() {
    }
}<|file_separator|>class RpcOptionsBuilderConfigured.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class RpcOptionsBuilderConfigured {
    public RpcOptionsBuilderConfigured() {
    }
}<|file_separator|><nl>
        this.value = value;
    <|file_separator|><nl>
        zipStrategies[idx] = zipStrategy;
    <|file_separator|><nl>
        if (e.getRejectedExecutionHandler() instanceof DiscardPolicyWithReport) {
            System.out.println("Discarding " + r + " from " + e);
        }
        else {
            super.rejectedExecution(r, e);
        }
    <|file_separator|>class ThreadPoolExecutorWithReport.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>import java.util.concurrent.RejectedExecutionHandler;
import java.util.concurrent.ThreadPoolExecutor;

public class ThreadPoolExecutorWithReport extends ThreadPoolExecutor {

    public ThreadPoolExecutorWithReport(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, RejectedExecutionHandler handler) {
        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, handler);
    }

    @Override
    public void execute(Runnable command) {
        super.execute(new RunnableWithReport(command));
    }
}<|file_separator|>class AbstractRejectedExecutionHandler.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>import java.util.concurrent.RejectedExecutionHandler;
import java.util.concurrent.ThreadPoolExecutor;

public abstract class AbstractRejectedExecutionHandler implements RejectedExecutionHandler {

    private String threadPoolName;
    private boolean isDiscardPolicy;
    private String report;

    public AbstractRejectedExecutionHandler(String threadPoolName, boolean isDiscardPolicy, String report) {
        this.threadPoolName = threadPoolName;
        this.isDiscardPolicy = isDiscardPolicy;
        this.report = report;
    }

    @Override
    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
        if (isDiscardPolicy) {
            System.out.println("Discarding " + r + " from " + e);
        }
        else {
            System.out.println("Executing " + r + " in " + e);<nl>
        if (LOG.isInfoEnabled()) {
            LOG.info("Task handler on timeout: {}.", Thread.currentThread().getName());
        }
    <|file_separator|><nl>
        final Class<?>[] interfaces = parameterizedSuperclass.getInterfaces();
        for (Class<?> i : interfaces) {
            if (i.isAssignableFrom(object.getClass())) {
                return i;
            }
        }

        final Class<?> superclass = parameterizedSuperclass.getSuperclass();
        if (superclass == null) {
            return fail(parameterizedSuperclass, typeParamName);
        }

        return find0(object, superclass, typeParamName);
    <|file_separator|><nl>
        super.setup();
    <|file_separator|><nl>
        return false;
    <|file_separator|><nl>
        System.out.println("RheaKVTestCluster start ...");
        for (String conf : CONF) {
            RheaKVStore store = new DefaultRheaKVStore(conf);
            store.start();
            stores.add(store);
        }
        System.out.println("RheaKVTestCluster start complete");
    <|file_separator|><nl>
        this.vlaue = vlaue;
    <|file_separator|><nl>
        return this.raftGroupService;
    <|file_separator|><nl>
        while (iter.hasNext()) {
            final String key = iter.next();
            final AtomicLong counter = getCounter(key, true);
            counter.incrementAndGet();
        }
    <|file_separator|><nl><nl>
    super.setUp();
    this.setTestFile("test.txt");
  <|file_separator|><nl>
    // TODO
  }
<|file_separator|><nl>
    NaturalLogicAnnotator annotator = new NaturalLogicAnnotator(pipeline.get());
    String text = "The quick brown fox jumps over the lazy dog.";
    Annotation annotation = annotator.annotate(text);
    System.out.println(annotation.toString());
  <|file_separator|><nl>
    Annotation annotation = pipeline.process(text);
    List<CoreMap> sentences = annotation.get(SentencesAnnotation.class);
    List<Polarity> polarities = new ArrayList<>();
    for (CoreMap sentence : sentences) {
      for (CoreLabel token : sentence.get(TokensAnnotation.class)) {
        String word = token.get(TextAnnotation.class);
        String pos = token.get(PartOfSpeechAnnotation.class);
        if (pos.startsWith("NN") || pos.startsWith("JJ") || pos.startsWith("VB")) {
          polarities.add(new Polarity(word, pos));
        }
      }
    }
    return polarities.toArray(new Polarity[0]);
  <|file_separator|><nl><nl>
    List<String> results = new ArrayList<>();
    for (Annotation annotation : annotations) {
      for (CoreLabel token : annotation.get(CoreAnnotations.TokensAnnotation.class)) {
        results.add(token.get(CoreAnnotations.TextAnnotation.class));
      }
    }
    return results;
  <|file_separator|><nl>
    String[] tokens = Tokenizer.split("This is a test", " ");
    assertEquals(tokens.length, 3);
    assertEquals(tokens[0], "This");
    assertEquals(tokens[1], "is");
    assertEquals(tokens[2], "a");
    assertEquals(tokens[3], "test");
  <|file_separator|><nl>
      systemTokensList = new ArrayList<>();
      Tokenizer tokenizer = new Tokenizer();
      tokenizer.tokenize(sentenceText);
    <|file_separator|><nl>
    BufferedReader bin = IOUtils.readerFromString(taggedText, "utf-8");
    StringWriter sout = new StringWriter();
    BufferedWriter bout = new BufferedWriter(sout);
    singleTagger.runTagger(bin, bout, "", OutputStyle.SLASH_TAGS);
    bout.flush();

    String singleOutput = sout.toString();

    bin = IOUtils.readerFromString(taggedText, "utf-8");
    sout = new StringWriter();
    bout = new BufferedWriter(sout);
    multiTagger.runTagger(bin, bout, "", OutputStyle.SLASH_TAGS);
    bout.flush();

    String multiOutput = sout.toString();

    assertEquals(singleOutput, multiOutput);
  <|file_separator|><nl>
    if (afterPostProcessing) {
      Redwood.log("Final conll score ((muc+bcub+ceafe)/3) = " + (new DecimalFormat("#.##")).format(getFinalConllScore(summary)));
    } else {
      Redwood.log(summary);
    }
  <|file_separator|><nl>
      int result = mentionType.hashCode();
      result = 31 * result + number.hashCode();
      result = 31 * result + gender.hashCode();
      result = 31 * result + animacy.hashCode();
      result = 31 * result + startIndex;
      result = 31 * result + endIndex;
      result = 31 * result + headIndex;
      result = 31 * result + corefClusterID;
      result = 31 * result + mentionID;
      result = 31 * result + sentNum;
      result = 31 * result + position.hashCode();
      return result;
    <|file_separator|><nl>
    mentions.add(m);
  }

  public void removeMention(Mention m) {
    mentions.remove(m);
  }

  public boolean isSpeakerIdAutoDetermined() {
    return speakerIdIsAutoDetermined;
  }

  public boolean isSpeakerIdNumber() {
    return speakerIdIsNumber;
  }

  public boolean isSpeakerIdValid() {
    return speakerIdIsAutoDetermined || speakerIdIsNumber;
  <|file_separator|><nl>
    // TODO
  <|file_separator|><nl>
    int pDen = 0;
    int pNum = 0;

    Map<Integer, Mention> predictedMentions = doc.allPredictedMentions;
    for(CorefCluster g : doc.goldCorefClusters.values()){
      if(g.corefMentions.size()==0) {
        SieveCoreferenceSystem.logger.warning("NO MENTIONS for cluster " + g.getClusterID());
        continue;
      }
      pDen += g.corefMentions.size();
      pNum += g.corefMentions.size()-1;

      Set<CorefCluster> partitions = Generics.newHashSet();
      for (Mention goldMention : g.corefMentions){
        if(!predictedMentions.containsKey(goldMention.mentionID)) {  // twinless goldmention
          pNum--;
        } else {
          partitions.add(doc.corefClusters.get(predictedMentions.get(goldMention.mentionID).corefClusterID));
        }
      }
      pNum -= partitions.size();
    }
    if (pDen != doc.allGoldMentions.size()-doc.goldCorefClusters.values().size()) {
      log.info("pDen is " + pDen);
      log.info("doc.allGoldMentions.size() is " + doc.allGoldMentions.size());
      log.info("doc.goldCorefClusters.values().size() is " + doc.goldCorefClusters.values().size());
    }
    assert(pDen == (doc.allGoldMentions.size()-doc.goldCorefClusters.values().size()));

    precisionNumSum += pNum;
    precisionDenSum += pDen;
  }

  @Override
  protected void calculateF1(Document doc<nl>
    if (input.subjectType == null || input.objectType == null) {
      return null;
    }
    if (input.subjectType.isRelationType() && input.objectType.isRelationType()) {
      return null;
    }
    if (input.subjectType.isRelationType() || input.objectType.isRelationType()) {
      return null;
    }
    if (input.subjectType.isEntity() && input.objectType.isEntity()) {
      return null;
    }
    if (input.subjectType.isEntity() || input.objectType.isEntity()) {
      return null;
    }
    if (input.subjectType.isEntity() && input.objectType.isEntity()) {
      return null;
    }
    if (input.subjectType.isEntity() && input.objectType.isEntity()) {
      return null;
    }
    if (input.subjectType.isEntity() && input.objectType.isEntity()) {
      return null;
    }
    if (input.subjectType.isEntity() && input.objectType.isEntity()) {
      return null;
    }
    if (input.subjectType.isEntity() && input.objectType.isEntity()) {
      return null;
    }
    if (input.subjectType.isEntity() && input.objectType.isEntity()) {
      return null;
    }
    if (input.subjectType.isEntity() && input.objectType.isEntity()) {
      return null;
    }
    if (input.subjectType.isEntity() && input.objectType.isEntity()) {
      return null;
    }
    if (input.subjectType.<nl>
    return classifyWithGlobalInformation(document, null, null);
  <|file_separator|><nl>
    Extractor[] extractors = new Extractor[extractorModelNames.length];
    for (int i = 0; i < extractorModelNames.length; i++) {
      extractors[i] = ExtractorFactory.getExtractor(extractorModelNames[i]);
    }
    return new ExtractorMerger(extractors);
  <|file_separator|><nl>
    List<List<AceToken>> sentences = tokenizeAndSegmentSentences("data/test");
    for (List<AceToken> sentence : sentences) {
      for (AceToken token : sentence) {
        System.out.println(token);
      }
      System.out.println();
    }
  <|file_separator|><nl>
    if(entityTagForNer.containsKey(ner)){
      return entityTagForNer.get(ner);
    }
    return ner;<|file_separator|><nl>
  <|file_separator|><nl>
    String[] prev = cols[pos-1];
    String[] cur = cols[pos];
    String[] next = cols[pos+1];
    String prevLabel = prev[1];
    String curLabel = cur[1];
    String nextLabel = next[1];
    if (prevLabel.equals("LOCATION") &&
        curLabel.equals("LOCATION") &&
        nextLabel.equals("LOCATION")) {
      String prevWord = prev[0];
      String nextWord = next[0];
      String key = prevWord + " " + nextWord;
      if (cache.containsKey(key)) {
        cur[0] = cache.get(key);
      } else {
        String answer = answers.readLine();
        if (answer == null) {
          log.info("No answer for " + key);
          cur[0] = "No answer";
        } else {
          cache.put(key, answer);
          cur[0] = answer;
        }
      }
    }
  <|file_separator|><nl> return Collections.unmodifiableSet(dimirMunfasala); <|file_separator|><nl>
    if(opts == null)
      return false;

    if(!ConfigParser.parse(opts, this))
      return false;

    if(!ConfigParser.checkRequired(this, requiredOptions))
      return false;

    if(!ConfigParser.checkRequired(this, configuredOptions))
      return false;

    return true;
  <|file_separator|><nl>
        return tf.getTokenizer(in).tokenize();
      }
    });
  }<|file_separator|><nl>
    String filename = args[0];
    BufferedReader br = new BufferedReader(new FileReader(filename));
    String line;
    while ((line = br.readLine()) != null) {
      String[] parts = line.split("\t");
      String pattern = parts[1];
      mwtPatternCounts.setCount(pattern,mwtPatternCounts.getCount(pattern)+1);
    }
    for (String pattern : mwtPatternCounts.keySet()) {
      System.out.println(pattern + "\t" + mwtPatternCounts.getCount(pattern));
    }
  <|file_separator|><nl>
    return pConditionalSuffix.matcher(s).find();
  <|file_separator|><nl>
    if (args.length == 0) {
      System.out.println(usage);
      System.exit(1);
    }

    String outputPath = null;
    List<File> fileList = new ArrayList<>();

    for (int i = 0; i < args.length; i++) {
      if (args[i].equals("-o")) {
        outputPath = args[++i];
      } else {
        fileList.add(new File(args[i]));
      }
    }

    if (outputPath == null) {
      System.out.println(usage);
      System.exit(1);
    }

    AnCoraPOSStats stats = new AnCoraPOSStats(fileList, outputPath);
    stats.process();

    TwoDimensionalCounter<String, String> unigramTagger = stats.getUnigramTagger();
    unigramTagger.writeToFile(outputPath);
  <|file_separator|><nl>
    // TODO Auto-generated method stub

  }

}
<|file_separator|><nl>
    if (file.isDirectory()) {
      return recursively;
    }
    if (extension == null) {
      return true;
    }
    return file.getName().toLowerCase().endsWith(extension);
  <|file_separator|><nl>
      return p.matcher(file.getName()).find();
    <|file_separator|><nl>
    if (in == null) {
      throw new IOException("Stream Closed");
    }
    if (slack == null) {
      char[] buf = new char[1];
      int n = in.read(buf);
      if (n == -1) {
        return -1;
      }
      slack = new String(buf, 0, n).getBytes(encoding);
      begin = 0;
    }
    char c = slack[begin];
    begin++;
    if (begin >= slack.length) {
      slack = null;
    }
    return c;
  <|file_separator|><nl>
    return pattern.matcher(file.getName()).matches();
  <|file_separator|><nl>
    return features.asSet();
  }

  /**
   * Returns the list of features with values
   */
  public Collection<F> asFeaturesWithValues() {
    return features.asSet();
  }

  /**
   * Returns the list of labels
   */
  public Collection<L> asLabels() {
    return Collections.singletonList(label);
  }

  /**
   * Returns the list of labels
   */
  public Collection<L> asLabelsWithValues() {
    return Collections.singletonList(label);
  }

  /**
   * Returns the list of labels
   */
  public Collection<L> asLabelsWithValues(boolean includeNull) {
    if (includeNull) {
      return asLabelsWithValues();
    }
    return Collections.singletonList(label);
  }

  /**
   * Returns the list of labels
   */
  public Collection<L> asLabelsWithValues(boolean includeNull, boolean includeEmpty) {
    if (includeNull) {
      return asLabelsWithValues();
    }
    if (includeEmpty) {
      return asLabelsWithValues();
    }
    return Collections.singletonList(label);
  }

  /**
   * Returns the list of labels
   */
  public Collection<L> asLabelsWithValues(boolean includeNull, boolean includeEmpty, boolean includeZero) {
    if (includeNull) {
      return asLabelsWithValues();
    }
    if (includeEmpty) {
      return asLabelsWithValues();
    }
    if (includeZero) {
      return asLabelsWithValues();
    }
    return Collections.singletonList(label);
  }

  /**
   * Returns the list of labels
   <nl>
    try {
      out.writeUTF(word);
      out.writeUTF(tag);
    } catch (Exception e) {
      e.printStackTrace();
    }
  }<|file_separator|><nl>
    StringBuffer buf = new StringBuffer();
    for (int i = 0; i < str.length(); i++) {
      int c = str.charAt(i);
      if (c < 32 || c >= 127) {
        buf.append("\\u");
        buf.append(Integer.toString(c, 16).toUpperCase());
      } else {
        buf.append(c);
      }
    }
    return buf.toString();
  <|file_separator|><nl>
    synchronized (sparseFeatureIndex) {
      if (!sparseFeatureIndex.containsKey(featureName)) {
        sparseFeatureIndex.put(featureName, new HashMap<>());
      }
      if (!sparseFeatureIndex.get(featureName).containsKey(index)) {
        sparseFeatureIndex.get(featureName).put(index, sparseFeatureIndex.get(featureName).size());
      }
      return sparseFeatureIndex.get(featureName).get(index);
    }
  <|file_separator|><nl>
        for (int i = assignments.length - 1; i >= 0; i--) {
          if (assignments[i] < dimensions[i] - 1) {
            assignments[i]++;
            for (int j = i + 1; j < assignments.length; j++) {
              assignments[j] = 0;
            }
            return assignments.clone();
          }
        }
        throw new NoSuchElementException();
      <|file_separator|><nl>
    return this.parseTree.toString();
  <|file_separator|><nl>
    return o;
  <|file_separator|><nl>
    int iters = 0;
    double[] x = initial;
    double[] xNew = null;
    double[] xOld = null;
    double[] f = null;
    double[] fNew = null;
    double[] fOld = null;
    double[] fNewOld = null;
    double[] fOldNew = null;
    double[] fOldOld = null;
    double[] fOldOldOld = null;
    double[] fOldOldOldNew = null;
    double[] fOldOldOldOld = null;
    double[] fOldOldOldOldNew = null;
    double[] fOldOldOldOldOld = null;
    double[] fOldOldOldOldOldNew = null;
    double[] fOldOldOldOldOldOld = null;
    double[] fOldOldOldOldOldOldNew = null;
    double[] fOldOldOldOldOldOldOld = null;
    double[] fOldOldOldOldOldOldOldNew = null;
    double[] fOldOldOldOldOldOldOldOld = null;
    double[] fOldOldOldOldOldOldOldOldNew = null;
    double[] fOldOldOldOldOldOldOldOldOld = null;
    double[] fOldOldOldOldOldOldOldOldOldNew = null;
    double[] fOldOldOldOldOldOldOldOldOldOld = null;
    double[] fOldOldOldOldOldOldOldOldOldOldNew = null;
    double[] fOldOldOldOldOldOldOldOldOldOldOld = null;
    double[] fOldOldOldOldOldOldOldOldOldOldOldNew = null;
    double[] fOldOldOldOldOldOldOldOldOldOldOldOld = null;
    double[] fOldOldOldOldOld<nl>
    if (maxIterations == -1) {
      maxIterations = Integer.MAX_VALUE;
    }
    int n = initial.length;
    double[] y = new double[n];
    double[] s = new double[n];
    double[] tmpY = new double[n];
    double[] tmpS = new double[n];
    double[] grad = new double[n];
    double[] yGrad = new double[n];
    double[] sGrad = new double[n];
    double[] yGrad2 = new double[n];
    double[] sGrad2 = new double[n];
    double[] yGrad3 = new double[n];
    double[] sGrad3 = new double[n];
    double[] yGrad4 = new double[n];
    double[] sGrad4 = new double[n];
    double[] yGrad5 = new double[n];
    double[] sGrad5 = new double[n];
    double[] yGrad6 = new double[n];
    double[] sGrad6 = new double[n];
    double[] yGrad7 = new double[n];
    double[] sGrad7 = new double[n];
    double[] yGrad8 = new double[n];
    double[] sGrad8 = new double[n];
    double[] yGrad9 = new double[n];
    double[] sGrad9 = new double[n];
    double[] yGrad10 = new double[n];
    double[] sGrad10 = new double[n];
    double[] yGrad11 = new double[n];
    double[] sGrad11 = new double[n];
    double[] yGrad12 = new double[n];
    double[] sGrad1<nl>
    double[] grad = newGrad;
    double[] newGrad = newGrad;
    double[] newX = newX;
    double[] x = x;
    double[] y = y;
    double[] s = s;
    double ro = ro;
    double[] dir = dir;
    double[] fg = fg;
    double[] newX = newX;
    double[] x = x;
    double[] y = y;
    double[] s = s;
    double ro = ro;
    double[] dir = dir;
    double[] fg = fg;
    double[] newX = newX;
    double[] x = x;
    double[] y = y;
    double[] s = s;
    double ro = ro;
    double[] dir = dir;
    double[] fg = fg;
    double[] newX = newX;
    double[] x = x;
    double[] y = y;
    double[] s = s;
    double ro = ro;
    double[] dir = dir;
    double[] fg = fg;
    double[] newX = newX;
    double[] x = x;
    double[] y = y;
    double[] s = s;
    double ro = ro;
    double[] dir = dir;
    double[] fg = fg;
    double[] newX = newX;
    double[] x = x;
    double[] y = y;
    double[] s = s;
    double ro = ro;
    double[] dir = dir;
    double[] fg = fg;
    double[] newX = newX;
    double[] x = x;
    double[] y = y;
    double[] s = s;
    double ro =<nl>
    runTest(TEST1, "1");
    runTest(TEST2, "1");
    runTest(TEST3, "1");
  <|file_separator|><nl>
    return null;
  }<|file_separator|><nl>
    if (t.isLeaf()) {
      return t;
    }
    if (t.isRoot()) {
      return t;
    }
    if (t.isLeaf()) {
      return t;
    }
    if (t.isRoot()) {
      return t;
    }
    if (t.isLeaf()) {
      return t;
    }
    if (t.isRoot()) {
      return t;
    }
    if (t.isLeaf()) {
      return t;
    }
    if (t.isRoot()) {
      return t;
    }
    if (t.isLeaf()) {
      return t;
    }
    if (t.isRoot()) {
      return t;
    }
    if (t.isLeaf()) {
      return t;
    }
    if (t.isRoot()) {
      return t;
    }
    if (t.isLeaf()) {
      return t;
    }
    if (t.isRoot()) {
      return t;
    }
    if (t.isLeaf()) {
      return t;
    }
    if (t.isRoot()) {
      return t;
    }
    if (t.isLeaf()) {
      return t;
    }
    if (t.isRoot()) {
      return t;
    }
    if (t.isLeaf()) {
      return t;
    }
    if (t.isRoot()) {
      return t;
    }
    if (t.isLeaf()) {
      return t;
    }
    if (t.isRoot()) {
      return t;
    }
    if (<nl>
    return word;
  <|file_separator|><nl>
    if (tw.tagIndex() == nullWord) {
      IntTaggedWord iT = new IntTaggedWord(tw.word(), tw.tagIndex());
      IntTaggedWord i = NULL_ITW;
      seenCounter.incrementCount(iT);
      seenCounter.incrementCount(i);
    } else {
      IntTaggedWord iT = new IntTaggedWord(tw.word(), tw.tagIndex());
      IntTaggedWord i = NULL_ITW;
      unSeenCounter.incrementCount(iT);
      unSeenCounter.incrementCount(i);
    }
  <|file_separator|><nl>
    return parent * 31 + child;
  <|file_separator|>class UnaryRuleSet.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/** A set of UnaryRules.
 *
 *  @author John
 */
public class UnaryRuleSet implements Serializable {

  private static final long serialVersionUID = 1L;

  /** The UnaryRules in this UnaryRuleSet.
   */
  private final List<UnaryRule> rules;

  /** Create a new UnaryRuleSet.
   */
  public UnaryRuleSet() {
    rules = new ArrayList<UnaryRule>();
  }

  /** Add a UnaryRule to this UnaryRuleSet.
   *
   *  @param rule The UnaryRule to add
   */
  public void add(UnaryRule rule) {
    rules.add(rule);
  }

  /** Get the UnaryRule at the given index.
   *
   *  @param index The index of the UnaryRule
   *  @return The UnaryRule at the given index
   */
  public UnaryRule get(int index) {
    return rules.get(index);
  }

  /** Get the number of UnaryRules in this UnaryRuleSet.
   *
   *  @return The number of UnaryRules in this UnaryRuleSet
   */
  public int size() {
    return rules.size();
  }

  /** Get the UnaryRule at the given index.
   *
   *  @param index The index of the UnaryRule
   *  @return The UnaryRule at the given index
   */
  public UnaryRule<nl>
    goldWriter.close();
    testWriter.close();
  <|file_separator|><nl>
    return new FilteredConstituents(tree, subtreeFilter, cf);
  }

  public static FilteredEval childFilteredEval(String str, boolean runningAverages, TreebankLanguagePack tlp, String childPattern, String childLabel) {
    return new FilteredEval(str, runningAverages, new TreeFilters.HasMatchingChild(tlp, childPattern, childLabel));
  <|file_separator|><nl>
    return features;
  <|file_separator|><nl>
    return new State(state.stack, state.transitions.push(this), state.separators, state.sentence, state.tokenPosition, state.score, true);
  <|file_separator|>class ShiftReduceUtils.java
<|fim_prefix|><|fim_suffix|>

  public static boolean constraintMatchesTreeTop(Stack<Token> stack, ParserConstraint constraint) {
    if (constraint.start == 0 && constraint.end == stack.size()) {
      return true;
    }
    if (constraint.start == 0 && constraint.end != stack.size()) {
      return false;
    }
    if (constraint.start != 0 && constraint.end == stack.size()) {
      return false;
    }
    if (constraint.start != 0 && constraint.end != stack.size()) {
      return false;
    }
    if (constraint.start == 0 && constraint.end == 0) {
      return true;
    }
    if (constraint.start == 0 && constraint.end == 1) {
      return stack.peek().value().equals(constraint.value);
    }
    if (constraint.start == 1 && constraint.end == 1) {
      return stack.peek().value().equals(constraint.value);
    }
    if (constraint.start == 1 && constraint.end == 0) {
      return false;
    }
    if (constraint.start == 1 && constraint.end == 2) {
      return stack.peek().value().equals(constraint.value);
    }
    if (constraint.start == 2 && constraint.end == 2) {
      return stack.peek().value().equals(constraint.value);
    }
    if (constraint.start == 2 && constraint.end ==<nl>
    return this.binarizedTree.root;
  <|file_separator|><nl>
    if (mode == Mode.BINARIZED) {
      Tree goldTree = gold.binarize();
      goldTree.display(pw);
    } else {
      gold.display(pw);
    }
  <|file_separator|><nl>
    try {
      Map<String,String> argMap = ArgumentParser.parse(ManipulateTopBracket.class,args,ManipulateTopBracket.minArgs,ManipulateTopBracket.usage(),ManipulateTopBracket.argDefs());
      String file = argMap.get("file");
      String enc = argMap.get("e");
      boolean verbose = argMap.get("v") == "1";
      boolean removeTopBracket = argMap.get("r") == "1";
      String lang = argMap.get("l");
      if (verbose) {
        ManipulateTopBracket.log.info("Verbose mode enabled.");
      }
      if (lang != null) {
        ManipulateTopBracket.log.info("Language settings: " + lang);
      }
      if (removeTopBracket) {
        ManipulateTopBracket.log.info("Removing top bracket.");
      }
      ManipulateTopBracket.log.info("Encoding: " + enc);
      ManipulateTopBracket.log.info("File: " + file);
      ManipulateTopBracket.log.info("Args: " + args);
      ManipulateTopBracket.log.info("ArgMap: " + argMap);
      ManipulateTopBracket.log.info("ArgDefs: " + ManipulateTopBracket.argDefs());
      ManipulateTopBracket.log.info("ArgDefs.size(): " + ManipulateTopBracket.argDefs().size());
      ManipulateTopBracket.log.info("ArgDefs.get(\"e\"): " + ManipulateTopBracket.argDefs().get("e"));
      ManipulateTopBracket.log.info("ArgDefs.get(\"v\"): " + ManipulateTopBracket.argDefs().get("v"));
      ManipulateTopBracket.log<nl>
    return graph;
  <|file_separator|><nl>
    Tree tree = sentence.get(TreeCoreAnnotations.TreeAnnotation.class);
    if (isBinarized(tree)) {
      return;
    }

    Tree binarizedTree = binarizer.binarize(tree);
    sentence.set(TreeCoreAnnotations.BinarizedTreeAnnotation.class, binarizedTree);
  <|file_separator|><nl>
    String headStr = orNeg(head);
    String deprelStr = orNull(deprel);
    return String.format("%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s<nl>
    return new Pair<>(sentenceCoreMap.get(CoreAnnotations.CharacterOffsetBeginAnnotation.class),
        sentenceCoreMap.get(CoreAnnotations.CharacterOffsetEndAnnotation.class));
  <|file_separator|><nl>
    // TODO
    log.info("ok");
  <|file_separator|><nl>
    for (TOKEN token : tokens) {
      doOneToken(token);
    }
  }

  private <TOKEN extends CoreLabel> void doOneToken(TOKEN token) {
    QuantifiableEntityNormalizer.addNormalizedQuantitiesToEntity(token, collapse);
  <|file_separator|><nl>
    return serializer.deserialize(stream);
  <|file_separator|><nl>
    if (word == null) {
      return unknownWordClass;
    }
    String wordClass = lexicon.get(word);
    if (wordClass == null) {
      return unknownWordClass;
    }
    return wordClass;
  <|file_separator|><nl>
    return input.toLowerCase();
  <|file_separator|><nl>
    return null;
  }
<|file_separator|><nl>
    return new MentionData(
            quote.get(CoreAnnotations.TextAnnotation.class),
            quote.get(QuoteAttributionAnnotator.MentionBeginAnnotation.class),
            quote.get(QuoteAttributionAnnotator.MentionEndAnnotation.class),
            quote.get(QuoteAttributionAnnotator.MentionTypeAnnotation.class));
  }

  protected static void fillInMention(CoreMap quote, MentionData md) {
    fillInMention(quote, md.text, md.begin, md.end, md.sieveName, md.type);
  }

  protected static void fillInMention(CoreMap quote, String text, int begin, int end, String sieveName, String mentionType) {
    quote.set(QuoteAttributionAnnotator.MentionAnnotation.class, text);
    quote.set(QuoteAttributionAnnotator.MentionBeginAnnotation.class, begin);
    quote.set(QuoteAttributionAnnotator.MentionEndAnnotation.class, end);
    quote.set(QuoteAttributionAnnotator.MentionSieveAnnotation.class, sieveName);
    quote.set(QuoteAttributionAnnotator.MentionTypeAnnotation.class, mentionType);
  <|file_separator|>class QMSieve.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>import java.util.List;

public class QMSieve extends QMSieve {
  public QMSieve(Annotation doc,
                 Map<String, List<Person>> characterMap,
                 Map<Integer,String> pronounCorefMap,
                 Set<String> animacySet,
                 String sieveName) {
    super(doc, characterMap, pronounCorefMap, animacySet, sieveName);
  }

  public void doQuoteToMention(Annotation doc) {
    // TODO: implement this
  }
}<|file_separator|><nl>
    Properties props = new Properties();
    props.setProperty("annotators", "tokenize, ssplit, pos, lemma, ner, parse, dcoref");
    this.pipeline = new StanfordCoreNLP(props);
  <|file_separator|><nl>
    throw new RuntimeException("Method not implemented!");
  <|file_separator|><nl>
    String model = new String(Files.readAllBytes(Paths.get(pathToModel)));
    String[] lines = model.split("\n");
    for (String line : lines) {
      if (line.contains("most_discriminative_syntactic_patterns")) {
        System.out.println(line);
      }
    }
  <|file_separator|><nl>
      return String.class;
    <|file_separator|><nl>

    HashMap<Integer, Integer> result = new HashMap<Integer, Integer>();

    for (IndexedWord noun : sg.getNodesInLevel(0)) {
      if (noun.tag().matches("^NNP?$") || (noun.tag().matches("^NNP?S?$"))) {
        IndexedWord gov = sg.getParent(noun);
        if (gov != null) {
          IndexedWord np = bfsNPSearch(sg, gov, noun.tag().matches("^NNP?S?$"));
          if (np != null) {
            result.put(np.index(), noun.index());
          }
        }
      }
    }

    return result;
  <|file_separator|><nl>
    if (format.equals("readable")) {
      return "Score: " + score + "\n" +
             "Justification: " + justification + "\n" +
             "Map:\n" + mapToString();
    }
    else if (format.equals("json")) {
      return "{ \"score\": " + score + ", \"justification\": \"" + justification + "\", \"map\": " + mapToString() + " }";
    }
    else {
      throw new IllegalArgumentException("Invalid format " + format);
    }
  }

  private String mapToString() {
    StringBuilder sb = new StringBuilder();
    for (IndexedWord hyp : map.keySet()) {
      sb.append("  ").append(iwToString(hyp)).append(" -> ").append(iwToString(map.get(hyp))).append("\n");
    }
    return sb.toString();
  <|file_separator|><nl>
    StringBuffer buf = new StringBuffer();
    for (int i = 0; i < str.length(); i++) {
      int c = str.charAt(i);
      if (c < 32 || c >= 127) {
        buf.append("\\u");
        buf.append(Integer.toString(c, 16).toUpperCase());
      } else {
        buf.append(c);
      }
    }
    return buf.toString();
  <|file_separator|><nl>
    if (sg.getNodes().size() == 0) {
      return false;
    }
    if (sg.getNodes().size() == 1) {
      return false;
    }
    if (sg.getNodes().size() == 2) {
      return false;
    }
    if (sg.getNodes().size() == 3) {
      return false;
    }
    if (sg.getNodes().size() == 4) {
      return false;
    }
    if (sg.getNodes().size() == 5) {
      return false;
    }
    if (sg.getNodes().size() == 6) {
      return false;
    }
    if (sg.getNodes().size() == 7) {
      return false;
    }
    if (sg.getNodes().size() == 8) {
      return false;
    }
    if (sg.getNodes().size() == 9) {
      return false;
    }
    if (sg.getNodes().size() == 10) {
      return false;
    }
    if (sg.getNodes().size() == 11) {
      return false;
    }
    if (sg.getNodes().size() == 12) {
      return false;
    }
    if (sg.getNodes().size() == 13) {
      return false;
    }
    if (sg.getNodes().size() == 14) {
      return false;
    }
    if (sg.getNodes().size() == 15) {
      return false;
    }
    if (sg.getNodes().size<nl>
    return null;
  <|file_separator|><nl>
    return getDisplayName();
  <|file_separator|><nl>
    switch (type) {
      case lemma:
        return node.getLemma().equals(resourceID);
      case current_lasttoken:
        return node.getCurrentLastToken().equals(resourceID);
      case lemma_and_currlast:
        return node.getLemma().equals(resourceID) && node.getCurrentLastToken().equals(resourceID);
      case word:
        return node.getWord().equals(resourceID);
      case pos:
        return node.getPos().equals(resourceID);
      default:
        return false;
    }
  <|file_separator|><nl>
        return String.class;
    }
    @Override
    public String getAnnotationValue(String value) {
        return value;
    <|file_separator|><nl>
    return mockSentiment(props);
  }

  /**
   * No dependency parsing implemented for Chinese.
   *
   * @see Document#runDepparse(Properties)
   */
  @Override
  protected Document runDepparse(Properties props) {
    return mockDepparse(props);
  <|file_separator|><nl>
    return decrementCount(key, 1.0);
  }

  public double getCount(E key) {
    return getCount(key, 0.0);
  }

  public double getCount(E key, double defaultValue) {
    return getCount(key, defaultValue, 0.0);
  }

  public double getCount(E key, double defaultValue, double defaultValueIfNotFound) {
    return getCount(key, defaultValue, defaultValueIfNotFound, 0.0);
  }

  public double getCount(E key, double defaultValue, double defaultValueIfNotFound, double defaultValueIfNotFoundIfNotFound) {
    return getCount(key, defaultValue, defaultValueIfNotFound, defaultValueIfNotFoundIfNotFound, 0.0);
  }

  public double getCount(E key, double defaultValue, double defaultValueIfNotFound, double defaultValueIfNotFoundIfNotFound, double defaultValueIfNotFoundIfNotFoundIfNotFound) {
    return getCount(key, defaultValue, defaultValueIfNotFound, defaultValueIfNotFoundIfNotFound, defaultValueIfNotFoundIfNotFoundIfNotFound, 0.0);
  }

  public double getCount(E key, double defaultValue, double defaultValueIfNotFound, double defaultValueIfNotFoundIfNotFound, double defaultValueIfNotFoundIfNotFoundIfNotFound, double defaultValueIfNotFoundIfNotFoundIfNotFoundIfNotFound) {
    return getCount(key, defaultValue, defaultValueIfNotFound, defaultValueIfNotFoundIfNotFound, defaultValueIfNotFoundIfNotFoundIfNotFound, defaultValueIfNotFoundIfNotFoundIfNotFoundIfNotFound, 0.0);
  }

  public double getCount(E key, double defaultValue, double defaultValueIfNotFound, double defaultValueIfNotFoundIfNotFound, double defaultValueIfNotFoundIfNotFoundIfNotFound, double defaultValueIfNotFoundIfNotFoundIfNotFoundIfNotFound, double defaultValueIfNotFoundIfNotFoundIfNotFoundIfNotFoundIfNotFound) {
    return getCount(key, defaultValue, defaultValueIfNotFound, defaultValueIfNotFoundIfNotFound, defaultValueIf<nl>
    if (sortedIds.contains(tagId)) {
      return false;
    }
    sortedIds.add(tagId);
    return true;
  }

  public int size() {
    return sortedIds.size();
  }

  public boolean contains(int tagId) {
    return sortedIds.contains(tagId);
  <|file_separator|>class Ambiguity.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>import java.util.List;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;

class Ambiguity {

  private final List<Integer> sortedIds;
  private final String key;
  private final String word;
  private final boolean single;

  protected Ambiguity(String word, boolean single, Dictionary dict, TTags ttags) {
    this.single = single;
    if (single) {
      this.word = word;
      sortedIds = Collections.emptyList();
    } else {
      this.word = null;
      String[] tags = dict.getTags(word);
      sortedIds = new ArrayList<>(tags.length);
      for (String tag : tags) {
        add(ttags.getIndex(tag));
      }
      // s = Generics.newHashSet();
      // for (Integer sortedId : sortedIds) {
      //   s.add(ttags.getTag(sortedId));
      // }
    }
    key = this.toString();
  }

  public String getWord() {
    return word;
  }

  /*
  public boolean belongs(String word) {
    String[] tags = GlobalHolder.dict.getTags(word);
    if (tags.length != sortedIds.size()) {
<nl>
    try {
      BufferedReader br = new BufferedReader(new FileReader(filename));
      String line;
      while ((line = br.readLine()) != null) {
        String[] parts = line.split("\t");
        String tag = parts[0];
        String word = parts[1];
        if (CTBunk_dict.get(tag) == null) {
          CTBunk_dict.put(tag, new HashSet<String>());
        }
        CTBunk_dict.get(tag).add(word);
      }
      br.close();
    } catch (IOException e) {
      e.printStackTrace();
    }
  <|file_separator|><nl>
    return h;
  <|file_separator|>class DataWordTag.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>import java.util.ArrayList;
import java.util.List;

public class DataWordTag {

  private final History h;
  private final int yNum;
  private final String tag;

  DataWordTag(History h, int y, String tag) {
    this.h = h;
    this.yNum = y;
    this.tag = tag;
  }


  public History getHistory() {
    return h;
  }

  @Override
  public String getY() {
    return tag;
  }

  public int getYInd() {
    return yNum;
  }

}<|file_separator|>class DataWordTag.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>import java.util.ArrayList;
import java.util.List;

public class DataWordTag {

  private final History h;
  private final int yNum;
  private final String tag;

  DataWordTag(History h, int y, String tag) {
    this.h = h;
    this.yNum = y;
    this.tag = tag;
  }


  public History getHistory() {
    return h;
  }

  @Override
  public String getY() {
    return tag;
  }

  public int getYInd() {
    return yNum;
  }

}<|file_separator|><nl>
    if (annotation.get(TimeAnnotations.TimexAnnotations.class) != null) {
      return;
    }
    if (annotation.get(CoreAnnotations.TokensAnnotation.class) == null) {
      log.error("Annotation " + annotation + " does not have a TokensAnnotation");
      return;
    }
    if (annotation.get(CoreAnnotations.SentencesAnnotation.class) == null) {
      log.error("Annotation " + annotation + " does not have a SentencesAnnotation");
      return;
    }
    if (annotation.get(CoreAnnotations.TextAnnotation.class) == null) {
      log.error("Annotation " + annotation + " does not have a TextAnnotation");
      return;
    }
    if (annotation.get(CoreAnnotations.DocumentDateAnnotation.class) == null) {
      log.error("Annotation " + annotation + " does not have a DocumentDateAnnotation");
      return;
    }
    if (annotation.get(CoreAnnotations.DocumentDateAnnotation.class).toString().isEmpty()) {
      log.error("Annotation " + annotation + " has an empty DocumentDateAnnotation");
      return;
    }
    if (annotation.get(CoreAnnotations.DocumentDateAnnotation.class).toString().equals("0000-00-00")) {
      log.error("Annotation " + annotation + " has a DocumentDateAnnotation of 0000-00-00");
      return;
    }
    if (annotation.get(CoreAnnotations.DocumentDateAnnotation.class).toString().equals("1970-01-01")) {
      log.error("Annotation " + annotation + " has a DocumentDateAnnotation of 1970-01-01");
      return;<nl>
    return tlp.getLabel(tree.label());
  }

  @Override
  public Tree transformTree(Tree tree) {
    if (tree.label() == tlp.getLabel("S")) {
      return tree;
    }
    return tree.transform(this);
  <|file_separator|><nl>
    return String.format("%" + (defaultPadding - s.length()) + "s", s);
  <|file_separator|><nl>
      if (parserCnt != goldCnt) {
        throw new RuntimeException(
          String.format("FScore cannot be used when count(gold deps:%d) != count(system deps:%d)", parserCnt, goldCnt));
      }
      double fscore = 2*correctAttachment/(double)(2*correctAttachment + parserUnlabeledCnt + goldUnlabeledCnt);
      StringBuilder sbuild = new StringBuilder();

      if (json) {
        sbuild.append("{");
        sbuild.append(String.format("'FScore' : %.3f, ", fscore));
        sbuild.append("}");
      } else {
        sbuild.append(String.format("|| F-Score ||"));
        sbuild.append(String.format(" %.3f ||n", fscore));
      }

      return sbuild.toString();
    <|file_separator|><nl>
    return new LabeledScoredConstituent(start, end, label, score);
  <|file_separator|><nl>
    SemanticGraph graph = new SemanticGraph();
    for (IndexedWord node : tree.vertexSet()) {
      graph.addVertex(node);
    }
    for (Edge edge : tree.edgeSet()) {
      graph.addEdge(edge);
    }
    return graph;
  <|file_separator|><nl>
    if (args.length != 1) {
      System.err.println("Usage: java edu.stanford.nlp.trees.FrenchHeadFinder treebankFilePath");
      System.exit(1);
    }

    FrenchTreebankLanguagePack tlp = new FrenchTreebankLanguagePack();
    AbishekFrenchHeadFinder headFinder = new AbishekFrenchHeadFinder(tlp);

    FrenchXMLTreeReader reader = new FrenchXMLTreeReader(args[0], tlp);
    reader.setHeadFinder(headFinder);
    reader.setPrintHeads(true);
    reader.setPrintTrees(true);
    reader.setPrintTreesToConsole(true);
    reader.setPrintTreesToFile(true, "heads.txt");
    reader.setPrintTreesToFile(true, "heads.xml");
    reader.setPrintTreesToFile(true, "heads.html");
    reader.setPrintTreesToFile(true, "heads.html.gz");
    reader.setPrintTreesToFile(true, "heads.html.bz2");
    reader.setPrintTreesToFile(true, "heads.html.zip");
    reader.setPrintTreesToFile(true, "heads.html.tar");
    reader.setPrintTreesToFile(true, "heads.html.tar.gz");
    reader.setPrintTreesToFile(true, "heads.html.tar.bz2");
    reader.setPrintTreesToFile(true, "heads.html.tar.zip");
    reader.setPrintTreesToFile(true, "heads.html.tar.gz.bz2");
    reader.setPrintTreesToFile(true, "heads.html.tar.gz.zip");
    reader.setPrintTreesToFile(true, "heads.html.tar.gz.bz<nl>
    return new FrenchTreeReader(in);
  <|file_separator|>class FrenchTreeReader.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>import java.io.Reader;
import java.io.IOException;
import java.io.Serializable;

public class FrenchTreeReader implements TreeReader, Serializable {

  private static final long serialVersionUID = 8943534517L;
  
  private Reader in;
  
  public FrenchTreeReader(Reader in) {
    this.in = in;
  }
  
  public void close() throws IOException {
    in.close();
  }
  
  public String readTree() throws IOException {
    return "FrenchTreeReader";
  }
}<|file_separator|><nl>
    return new CTBTreeReader(in, tn, discardFrags);
  }

  public static class BobChrisCTBTreeReaderFactory extends CTBTreeReaderFactory {

    public BobChrisCTBTreeReaderFactory() {
      super(new BobChrisTreeNormalizer());
    }

  <|file_separator|><nl>
    return new SpanishTreeReader(in);
  <|file_separator|>class SpanishTreeReader.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>import java.io.Reader;
import java.io.IOException;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class SpanishTreeReader implements TreeReader, Serializable {

  // TODO
  private static final long serialVersionUID = 8L;

  private static final Pattern PATTERN = Pattern.compile("([\\w\\s]+)\\s*\\((.*)\\)");

  private final Reader in;

  public SpanishTreeReader(Reader in) {
    this.in = in;
  }

  public List<Tree> read() throws IOException {
    List<Tree> trees = new ArrayList<Tree>();
    String line;
    while ((line = in.readLine()) != null) {
      Matcher matcher = PATTERN.matcher(line);
      if (matcher.matches()) {
        String word = matcher.group(1);
        String[] parts = matcher.group(2).split(",");
        List<Tree> children = new ArrayList<Tree>();
        for (String part : parts) {
          children.add(new Tree(part));
        }
        trees.add(new Tree(word, children));
      }
    }
    return trees;
  }

}<|file_separator|><nl>
      if (tregex.isMatch(tree)) {
        return new RelabelNode(tree, newNodeNames, coindexer);
      }
      return tree;
    <|file_separator|><nl>
    return label;
  <|file_separator|>class TsurgeonMatcher.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class TsurgeonMatcher {

  public TsurgeonMatcher(TsurgeonPattern pattern) {
    this.pattern = pattern;
  }

  public TsurgeonMatcher(TsurgeonPattern pattern, TsurgeonMatcher[] children) {
    this.pattern = pattern;
    this.children = children;
  }

  public TsurgeonMatcher(TsurgeonPattern pattern, TsurgeonMatcher[] children, TsurgeonMatcher[] siblings) {
    this.pattern = pattern;
    this.children = children;
    this.siblings = siblings;
  }

  public TsurgeonMatcher(TsurgeonPattern pattern, TsurgeonMatcher[] children, TsurgeonMatcher[] siblings, TsurgeonMatcher[] grandchildren) {
    this.pattern = pattern;
    this.children = children;
    this.siblings = siblings;
    this.grandchildren = grandchildren;
  }

  public TsurgeonMatcher(TsurgeonPattern pattern, TsurgeonMatcher[] children, TsurgeonMatcher[] siblings, TsurgeonMatcher[] grandchildren, TsurgeonMatcher[] greatGrandchildren) {
    this.pattern = pattern;
    this.children = children;
    this.siblings = siblings;
    this.grandchildren = grandchildren;
    this.greatGrandchildren = greatGrandchildren;
  }

  public TsurgeonMatcher(TsurgeonPattern pattern, TsurgeonMatcher[] children, TsurgeonMatcher[] siblings, TsurgeonMatcher[] grandchildren, TsurgeonMatcher[] greatGrandchildren, TsurgeonMatcher[] greatGreatGrandchildren) {
    this.pattern = pattern;
    this.children = children;
    this.siblings = siblings;
    this.grandchildren = grandchildren;
<nl>
    if (useFileParams) {
      return (CacheMap<K,V>)create(numEntries, loadFactor, accessOrder);
    } else {
      return (CacheMap<K,V>)create(numEntries, loadFactor, accessOrder,
                                   file, false);
    }
  <|file_separator|><nl>
    int cType = Character.getType(c);
    return cType == Character.SYMBOL ||
        cType == Character.MODIFIER_SYMBOL ||
        cType == Character.OTHER_SYMBOL;
  }

  /**
   * Returns true if a character is a digit, and false
   * otherwise.
   * 
   * @param c
   * @return
   */
  public static boolean isDigit(char c) {
    int cType = Character.getType(c);
    return cType == Character.DECIMAL_DIGIT_NUMBER ||
        cType == Character.DIGIT ||
        cType == Character.OTHER_NUMBER;
  }

  /**
   * Returns true if a character is a letter, and false
   * otherwise.
   * 
   * @param c
   * @return
   */
  public static boolean isLetter(char c) {
    int cType = Character.getType(c);
    return cType == Character.LETTER ||
        cType == Character.TITLECASE_LETTER ||
        cType == Character.MODIFIER_LETTER ||
        cType == Character.OTHER_LETTER;
  }

  /**
   * Returns true if a character is a whitespace character, and
   * false otherwise.
   * 
   * @param c
   * @return
   */
  public static boolean isWhitespace(char c) {
    int cType = Character.getType(c);
    return cType == Character.SPACE_SEPARATOR ||
        cType == Character.LINE_SEPARATOR ||
        cType == Character.PARAGRAPH_SEPARATOR ||
        cType == Character.FORMAT_SPACE ||
        cType == Character.SURROGATE ||
        cType == Character.PRIVATE_USE_SPACE ||
        c<nl>
    Object value = deltaMap.get(key);
    if (value == null) {
      return originalMap.get(key);
    }
    return (V) value;
  }
<|file_separator|><nl>
    Element<T> e = objectToElement.get(a);
    Element<T> f = objectToElement.get(b);
    if (e == null || f == null) {
      return;
    }
    Element<T> repE = findElement(e);
    Element<T> repF = findElement(f);
    if (repE == repF) {
      return;
    }
    linkElements(repE, repF);
  }
}
<|file_separator|><nl>
    T result = currentCandidate();
    advanceCandidate();
    skipUnacceptableCandidates();
    return result;
  <|file_separator|><nl>
      return g.apply(f.apply(t1));
    <|file_separator|><nl>
    return new IntQuadruple(elements[0], elements[1], elements[2], elements[3]);
  <|file_separator|>class IntTuple.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>import java.io.Serializable;

public class IntTuple implements Serializable {

  private static final long serialVersionUID = 7154973101012473479L;

  protected int[] elements;

  public IntTuple(int size) {
    elements = new int[size];
  }

  public int get(int index) {
    return elements[index];
  }

  public void set(int index, int value) {
    elements[index] = value;
  }

  public int[] getElements() {
    return elements;
  }

  public void setElements(int[] elements) {
    this.elements = elements;
  }

  public IntTuple getCopy() {
    return new IntTuple(elements.length);
  }
}<|file_separator|>class IntPair.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>import java.io.Serializable;

public class IntPair implements Serializable {

  private static final long serialVersionUID = 7154973101012473479L;

  private int first;
  private int second;

  public IntPair() {
    this(0, 0);
  }

  public IntPair(int first, int second) {
    this.first = first;
    this.second = second;
  }

  public int getFirst() {
    return first;
  }

  public int getSecond() {
    return second;
  }

  public void setFirst(int first) {
    this.first = first;
  }

  public void setSecond<nl>
    try {
      Process process = builder.start();
      if (output != null) {
        process.getOutputStream().transferTo(output);
      }
      if (error != null) {
        process.getErrorStream().transferTo(error);
      }
    } catch (IOException e) {
      throw new ProcessException(e);
    }
  }<|file_separator|><nl> logB(charSequence.subSequence(i, i1)); return this; }
  @Override public PrintStream append(char c) { logB(c); return this; }
  @Override public PrintStream append(boolean b) { logB(b); return this; }
  @Override public PrintStream append(char c) { logB(c); return this; }
  @Override public PrintStream append(int i) { logB(i); return this; }
  @Override public PrintStream append(long l) { logB(l); return this; }
  @Override public PrintStream append(float f) { logB(f); return this; }
  @Override public PrintStream append(double d) { logB(d); return this; }
  @Override public PrintStream append(char[] chars) { logB(new String(chars)); return this; }
  @Override public PrintStream append(CharSequence charSequence) { logB(charSequence); return this; }
  @Override public PrintStream append(Object o) { logB(o); return this; <|file_separator|><nl>
    double sum = 0.0;
    for (T d : dataset) {
      sum += fn.getValue(d, weights);
    }
    return sum;
  <|file_separator|><nl>
    double[] values = new double[] { 0.1, 0.2, 0.3, 0.4, 0.5 };
    SimpleMatrix vector1 = new SimpleMatrix(values);
    SimpleMatrix vector2 = new SimpleMatrix(values);
    double cosine = NeuralUtils.cosine(vector1, vector2);
    assertEquals(1.0, cosine, 0.0000001);
  <|file_separator|><nl>
    List<String> list = new ArrayList<String>();
    list.add("foo");
    list.add("bar");
    list.add("baz");
    String result = Annotation.fromList(list);
    assertEquals("foo, bar, baz", result);
  <|file_separator|><nl><nl>
    String s = "foo(bar)";
    String result = Extractor.getParenthesizedArg(s);
    assertEquals("bar", result);
  <|file_separator|><nl>
    TreebankLanguagePack tlp = new TreebankLanguagePack();
    Category cat = tlp.getCategory("en", "NN");
    assertEquals("noun", cat.getName());
  <|file_separator|><nl>
    assertEquals("negra", this.getLanguagePack().getLanguageCategory());
  <|file_separator|><nl>
    assertEquals("a", ChineseUtils.normalize("a"));
  <|file_separator|><nl>
    MixedClass x = new MixedClass();
    assertEquals(-1, MixedClass.staticOption);
    assertEquals(-1, x.nonstaticOption);
    ArgumentParser.fillOptions(MixedClass.class, "-option.nonstatic", "42", "-option.static", "43");
    assertEquals(43, MixedClass.staticOption);
    assertEquals(42, x.nonstaticOption);
  }
<|file_separator|><nl>
    Set<Map.Entry<String, Integer>> hmapEntries = new HashSet<>();
    hmapEntries.addAll(hmap.entrySet());

    Set<Map.Entry<String, Integer>> mapEntries = new HashSet<>();
    mapEntries.addAll(map.entrySet());

    assertEquals(hmapEntries, mapEntries);
  }

  public void testKeySet() {
    Set<String> hmapKeys = new HashSet<>();
    hmapKeys.addAll(hmap.keySet());

    Set<String> mapKeys = new HashSet<>();
    mapKeys.addAll(map.keySet());

    assertEquals(hmapKeys, mapKeys);
  }

  public void testSize() {
    assertEquals(3, map.size());
  <|file_separator|><nl>
    LeastRecentlyUsedCache<String, Integer> cache = new LeastRecentlyUsedCache<>(100);
    cache.add("foo", 2);
    cache.add("bar", 3);
    cache.add("baz", 4);
    cache.get("foo");
    cache.add("qux", 5);

    assertEquals(3, cache.size());
    assertEquals(2, cache.getOrDefault("foo", 0).intValue());
    assertEquals(3, cache.getOrDefault("bar", 0).intValue());
    assertEquals(4, cache.getOrDefault("baz", 0).intValue());
    assertEquals(5, cache.getOrDefault("qux", 0).intValue());
  <|file_separator|><nl>
        StringBuilder sb = new StringBuilder();
        for (String name : jo.keys()) {
            sb.append(Cookie.escape(name));
            sb.append('=');
            sb.append(Cookie.escape(jo.getString(name)));
            sb.append(';');
        }
        return sb.toString();
    <|file_separator|><nl>
        JSONObject jo = new JSONObject();
        if (properties != null) {
        	// Don't use the new entrySet API to maintain Android support
            for (final String key : properties.stringPropertyNames()) {
                Object value = properties.get(key);
                if (!JSONObject.NULL.equals(value)) {
                    jo.put(key, value.toString());
                }
            }
        }
        return jo;
    <|file_separator|><nl>
        <|file_separator|><nl>
        // Mark the current node as visited and store it in path[]
        isVisited[u] = true;
        localPathList.add(u);

        // If current vertex is same as destination, then print
        // current path[]
        if (u == d) {
            nm.add(new ArrayList<>(localPathList));
        } else {
            // If current vertex is not destination
            // Recur for all the vertices adjacent to current vertex
            for (Integer i : adjList[u]) {
                if (!isVisited[i]) {
                    storeAllPathsUtil(i, d, isVisited, localPathList);
                }
            }
        }

        // Remove current vertex from path[] and mark it as unvisited
        localPathList.remove(localPathList.size() - 1);
        isVisited[u] = false;
    <|file_separator|><nl>
        if (image[x][y] == oldColor) {
            putPixel(image, x, y, newColor);
            floodFill(image, x - 1, y, newColor, oldColor);
            floodFill(image, x + 1, y, newColor, oldColor);
            floodFill(image, x, y - 1, newColor, oldColor);
            floodFill(image, x, y + 1, newColor, oldColor);
        }
    <|file_separator|><nl>
        if (this.map.get(key) != null) {
            Node node = map.get(key);
            node.value = value;
            removeNode(node);
            node.frequency += 1;
            addNodeWithUpdatedFrequency(node);
        } else {
            Node node = new Node(key, value, 1);
            if (this.map.size() == this.capacity) {
                Node leastFrequentNode = this.head.next;
                removeNode(leastFrequentNode);
                this.map.remove(leastFrequentNode.key);
            }
            addNodeWithUpdatedFrequency(node);
        }
    }
}<|file_separator|><nl>
        int total = 0;
        for (int i = 0; i < n; i++) {
            total += P.get(i);
        }
        return total;
    <|file_separator|><nl>
        if (this.n != other.n) {
            throw new IllegalArgumentException("Cannot merge PN-Counters with different number of nodes");
        }
        for (int i = 0; i < n; i++) {
            this.P.put(i, Math.max(this.P.get(i), other.P.get(i)));
            this.N.put(i, Math.max(this.N.get(i), other.N.get(i)));
        }
    <|file_separator|><nl>
        return this.setA.containsAll(otherSet.setA) && this.setR.containsAll(otherSet.setR);
    <|file_separator|><nl>
        this.V = graph.length;
        this.graph = graph;
        this.cycle = new int[this.V];
        this.pathCount = 0;

        /** add start vertex **/
        this.cycle[this.pathCount++] = 0;

        /** find all paths **/
        for (int i = 0; i < this.V; i++) {
            if (isPathFound(i)) {
                return this.cycle;
            }
        }
        return new int[]{-1};
    <|file_separator|><nl>
        
    <|file_separator|><nl>
        String result = "";
        Node<E> current = head.next;
        while (current != head) {
            result += current.value + " ";
            current = current.next;
        }
        return result;
    }
<|file_separator|><nl>
        if (head == null || head.getNext() == null) {
            return head;
        }
        Node pivot = head;
        Node left = null;
        Node right = null;
        Node current = head.getNext();
        while (current != null) {
            Node next = current.getNext();
            if (current.getData() < pivot.getData()) {
                if (left == null) {
                    left = current;
                } else {
                    left.setNext(current);
                    left = current;
                }
            } else {
                if (right == null) {
                    right = current;
                } else {
                    right.setNext(current);
                    right = current;
                }
            }
            current = next;
        }
        if (left != null) {
            left.setNext(null);
        }
        if (right != null) {
            right.setNext(null);
        }
        if (left != null) {
            left = sortList(left);
        }
        if (right != null) {
            right = sortList(right);
        }
        head.setNext(right);
        if (left != null) {
            left.setNext(pivot);
        } else {
            pivot.setNext(right);
        }
        return left != null ? left : pivot;
    <|file_separator|><nl>
        CircularQueue queue = new CircularQueue(5);
        queue.enQueue(1);
        queue.enQueue(2);
        queue.enQueue(3);
        queue.enQueue(4);
        queue.enQueue(5);
        queue.enQueue(6);
        System.out.println(queue.deQueue());
        System.out.println(queue.deQueue());
        System.out.println(queue.deQueue());
        System.out.println(queue.deQueue());
        System.out.println(queue.deQueue());
        System.out.println(queue.deQueue());
    <|file_separator|><nl>
        // Create a new node with the given value
        DequeNode<T> newNode = new DequeNode<T>(val);

        // Add the node
        if (tail == null) {
            // If the deque is empty, add the node as the head and tail
            head = newNode;
            tail = newNode;
        } else {
            // If the deque is not empty, insert the node as the new tail
            newNode.prev = tail;
            tail.next = newNode;
            tail = newNode;
        }

        size++;
    }<|file_separator|><nl>
        LinkedQueue<Integer> queue = new LinkedQueue<>();
        queue.enqueue(1);
        queue.enqueue(2);
        queue.enqueue(3);
        queue.enqueue(4);
        queue.enqueue(5);
        System.out.println(queue);
        System.out.println(queue.peekFront());
        System.out.println(queue.peekRear());
        System.out.println(queue.peek(2));
    }
}<|file_separator|><nl>
        return NodeStack.getSize() == 0;
    <|file_separator|><nl>
        Node b = a.right;
        b.parent = a.parent;
        a.right = b.left;
        if (a.right != null) {
            a.right.parent = a;
        }
        b.left = a;
        a.parent = b;
        if (b.parent != null) {
            if (b.parent.left == a) {
                b.parent.left = b;
            } else {
                b.parent.right = b;
            }
        }
        setBalance(a);
        setBalance(b);
        return b;
    }<|file_separator|><nl>
        Node parent = null;
        Node temp = this.root;
        /* Finds the node to be deleted
         */
        while (temp != null) {
            if (temp.data > data) {
                parent = temp;
                temp = parent.left;
            } else if (temp.data < data) {
                parent = temp;
                temp = parent.right;
            } else {
                /* If found then delete it
                 */
                if (temp.left == null && temp.right == null) {
                    if (parent.left == temp) {
                        parent.left = null;
                    } else {
                        parent.right = null;
                    }
                } else if (temp.left == null) {
                    if (parent.left == temp) {
                        parent.left = temp.right;
                    } else {
                        parent.right = temp.right;
                    }
                } else if (temp.right == null) {
                    if (parent.left == temp) {
                        parent.left = temp.left;
                    } else {
                        parent.right = temp.left;
                    }
                } else {
                    /* If node has two children
                     * then find the inorder successor
                     * and replace the node to be deleted
                     * with the successor.
                     */
                    Node successor = temp.right;
                    Node successorParent = temp;
                    while (successor.left != null) {
                        successorParent = successor;
                        successor = successor.left;
                    }
                    temp.data = successor.data;
                    if (successorParent.left == successor) {
                        successorParent.left = successor.right;
                    } else {
                        successorParent.right = successor.right;
                    }<nl>
        int n = scanner.nextInt();
        int q = scanner.nextInt();
        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            adj.add(new ArrayList<>());
        }
        for (int i = 0; i < n - 1; i++) {
            int u = scanner.nextInt() - 1;
            int v = scanner.nextInt() - 1;
            adj.get(u).add(v);
            adj.get(v).add(u);
        }
        int[] parent = new int[n];
        int[] depth = new int[n];
        dfs(adj, 0, -1, parent, depth);
        for (int i = 0; i < q; i++) {
            int v1 = scanner.nextInt() - 1;
            int v2 = scanner.nextInt() - 1;
            int lca = getLCA(v1, v2, depth, parent);
            System.out.println(lca + 1);
        }
    <|file_separator|><nl>
        if (q_start <= start && q_end >= end) {
            return this.seg_t[seg_index];
        }

        if (q_start > end || q_end < start) {
            return 0;
        }

        int mid = start + (end - start) / 2;
        return getSumTree(start, mid, q_start, q_end, seg_index * 2 + 1) + getSumTree(mid + 1, end, q_start, q_end, seg_index * 2 + 2);
    <|file_separator|><nl>
        TrieImp trie = new TrieImp();
        trie.insert("apple");
        trie.insert("app");
        trie.insert("appl");
        trie.insert("applee");
        trie.insert("appleee");
        trie.insert("appleeee");
        trie.insert("appleeeee");
        trie.insert("appleeeeee");
        trie.insert("appleeeeeee");
        trie.insert("appleeeeeeee");
        trie.insert("appleeeeeeeee");
        trie.insert("appleeeeeeeeeee");
        trie.insert("appleeeeeeeeeee");
        trie.insert("appleeeeeeeeeee");
        trie.insert("appleeeeeeeeeee");
        trie.insert("appleeeeeeeeeee");
        trie.insert("appleeeeeeeeeee");
        trie.insert("appleeeeeeeeeee");
        trie.insert("appleeeeeeeeeee");
        trie.insert("appleeeeeeeeeee");
        trie.insert("appleeeeeeeeeee");
        trie.insert("appleeeeeeeeeee");
        trie.insert("appleeeeeeeeeee");
        trie.insert("appleeeeeeeeeee");
        trie.insert("appleeeeeeeeeee");
        trie.insert("appleeeeeeeeeee");
        trie.insert("appleeeeeeeeeee");
        trie.insert("appleeeeeeeeeee");
        trie.insert("appleeeeeeeeeee");
        trie.insert("appleeeeeeeeeee");
        trie.insert("appleeeeeeeeeee");
        trie.insert("appleeeeeeeeeee");
        trie.insert("appleeeeeeeeeee");
        trie.insert("appleeeeeeeeeee");
        trie.insert("appleeeeeeeeeee");
        trie.insert("appleeeeeeeeeee");
        trie.insert("appleeeeeeeeeee<nl>
        return 0;
    <|file_separator|><nl>
        // Sort jobs in descending order of profit
        Collections.sort(jobs);

        // Initialize the job sequence
        String jobSequence = "";

        // Iterate over the jobs
        for (Job job : jobs) {
            // Check if the job can be scheduled
            if (job.deadline > 0) {
                // Add the job to the sequence
                jobSequence += job.id;

                // Decrement the deadline of the job
                job.deadline--;
            }
        }

        return jobSequence;
    }<|file_separator|><nl>
        if (from < 1 || to < 1) {
            throw new IllegalArgumentException("Input numbers must be natural!");
        }
        Set<Pair<Integer, Integer>> amicableNumbers = new HashSet<>();
        for (int i = from; i <= to; i++) {
            for (int j = i + 1; j <= to; j++) {
                if (isAmicableNumber(i, j)) {
                    amicableNumbers.add(new Pair<>(i, j));
                }
            }
        }
        return amicableNumbers;
    <|file_separator|><nl>
        if (!areAllSidesPositive(a, b, c)) {
            throw new IllegalArgumentException("All sides of the triangle must be positive");
        }
        if (!canFormTriangle(a, b, c)) {
            throw new IllegalArgumentException("The sum of any two sides must be greater than the third side");
        }
        final double s = (a + b + c) / 2;
        return Math.sqrt(s * (s - a) * (s - b) * (s - c));
    <|file_separator|><nl>
        return dividend / divisor;
    <|file_separator|><nl>
        int result = 1;
        int i = 2;
        while (i * i <= number) {
            if (number % i == 0) {
                int count = 0;
                while (number % i == 0) {
                    number /= i;
                    count++;
                }
                if (count % 2 == 0) {
                    result *= -1;
                } else {
                    result *= 1;
                }
            }
            i++;
        }
        if (number > 1) {
            result *= -1;
        }
        return result;
    <|file_separator|><nl>
        int[] arr = { 1, 2, 1, 2, 3, 4 };
        int res = 0;
        for (int i = 0; i < arr.length; i++) {
            res = res ^ arr[i];
        }
        System.out.println(res);
    <|file_separator|><nl>
        System.out.println(calculatePi(100));
    <|file_separator|><nl>
        TreeMap<Double, Double> data = new TreeMap<>();
        double x0 = a;
        for (int i = 0; i < N; i++) {
            data.put(x0, f(x0));
            x0 += h;
        }

        double result = 0;
        for (int i = 0; i < N; i++) {
            if (i == 0 || i == N - 1) {
                result += data.get(a + i * h);
            } else if (i % 2 == 0) {
                result += 2 * data.get(a + i * h);
            } else {
                result += 4 * data.get(a + i * h);
            }
        }
        result *= h / 3;
        return result;
    <|file_separator|><nl>
        return (num - mean) / stdDev;
    <|file_separator|><nl>
        int left = 0;
        int right = number.length() - 1;
        while (left <= right) {
            char leftChar = number.charAt(left);
            char rightChar = number.charAt(right);
            if (leftChar == '0' && rightChar == '0') {
                left++;
                right--;
            } else if (leftChar == '1' && rightChar == '1') {
                left++;
                right--;
            } else if (leftChar == '6' && rightChar == '9') {
                left++;
                right--;
            } else if (leftChar == '9' && rightChar == '6') {
                left++;
                right--;
            } else {
                return false;
            }
        }
        return true;
    <|file_separator|><nl>
        if (maxHeap.size() == minHeap.size()) {
            return calculateAverage(maxHeap.peek(), minHeap.peek());
        } else {
            return maxHeap.peek();
        }
    <|file_separator|><nl>
        for (int i = 0; i < values.length; i++) {
            for (int j = i + 1; j < values.length; j++) {
                if (values[i] + values[j] == target) {
                    return Optional.of(new Pair<>(i, j));
                }
            }
        }
        return Optional.empty();
    <|file_separator|><nl>
        int n1 = 0, n2 = 1, n3, i, count = 10;
        System.out.print(n1 + " " + n2);
        for (i = 2; i < count; ++i) {
            n3 = n1 + n2;
            System.out.print(" " + n3);
            n1 = n2;
            n2 = n3;
        }
    <|file_separator|><nl>
        String keys[] = { "the", "a", "there", "answer", "any",
                "by", "bye", "their" };
        String output[] = { "Not present in trie", "Present in trie" };

        TrieNode root = getNode();

        // Construct trie
        for (int i = 0; i < keys.length; i++) {
            insert(root, keys[i]);
        }

        // Search for different keys
        System.out.println(printAutoSuggestions(root, "the") == 1 ? output[1] : output[0]);
        System.out.println(printAutoSuggestions(root, "the") == 1 ? output[1] : output[0]);
        System.out.println(printAutoSuggestions(root, "the") == 1 ? output[1] : output[0]);
        System.out.println(printAutoSuggestions(root, "the") == 1 ? output[1] : output[0]);
    }
}<|file_separator|><nl>
        int[] arr = {1, 2, 3, 4, 5};
        int index = 2;
        int element = 10;
        int[] newArr = new int[arr.length + 1];
        for (int i = 0; i < arr.length; i++) {
            if (i < index) {
                newArr[i] = arr[i];
            } else if (i == index) {
                newArr[i] = element;
            } else {
                newArr[i] = arr[i - 1];
            }
        }
        for (int i = 0; i < newArr.length; i++) {
            System.out.print(newArr[i] + " ");
        }
    <|file_separator|><nl>
        // TODO Auto-generated method stub
        String text = "ABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABAB<nl>
        // TODO: Implement the preemptive priority scheduling algorithm
        return null;
    <|file_separator|>class RoundRobinScheduling.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>class RoundRobinScheduling {
    public static List<String> roundRobinScheduling(List<Process> processes, int timeQuantum) {
        // TODO: Implement the round John scheduling algorithm
        return null;
    }
}<|file_separator|>class NonPreemptivePriorityScheduling.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>class NonPreemptivePriorityScheduling {
    public static List<String> nonPreemptivePriorityScheduling(List<Process> processes) {
        // TODO: Implement the non-preemptive priority scheduling algorithm
        return null;
    }
}<|file_separator|>class Process.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>class Process {
    private int id;
    private int arrivalTime;
    private int burstTime;
    private int priority;

    public Process(int id, int arrivalTime, int burstTime, int priority) {
        this.id = id;
        this.arrivalTime = arrivalTime;
        this.burstTime = burstTime;
        this.priority = priority;
    }

    public int getId() {
        return id;
    }

    public int getArrivalTime() {
        return arrivalTime;
    }

    public int getBurstTime() {
        return burstTime;
    }

    public int getPriority() {
        return priority;
    }
}<|file_separator|>class FirstComeFirstServe.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>class FirstComeFirstServe {
    public static List<String> firstComeFirstServe(List<Process> processes) {
        // TODO: Implement the first-come first-serve algorithm
        return null;
    }
}<|file_separator|><nl>
        int row = 0;
        int col = matrix[0].length - 1;
        while (row < matrix.length && col >= 0) {
            if (matrix[row][col] == value) {
                return new int[]{row, col};
            } else if (matrix[row][col] > value) {
                col--;
            } else {
                row++;
            }
        }
        return new int[]{-1, -1};
    <|file_separator|><nl>
        if (start > end) {
            return -1;
        }

        int mid1 = start + (end - start) / 3;
        int mid2 = end - (end - start) / 3;

        if (key.compareTo(arr[mid1]) < 0) {
            return ternarySearch(arr, key, start, mid1 - 1);
        } else if (key.compareTo(arr[mid2]) > 0) {
            return ternarySearch(arr, key, mid2 + 1, end);
        } else {
            return ternarySearch(arr, key, mid1 + 1, mid2 - 1);
        }
    <|file_separator|>class LinearSearch implements SearchAlgorithm.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class LinearSearch implements SearchAlgorithm {

    /**
     * @param arr The **Sorted** array in which we will search the element.
     * @param value The value that we want to search for.
     * @return The index of the element if found. Else returns -1.
     */
    @Override
    public <T extends Comparable<T>> int find(T[] arr, T value) {
        for (int i = 0; i < arr.length; i++) {
            if (arr[i].compareTo(value) == 0) {
                return i;
            }
        }
        return -1;
    }

    public static void main(String[] args) {
        // just generate data
        Random r = new Random();
        int size = 100;
        int maxElement = 100000;
        Integer[] integers = Stream.generate(() -> r.nextInt(maxElement)).limit(size).sorted().toArray(Integer[] ::new);

<nl>
        return unsorted;
    <|file_separator|><nl>
        int min = arr[0];
        for (int value : arr) {
            if (value < min) {
                min = value;
            }
        }
        return min;
    <|file_separator|><nl>
        int left = 0;
        int right = arr.length - 1;
        int middle = (int) Math.ceil((arr.length) / 2.0) - 1;
        while (left <= right) {
            if (arr[left].compareTo(intendedMiddle) < 0) {
                left++;
            } else if (arr[right].compareTo(intendedMiddle) > 0) {
                right--;
            } else {
                T temp = arr[left];
                arr[left] = arr[right];
                arr[right] = temp;
                left++;
                right--;
            }
        }
        return arr;
    <|file_separator|><nl>
        aux = new Comparable[unsorted.length];
        doSort(unsorted, 0, unsorted.length - 1);
        return unsorted;
    <|file_separator|><nl>
        SimpleSort simpleSort = new SimpleSort();
        Integer[] array = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        simpleSort.sort(array);
        System.out.println(Arrays.toString(array));
    <|file_separator|><nl>
        Stack<Character> stack = new Stack<>();
        for (int i = 0; i < str.length(); i++) {
            char ch = str.charAt(i);
            if (ch == '(') {
                stack.push(ch);
            } else if (ch == ')') {
                if (stack.isEmpty()) {
                    return false;
                }
                stack.pop();
            }
        }
        return stack.isEmpty();
    <|file_separator|><nl>
            Queue<Node> q = new LinkedList<>(); // Initialize a queue for BFS traversal

            initializeSuffixLinksForChildNodesOfTheRoot(q);
        <|file_separator|><nl>
        return s.toLowerCase();
    <|file_separator|><nl>
        int result = 0;
        int sign = 1;
        int i = 0;
        while (i < s.length() && s.charAt(i) == ' ') {
            i++;
        }
        if (i < s.length() && s.charAt(i) == '-') {
            sign = -1;
            i++;
        } else if (i < s.length() && s.charAt(i) == '+') {
            i++;
        }
        while (i < s.length() && Character.isDigit(s.charAt(i))) {
            int digit = s.charAt(i) - '0';
            if (result > Integer.MAX_VALUE / 10 || (result == Integer.MAX_VALUE / 10 && digit > Integer.MAX_VALUE % 10)) {
                return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE;
            }
            result = result * 10 + digit;
            i++;
        }
        return result * sign;
    <|file_separator|><nl>
        List<Integer[]> result = Permutation.permutation(new Integer[] {});
        assertTrue(result.isEmpty());
    <|file_separator|><nl>
        assertEquals(31, HighestSetBit.highestSetBit(1024));
    <|file_separator|><nl>
        // given
        String text = "Hello World!";
        String key = "suchsecret";

        // when
        String encryptedText = vigenere.encrypt(text, key);

        // then
        assertEquals("Zynsg Yfvev!", encryptedText);
    <|file_separator|><nl>
        LFUCache<String, String> lfuCache = new LFUCache<>(5);
        lfuCache.put("a", "beijing");
        lfuCache.put("b", "shanghai");
        lfuCache.put("c", "gansu");
        lfuCache.put("d", "tianjin");
        lfuCache.put("e", "chongqing");

        // get method call will increase frequency of key a by 1
        assertEquals("beijing", lfuCache.get("a"));

        // this operation will remove value with key as b
        lfuCache.put("f", "guangzhou");

        // will return null as value with key b is now evicted
        assertEquals(null, lfuCache.get("b"));

        // should return 60
        assertEquals("guangzhou", lfuCache.get("f"));

        // this operation will remove value with key as c
        lfuCache.put("g", "xian");

        assertEquals(null, lfuCache.get("c"));
        assertEquals("xian", lfuCache.get("g"));
    <|file_separator|><nl>
        LRUCache<String, String> mruCache = new LRUCache<>(SIZE);

        for (int i = 0; i < SIZE; i++) {
            mruCache.put(String.valueOf(i), String.valueOf(i));
        }

        for (int i = 0; i < SIZE; i++) {
            assertEquals(String.valueOf(i), mruCache.get(String.valueOf(i)));
        }
    <|file_separator|><nl>
        MRUCache<Integer, Integer> lruCache = new MRUCache<>(SIZE);

        for (int i = 0; i < SIZE; i++) {
            lruCache.put(i, i);
        }

        for (int i = 0; i < SIZE; i++) {
            assertEquals(i, lruCache.get(i));
        }
    <|file_separator|><nl>
        GSet<String> gSet1 = new GSet<>();
        GSet<String> gSet2 = new GSet<>();
        gSet1.addElement("apple");
        gSet1.addElement("orange");
        gSet2.addElement("banana");
        gSet1.merge(gSet2);
        assertTrue(gSet1.lookup("apple"));
        assertTrue(gSet1.lookup("orange"));
        assertTrue(gSet1.lookup("banana"));
    <|file_separator|><nl>
        ORSet<String> orSet1 = new ORSet<>();
        ORSet<String> orSet2 = new ORSet<>();

        orSet1.add("A");
        orSet2.add("B");
        orSet1.merge(orSet2);
        orSet2.merge(orSet1);
        orSet2.remove("B");

        assertTrue(orSet1.compare(orSet2));
    <|file_separator|><nl>
        SinglyLinkedList multipleElementsList = new SinglyLinkedList();
        multipleElementsList.insert(10);
        multipleElementsList.insert(5);
        multipleElementsList.insert(20);
        multipleElementsList.insert(15);
        QuickSortLinkedList sorter = new QuickSortLinkedList(multipleElementsList);

        // Test case: Sorting a list with multiple elements should result in the correct order
        sorter.sortList();
        assertEquals(5, multipleElementsList.getHead().value);
        assertEquals(10, multipleElementsList.getHead().next.value);
        assertEquals(15, multipleElementsList.getHead().next.next.value);
        assertEquals(20, multipleElementsList.getHead().next.next.next.value);
    <|file_separator|><nl>
        int[][] coordinates = {
            {30, 40},
            {5, 25},
            {70, 70},
            {10, 12},
            {50, 30},
            {35, 45},
        };
        KDTree kdTree = new KDTree(coordinates);

        assertEquals(pointOf(5, 25), kdTree.findMin());
    }

    @Test
    void findMax() {
        int[][] coordinates = {
            {30, 40},
            {5, 25},
            {70, 70},
            {10, 12},
            {50, 30},
            {35, 45},
        };
        KDTree kdTree = new KDTree(coordinates);

        assertEquals(pointOf(70, 70), kdTree.findMax());
    }

    @Test
    void insert() {
        int[][] coordinates = {
            {30, 40},
            {5, 25},
            {70, 70},
            {10, 12},
            {50, 30},
            {35, 45},
        };
        KDTree kdTree = new KDTree(coordinates);

        kdTree.insert(pointOf(30, 40));
        assertEquals(30, kdTree.getRoot().getPoint().getCoordinate(0));
        assertEquals(40, kdTree.getRoot().getPoint().getCoordinate(1));
    <|file_separator|><nl>
        assertFalse(PartitionProblem.partition(new int[] {1, 2, 3}));
    <|file_separator|><nl>
        assertEquals(28, UniquePaths.uniquePaths2(3, 7));
    <|file_separator|><nl>
        assertTrue(WildcardMatching.isMatch("aa", "a"));
        assertTrue(WildcardMatching.isMatch("aa", "*"));
        assertTrue(WildcardMatching.isMatch("cb", "?a"));
        assertTrue(WildcardMatching.isMatch("adceb", "*a*b"));
        assertTrue(WildcardMatching.isMatch("acdcb", "a*c?b"));
        assertTrue(WildcardMatching.isMatch("mississippi", "m??*ss*?i*pi*"));
    <|file_separator|><nl>
        assertEquals("3/5", fraction1.toString());
    <|file_separator|><nl>
        FFT.Complex complex1 = new FFT.Complex(2.0, 2.0);
        double divReal = complex1.divide(2).getReal();
        double divImg = complex1.divide(2).getImaginary();
        assertEquals(1.0, divReal);
        assertEquals(1.0, divImg);
    <|file_separator|><nl>
        return Stream.of(
                Arguments.of(1, new int[] {1, 2, 3, 4, 5}),
                Arguments.of(1, new int[] {1, 1, 1, 1, 1}),
                Arguments.of(1, new int[] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}),
                Arguments.of(1, new int[] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}),
                Arguments.of(1, new int[] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}),
                Arguments.of(1, new int[] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13}),
                Arguments.of(1, new int[] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14}),
                Arguments.of(1, new int[] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15}),
                Arguments.of(1, new int[] {1, 2, 3, 4, 5, 6,<nl>
        return Stream.of(
                Arguments.of(new TestCase(new int[] {1, 2, 3, 4, 5}, 2, 3)),
                Arguments.of(new TestCase(new int[] {1, 2, 3, 4, 5, 6}, 2, 3)),
                Arguments.of(new TestCase(new int[] {1, 2, 3, 4, 5, 6, 7}, 2, 3)),
                Arguments.of(new TestCase(new int[] {1, 2, 3, 4, 5, 6, 7, 8}, 2, 3))
        );
    }<|file_separator|><nl>
        Assertions.assertEquals(25, SquareRootWithNewtonRaphsonMethod.squareRoot(625));
    <|file_separator|><nl>
        Assertions.assertEquals(1, SquareRootWithBabylonianMethod.square_Root(2));
    }

    @Test
    void testfor10() {
        Assertions.assertEquals(3, SquareRootWithBabylonianMethod.square_Root(10));
    }

    @Test
    void testfor16() {
        Assertions.assertEquals(4, SquareRootWithBabylonianMethod.square_Root(16));
    }

    @Test
    void testfor25() {
        Assertions.assertEquals(5, SquareRootWithBabylonianMethod.square_Root(25));
    <|file_separator|><nl>
        Assertions.assertEquals(StandardScore.zScore(1.5, 1.8, 0.7), 0.0);
    }

    @Test
    void test5() {
        Assertions.assertEquals(StandardScore.zScore(1.5, 1.8, 1.0), 1.0);
    <|file_separator|><nl>
        List<List<Integer>> matrix = new ArrayList<>();
        matrix.add(Arrays.asList(1, 3));
        matrix.add(Arrays.asList(2, 4));
        matrix.add(Arrays.asList(7, 8));

        int result = MedianOfMatrix.median(matrix);

        assertEquals(4, result);
    <|file_separator|><nl>
        int[] a = {1, 2, 2, 3, 3, 4, 4, 4, 5, 5};
        assertTrue(CountFriendsPairing.countFriendsPairing(10, a));
    <|file_separator|><nl>
        assertThrows(IllegalArgumentException.class, () -> { PasswordGen.generatePassword(1, 0); });
    <|file_separator|><nl>
        int[][] arr = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};
        int target = 6;

        // Assert that the requirement, that the target is in the middle of the array.
        assertEquals(arr.length % 2, 0);
        assertEquals(arr[arr.length / 2][arr[0].length / 2], target);
        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);
        System.out.println(Arrays.toString(ans));
        assertEquals(1, ans[0]);
        assertEquals(1, ans[1]);
    <|file_separator|><nl>
        int result = RabinKarpAlgorithm.rabinKarp(txt, pat, q);
        assertEquals(result, 101);
    <|file_separator|><nl>
        int[] arr = {5, 4, 3, 2, 1}; // for descending order.
        int target = 2;
        int ans = sortOrderAgnosticBinarySearch.find(arr, target);
        int excepted = 4;
        assertEquals(excepted, ans);
    <|file_separator|><nl>
        String[] inputArray = {"s", "b", "d", "a", "c", "h"};
        String[] outputArray = bogoSort.sort(inputArray);
        String[] expectedOutput = {"a", "b", "c", "d", "h", "s"};
        assertArrayEquals(outputArray, expectedOutput);
    <|file_separator|><nl>
        String[] inputArray = {"W", "A", "d", "be", "jk", "hb", "bgh", "bgh", "jk"};
        String[] expectedOutput = {"A", "W", "be", "bgh", "bgh", "d", "hb", "jk"};
        String[] outputArray = pancakeSort.sort(inputArray);
        assertThat(outputArray).isEqualTo(expectedOutput);
    }

    @Test
    @DisplayName("PancakeSort negative String Array with duplicates")
    public void pancakeSortNegativeDuplicateStringArray() {
        String[] inputArray = {"W", "A", "d", "be", "jk", "hb", "bgh", "bgh", "jk", "W", "A", "d", "be", "jk", "hb", "bgh", "bgh", "jk"};
        String[] expectedOutput = {"A", "W", "be", "bgh", "bgh", "d", "hb", "jk", "W", "A", "be", "bgh", "bgh", "d", "hb", "jk", "jk"};
        String[] outputArray = pancakeSort.sort(inputArray);
        assertThat(outputArray).isEqualTo(expectedOutput);
    <|file_separator|><nl>
        List<Integer> list = List.of(60, -7, 55, 9, -999, -3);
        List<Integer> expected = List.of(-999, -7, -3, 9, 55, 60);

        List<Integer> sorted = getSortAlgorithm().sort(list);

        assertIterableEquals(expected, sorted);
    <|file_separator|><nl>
        return new TimSort();
    <|file_separator|><nl>
        String[] inputArray = {};
        String[] outputArray = treeSort.sort(inputArray);
        String[] expectedArray = {};
        assertArrayEquals(outputArray, expectedArray);
    <|file_separator|><nl>
        String s = "abcabcbb";
        int result = longestNonRepeativeSubstring.longestNonRepeativeSubstring(s);
        assertEquals(3, result);
    <|file_separator|><nl>
    ReconnectClient client = new ReconnectClient();
    client.connect();
    client.send("Hello World");
    client.close();
  <|file_separator|><nl>
    SSLContext sslContext = SSLContext.getInstance("TLS");
    sslContext.init(null, new TrustManager[] { new X509TrustManager() {
      public X509Certificate[] getAcceptedIssuers() {
        return null;
      }

      public void checkClientTrusted(X509Certificate[] certs, String authType) {
      }

      public void checkServerTrusted(X509Certificate[] certs, String authType) {
      }
    } }, new SecureRandom());
    SSLServerSocketFactory factory = sslContext.getServerSocketFactory();
    SSLServerSocket serverSocket = (SSLServerSocket) factory.createServerSocket(8080);
    serverSocket.setNeedClientAuth(true);
    serverSocket.setNeedClientAuth(true);
    serverSocket.setNeedClientAuth(true);
    serverSocket.setNeedClientAuth(true);
    serverSocket.setNeedClientAuth(true);
    serverSocket.setNeedClientAuth(true);
    serverSocket.setNeedClientAuth(true);
    serverSocket.setNeedClientAuth(true);
    serverSocket.setNeedClientAuth(true);
    serverSocket.setNeedClientAuth(true);
    serverSocket.setNeedClientAuth(true);
    serverSocket.setNeedClientAuth(true);
    serverSocket.setNeedClientAuth(true);
    serverSocket.setNeedClientAuth(true);
    serverSocket.setNeedClientAuth(true);
    serverSocket.setNeedClientAuth(true);
    serverSocket.setNeedClientAuth(true);
    serverSocket.setNeedClientAuth(true);
    serverSocket.setNeedClientAuth(true);
    serverSocket.setNeedClientAuth(true);
    serverSocket.setNeed<nl>
    SecWebSocketProtocolClient client = new SecWebSocketProtocolClient();
    client.connect("wss://echo.websocket.org");
    client.send("Hello, world!");
    String response = client.receive();
    System.out.println("Received: " + response);
    client.close();
  <|file_separator|><nl>
    this.resourceDescriptor = resourceDescriptor;
  <|file_separator|><nl>
    return new CustomSSLWebSocketChannel(channel, key, enabledProtocols, enabledCiphersuites);
  <|file_separator|><nl>
    try {
      new IncompleteException();
    } catch (IncompleteException e) {
      fail("Expected no exception");
    }
  <|file_separator|><nl>
    PongFrame frame = new PongFrame();
    frame.setFin(true);
    try {
      frame.isValid();
      fail("InvalidDataException should be thrown");
    } catch (InvalidDataException e) {
      assertEquals("Opcode must be equal", Opcode.PONG, e.getOpcode());
    }
  <|file_separator|><nl>
    final CountDownLatch latch = new CountDownLatch(1);
    final TestClient client = new TestClient(new URI("ws://localhost:8080/"), latch);
    client.connect();
    latch.await();
  }<|file_separator|><nl>
    final CountDownLatch countDownLatch = new CountDownLatch(1);
    final CountDownLatch countDownLatch2 = new CountDownLatch(1);
    final CountDownLatch countDownLatch3 = new CountDownLatch(1);
    final CountDownLatch countDownLatch4 = new CountDownLatch(1);
    final CountDownLatch countDownLatch5 = new CountDownLatch(1);
    final CountDownLatch countDownLatch6 = new CountDownLatch(1);
    final CountDownLatch countDownLatch7 = new CountDownLatch(1);
    final CountDownLatch countDownLatch8 = new CountDownLatch(1);
    final CountDownLatch countDownLatch9 = new CountDownLatch(1);
    final CountDownLatch countDownLatch10 = new CountDownLatch(1);
    final CountDownLatch countDownLatch11 = new CountDownLatch(1);
    final CountDownLatch countDownLatch12 = new CountDownLatch(1);
    final CountDownLatch countDownLatch13 = new CountDownLatch(1);
    final CountDownLatch countDownLatch14 = new CountDownLatch(1);
    final CountDownLatch countDownLatch15 = new CountDownLatch(1);
    final CountDownLatch countDownLatch16 = new CountDownLatch(1);
    final CountDownLatch countDownLatch17 = new CountDownLatch(1);
    final CountDownLatch countDownLatch18 = new CountDownLatch(1);
    final CountDownLatch countDownLatch19 = new CountDownLatch(1);
    final CountDownLatch countDownLatch20 = new CountDownLatch(1);
    final CountDownLatch countDownLatch21 = new CountDownLatch(1);
    final CountDownLatch countDownLatch22 = new CountDownLatch(1);
    final CountDownLatch countDownLatch23 = new CountDownLatch(1);
    final CountDownLatch countDownLatch24 = new CountDownLatch(1);
    <nl>
    return Arrays.asList(new Integer[][]{{NUMBER_OF_TESTS}});
  <|file_separator|><nl>
    int port = SocketUtil.getAvailablePort();
    final CountDownLatch countServerDownLatch = new CountDownLatch(1);
    final WebSocketClient webSocket = new WebSocketClient(new URI("wss://localhost:" + port)) {
      @Override
      public void onOpen(ServerHandshake handshakedata) {
        countServerDownLatch.countDown();
      }

      @Override
      public void onMessage(String message) {
      }

      @Override
      public void onClose(int code, String reason, boolean remote) {
      }

      @Override
      public void onError(Exception ex) {
      }
    };
    TestResult testResult = new TestResult();
    WebSocketServer server = new MyWebSocketServer(port, testResult, countServerDownLatch);
    server.start();
    countServerDownLatch.await();
    webSocket.connectBlocking();
    assertTrue(testResult.hasSSLSupport);
    assertNotNull(testResult.sslSession);
  <|file_separator|><nl>
    Assert.assertEquals("foo", Charsetfunctions.stringAscii(new byte[]{102, 111, 111}));
  <|file_separator|><nl>
    return KeyUtils.generateKey(in);
  }

  /**
   * Generate a key from a input string
   *
   * @param in the input string
   * @return a key
   */
  public static String generateKey(String in) {
    return Base64.encodeBase64String(
      MessageDigest.getInstance("SHA-1").digest(
        (in + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11").getBytes()
      )
    );
  <|file_separator|><nl>
    return reservedReadPoolSize;
  <|file_separator|><nl>
    this.log4j2File = log4j2File;
  <|file_separator|><nl>
    this.mongopassFile = mongopassFile;
  }

  @Override
  public void setRole(EnumWithDefault<Role> role) {
    super.setRole(role);
  <|file_separator|><nl>
    vertx.createHttpServer().requestHandler(req -> {
      req.response().end("Hello World!");
    }).listen(8080);
  <|file_separator|><nl>
    super.start();
  <|file_separator|><nl>
    vertx.createHttpServer().requestHandler(req -> {
      req.response().end("Hello World!");
    }).listen(8080);
  <|file_separator|><nl>
    Vertx.vertx().deployVerticle(new Server());
  <|file_separator|><nl>

    // If you have slow startup tasks to perform, you can similarly override the async start method

    vertx.setTimer(2000, tid -> {

      System.out.println("Startup tasks are now complete, OtherVerticle is now started!");

      startPromise.complete();

    });

  <|file_separator|><nl>
    vertx.createHttpClient().getNow(8080, "localhost", "/", response -> {
      response.bodyHandler(body -> {
        System.out.println(body);
      });
    });
  <|file_separator|><nl>
    vertx.createHttpClient().getNow(8080, "localhost", "/", response -> {
      response.bodyHandler(body -> {
        System.out.println(body);
      });
    });
  <|file_separator|><nl>
    vertx.createHttpServer()
      .requestHandler(req -> {
        req.response()
          .putHeader("content-type", "text/plain")
          .end("Hello World");
      })
      .listen(8080);
  <|file_separator|><nl>
    vertx.createHttpClient()
      .getNow(8080, "localhost", "/", response -> {
        response.bodyHandler(buffer -> {
          System.out.println(buffer.toString());
        });
      });
  <|file_separator|><nl>
    // do something with the data
  <|file_separator|><nl>
    Vertx vertx = Vertx.vertx();
    vertx.deployVerticle(new Client());
  <|file_separator|><nl>
    return io.reactivex.Single.create(single -> {
      getDataById(id, ar -> {
        if (ar.succeeded()) {
          single.onSuccess(ar.result());
        } else {
          single.onError(ar.cause());
        }
      });
    });
  <|file_separator|><nl>
    // TODO: Implement your application
  <|file_separator|><nl>
    Vertx vertx = Vertx.vertx();
    vertx.deployVerticle(new Server());
  <|file_separator|><nl>
    vertx.createHttpServer().requestHandler(req -> {
      req.response().end("Hello World!");
    }).listen(8080);
  <|file_separator|><nl>
    Vertx vertx = Vertx.vertx();
    vertx.deployVerticle(new Client());
  <|file_separator|><nl>
    vertx.createHttpServer().requestHandler(req -> {
      req.response().end("Hello World!");
    }).listen(8080);
  <|file_separator|><nl>
    // TODO Auto-generated method stub
    
  }

  @Override
  public void stop() throws Exception {
    // TODO Auto-generated method stub
    
  }

  @Override
  public void run() {
    // TODO Auto-generated method stub
    
  }<|file_separator|><nl>
    if (System.nanoTime() - lastAccessed > timeoutSeconds * 1000 * 1000 * 1000) {
      close();
    }
  <|file_separator|><nl>
    vertx.deployVerticle(new DeployShell());
  <|file_separator|><nl>
    vertx.createHttpServer().requestHandler(req -> {
      req.response().putHeader("content-type", "text/plain").end("Hello World!");
    }).listen(8080);
  <|file_separator|><nl>
    this.lastName = lastName;
    return this;
  <|file_separator|><nl>
    vertx = Vertx.vertx();
    vertx.deployVerticle(new MyVerticle());
  <|file_separator|><nl>
    new SqlClientExample(new Pool(new PoolOptions().setMaxSize(5))).start();
  <|file_separator|><nl>
    Vertx vertx = Vertx.vertx();
    vertx.deployVerticle(new Client());
  <|file_separator|><nl>
    Vertx vertx = Vertx.vertx();
    vertx.deployVerticle(new Client());
  <|file_separator|><nl>
    super.start();
  <|file_separator|><nl>
    super.start();
  <|file_separator|><nl>
    super.start();
    mongo = MongoClient.createShared(vertx, new JsonObject()
      .put("host", "localhost")
      .put("port", 27017));

    // create a new router to serve the web application
    Router router = Router.router(vertx);

    // create a new web server and pass in the router to handle every request
    HttpServer server = vertx.createHttpServer().requestHandler(router::accept).listen(8080);

    // create a new web client to make requests to the server
    WebClient client = WebClient.create(vertx);

    // create a new router to serve the web application
    Router router = Router.router(vertx);

    // create a new web server and pass in the router to handle every request
    HttpServer server = vertx.createHttpServer().requestHandler(router::accept).listen(8080);

    // create a new web client to make requests to the server
    WebClient client = WebClient.create(vertx);

    // create a new router to serve the web application
    Router router = Router.router(vertx);

    // create a new web server and pass in the router to handle every request
    HttpServer server = vertx.createHttpServer().requestHandler(router::accept).listen(8080);

    // create a new web client to make requests to the server
    WebClient client = WebClient.create(vertx);

    // create a new router to serve the web application
    Router router = Router.router(vertx);

    // create a new web server and pass in the router to handle every request
    HttpServer server = vertx.createHttpServer().requestHandler(router::accept).listen(8080);

    // create a new web<nl>
        return new main(title);
    }

    public main() {
        super();
    }

    public main(String title) {
        super();
        this.title = title;
    }

    public main(String title, RockerContent content) {
        super();
        this.title = title;
        this.content = content;
    }

    @Override
    public RockerContent __body() {
        return this.content;
    <|file_separator|><nl>
		Throwable cause = throwable;
		while (cause != null) {
			if (cause.getClass().equals(cause)) {
				return (T) cause;
			}
			cause = cause.getCause();
		}
		return null;
	<|file_separator|><nl>
		return "Triple{" +
				"left=" + left +
				", middle=" + middle +
				", right=" + right +
				'}';
	<|file_separator|><nl>
		try {
			Thread.sleep(unit.toMillis(duration));
		} catch (InterruptedException e) {
			Thread.currentThread().interrupt();
		}
	<|file_separator|><nl>
		logger.info("Thread {} rejected execution of task {}", threadName, r);
		dumpper.dumpThread(r);
		super.rejectedExecution(r, e);
	<|file_separator|><nl>
		builder.append(value, offset, length);
	<|file_separator|><nl>
		return isMatch(PATTERN_REGEX_EMAIL, input);
	<|file_separator|><nl>
		Pair<String, Integer> pair = Pair.of("haha", 1);
		Pair<String, Integer> pair2 = Pair.of("haha", 1);
		Pair<String, Integer> pair3 = Pair.of("haha", 2);
		Pair<String, Integer> pair4 = Pair.of("kaka", 2);

		assertThat(pair.equals(pair2)).isTrue();
		assertThat(pair.equals(pair3)).isFalse();
		assertThat(pair.equals(pair4)).isFalse();
		assertThat(pair.equals(null)).isFalse();
		assertThat(pair.hashCode() != pair2.hashCode()).isTrue();
		assertThat(pair.toString()).isEqualTo("Pair [left=haha, right=1]");

		assertThat(pair.getLeft()).isEqualTo("haha");
		assertThat(pair.getRight()).isEqualTo(1);
	<|file_separator|><nl>
		for (int i = 0; i < 10; i++) {
			new Thread(new LongRunTask()).start();
		}
	}<|file_separator|><nl>
		IOUtil.write("test.txt", "ABCDEFG");
		assertThat(IOUtil.toString(ResourceUtil.asStream("test.txt"))).isEqualTo("ABCDEFG");
	<|file_separator|><nl>
		String input = "1>2";
		String result = EscapeUtil.escapeUrl(input);
		assertThat(result).isEqualTo("1%3E2");
		assertThat(EscapeUtil.unescapeUrl(result)).isEqualTo(input);
	<|file_separator|><nl>
					return x.getName().asString().compareTo(y.getName().asString());
				<|file_separator|><nl>
		printSingleThread(view.vmInfo.getTopThreadInfo());
	<|file_separator|><nl>
		return fgcStrategy;
	<|file_separator|><nl>
        this.triggerDay = triggerDay;
    <|file_separator|><nl>
    mockMvc.perform(
        post("/jobInfo/add")
            .contentType(MediaType.APPLICATION_FORM_URLENCODED)
            .param("jobName", "test")
            .param("jobGroup", "test")
            .param("jobCron", "test")
            .param("jobClass", "test")
            .param("jobStatus", "1")
            .param("jobDesc", "test")
            .cookie(cookie)
    ).andExpect(status().isOk());
  }

  @Test
  public void testUpdate() throws Exception {
    mockMvc.perform(
        post("/jobInfo/update")
            .contentType(MediaType.APPLICATION_FORM_URLENCODED)
            .param("jobId", "1")
            .param("jobName", "test")
            .param("jobGroup", "test")
            .param("jobCron", "test")
            .param("jobClass", "test")
            .param("jobStatus", "1")
            .param("jobDesc", "test")
            .cookie(cookie)
    ).andExpect(status().isOk());
  }

  @Test
  public void testDelete() throws Exception {
    mockMvc.perform(
        post("/jobInfo/delete")
            .contentType(MediaType.APPLICATION_FORM_URLENCODED)
            .param("jobId", "1")
            .cookie(cookie)
    ).andExpect(status().isOk());
  <|file_separator|><nl>
        // run handlerThread
        JobThread jobThread = XxlJobExecutor.loadJobThread(triggerParam.getJobId());
        if (jobThread != null) {
            XxlJobExecutor.removeJobThread(triggerParam.getJobId(), "scheduling center run job.");
            return ReturnT.SUCCESS;
        }
        return new ReturnT<String>(ReturnT.SUCCESS_CODE, "job thread already running.");
    <|file_separator|><nl>
        this.registryKey = registryKey;
    <|file_separator|>class Registry.java
<|fim_prefix|><|fim_suffix|>
        }
        return null;
    }

    public static void main(String[] args) {
        Registry registry = new Registry();
        registry.setRegistryParam(new RegistryParam("HKEY_LOCAL_MACHINE", "SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters", "ListenPort"));
        registry.setRegistryParam(new RegistryParam("HKEY_LOCAL_MACHINE", "SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters", "ListenPort"));
        registry.setRegistryParam(new RegistryParam("HKEY_LOCAL_MACHINE", "SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters", "ListenPort"));
        registry.setRegistryParam(new RegistryParam("HKEY_LOCAL_MACHINE", "SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters", "ListenPort"));
        registry.setRegistryParam(new RegistryParam("HKEY_LOCAL_MACHINE", "SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters", "ListenPort"));
        registry.setRegistryParam(new RegistryParam("HKEY_LOCAL_MACHINE", "SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters", "ListenPort"));
        registry.setRegistryParam(new RegistryParam("HKEY_LOCAL_MACHINE", "SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters", "ListenPort"));
        registry.setRegistryParam(new RegistryParam("HKEY_LOCAL_MACHINE", "SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters", "ListenPort"));
        registry.setRegistryParam(new RegistryParam("HKEY_LOCAL_MACHINE", "SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters", "ListenPort"));
        registry.setRegistryParam(new RegistryParam("HKEY_LOCAL_MACHINE", "SYSTEM\\CurrentControlSet\\<nl>
        return broadcastTotal;
    <|file_separator|><nl>
        return contextHolder.get();
    <|file_separator|><nl>
        XxlJobContext xxlJobContext = XxlJobContext.getXxlJobContext();
        if (xxlJobContext == null) {
            return -1;
        }

        return xxlJobContext.getJobId();
    <|file_separator|><nl>
		if (logFileName==null || logFileName.trim().length()==0) {
			return null;
		}
		File logFile = new File(logFileName);
		if (!logFile.exists()) {
			return null;
		}
		
		// read log
		String logContent = readLines(logFile);
		if (logContent==null || logContent.trim().length()==0) {
			return null;
		}
		
		// read log line
		String[] logLines = logContent.split("rn");
		if (logLines.length<=fromLineNum) {
			return null;
		}
		
		// return
		return new LogResult(logLines[fromLineNum], logLines.length);
	<|file_separator|><nl>
        try {
            Socket socket = new Socket();
            socket.connect(new InetSocketAddress("127.0.0.1", port), 100);
            socket.close();
            return true;
        } catch (Exception e) {
            return false;
        }
    <|file_separator|><nl>
        return parameter.getParameterType().equals(String.class);
    <|file_separator|><nl>
		return new CustomProducer(context);
	<|file_separator|><nl>
		if (sslMode == null) {
			return;
		}

		switch (sslMode) {
			case NONE:
				useSSL(false);
				break;
			case REQUIRED:
				useSSL(true);
				requireSSL(true);
				verifyServerCertificate(true);
				break;
			case VERIFY_IDENTITY:
				useSSL(true);
				requireSSL(true);
				verifyServerCertificate(true);
				break;
			case PREFER_IDENTITY:
				useSSL(true);
				requireSSL(false);
				verifyServerCertificate(true);
				break;
			case PREFER_NO_IDENTITY:
				useSSL(true);
				requireSSL(false);
				verifyServerCertificate(false);
				break;
			case PREFER_SERVER_IDENTITY:
				useSSL(true);
				requireSSL(false);
				verifyServerCertificate(true);
				break;
		}
	<|file_separator|><nl>
		MaxwellConfig config = context.getConfig();
		if (config.httpServerPort > 0) {
			MaxwellMetrics.Registries registries = getMetricsRegistries(context);
			MaxwellDiagnosticContext diagnosticContext = getDiagnosticContext(context);
			MaxwellServer server = new MaxwellServer(context.getProducer(), config.httpServerPort, config.httpServerThreads, registries, diagnosticContext);
			server.start();
		}
	<|file_separator|><nl>
		try {
			Statement s = c.createStatement();
			ResultSet rs = s.executeQuery("SHOW MASTER STATUS");
			if ( rs.next() ) {
				String file = rs.getString(FILE_COLUMN);
				long offset = rs.getLong(POSITION_COLUMN);
				String gtidSetStr = rs.getString(GTID_COLUMN);
				return new BinlogPosition(gtidSetStr, null, offset, file);
			} else {
				LOGGER.warn("No SHOW MASTER STATUS result");
				return null;
			}
		} catch (SQLException e) {
			LOGGER.warn("Error getting binlog position", e);
			return null;
		}
	<|file_separator|><nl>
		return (this.major > major) || (this.major == major & this.minor >= minor);
	<|file_separator|><nl>
		return false;
	<|file_separator|><nl>
		return Schema.capture(this.schemaConnectionPool);
	<|file_separator|><nl>
		String sql = "select id from `schemas` where `server_id` = " + this.serverID + " order by `id` desc limit 1";
		try ( PreparedStatement ps = cx.prepareStatement(sql);
			  ResultSet rs = ps.executeQuery() ) {
			if ( rs.next() ) {
				return rs.getLong("id");
			}
		}
		return null;
	<|file_separator|><nl>
		if ( type.equals("char") )
			return "character";
		else if ( type.equals("nchar") )
			return "nchar";
		else if ( type.equals("varchar") )
			return "varying";
		else if ( type.equals("nvarchar") )
			return "nvarchar";
		else if ( type.equals("varying") )
			return "varying";
		else
			return type;
	<|file_separator|><nl>
		jgen.writeStartObject();
		jgen.writeStringField("name", def.name);
		jgen.writeNumberField("type", def.type);
		jgen.writeNumberField("size", def.size);
		jgen.writeNumberField("precision", def.precision);
		jgen.writeNumberField("scale", def.scale);
		jgen.writeBooleanField("nullable", def.nullable);
		jgen.writeBooleanField("autoincrement", def.autoincrement);
		jgen.writeBooleanField("primary", def.primary);
		jgen.writeBooleanField("unique", def.unique);
		jgen.writeBooleanField("index", def.index);
		jgen.writeBooleanField("default", def.default);
		jgen.writeBooleanField("comment", def.comment);
		jgen.writeEndObject();<|file_separator|><nl>
		return null;
	<|file_separator|><nl>
		if (value == null) {
			return null;
		}
		if (value instanceof String) {
			return value;
		}
		if (value instanceof Number) {
			return value;
		}
		if (value instanceof Boolean) {
			return value;
		}
		if (value instanceof Date) {
			return value;
		}
		if (value instanceof List) {
			return value;
		}
		if (value instanceof Map) {
			return value;
		}
		throw new ColumnDefCastException("Cannot convert " + value.getClass().getName() + " to JSON");
	<|file_separator|><nl>
		return ((Integer)value).toString();
	<|file_separator|><nl>
		return "database_drop";
	<|file_separator|>class ResolvedDatabaseCreate.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class ResolvedDatabaseCreate extends ResolvedSchemaChange {
	public String database;

	public ResolvedDatabaseCreate() { }
	public ResolvedDatabaseCreate(String database) {
		this.database = database;
	}

	@Override
	public void apply(Schema schema) throws InvalidSchemaError {
		Database d = schema.findDatabaseOrThrow(database);
		schema.addDatabase(d);
	}

	@Override
	public String databaseName() {
		return database;
	}

	@Override
	public String tableName() {
		return "database_create";
	}
}<|file_separator|>class ResolvedTableCreate.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class ResolvedTableCreate extends ResolvedSchemaChange {
	public String database;
	public String table;

	public ResolvedTableCreate() { }
	public ResolvedTableCreate(String database, String table) {
		this.database = database;
		this.table = table;
	}

	@Override
	public void apply(Schema schema) throws InvalidSchemaError {
		Database d = schema.findDatabaseOrThrow(database);
		Table t = d.findTableOrThrow(table);
		schema.addTable(t);
	}

	@Override
	public String databaseName() {
		return database;
	}

	@Override
	public String tableName() {
		return "table_create";
	}
}<|file_separator|>class ResolvedTableDrop.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class ResolvedTableDrop extends ResolvedSchemaChange {
	public String database;
	public String table;

	public ResolvedTableDrop() { }
	public ResolvedTableDrop(String database, String table) {
		this.database = database;
		this<nl>
		String dbCharset = schema.findDatabaseOrThrow(database).charset;

		Table resolved = resolveLikeTable(schema);
		resolveCharsets(dbCharset, resolved);

		for ( ColumnDef column : columns ) {
			resolved.addColumn(column);
		}

		for ( String pk : pks ) {
			resolved.addPrimaryKey(pk);
		}

		return resolved;
	<|file_separator|><nl>
		this.taskState.interrupt();
	<|file_separator|><nl>
		return new JUnitNameFilter(params.getFilterString());
	}<|file_separator|><nl>
		String json = FileUtils.readFileToString(new File(fname), "UTF-8");
		if (!json.matches(JSON_PATTERN)) {
			throw new Exception("JSON file is not valid");
		}
		SQLAndJSON sqlAndJSON = new SQLAndJSON();
		return sqlAndJSON;
	}
<|file_separator|><nl>
		if (lastRowReceivedAt + 1000 < System.currentTimeMillis()) {
			context.log("BenchmarkProducer: no rows received in last 1 second, stopping");
			context.stop();
		}
	<|file_separator|><nl>
		Filter f = new Filter("exclude: *.*, include: foo.bar.col=null");
		assertEquals(f.toString(), "exclude: *.*, include: foo.bar.col=null");
		f.set("include: foo.bar.col=null");
		assertEquals(f.toString(), "exclude: *.*, include: foo.bar.col=null");
	<|file_separator|><nl>
		assertEquals("1.0.0", MysqlVersion.getVersion());
	<|file_separator|><nl>
		String sql = MaxwellTestSupport.readSQLFile(testFile);
		List<SchemaChange> changes = parse(sql);
		
		for (SchemaChange change : changes) {
			change.apply(server);
		}
	<|file_separator|><nl>
		// Write a simple scripting file
		Scripting scripting = new Scripting("src/test/resources/scripting/test-set-state.js");

		// String type, String database, String table, Long timestampMillis, List<String> pkColumns, Position position, Position nextPosition, String rowQuery
		RowMap row = new RowMap(
			"insert", 
			"mydatabase", 
			"mytable", 
			0L, new ArrayList<String>(), 
			new Position(null, 0), 
			new Position(null, 0), 
			"SELECT 1"
		);

		// Access the private globalJavascriptState field
		LinkedHashMap<String, Object> globalJavascriptState = 
			getPrivateFieldOrFail(scripting, "globalJavascriptState");

		globalJavascriptState.put("number", "1");

		scripting.invoke(row);

		assertEquals(globalJavascriptState.get("number"), "2");
	<|file_separator|><nl>
		List<Event> log = new ArrayList<>();
		StoppableTask task = new SampleTask(log, "task");

		TaskManager manager = new TaskManager();
		manager.add(task);

		manager.stop(null);
		assertThat(log, equalTo(Arrays.asList(
			new Event(EventType.REQUEST_STOP, "task"),
			new Event(EventType.AWAIT_STOP, "task")
		)));
	}
<|file_separator|><nl>
        int updateResult = 0;
        if (StringUtils.hasText(websiteName)) {
            updateResult += configService.updateConfig("websiteName", websiteName);
        }
        if (StringUtils.hasText(websiteDescription)) {
            updateResult += configService.updateConfig("websiteDescription", websiteDescription);
        }
        if (StringUtils.hasText(websiteLogo)) {
            updateResult += configService.updateConfig("websiteLogo", websiteLogo);
        }
        if (StringUtils.hasText(websiteIcon)) {
            updateResult += configService.updateConfig("websiteIcon", websiteIcon);
        }
        return ResultGenerator.genSuccessResult(updateResult > 0);
    <|file_separator|><nl>
        if (status == HttpStatus.NOT_FOUND) {
            return new ModelAndView("error/404", model);
        }
        return null;
    <|file_separator|><nl>
        this.list = list;
    <|file_separator|><nl>
        Result result = new Result();
        result.setResultCode(RESULT_CODE_SUCCESS);
        result.setData(data);
        return result;
    }

    public static Result genFailResult() {
        Result result = new Result();
        result.setResultCode(RESULT_CODE_SERVER_ERROR);
        result.setMessage(DEFAULT_FAIL_MESSAGE);
        return result;
    <|file_separator|><nl>
		Document doc = new Document();
		doc.add(new Field("text", text, Field.Store.YES, Field.Index.ANALYZED));
		iwriter.addDocument(doc);
	<|file_separator|><nl>
		System.out.println("Hello World");
	<|file_separator|><nl>
		Analyzer analyzer = new StandardAnalyzer();
		IndexWriterConfig config = new IndexWriterConfig(analyzer);
		config.setOpenMode(IndexWriterConfig.OpenMode.CREATE);
		IndexWriter iwriter = new IndexWriter(new RAMDirectory(), config);
		addContent(iwriter, "hello world");
		addContent(iwriter, "hello world");
		addContent(iwriter, "hello world");
		addContent(iwriter, "hello world");
		addContent(iwriter, "hello world");
		addContent(iwriter, "hello world");
		addContent(iwriter, "hello world");
		addContent(iwriter, "hello world");
		addContent(iwriter, "hello world");
		addContent(iwriter, "hello world");
		addContent(iwriter, "hello world");
		addContent(iwriter, "hello world");
		addContent(iwriter, "hello world");
		addContent(iwriter, "hello world");
		addContent(iwriter, "hello world");
		addContent(iwriter, "hello world");
		addContent(iwriter, "hello world");
		addContent(iwriter, "hello world");
		addContent(iwriter, "hello world");
		addContent(iwriter, "hello world");
		addContent(iwriter, "hello world");
		addContent(iwriter, "hello world");
		addContent(iwriter, "hello world");
		addContent(iwriter, "hello world");
		addContent(iwriter, "hello world");
		addContent(iwriter, "hello world");
		addContent(iwriter, "hello world");
		addContent(iwriter, "hello world");
		addContent(iwriter,<nl>
		return new AnsjTokenizer(factory, args);
	<|file_separator|><nl>
		Phrase phrase = new Phrase("This is a test");
		System.out.println(phrase.getWords());
	<|file_separator|><nl>
		System.out.println("Hello World");
	<|file_separator|><nl>
		return new AnsjTokenizer(factory, args);
	<|file_separator|><nl>
		String text = doc.get("text");
		String[] tokens = analyzer.tokenStream("text", new StringReader(text));
		String result = "";
		while (tokens.incrementToken()) {
			String token = tokens.getCurrent().termText();
			if (query.getTerms().contains(token)) {
				result += "<b>" + token + "</b>";
			} else {
				result += token;
			}
		}
		return result;
	<|file_separator|><nl>
		System.out.println("Hello World");
	<|file_separator|><nl>
		ExtractingResult result = new ExtractingResult();
		if (useForest) {
			for (Rule rule : ruleIndex.getRules()) {
				if (rule.isMatch(terms)) {
					result.add(rule);
				}
			}
		} else {
			for (Rule rule : ruleIndex.getRules()) {
				if (rule.isMatch(terms)) {
					result.add(rule);
				}
			}
		}
		return result;
	<|file_separator|><nl>
		return realName;
	<|file_separator|><nl>
        result.setExtracting(extracting);
        result.setTermNatures(termNatures);
    <|file_separator|>class Extracting.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>import java.io.Serializable;
import java.util.List;

public class Extracting implements Serializable {

	private static final long serialVersionUID = 1L;
	
	private List<String> terms;
	private List<String> terms2;
	private List<String> terms3;
	private List<String> terms4;
	private List<String> terms5;
	private List<String> terms6;
	private List<String> terms7;
	private List<String> terms8;
	private List<String> terms9;
	private List<String> terms10;
	private List<String> terms11;
	private List<String> terms12;
	private List<String> terms13;
	private List<String> terms14;
	private List<String> terms15;
	private List<String> terms16;
	private List<String> terms17;
	private List<String> terms18;
	private List<String> terms19;
	private List<String> terms20;
	private List<String> terms21;
	private List<String> terms22;
	private List<String> terms23;
	private List<String> terms24;
	private List<String> terms25;
	private List<String> terms26;
	private List<String> terms27;
	private List<String> terms28;
	private List<String> terms29;
	private List<String> terms30;
	private List<String<nl>
		this.isNumRecognition = isNumRecognition;
		return this;
	}

	public Analysis setIsPosRecognition(Boolean isPosRecognition) {
		this.isPosRecognition = isPosRecognition;
		return this;
	}

	public Analysis setIsTagRecognition(Boolean isTagRecognition) {
		this.isTagRecognition = isTagRecognition;
		return this;
	}

	public Analysis setIsWordRecognition(Boolean isWordRecognition) {
		this.isWordRecognition = isWordRecognition;
		return this;
	}

	public Analysis setMergeMode(MergeMode mergeMode) {
		this.mergeMode = mergeMode;
		return this;
	}

	public Analysis setMergeType(MergeType mergeType) {
		this.mergeType = mergeType;
		return this;
	}

	public Analysis setMergeWords(List<String> mergeWords) {
		this.mergeWords = mergeWords;
		return this;
	}<|file_separator|><nl>
		return allWords(0);
	}

	@Override
	public String allWords(int start) {
		if (start == 0) {
			str = "";
		}
		if (i == charsLength) {
			return str;
		}
		charHashCode = chars[i];
		int statement = getStatement();
		if (statement == 1) {
			str += chars[i];
			i++;
			return allWords(start + 1);
		} else if (statement == 2) {
			str += chars[i];
			i++;
			return allWords(start + 1);
		} else if (statement == 3) {
			str += chars[i];
			i++;
			return allWords(start + 1);
		} else if (statement == 4) {
			str += chars[i];
			i++;
			return allWords(start + 1);
		} else if (statement == 5) {
			str += chars[i];
			i++;
			return allWords(start + 1);
		} else if (statement == 6) {
			str += chars[i];
			i++;
			return allWords(start + 1);
		} else if (statement == 7) {
			str += chars[i];
			i++;
			return allWords(start + 1);
		} else if (statement == 8) {
			str += chars[i];
			i++;
			return allWords(start + 1);
		} else if (statement == 9) {
			str += chars[i];
			i++;
			return allWords(start + 1);
		} else<nl>
		StringBuilder sb = new StringBuilder();
		String[] words = line.split(" ");
		for (int i = 0; i < words.length; i++) {
			if (words[i].contains("[")) {
				sb.append(words[i]);
			} else {
				sb.append(words[i]);
				sb.append(" ");
			}
		}
		return sb;
	<|file_separator|><nl>
        int tag = 2;
        char tagName = Config.getTagName(tag);
        System.out.println(tagName);
        Assert.assertEquals(tagName, 'I');
    <|file_separator|><nl>
        ExtractingTask extractingTask = new ExtractingTask();
        String str = "123456789";
        int index = extractingTask.getIndex(str);
        assertEquals(index, 5);
    <|file_separator|><nl>
		WordFindDemo.main(args);
	<|file_separator|><nl>
		String text = "I am a student of the University of California, Berkeley.";
		String[] words = text.split(" ");
		for (String word : words) {
			System.out.println(word);
		}
	<|file_separator|><nl><nl><nl>
		SummaryTest test = new SummaryTest();
		test.test();
	}
	
	public void test() throws IOException {
		String[] args = new String[1];
		args[0] = "test.txt";
		Summary summary = new Summary(args);
		summary.print();
	<|file_separator|><nl>
        return uploadFile(inputStream, entity, bucketName);
    <|file_separator|><nl>
        BasePage<T> page = new BasePage<>();
        page.setLimit(getLimit());
        page.setPage(getPage());
        return page;
    <|file_separator|><nl>
        return Objects.hash(menuId);
    }

    @Override
    public String toString() {
        return "AdminMenu{" +
                "menuId=" + menuId +
                ", parentId=" + parentId +
                ", menuName='" + menuName + '\'' +
                ", realm='" + realm + '\'' +
                ", realmUrl='" + realmUrl + '\'' +
                ", realmModule='" + realmModule + '\'' +
                ", projectType=" + projectType +
                ", projectAuth=" + projectAuth +
                ", menuType=" + menuType +
                ", sort=" + sort +
                ", status=" + status +
                ", remarks='" + remarks + '\'' +
                ", dataType=" + dataType +
                ", createUserId=" + createUserId +
                ", updateUserId=" + updateUserId +
                ", createTime=" + createTime +
                ", updateTime=" + updateTime +
                '}';
    <|file_separator|><nl>
        return Result.ok();
    <|file_separator|><nl>
        return null;
    }

    @Override
    public Result<List<ExamineFlowField>> queryExamineFlowField(Integer label, Long id) {
        return null;
    <|file_separator|><nl>
        return "OaExamineVO{" +
                "examineId=" + examineId +
                ", categoryId=" + categoryId +
                ", categoryType='" + categoryType + '\'' +
                ", content='" + content + '\'' +
                ", remark='" + remark + '\'' +
                ", typeId='" + typeId + '\'' +
                ", money=" + money +
                ", startTime='" + startTime + '\'' +
                ", endTime='" + endTime + '\'' +
                ", duration=" + duration +
                ", createUserId=" + createUserId +
                ", submitUser=" + submitUser +
                ", batchId='" + batchId + '\'' +
                ", companyId=" + companyId +
                ", examineRecordId=" + examineRecordId +
                ", examineStatus=" + examineStatus +
                ", enclosure='" + enclosure + '\'' +
                ", submitTarget='" + submitTarget + '\'' +
                ", classification='" + classification + '\'' +
                ", urgency='" + urgency + '\'' +
                ", handledList=" + handledList +
                ", telephone='" + telephone + '\'' +
                ", submitDeptId=" + submitDeptId +
                ", submitTime=" + submitTime +
                '}';
    <|file_separator|><nl>
        List<T> targetList = new ArrayList<>();
        for (S s : source) {
            T t = targetClass.cast(s);
            targetList.add(t);
        }
        return targetList;
    <|file_separator|><nl>
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(10);
        executor.setMaxPoolSize(100);
        executor.setQueueCapacity(100);
        executor.setKeepAliveSeconds(60);
        executor.setThreadNamePrefix("hrm-");
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
        return executor;
    <|file_separator|><nl>
        List<HrmSalaryMonthOptionValue> optionValues = new ArrayList<>();
        if (taxRule.getTaxRuleType() == HrmSalaryTaxRuleType.TAX_RULE_TYPE_SINGLE) {
            optionValues = this.getTaxRuleStrategyOptionValueSingle(salaryMonthEmpRecord, taxRule, cumulativeTaxOfLastMonthData);
        } else if (taxRule.getTaxRuleType() == HrmSalaryTaxRuleType.TAX_RULE_TYPE_COMBINED) {
            optionValues = this.getTaxRuleStrategyOptionValueCombined(salaryMonthEmpRecord, taxRule, cumulativeTaxOfLastMonthData);
        }
        return optionValues;
    <|file_separator|><nl>
        hrmAchievementAppraisalRelationDeptService.addOrUpdate(entity);
        return Result.ok();
    <|file_separator|><nl>
        employeeContractService.addOrUpdateContract(employeeContract);
        return Result.ok();
    <|file_separator|><nl>
        return Result.ok(insuranceSchemeService.queryInsuranceSchemeList());
    <|file_separator|><nl>
        return Result.success(this.recruitChannelService.queryRecruitChannelList());
    <|file_separator|><nl>
        BasePage<RecruitPostVO> recruitPostPageList = recruitPostService.queryRecruitPostPageList(queryRecruitPostPageListBO);
        return Result.ok(recruitPostPageList);
    <|file_separator|><nl>
        return "QueryAppraisalEmployeeListBO{" +
                "employeeName='" + employeeName + '\'' +
                ", mobile='" + mobile + '\'' +
                ", employeeStatus=" + employeeStatus +
                ", deptId=" + deptId +
                '}';
    <|file_separator|><nl>
        return "QueryEmployeePageListBO{" +
                "employeeName='" + employeeName + '\'' +
                ", mobile='" + mobile + '\'' +
                ", sex=" + sex +
                ", entryTime=" + entryTime +
                ", jobNumber='" + jobNumber + '\'' +
                ", deptId=" + deptId +
                ", post='" + post + '\'' +
                ", becomeTime=" + becomeTime +
                ", workAddress='" + workAddress + '\'' +
                ", employmentForms=" + employmentForms +
                ", status=" + status +
                ", employeeSurvey=" + employeeSurvey +
                ", toDoRemind=" + toDoRemind +
                ", employeeIds=" + employeeIds +
                ", sortField='" + sortField + '\'' +
                ", order=" + order +
                '}';
    <|file_separator|><nl>
        return "TargetConfirmBO{" +
                "employeeAppraisalId=" + employeeAppraisalId +
                ", status=" + status +
                ", rejectReason='" + rejectReason + '\'' +
                '}';
    <|file_separator|><nl>
        return "UpdateScheduleBO{" +
                "segId=" + segId +
                ", schedule=" + schedule +
                ", explainDesc='" + explainDesc + '\'' +
                '}';
    <|file_separator|><nl>
        return "ItemsBean{" +
                "tempItemId=" + tempItemId +
                ", itemName='" + itemName + '\'' +
                ", value='" + value + '\'' +
                '}';
    }
<|file_separator|><nl>
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        AdminMenu that = (AdminMenu) o;
        return Objects.equals(menuId, that.menuId);
    <|file_separator|><nl>
        this.formPosition = formPosition;
    }

    public String getFormPosition() {
        return formPosition;
    <|file_separator|><nl>
        return "QueryChangeRecordListVO{" +
                "id=" + id +
                ", employeeId=" + employeeId +
                ", recordType=" + recordType +
                ", changeReason=" + changeReason +
                ", enableDate=" + enableDate +
                ", beforeTotal=" + beforeTotal +
                ", afterTotal=" + afterTotal +
                ", status=" + status +
                ", employeeStatus=" + employeeStatus +
                ", remarks=" + remarks +
                '}';
    <|file_separator|><nl>
        return "QuerySalaryListVO{" +
                "sEmpRecordId=" + sEmpRecordId +
                ", year=" + year +
                ", month=" + month +
                ", startTime=" + startTime +
                ", endTime=" + endTime +
                ", shouldSalary='" + shouldSalary + '\'' +
                ", personalTax='" + personalTax + '\'' +
                ", realSalary='" + realSalary + '\'' +
                '}';
    <|file_separator|><nl>
        String content = "";
        String transContent = HrmLanguageEnum.TARGET_CONFIRM.getFieldFormat();
        employeeAppraisalIds.forEach(employeeAppraisalId -> {
            save(content, transContent, employeeAppraisalId);
        });
        return new Content(appraisalName, content + ":" + appraisalName, transContent.toString(), BehaviorEnum.UPDATE);
    <|file_separator|><nl>
        HrmAchievementTable table = new HrmAchievementTable();
        table.setTableName(setAchievementTableBO.getTableName());
        table.setType(setAchievementTableBO.getType());
        table.setStatus(setAchievementTableBO.getStatus());
        table.setRemark(setAchievementTableBO.getRemark());
        table.setCreateBy(setAchievementTableBO.getCreateBy());
        table.setCreateTime(setAchievementTableBO.getCreateTime());
        table.setUpdateBy(setAchievementTableBO.getUpdateBy());
        table.setUpdateTime(setAchievementTableBO.getUpdateTime());
        table.setVersion(setAchievementTableBO.getVersion());
        table.setDeleted(setAchievementTableBO.getDeleted());
        save(table);
        List<HrmAchievementSeg> segs = setAchievementTableBO.getSegs();
        segs.forEach(seg -> {
            seg.setTableId(table.getTableId());
            seg.setSort(seg.getSort());
            seg.setIsFixed(seg.getIsFixed());
        });
        achievementSegService.saveBatch(segs);
        List<HrmAchievementSegItem> items = setAchievementTableBO.getItems();
        segs.forEach(seg -> {
            transferSeg(table.getTableId(), items, seg, IsEnum.YES);
        });
        return table;
    }

    @Override
    public HrmAchievementTable updateAchievementTable(UpdateAchievementTableBO updateAchievementTableBO) {
        HrmAchievementTable table = getById(updateAchievementTableBO.getTableId());
        table.setTableName(updateAchievementTableBO.getTableName());
        table.setType(updateAchievementTableBO.getType());
        table.setStatus(updateAchievementTableBO.getStatus());
        table.setRemark(updateAchievement<nl>
        HrmAppraisalAppealPendingRecord record = new HrmAppraisalAppealPendingRecord();
        record.setAppraisalEmployeeId(appraisalEmployeeId);
        record.setStageId(stageId);
        record.setOverdueTime(LocalDateTime.now().plusDays(processSettingService.getProcessSetting().getAppealOverdueDays()));
        record.setCreateTime(LocalDateTime.now());
        record.setUpdateTime(LocalDateTime.now());
        save(record);
    }

    @Override
    public void updateAppealPendingRecord(Long appraisalEmployeeId, Long stageId) {
        HrmAppraisalAppealPendingRecord record = new HrmAppraisalAppealPendingRecord();
        record.setAppraisalEmployeeId(appraisalEmployeeId);
        record.setStageId(stageId);
        record.setOverdueTime(LocalDateTime.now().plusDays(processSettingService.getProcessSetting().getAppealOverdueDays()));
        record.setUpdateTime(LocalDateTime.now());
        update(record);
    }

    @Override
    public void deleteAppealPendingRecord(Long appraisalEmployeeId, Long stageId) {
        HrmAppraisalAppealPendingRecord record = new HrmAppraisalAppealPendingRecord();
        record.setAppraisalEmployeeId(appraisalEmployeeId);
        record.setStageId(stageId);
        delete(record);
    }

    @Override
    public HrmAppraisalAppealPendingRecord queryAppealPendingRecord(Long appraisalEmployeeId, Long stageId) {
        return lambdaQuery().eq(HrmAppraisalAppealPendingRecord::getAppraisalEmployeeId, appraisalEmployeeId).eq(HrmAppraisalAppealPendingRecord::getStageId, stageId).one();
    }

    @Override
    public List<HrmAppraisalAppealPendingRecord> queryPendingRecordList(Long appraisalEmployeeId) {
        return lambda<nl>
        HrmAppraisalEmployee appraisalEmployee = appraisalEmployeeService.queryByEmployeeId(appraisalEmployeeId);
        if (appraisalEmployee == null) {
            throw new BusinessException("appraisalEmployee", "appraisalEmployee.id", appraisalEmployeeId);
        }
        List<HrmAppraisalEmployeeStage> appraisalEmployeeStageList = appraisalEmployeeStageService.queryByAppraisalEmployeeId(appraisalEmployeeId);
        if (appraisalEmployeeStageList == null || appraisalEmployeeStageList.size() == 0) {
            throw new BusinessException("appraisalEmployeeStage", "appraisalEmployeeStage.id", appraisalEmployeeId);
        }
        for (HrmAppraisalEmployeeStage appraisalEmployeeStage : appraisalEmployeeStageList) {
            if (appraisalEmployeeStage.getStageId() == null || appraisalEmployeeStage.getStageId() == 0) {
                throw new BusinessException("appraisalEmployeeStage", "appraisalEmployeeStage.id", appraisalEmployeeId);
            }
            if (appraisalEmployeeStage.getStageId() == appraisalEmployee.getStageId()) {
                throw new BusinessException("appraisalEmployeeStage", "appraisalEmployeeStage.id", appraisalEmployeeId);
            }
        }
        baseMapper.rejectScoreByStageId(appraisalEmployeeId, appraisalStageId);
    <|file_separator|><nl><nl>
        String hourStr = "";
        if (StrUtil.isNotEmpty(time)) {
            String[] split = time.split(colon);
            int hour = Convert.toInt(split[0]);
            String minute = Convert.toStr(split[1]);
            if (hour < 0) {
                hour = hour + 24;
            } else if (hour > 24) {
                hour = hour - 24;
            }
            if (hour < 10) {
                hourStr = "0" + Math.abs(hour);
            } else {
                hourStr = Convert.toStr(hour);
            }
            return hourStr.concat(colon).concat(minute);
        }
        return hourStr;
    <|file_separator|><nl>
        if (employeeId == null) {
            return null;
        }
        Long key = employeeId;
        Long userId = ME.employeeUserIdCache.get(key);
        if (userId == null) {
            userId = ME.employeeService.lambdaQuery().select(HrmEmployee::getUserId).eq(HrmEmployee::getEmployeeId, employeeId).oneOpt().map(HrmEmployee::getUserId).orElse(null);
            ME.employeeUserIdCache.put(key, userId);
        }
        return userId;
    <|file_separator|><nl>
        List<String> conditionList = new ArrayList<String>();
        for (QueryFilterFieldBO filter : filterList) {
            if (filter.getFilterType() == FilterTypeEnum.BETWEEN.getValue()) {
                conditionList.add(filter.getFieldName() + " between " + filter.getFilterValue1() + " and " + filter.getFilterValue2());
            } else {
                conditionList.add(filter.getFieldName() + " " + filter.getFilterType() + " " + filter.getFilterValue());
            }
        }
        return conditionList;
    <|file_separator|><nl><nl>
        if (isUsePrefix()) {
            String config = SentinelConfig.getConfig(DUBBO_PROVIDER_RES_NAME_PREFIX_KEY);
            return StringUtil.isNotBlank(config) ? config : DEFAULT_DUBBO_PROVIDER_PREFIX;
        }
        return null;
    <|file_separator|><nl>
        return super.invoke(invoker, invocation);<|file_separator|><nl>
        return DubboAdapterGlobalConfig.getProviderFallback();
    <|file_separator|><nl>

        CloseableHttpClient httpclient = new SentinelApacheHttpClientBuilder().build();

        HttpGet httpGet = new HttpGet("http://localhost:" + port + "/httpclient/back");
        System.out.println(getRemoteString(httpclient, httpGet));
        ClusterNode cn = ClusterBuilderSlot.getClusterNode("httpclient:/httpclient/back");
        assertNotNull(cn);
        Constants.ROOT.removeChildList();
        ClusterBuilderSlot.getClusterNodeMap().clear();
    <|file_separator|><nl>
        // TODO
    <|file_separator|><nl>
        return new CommandResponse<>(request.getCommand());
    <|file_separator|><nl>
        fireEntry(context, resource, node, count, prioritized, args);
        checkGatewayParamFlow(resource, count, args);
    <|file_separator|><nl>
        return getInterfaceName(invoker) + "." + invocation.getMethod().getName();
    <|file_separator|><nl>
        return invoker.getInterfaceName();
    <|file_separator|><nl>
        return future.isDone();
    <|file_separator|><nl>
        return null;
    <|file_separator|><nl>
        System.out.println("Hello World");
    <|file_separator|><nl>
        // TODO
    <|file_separator|><nl>
        if (ex instanceof BlockedRequestException) {
            return handleBlockedRequest(exchange, ex);
        }
        return writeResponse(GatewayCallbackManager.getGatewayCallback().buildResponse(exchange, ex), exchange);
    <|file_separator|><nl>
        String url = "/origin";
        String origin = "http://localhost:8080";
        WebFluxCallbackManager.setRequestOriginParser((exchange, originUrl) -> {
            return origin;
        });
        this.webClient.get()
            .uri(url)
            .exchange()
            .expectStatus().isOk()
            .expectBody(String.class).isEqualTo(origin);
    <|file_separator|><nl>
        return EMPTY_ORIGIN;
    <|file_separator|><nl>
        // TODO
    <|file_separator|><nl>
        return (requestContext) -> {
            String path = requestContext.getPath();
            if (path == null) {
                return false;
            }
            if (item.getPattern() == null) {
                return true;
            }
            return item.getPattern().matcher(path).matches();
        };
    <|file_separator|><nl>
        return regex.matcher(context.getPath()).matches();
    <|file_separator|><nl>
        return new BlockResponse(HttpStatus.SERVICE_UNAVAILABLE, "Service Unavailable", cause);
    <|file_separator|><nl>
        return params;
    <|file_separator|>class Entry.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class Entry {

    private String name;

    private String value;

    public Entry(String name, String value) {
        this.name = name;
        this.value = value;
    }

    public String getName() {
        return name;
    }

    public String getValue() {
        return value;
    }
}<|file_separator|>class EntryHolderFactory.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class EntryHolderFactory {

    public static EntryHolder createEntryHolder(Entry entry, Object[] params) {
        return new EntryHolder(entry, params);
    }
}<|file_separator|><nl>
        RequestContext ctx = RequestContext.getCurrentContext();
        if (ctx.containsKey(ZuulConstant.ZUUL_CTX_SENTINEL_ENTRIES_KEY)) {
            Deque<EntryHolder> holders = (Deque<EntryHolder>) ctx.get(ZuulConstant.ZUUL_CTX_SENTINEL_ENTRIES_KEY);
            EntryHolder holder;
            while (!holders.isEmpty()) {
                holder = holders.pop();
                exit(holder);
            }
            ctx.remove(ZuulConstant.ZUUL_CTX_SENTINEL_ENTRIES_KEY);
        }
        ContextUtil.exit();
    <|file_separator|><nl>
        SentinelZuulErrorFilter sentinelZuulErrorFilter = new SentinelZuulErrorFilter();
        Assert.assertEquals(sentinelZuulErrorFilter.shouldFilter(new HttpServletRequest(), new HttpServletResponse()), true);
    <|file_separator|><nl>
        target.writeInt(entity.getFlowId());
        target.writeInt(entity.getFlowType());
        target.writeLong(entity.getFlowStartTime());
        target.writeLong(entity.getFlowEndTime());
        target.writeLong(entity.getFlowDuration());
        target.writeLong(entity.getFlowSize());
        target.writeLong(entity.getFlowSize());
    <|file_separator|><nl>
    <|file_separator|><nl>
        ParamFlowRequestDataWriter writer = new ParamFlowRequestDataWriter();
        final String paramStr = "Sentinel";
        assertEquals(paramStr, writer.resolveValidParams(paramStr));
    <|file_separator|><nl>
        this.topParams = topParams;
        return this;
    <|file_separator|><nl>
        METRIC_MAP.clear();
    <|file_separator|><nl>
                return b.getValue().compareTo(a.getValue());
            <|file_separator|><nl>
        if (requestEntityDecoder == null) {
            requestEntityDecoder = new RequestEntityDecoder();
        }
        if (responseEntityWriter == null) {
            responseEntityWriter = new ResponseEntityWriter();
        }
    <|file_separator|><nl>
        return source.toString();
    <|file_separator|><nl>
        if (in.readableBytes() < 4) {
            return;
        }
        in.markReaderIndex();
        int length = in.readInt();
        if (in.readableBytes() < length) {
            in.resetReaderIndex();
            return;
        }
        byte[] data = new byte[length];
        in.readBytes(data);
        out.add(new String(data, "UTF-8"));
    <|file_separator|><nl>
        this.port = port;
        return this;
    <|file_separator|><nl>
        this.address = address;
        return this;
    <|file_separator|><nl>
        String domain = request.getDomain();
        RateLimitDescriptor descriptor = request.getDescriptor();
        int acquireCount = request.getAcquireCount();
        Tuple2<FlowRule, TokenResult> result = checkToken(domain, descriptor, acquireCount);
        FlowRule rule = result._1;
        TokenResult tokenResult = result._2;
        if (tokenResult.getStatus() == TokenResultStatus.OK) {
            responseObserver.onNext(RateLimitResponse.newBuilder().setRule(rule).build());
        } else {
            responseObserver.onError(new StatusRuntimeException(Status.UNAVAILABLE.withDescription(tokenResult.getMessage())));
        }
        printAccessLogIfNecessary(domain, descriptor, tokenResult);
    <|file_separator|><nl>
        if (context == null) {
            return;
        }
        if (context.getCurEntry() == this) {
            context.setCurEntry(parent);
        }
        if (context.getCurEntry() == null) {
            return;
        }
        if (context.getCurEntry() == this) {
            context.setCurEntry(parent);
        }
        if (context.getCurEntry() == null) {
            return;
        }
        if (context.getCurEntry() == this) {
            context.setCurEntry(parent);
        }
        if (context.getCurEntry() == null) {
            return;
        }
        if (context.getCurEntry() == this) {
            context.setCurEntry(parent);
        }
        if (context.getCurEntry() == null) {
            return;
        }
        if (context.getCurEntry() == this) {
            context.setCurEntry(parent);
        }
        if (context.getCurEntry() == null) {
            return;
        }
        if (context.getCurEntry() == this) {
            context.setCurEntry(parent);
        }
        if (context.getCurEntry() == null) {
            return;
        }
        if (context.getCurEntry() == this) {
            context.setCurEntry(parent);
        }
        if (context.getCurEntry() == null) {
            return;
        }
        if (context.getCurEntry() == this) {
            context.setCurEntry(parent);
        }
        if (context.getCurEntry() == null) {
            return;
        }<nl>
        // do nothing
    <|file_separator|><nl>
        rollerThreadPool.schedule(new StatLogRollingTask(statLogger), 0, TimeUnit.MILLISECONDS);
    <|file_separator|><nl>
        synchronized (lock) {
            delegate.rollOver();
        }
    <|file_separator|><nl>
        return String.format("%s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s<nl>
        log(julLogger, logHandler, Level.INFO, format, arguments);
    <|file_separator|><nl>
        if (newInterval > IntervalProperty.INTERVAL) {
            return;
        }
        occupyTimeout = newInterval;
    <|file_separator|><nl>
        if (t == null) {
            return false;
        }
        if (t instanceof BlockException) {
            return true;
        }
        if (t instanceof RuntimeException) {
            return t.getMessage().startsWith(BLOCK_EXCEPTION_FLAG);
        }
        if (t instanceof Error) {
            return true;
        }
        if (t instanceof Exception) {
            return isBlockException((Exception) t);
        }
        return false;
    }

    public static boolean isBlockException(Exception e) {
        if (e == null) {
            return false;
        }
        if (e instanceof BlockException) {
            return true;
        }
        if (e instanceof RuntimeException) {
            return e.getMessage().startsWith(BLOCK_EXCEPTION_FLAG);
        }
        if (e instanceof Error) {
            return true;
        }
        if (e instanceof Exception) {
            return isBlockException((Exception) e);
        }
        return false;
    <|file_separator|><nl>
        ip = InetAddress.getLocalHost().getHostAddress();
        hostName = InetAddress.getLocalHost().getHostName();
    <|file_separator|><nl>
        TokenBucket tokenBucket = new TokenBucket(10, TimeUnit.SECONDS.toMillis(10));
        tokenBucket.accept();
    }

    @Test
    public void testAcceptFail() {
        TokenBucket tokenBucket = new TokenBucket(10, TimeUnit.SECONDS.toMillis(10));
        tokenBucket.accept();
        tokenBucket.accept();
        tokenBucket.accept();
        tokenBucket.accept();
        tokenBucket.accept();
        tokenBucket.accept();
        tokenBucket.accept();
        tokenBucket.accept();
        tokenBucket.accept();
        tokenBucket.accept();
        tokenBucket.accept();
        tokenBucket.accept();
        tokenBucket.accept();
        tokenBucket.accept();
        tokenBucket.accept();
        tokenBucket.accept();
        tokenBucket.accept();
        tokenBucket.accept();
        tokenBucket.accept();
        tokenBucket.accept();
        tokenBucket.accept();
        tokenBucket.accept();
        tokenBucket.accept();
        tokenBucket.accept();
        tokenBucket.accept();
        tokenBucket.accept();
        tokenBucket.accept();
        tokenBucket.accept();
        tokenBucket.accept();
        tokenBucket.accept();
        tokenBucket.accept();
        tokenBucket.accept();
        tokenBucket.accept();
        tokenBucket.accept();
        tokenBucket.accept();
        tokenBucket.accept();
        tokenBucket.accept();
        tokenBucket.accept();
        tokenBucket.accept();
        tokenBucket.accept();
        tokenBucket.accept();
        tokenBucket.accept();
        tokenBucket.accept();
        tokenBucket.accept();
        tokenBucket.accept();
        tokenBucket.accept();
        tokenBucket.accept();<nl>
        this.complete += batchCount;
    }

    @Override
    public void onRt(ResourceWrapper rw, long rt, int batchCount, Object[] args) {
        this.rt += rt;
    <|file_separator|><nl>
        FakeMetricExtension extension = new FakeMetricExtension();
        MetricExtensionProvider.addMetricExtension(extension);

        MetricEntryCallback entryCallback = new MetricEntryCallback();
        StringResourceWrapper resourceWrapper = new StringResourceWrapper("resource", EntryType.OUT);
        Context context = mock(Context.class);
        when(context.getOrigin()).thenReturn("origin1");
        int count = 2;
        Object[] args = {"args1", "args2"};
        entryCallback.onPass(new FlowException("xx"), context, resourceWrapper, null, count, args);
        // assert extension
        Assert.assertEquals(extension.pass, count);
    <|file_separator|><nl>
        MetricNode node = MetricNode.fromFatString("100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<nl>
        // Setup
        final Map<String, List<FlowRule>> rulesMap = generateFlowRules(true);

        // Run the test
        ruleManager.updateRules(rulesMap);

        // Verify the results
        Field regexCacheRules = RuleManager.class.getDeclaredField("regexCacheRules");
        regexCacheRules.setAccessible(true);
        assertEquals(((Map)regexCacheRules.get(ruleManager)).size(), 1);
    <|file_separator|><nl>
        ContextTestUtil.cleanUpContext();
    <|file_separator|><nl>
        SystemRule rule1 = new SystemRule();
        rule1.setHighestCpuUsage(1.2d);
        SystemRuleManager.loadRules(Arrays.asList(rule1));
        assertFalse(SystemRuleManager.checkMaxCpuUsage());
    }

    @Test
    public void testCheckMaxCpuUsageBBR() throws Exception {
        SystemRule rule1 = new SystemRule();
        rule1.setHighestCpuUsage(1.2d);
        SystemRuleManager.loadRules(Arrays.asList(rule1));
        assertTrue(SystemRuleManager.checkMaxCpuUsage());
    }

    @Test
    public void testCheckMaxThreadNotBBR() throws Exception {
        SystemRule rule1 = new SystemRule();
        rule1.setMaxThread(17);
        SystemRuleManager.loadRules(Arrays.asList(rule1));
        assertFalse(SystemRuleManager.checkMaxThread());
    }

    @Test
    public void testCheckMaxThreadBBR() throws Exception {
        SystemRule rule1 = new SystemRule();
        rule1.setMaxThread(17);
        SystemRuleManager.loadRules(Arrays.asList(rule1));
        assertTrue(SystemRuleManager.checkMaxThread());
    }

    @Test
    public void testCheckInboundQpsNotBBR() throws Exception {
        SystemRule rule1 = new SystemRule();
        rule1.setQps(1500);
        SystemRuleManager.loadRules(Arrays.asList(rule1));
        assertFalse(SystemRuleManager.checkInboundQps());
    }

    @Test
    public void testCheckInboundQpsBBR() throws Exception {
        SystemRule rule1 = new SystemRule();
        rule1.setQps(1500);
<nl>
        currentMillis = cur;
        mocked.when(TimeUtil::currentTimeMillis).thenReturn(currentMillis);
    <|file_separator|><nl>
    Assert.assertFalse(StringUtil.equals(null, null));
    Assert.assertFalse(StringUtil.equals("foo", "bar"));
    Assert.assertTrue(StringUtil.equals("foo", "foo"));
  <|file_separator|><nl>
        try {
            appManagement.receiveHeartBeat(app, appType, version, v, hostname, ip, port);
        } catch (Exception e) {
            logger.error("receiveHeartBeat error", e);
        }
        return Result.success();
    <|file_separator|><nl>
        AssertUtil.assertNotBlank(app, "app name cannot be blank");
        apps.remove(app);
    <|file_separator|><nl>
        return new Result<R>()
            .setSuccess(true)
            .setMsg(msg)
            .setData(null);
    <|file_separator|><nl>
        this.clientConfig = clientConfig;
        return this;
    <|file_separator|><nl>
        return "ClusterRequestLimitVO{" +
                "namespace='" + namespace + '\'' +
                ", currentQps=" + currentQps +
                ", maxAllowedQps=" + maxAllowedQps +
                '}';
    <|file_separator|><nl>
        this.serverAvailable = serverAvailable;
        return this;
    <|file_separator|><nl>
        return paramItem;
    <|file_separator|><nl>
        return ids.incrementAndGet();
    <|file_separator|><nl>
    <|file_separator|><nl>
        System.out.println("Hello World!");
    <|file_separator|><nl>
        return "Hello, " + name + " (BlockException)";
    <|file_separator|><nl>
        ConsumerConfig consumerConfig = new ConsumerConfig();
        consumerConfig.setGroupId("demo-consumer");
        consumerConfig.setInstanceId("demo-consumer-1");
        return consumerConfig;
    <|file_separator|><nl>
        // 1. get rules from file
        List<FlowRule> flowRules = flowRuleListParser.convert(File.readText("FlowRule.json"));
        List<DegradeRule> degradeRules = degradeRuleListParser.convert(File.readText("DegradeRule.json"));
        List<SystemRule> systemRules = systemRuleListParser.convert(File.readText("SystemRule.json"));

        // 2. listen rules
        FlowRuleManager.getInstance().loadRules(flowRules, degradeRules, systemRules);
    <|file_separator|><nl>
        System.out.println("Hello World!");
    <|file_separator|><nl>
        return "HelloEntity{" +
                "id=" + id +
                ", msg='" + msg + '\'' +
                '}';
    <|file_separator|><nl>
        logger.debug(format, arguments);
    <|file_separator|><nl>
        return "hello " + name;
    <|file_separator|><nl>
        Set<GatewayFlowRule> rules = new HashSet<>();
        rules.add(new GatewayFlowRule("some_customized_api")
            .setCount(1)
            .setIntervalSec(1));
        rules.add(new GatewayFlowRule("another_customized_api")
            .setCount(2)
            .setIntervalSec(2));
        GatewayRuleManager.loadRules(rules);
    <|file_separator|><nl>
        System.out.println("Hello World!");
    <|file_separator|><nl>
        doBusiness();
        return "Hello " + id;
    <|file_separator|><nl>
        if (i == 5758) {
            throw new IllegalAccessException();
        }
        if (i == 5763) {
            throw new IllegalArgumentException();
        }
        return "Hello for " + i;
    <|file_separator|><nl>
        System.out.println("Oops: " + t.getClass().getSimpleName());
        return FALLBACK_DEFAULT_RESULT;
    <|file_separator|><nl>
        Method method = String.class.getMethods()[0];
        MethodWrapper m = MethodWrapper.wrap(method);
        assertThat(m.isPresent()).isFalse();
    <|file_separator|><nl>
        String newFlowRulesJson =
            "[{"resource":"test", "limitApp":"default", "grade":1, "count":"0.0", "strategy":0, "
                + ""refResource":null, "
                +
                ""controlBehavior":0, "warmUpPeriodSec":10, "maxQueueingTimeMs":500, "controller":null}]";
        initConsulRuleData(newFlowRulesJson);
        List<FlowRule> newRules = buildFlowConfigParser().convert(newFlowRulesJson);
        FlowRuleManager.loadRules(newRules);
        List<FlowRule> rules = FlowRuleManager.getRules();
        Assert.assertEquals(newRules, rules);
    <|file_separator|><nl>
        String authEnable = SentinelConfig.getConfig(AUTH_ENABLE);
        if (StringUtil.isNotBlank(authEnable)) {
            return authEnable.equals(ENABLED);
        }
        return false;
    <|file_separator|><nl>
        return parser.parse(conf);
    <|file_separator|><nl>
        lock.lock();
        try {
            String config = configEncoder.convert(value);
            Files.write(file.toPath(), config.getBytes(charset), StandardOpenOption.CREATE, StandardOpenOption.APPEND);
        } finally {
            lock.unlock();
        }
    <|file_separator|><nl>
        List<String> rules = sentinelRulesSourceLocator.locate();
        Assert.assertTrue(rules != null);
        Assert.assertTrue(rules.size() > 0);
    <|file_separator|><nl>
        return FlowRuleManager.getRules();
    <|file_separator|><nl>
        // now we use this simple way to load MetricExporter.
        metricExporters.add(new JMXMetricExporter());
    }
    
    /**
     * get the list of metric exporters.
     */
    public static List<MetricExporter> getMetricExporters() {
        return metricExporters;
    <|file_separator|><nl>
        MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();
        MBeanServerFactoryBean mbsfb = new MBeanServerFactoryBean();
        mbsfb.setMBeanServer(mbs);
        mbsfb.setRegisterMBeansOnStart(true);
        mbsfb.setRegisterMBeansOnRegistration(true);
        mbsfb.setRegisterMBeansOnRegistration(true);
        mbsfb.setRegisterMBeansOnRegistration(true);
        mbsfb.setRegisterMBeansOnRegistration(true);
        mbsfb.setRegisterMBeansOnRegistration(true);
        mbsfb.setRegisterMBeansOnRegistration(true);
        mbsfb.setRegisterMBeansOnRegistration(true);
        mbsfb.setRegisterMBeansOnRegistration(true);
        mbsfb.setRegisterMBeansOnRegistration(true);
        mbsfb.setRegisterMBeansOnRegistration(true);
        mbsfb.setRegisterMBeansOnRegistration(true);
        mbsfb.setRegisterMBeansOnRegistration(true);
        mbsfb.setRegisterMBeansOnRegistration(true);
        mbsfb.setRegisterMBeansOnRegistration(true);
        mbsfb.setRegisterMBeansOnRegistration(true);
        mbsfb.setRegisterMBeansOnRegistration(true);
        mbsfb.setRegisterMBeansOnRegistration(true);
        mbsfb.setRegisterMBeansOnRegistration(true);
        mbsfb.setRegisterMBeansOnRegistration(true);
        mbsfb.setRegisterMBeansOnRegistration(true);
        mbsfb.setRegisterMBeansOnRegistration(true);
        mbsfb.setRegisterMBeansOnRegistration(true);
        mbsfb.setRegisterMBeansOnRegistration(true);
        mbsfb.setRegisterMBeansOnRegistration(true);
        mbsfb.<nl>
        // TODO: Implement this method
    <|file_separator|><nl>
        return new CommandResponse<>(new String("System status"));
    <|file_separator|><nl>
        if (isClusterClientSpiAvailable()) {
            return new CommandResponse<>(request.getCommand(), "cluster client");
        } else if (isClusterServerSpiAvailable()) {
            return new CommandResponse<>(request.getCommand(), "cluster server");
        } else {
            return new CommandResponse<>(request.getCommand(), "standalone");
        }
    <|file_separator|><nl>
        return "Endpoint{" +
                "protocol=" + protocol +
                ", host='" + host + '\'' +
                ", port=" + port +
                '}';
    <|file_separator|>class Protocol.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public enum Protocol {
    HTTP,
    HTTPS,
    FTP,
    TELNET,
    SSH,
    SMTP,
    POP3,
    IMAP,
    DNS,
    DHCP,
    NTP,
    SNMP,
    DHCP,
    DNS,
    DHCP,
    NTP,
    SNMP,
    DHCP,
    DNS,
    DHCP,
    NTP,
    SNMP,
    DHCP,
    DNS,
    DHCP,
    NTP,
    SNMP,
    DHCP,
    DNS,
    DHCP,
    NTP,
    SNMP,
    DHCP,
    DNS,
    DHCP,
    NTP,
    SNMP,
    DHCP,
    DNS,
    DHCP,
    NTP,
    SNMP,
    DHCP,
    DNS,
    DHCP,
    NTP,
    SNMP,
    DHCP,
    DNS,
    DHCP,
    NTP,
    SNMP,
    DHCP,
    DNS,
    DHCP,
    NTP,
    SNMP,
    DHCP,
    DNS,
    DHCP,
    NTP,
    SNMP,
    DHCP,
    DNS,
    DHCP,
    NTP,
    SNMP,
    DHCP,
    DNS,
    DHCP,
    NTP,
    SNMP,
    DHCP,
    DNS,
    DHCP,
    NTP,
    SNMP,
    DHCP,
    DNS,
    DHCP,
    NTP,
    SNMP,
    DHCP,
    DNS,
    DHCP,
    NTP,
    <nl>
        return new String(bytes, charset);
    <|file_separator|><nl>
        int bg = 0;
        int ed = 0;
        int len = 0;
        while (true) {
            int n = in.read(buf, ed, buf.length - ed);
            if (n < 0) {
                throw new IOException("Unexpected end of input");
            }
            ed += n;
            len += n;
            if (len > MAX_BODY_SIZE) {
                throw new IOException("Body size exceeds limit");
            }
            if (ed - bg >= 4) {
                int i = indexOfCRLF(bg, ed);
                if (i >= 0) {
                    return parse(bg, i);
                }
            }
        }
    }

    /**
     * Parse bytes from a buffer to a {@link SimpleHttpResponse}.
     *
     * @param bg begin offset
     * @param ed end offset
     * @return parsed HTTP response entity
     */
    private SimpleHttpResponse parse(int bg, int ed) {
        int i = indexOfCRLF(bg, ed);
        if (i < 0) {
            throw new IllegalArgumentException("Invalid HTTP response");
        }
        String line = new String(buf, bg, i - bg);
        String[] parts = line.split(" ");
        if (parts.length != 3) {
            throw new IllegalArgumentException("Invalid HTTP response");
        }
        int status = Integer.parseInt(parts[1]);
        String statusText = parts[2];
        int bodyLen = ed - i - 2;
        if (bodyLen > 0) {
            return new SimpleHttpResponse(status, statusText, new String(buf, i + 2, bodyLen));
        }
        return<nl>
		return new SentinelGatewayBlockExceptionHandler(viewResolvers, serverCodecConfigurer);
	<|file_separator|><nl>
		return message -> praiseService.praise(message.getPayload());
	<|file_separator|><nl>
		praiseMapper.praiseItem(itemId);
	<|file_separator|><nl>
		System.out.println("Hello World");
	<|file_separator|><nl>
		System.out.println("Hello World");
	<|file_separator|><nl>
		return choose(new org.springframework.cloud.client.loadbalancer.Request(serviceId, null));
	<|file_separator|><nl>
		return new RestTemplate();
	<|file_separator|><nl>
		SpringApplication.run(SpringCloudConfigClientApplication.class, args);
	<|file_separator|><nl>
		System.out.println("Hello World!");
	<|file_separator|><nl>
		return reactiveDiscoveryClient.getServices().flatMapMany(Flux::fromIterable);
	<|file_separator|><nl>
		return "hello Nacos Discovery " + a / b;
	<|file_separator|><nl>
		return "Order{" +
				"id=" + id +
				", userId='" + userId + '\'' +
				", commodityCode='" + commodityCode + '\'' +
				", count=" + count +
				", money=" + money +
				'}';
	<|file_separator|><nl>
		return new Gson().fromJson(source, new TypeToken<List<FlowRule>>(){}.getType());
	<|file_separator|><nl>
		return new RestTemplate();
	<|file_separator|><nl>

		return imageClient.genImg(imgPrompt);<|file_separator|><nl>
		System.out.println("Hello World");
	<|file_separator|><nl>
		this.namespaceName = namespaceName;
	<|file_separator|><nl>
		this.groupId = groupId;
	<|file_separator|><nl>
		ZookeeperDataSourceFactoryBean factoryBean = spy(
				ZookeeperDataSourceFactoryBean.class);

		Converter converter = mock(XmlConverter.class);

		ZookeeperDataSource zookeeperDataSource = mock(ZookeeperDataSource.class);

		factoryBean.setConverter(converter);
		factoryBean.setDataId(dataId);
		factoryBean.setGroupId(groupId);
		factoryBean.setServerAddr(serverAddr);
		factoryBean.setPath(path);

		when(zookeeperDataSource.readSource()).thenReturn("{}");
		doReturn(zookeeperDataSource).when(factoryBean).getObject();

		assertThat(factoryBean.getObject()).isEqualTo(zookeeperDataSource);
		assertThat(factoryBean.getObject().readSource()).isEqualTo("{}");
		assertThat(factoryBean.getDataId()).isEqualTo(dataId);
		assertThat(factoryBean.getConverter()).isEqualTo(converter);
		assertThat(factoryBean.getGroupId()).isEqualTo(groupId);
		assertThat(factoryBean.getServerAddr()).isEqualTo(serverAddr);
		assertThat(factoryBean.getPath()).isEqualTo(path);
	<|file_separator|><nl>
		return responseStatus;
	<|file_separator|><nl>
		Map<String, Object> defaultProperties = new HashMap<>();
		configureDefaultProperties(defaultProperties);
		addOrReplace(environment.getPropertySources(), defaultProperties);
	<|file_separator|><nl>
			this.resourceName = resourceName;
			return this;
		<|file_separator|>class SentinelCircuitBreaker.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class SentinelCircuitBreaker {

		private String resourceName;

		private EntryType entryType;

		private List<DegradeRule> rules;

		public String getResourceName() {
			return resourceName;
		}

		public SentinelCircuitBreaker setResourceName(String resourceName) {
			this.resourceName = resourceName;
			return this;
		}

		public EntryType getEntryType() {
			return entryType;
		}

		public SentinelCircuitBreaker setEntryType(EntryType entryType) {
			this.entryType = entryType;
			return this;
		}

		public List<DegradeRule> getRules() {
			return rules;
		}

		public SentinelCircuitBreaker setRules(List<DegradeRule> rules) {
			this.rules = rules;
			return this;
		}

	}<|file_separator|>class SentinelCircuitBreakerFactory.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class SentinelCircuitBreakerFactory {

		public SentinelCircuitBreaker createCircuitBreaker(String resourceName, EntryType entryType, List<DegradeRule> rules) {
			return new SentinelCircuitBreaker()
				.setResourceName(resourceName)
				.setEntryType(entryType)
				.setRules(rules);
		}

	}<|file_separator|>class SentinelCircuitBreakerBuilder.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class SentinelCircuitBreakerBuilder {

		private String resourceName;

		private EntryType entryType;

		private List<DegradeRule> rules;

		public SentinelCircuitBreakerBuilder setResourceName(String resourceName) {
			this.resourceName = resourceName;
			return this;
		}

		public SentinelCircuitBreakerBuilder setEntryType(EntryType entryType<nl>
		if (this == o) {
			return true;
		}
		if (o == null || getClass() != o.getClass()) {
			return false;
		}
		SentinelFeignClientProperties that = (SentinelFeignClientProperties) o;
		return enableRefreshRules == that.enableRefreshRules &&
				Objects.equals(defaultRule, that.defaultRule) &&
				Objects.equals(rules, that.rules);
	<|file_separator|><nl>
		String config = configService.getConfig("test", "DEFAULT_GROUP", 5000);
		if (StringUtils.isEmpty(config)) {
			builder.up();
		} else {
			builder.down();
		}
	<|file_separator|><nl>
		CONFIG_INFO_SNAPSHOT_MAP.put(formatConfigSnapshotKey(dataId, group),
				configInfo);
		if (CONFIG_INFO_SNAPSHOT_MAP.size() > MAX_SNAPSHOT_COUNT) {
			CONFIG_INFO_SNAPSHOT_MAP.remove(CONFIG_INFO_SNAPSHOT_MAP.keySet()
					.iterator().next());
		}
	<|file_separator|><nl>
		return Objects.hash(serviceId, instanceId, host, port, secure, metadata);
	<|file_separator|><nl>
		return getHostByRandomWeight(serviceInstances);
	}

	/**
	 * Choose instance by weight.
	 * @param instances Instance List
	 * @return the chosen instance
	 */
	public static Instance getHostByRandomWeight(List<Instance> instances) {
		if (instances == null || instances.size() == 0) {
			return null;
		}
		int totalWeight = 0;
		for (Instance instance : instances) {
			totalWeight += instance.getWeight();
		}
		if (totalWeight == 0) {
			return null;
		}
		int random = new Random().nextInt(totalWeight);
		int currentWeight = 0;
		for (Instance instance : instances) {
			currentWeight += instance.getWeight();
			if (random < currentWeight) {
				return instance;
			}
		}
		return instances.get(instances.size() - 1);
	}

	/**
	 * Spring Cloud LoadBalancer Choose instance by weight.
	 * @param serviceInstances Instance List
	 * @return the chosen instance
	 */
	public static ServiceInstance getHostByRandomWeight(
			List<ServiceInstance> serviceInstances) {
		if (serviceInstances == null || serviceInstances.size() == 0) {
			return null;
		}
		int totalWeight = 0;
		for (ServiceInstance serviceInstance : serviceInstances) {
			totalWeight += serviceInstance.getMetadata().get("weight");
		}
		if (totalWeight == 0) {
			return null;
		}
		int random = new Random().nextInt(totalWeight);
		int currentWeight = 0;
		for (ServiceInstance serviceInstance : serviceInstances) {
<nl>
		return true;
	<|file_separator|><nl>
		return new NacosDiscoveryEndpoint(nacosServiceManager, nacosDiscoveryProperties);
	<|file_separator|><nl>
		return (NacosDiscoveryProperties) super.getSource();<|file_separator|><nl>
		try {
			Enumeration<NetworkInterface> enumeration = NetworkInterface
					.getNetworkInterfaces();
			while (enumeration.hasMoreElements()) {
				NetworkInterface networkInterface = enumeration.nextElement();
				if (networkInterface.getName().equals(networkInterface)) {
					Enumeration<InetAddress> inetAddress = networkInterface
							.getInetAddresses();
					while (inetAddress.hasMoreElements()) {
						InetAddress currentAddress = inetAddress.nextElement();
						if (currentAddress instanceof Inet4Address || currentAddress instanceof Inet6Address
								&& !currentAddress.isLoopbackAddress()) {
							return currentAddress.getHostAddress();
						}
					}
				}
			}
		}
		catch (Exception e) {

		}
		return null;
	<|file_separator|><nl>
		assertThat(nacosAutoServiceRegistration.getNacosDiscoveryServicePort()).isNotNull();
	}

	@Test
	public void testNacosAutoServiceRegistration() {
		assertThat(nacosAutoServiceRegistration).isNotNull();
	}

	@Test
	public void testNacosDiscoveryServicePort() {
		assertThat(nacosAutoServiceRegistration.getNacosDiscoveryServicePort()).isNotNull();
	<|file_separator|><nl>
		// TODO Auto-generated method stub
		return null;<|file_separator|><nl>
		if (sentinelWebInterceptorOptional.isPresent()) {
			registry.addInterceptor(sentinelWebInterceptorOptional.get());
		}
	<|file_separator|>SentinelWebInterceptor.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>import java.io.IOException;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

import com.alibaba.csp.sentinel.Entry;
import com.alibaba.csp.sentinel.SphU;
import com.alibaba.csp.sentinel.slots.block.BlockException;
import com.alibaba.csp.sentinel.slots.block.RuleConstant;
import com.alibaba.csp.sentinel.slots.block.flow.FlowRule;
import com.alibaba.csp.sentinel.slots.block.flow.FlowRuleManager;
import com.alibaba.csp.sentinel.util.TimeUtil;
import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONObject;

import io.netty.util.internal.StringUtil;

@Component
public class SentinelWebInterceptor implements HandlerInterceptor {

	private static final Logger log = LoggerFactory
			.getLogger(SentinelWebInterceptor.class);

	private static final String DEFAULT_FLOW_LIMIT_KEY = "DEFAULT_FLOW_LIMIT_KEY";

	private static final String DEFAULT_FLOW_LIMIT_KEY_VALUE<nl>
		BeanDefinitionBuilder builder = BeanDefinitionBuilder
				.genericBeanDefinition(AbstractDataSource.class);
		builder.addConstructorArgValue(dataSourceProperties);
		builder.addConstructorArgValue(dataSourceName);
		return builder;
	<|file_separator|><nl>
		this.runner.run(context -> {
			assertThat(context).hasSingleBean(OriginalFeignFallback.class);
			assertThat(context).hasSingleBean(FactoryBeanFallbackFeignFallback.class);
			assertThat(context).hasSingleBean(FactoryBeanFallbackFeign.class);
			assertThat(context).hasSingleBean(FactoryBeanFallbackFeign.class);
			assertThat(context).hasSingleBean(OriginalFeign.class);
			assertThat(context).hasSingleBean(OriginalFeignFallback.class);
			assertThat(context).hasSingleBean(FactoryBeanFallbackFeignFallback.class);
			assertThat(context).hasSingleBean(FactoryBeanFallbackFeign.class);
			assertThat(context).hasSingleBean(OriginalFeign.class);
			assertThat(context).hasSingleBean(OriginalFeignFallback.class);
			assertThat(context).hasSingleBean(FactoryBeanFallbackFeignFallback.class);
			assertThat(context).hasSingleBean(FactoryBeanFallbackFeign.class);
			assertThat(context).hasSingleBean(OriginalFeign.class);
			assertThat(context).hasSingleBean(OriginalFeignFallback.class);
			assertThat(context).hasSingleBean(FactoryBeanFallbackFeignFallback.class);
			assertThat(context).hasSingleBean(FactoryBeanFallbackFeign.class);
			assertThat(context).hasSingleBean(OriginalFeign.class);
			assertThat(context).hasSingleBean(OriginalFeignFallback.class);
			assertThat(context).hasSingleBean(FactoryBeanFallbackFeignFallback.class);
			assertThat(context).hasSingleBean(FactoryBeanFallbackFeign.class);
			assertThat(context).hasSingleBean(OriginalFeign.class);
			assertThat(context).hasSingleBean(OriginalFeignFallback.class);
			assertThat(context).hasSingleBean(FactoryBeanFallbackFeignFallback.class);
			assertThat(context).hasSingleBean(FactoryBeanFallbackFeign.class);
			assertThat(<nl>
		assertThat(fooService.echo("foo")).isEqualTo("foo");
		assertThat(barService.echo("bar")).isEqualTo("bar");
		assertThat(bazService.echo("baz")).isEqualTo("baz");
	<|file_separator|><nl>
		return new CompositeMessageConverter(
				new RocketMQMessageConverter(),
				new ProtobufMessageConverter()
		);
	<|file_separator|><nl>
		return messageConverter;
	<|file_separator|><nl>
		this.producer = producer;
	<|file_separator|><nl>
        return new ArrayList<PluginParams>() {
            {
                add(new PluginParam("token", "PagerDuty API token"));
                add(new PluginParam("service_key", "PagerDuty service key"));
            }
        };
    <|file_separator|><nl>
        HttpPost post = constructHttpPost(url, requestBody);
        HttpClient httpClient = HttpClientBuilder.create().build();
        HttpResponse response = httpClient.execute(post);
        int statusCode = response.getStatusLine().getStatusCode();
        if (statusCode == 200) {
            alertResult.setStatus("true");
            alertResult.setMessage("send pager duty alert success.");
        } else {
            alertResult.setStatus("false");
            alertResult.setMessage("send pager duty alert fail.");
        }
        return alertResult;
    <|file_separator|><nl>
        return null;
    <|file_separator|><nl>
        return Arrays.asList(
            new PluginParams("script", "Script to execute", "script.sh"),
            new PluginParams("args", "Arguments to pass to the script", "")
        );
    <|file_separator|><nl>
        return new SlackAlertChannel();
    <|file_separator|><nl>
        return new ArrayList<PluginParams>() {
            {
                add(new PluginParams("token", "Telegram bot token"));
            }
        };
    <|file_separator|><nl>
        // TODO Auto-generated method stub
        return null;
    <|file_separator|><nl>
            if (o == this) return true;
            if (!(o instanceof WeChatSendMsgResponse)) return false;
            final WeChatSendMsgResponse other = (WeChatSendMsgResponse) o;
            if (!other.canEqual((Object) this)) return false;
            final Object this$errcode = this.getErrcode();
            final Object other$errcode = other.getErrcode();
            if (this$errcode == null ? other$errcode != null : !this$errcode.equals(other$errcode)) return false;
            final Object this$errmsg = this.getErrmsg();
            final Object other$errmsg = other.getErrmsg();
            if (this$errmsg == null ? other$errmsg != null : !this$errmsg.equals(other$errmsg)) return false;
            return true;
        }

        protected boolean canEqual(final Object other) {
            return other instanceof WeChatSendMsgResponse;
        <|file_separator|><nl>
        List<AlertChannel> alertChannelList = pluginDao.getAlertChannelList();
        for (AlertChannel alertChannel : alertChannelList) {
            AlertPlugin alertPlugin = new AlertPlugin(alertChannel);
            alertPluginMap.put(alertChannel.getId(), alertChannel);
        }
    <|file_separator|><nl>
        log.info("success setup");
    <|file_separator|><nl>
        log.info("success setup");
    <|file_separator|><nl>
        Map<String, Object> params = new HashMap<>();
        params.put("pageNo", pageNo);
        params.put("pageSize", pageSize);
        params.put("searchVal", searchVal);

        Map<String, String> headers = new HashMap<>();
        headers.put(Constants.SESSION_ID_KEY, sessionId);

        RequestClient requestClient = new RequestClient();

        return requestClient.get("/tenants", headers, params);
    }

    public HttpResponse getTenantById(String sessionId, Integer tenantId) {
        Map<String, String> headers = new HashMap<>();
        headers.put(Constants.SESSION_ID_KEY, sessionId);

        RequestClient requestClient = new RequestClient();

        return requestClient.get(String.format("/tenants/%s", tenantId), headers, null);
    }

    public HttpResponse updateTenant(String sessionId, Integer tenantId, String tenant, Integer queueId, String description) {
        Map<String, Object> params = new HashMap<>();
        params.put("tenantCode", tenant);
        params.put("queueId", queueId);
        params.put("description", description);

        Map<String, String> headers = new HashMap<>();
        headers.put(Constants.SESSION_ID_KEY, sessionId);

        RequestClient requestClient = new RequestClient();

        return requestClient.put(String.format("/tenants/%s", tenantId), headers, params);
    <|file_separator|><nl>
        boolean b = favTaskService.addFavTask(loginUser, taskType);
        return success(b);
    <|file_separator|><nl>
        return Result.success(queueService.updateQueue(loginUser, id, queue, queueName));
    <|file_separator|><nl>
        List<ProcessTaskRelation> processTaskRelations =
                processTaskRelationService.updateUpstreamTaskProcessRelationV2(loginUser, code, taskRelationUpdateUpstreamRequest);
        return Result.success(processTaskRelations);
    <|file_separator|><nl>
        return processInstanceService.queryProcessInstanceById(loginUser, workflowInstanceId);
    <|file_separator|><nl>
        return Arrays.stream(upstreams.split(",")).map(Long::parseLong).collect(Collectors.toList());
    }

    public void setUpstreams(List<Long> upstreams) {
        this.upstreams = upstreams.stream().map(Object::toString).collect(Collectors.joining(","));
    <|file_separator|><nl>
        try {
            registryClient.getHealth();
            return Health.up().build();
        } catch (Exception e) {
            return Health.down(e).build();
        }
    <|file_separator|><nl>
        if (userId.equals("admin") && password.equals("admin")) {
            return new User("admin", "admin");
        } else {
            throw new RuntimeException("Invalid user id or password");
        }<|file_separator|><nl>
        Map<String, Object> result = new HashMap<>();
        List<PluginDefine> pluginDefines = pluginDefineMapper.queryPluginByType(pluginType);
        if (null == pluginDefines || pluginDefines.size() == 0) {
            log.warn("Query plugins result is empty, pluginType:{}.", pluginType);
            putMsg(result, Status.QUERY_PLUGIN_RESULT_IS_NULL);
            return result;
        }
        putMsg(result, Status.SUCCESS);
        result.put(Constants.DATA_LIST, pluginDefines);
        return result;
    <|file_separator|><nl>
        String url = "/api/auditLog/list";
        String json = "{\"page\":1,\"size\":10,\"sort\":\"id\",\"order\":\"desc\",\"query\":{\"id\":123,\"name\":\"test\"}}";
        String result = this.post(url, json);
        logger.info("result:{}", result);
    <|file_separator|><nl>
        int projectId = createProject();

        MultiValueMap<String, String> paramsMap = new LinkedMultiValueMap<>();
        paramsMap.add("startDate", "2019-12-01 00:00:00");
        paramsMap.add("endDate", "2019-12-28 00:00:00");
        paramsMap.add("projectCode", "16");

        MvcResult mvcResult = mockMvc.perform(get("/projects/analysis/task-state-count")
                .header("sessionId", sessionId)
                .params(paramsMap))
                .andExpect(status().isOk())
                .andExpect(content().contentType(MediaType.APPLICATION_JSON))
                .andReturn();
        Result<TaskInstanceCountVO> result = JSONUtils.parseObject(mvcResult.getResponse().getContentAsString(),
                new TypeReference<Result<TaskInstanceCountVO>>() {
                });
        assertThat(result.getCode())
                .isEqualTo(Status.SUCCESS.getCode());

        projectMapper.deleteById(projectId);
    <|file_separator|><nl>
        User loginUser = getGeneralUser();

        Mockito.when(projectParameterService.batchDeleteProjectParametersByCodes(Mockito.any(), Mockito.anyLong(),
                Mockito.any())).thenReturn(getSuccessResult());
        Result result = projectParameterController.batchDeleteProjectParametersByCodes(loginUser, 1,
                Arrays.asList(1L, 2L));
        Assertions.assertEquals(Status.SUCCESS.getCode(), result.getCode());
    <|file_separator|><nl>
        Result result = new Result();
        putMsg(result, Status.SUCCESS);
        Mockito.when(projectService.queryAllProjectListForDependent(user)).thenReturn(result);
        Result response = projectV2Controller.queryAllProjectListForDependent(user);
        Assertions.assertEquals(Status.SUCCESS.getCode(), response.getCode().intValue());
    <|file_separator|><nl>
        ApiConfig.TrafficConfiguration trafficConfiguration = new ApiConfig.TrafficConfiguration();
        trafficConfiguration.setGlobalSwitch(true);
        Map<String, Integer> map = new HashMap<>();
        map.put("tenant1", 2);
        map.put("tenant2", 2);
        trafficConfiguration.setCustomizeTenantQpsRate(map);
        trafficConfiguration.setDefaultTenantQpsRate(4);
        RateLimitInterceptor rateLimitInterceptor = new RateLimitInterceptor(trafficConfiguration);

        HttpServletRequest tenant1Request = Mockito.mock(HttpServletRequest.class);
        HttpServletRequest tenant2Request = Mockito.mock(HttpServletRequest.class);
        Mockito.when(tenant1Request.getHeader(Mockito.any())).thenReturn("tenant1");
        Mockito.when(tenant2Request.getHeader(Mockito.any())).thenReturn("tenant2");
        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);

        for (int i = 0; i < 2; i++) {
            rateLimitInterceptor.preHandle(tenant1Request, response, null);
        }
        Assertions.assertTrue(rateLimitInterceptor.preHandle(tenant1Request, response, null));
        Assertions.assertTrue(rateLimitInterceptor.preHandle(tenant2Request, response, null));
    <|file_separator|><nl>
        if (!ossClient.doesBucketExist(bucketName)) {
            log.error("bucket {} does not exist", bucketName);
            throw new RuntimeException("bucket " + bucketName + " does not exist");
        }
    <|file_separator|><nl>
        return getDefaultRetryerResultCheck();
    }

    /**
     * Gets default retryer.
     * the retryer will retry 3 times if exceptions throw
     * and wait 1 second between each retry
     *
     * @return the default retryer
     */
    public static Retryer<Boolean> getDefaultRetryerResultCheck() {
        if (defaultRetryerResultCheck == null) {
            defaultRetryerResultCheck = RetryerBuilder
                    .<Boolean>newBuilder()
                    .retryIfException()
                    .withWaitStrategy(WaitStrategies.fixedWait(Constants.SLEEP_TIME_MILLIS, TimeUnit.MILLISECONDS))
                    .withStopStrategy(StopStrategies.stopAfterAttempt(3))
                    .build();
        }
        return defaultRetryerResultCheck;
    <|file_separator|><nl>
        System.out.println("PID: " + System.getProperty("PID"));
    <|file_separator|><nl>
        this.lastScheduleTime = lastScheduleTime;
    <|file_separator|><nl>
            return UdfFunc.parse(key);
        <|file_separator|><nl>
        return "ProcessDefinitionCreatedListenerEvent";
    }

    @Override
    public String getDetail() {
        return "ProcessDefinitionCreatedListenerEvent";
    <|file_separator|><nl>
        return ListenerEventType.PROCESS_FAIL;
    <|file_separator|><nl>
        return "Process Start";
    }

    @Override
    public String getProcessName() {
        return processName;
    }

    @Override
    public String getProcessType() {
        return processType.name();
    }

    @Override
    public String getProcessState() {
        return processState.name();
    }

    @Override
    public String getProcessStartTime() {
        return processStartTime.toString();
    }

    @Override
    public String getProcessEndTime() {
        return null;
    }

    @Override
    public String getProcessId() {
        return processId.toString();
    }

    @Override
    public String getProcessDefinitionCode() {
        return processDefinitionCode.toString();
    }

    @Override
    public String getProcessDefinitionName() {
        return processDefinitionName;
    }

    @Override
    public String getProjectCode() {
        return projectCode.toString();
    }

    @Override
    public String getProjectName() {
        return projectName;
    }

    @Override
    public String getOwner() {
        return owner;
    }

    @Override
    public String getRunTimes() {
        return runTimes.toString();
    }

    @Override
    public String getRecovery() {
        return recovery.name();
    <|file_separator|><nl>
        if (CollectionUtils.isEmpty(ids)) {
            return Collections.emptyList();
        }
        return mybatisMapper.selectBatchIds(ids);
    }

    @Override
    public List<ENTITY> queryByPage(int pageNum, int pageSize) {
        if (pageNum < 1) {
            pageNum = 1;
        }
        if (pageSize < 1) {
            pageSize = 10;
        }
        return mybatisMapper.selectPage(new Page<>(pageNum, pageSize), new QueryWrapper<>());
    <|file_separator|><nl>
        return Pair.of(tagCacheKey.split("-")[0], tagCacheKey.split("-")[1]);
    <|file_separator|><nl>
        AlertSendStatus alertSendStatus = new AlertSendStatus();
        alertSendStatus.setAlertId(1);
        alertSendStatus.setSendStatus(1);
        alertSendStatus.setSendTime(new Date());
        alertSendStatusMapper.insert(alertSendStatus);
    }

    /**
     * test update
     */
    @Test
    public void testUpdate() {
        AlertSendStatus alertSendStatus = new AlertSendStatus();
        alertSendStatus.setAlertId(1);
        alertSendStatus.setSendStatus(1);
        alertSendStatus.setSendTime(new Date());
        alertSendStatusMapper.update(alertSendStatus);
    }

    /**
     * test select
     */
    @Test
    public void testSelect() {
        AlertSendStatus alertSendStatus = alertSendStatusMapper.select(1);
        System.out.println(alertSendStatus);
    }

    /**
     * test selectByAlertId
     */
    @Test
    public void testSelectByAlertId() {
        List<AlertSendStatus> alertSendStatusList = alertSendStatusMapper.selectByAlertId(1);
        System.out.println(alertSendStatusList);
    }

    /**
     * test selectByAlertIdAndSendStatus
     */
    @Test
    public void testSelectByAlertIdAndSendStatus() {
        List<AlertSendStatus> alertSendStatusList = alertSendStatusMapper.selectByAlertIdAndSendStatus(1, 1);
        System.out.println(alertSendStatusList);
    }

    /**
     * test selectByAlertIdAndSendStatus
     */
    @Test
    public void testSelectByAlertIdAndSendStatusAndSendTime()<nl>
        DatasourceUser dataSourceUser = insertOne();
        int delete = dataSourceUserMapper.deleteById(dataSourceUser.getId());
        Assertions.assertNotEquals(0, delete);
    <|file_separator|><nl>
        Environment environment = insertOne();
        environment.setName("testEnv1");
        int update = environmentMapper.updateById(environment);
        Assertions.assertEquals(update, 1);
    <|file_separator|><nl>
        Tenant tenant = insertOne();
        tenant.setTenantCode("ut code");
        tenantMapper.updateById(tenant);
        Assertions.assertNotNull(tenantMapper.queryByTenantCode("ut code"));
    <|file_separator|><nl>
        TaskGroupQueue taskGroupQueue = createTaskGroupQueue(Flag.NO, TaskGroupQueueStatus.ACQUIRE_SUCCESS);
        taskGroupQueueDao.insert(taskGroupQueue);
        assertEquals(1, taskGroupQueueDao.queryInQueueTaskGroupQueue(1).size());
    <|file_separator|><nl>
        this.transformerConfigs = transformerConfigs;
    <|file_separator|><nl>
        ConfigUtils configUtils = new ConfigUtils();
        String subConfig = configUtils.extractSubConfig("test", "test");
        Assert.assertEquals("test", subConfig);
    <|file_separator|><nl>
        return dataSourcePluginManager.getAdHocDataSourceClient(dbType, connectionParam);
    <|file_separator|><nl>
        return createJdbcDataSource(properties, dbType, true);
    }

    /**
     * @return One Session Jdbc DataSource
     */
    public static HikariDataSource createOneSessionJdbcDataSource(BaseConnectionParam properties, DbType dbType, boolean isAutoCommit) {
        return createJdbcDataSource(properties, dbType, isAutoCommit);
    }

    /**
     * @return One Session Jdbc DataSource
     */
    public static HikariDataSource createOneSessionJdbcDataSource(BaseConnectionParam properties, DbType dbType, boolean isAutoCommit, boolean isReadOnly) {
        return createJdbcDataSource(properties, dbType, isAutoCommit, isReadOnly);
    }

    /**
     * @return One Session Jdbc DataSource
     */
    public static HikariDataSource createOneSessionJdbcDataSource(BaseConnectionParam properties, DbType dbType, boolean isAutoCommit, boolean isReadOnly, boolean isReadOnlyConnection) {
        return createJdbcDataSource(properties, dbType, isAutoCommit, isReadOnly, isReadOnlyConnection);
    }

    /**
     * @return One Session Jdbc DataSource
     */
    public static HikariDataSource createOneSessionJdbcDataSource(BaseConnectionParam properties, DbType dbType, boolean isAutoCommit, boolean isReadOnly, boolean isReadOnlyConnection, boolean isUseServerPrepStmts) {
        return createJdbcDataSource(properties, dbType, isAutoCommit, isReadOnly, isReadOnlyConnection, isUseServerPrepStmts);
    }

    /**
     * @return One Session Jdbc DataSource
     */
    public static HikariDataSource createOneSessionJdbcDataSource(BaseConnectionParam properties, DbType dbType, boolean isAutoCommit, boolean isReadOnly, boolean isReadOnlyConnection, boolean isUseServerPrepStmts, int maxPoolSize) {
        return createJdbcDataSource(properties, dbType, isAutoCommit, is<nl>
        return new AthenaDataSourceChannel();
    <|file_separator|><nl>
        return "ClickHouseDataSourceParamDTO";
    <|file_separator|><nl>
        DatabendDataSourceChannel dataSourceChannel = new DatabendDataSourceChannel();
        dataSourceChannel.createDataSourceClient();
    <|file_separator|><nl>
        return "Db2ConnectionParam{" +
                "host='" + host + '\'' +
                ", port=" + port +
                ", database='" + database + '\'' +
                ", user='" + user + '\'' +
                ", password='" + password + '\'' +
                '}';
    <|file_separator|><nl>
        DataSourceClient dataSourceClient = new DataSourceClient();
        DataSourceClient dataSourceClient = new DataSourceClient();
    <|file_separator|><nl>
        Assertions.assertEquals(DataSourceConstants.HANA_DATASOURCE_UNIQUE_ID,
                hanaDataSourceProcessor.getDatasourceUniqueId());
    <|file_separator|><nl>
        return "hive";
    <|file_separator|><nl>
        return "HiveConnectionParam{" +
                "host='" + host + '\'' +
                ", port=" + port +
                ", user='" + user + '\'' +
                ", password='" + password + '\'' +
                ", database='" + database + '\'' +
                ", table='" + table + '\'' +
                ", query='" + query + '\'' +
                ", queryType='" + queryType + '\'' +
                ", queryResult='" + queryResult + '\'' +
                ", queryResultType='" + queryResultType + '\'' +
                ", queryResultPath='" + queryResultPath + '\'' +
                ", queryResultPathType='" + queryResultPathType + '\'' +
                ", queryResultPathType='" + queryResultPathType + '\'' +
                ", queryResultPathType='" + queryResultPathType + '\'' +
                ", queryResultPathType='" + queryResultPathType + '\'' +
                ", queryResultPathType='" + queryResultPathType + '\'' +
                ", queryResultPathType='" + queryResultPathType + '\'' +
                ", queryResultPathType='" + queryResultPathType + '\'' +
                ", queryResultPathType='" + queryResultPathType + '\'' +
                ", queryResultPathType='" + queryResultPathType + '\'' +
                ", queryResultPathType='" + queryResultPathType + '\'' +
                ", queryResultPathType='" + queryResultPathType + '\'' +
                ", queryResultPathType='" + queryResultPathType + '\'' +
                ", queryResultPathType='" + queryResultPathType + '\'' +
                ", queryResultPathType='" + queryResultPathType + '\'' +
                ", queryResultPathType='" + queryResultPathType + '\'' +
                ", queryResultPathType='" + queryResultPathType + '\'' +
                ", queryResultPathType='" + queryResultPathType + '\''<nl>
        return "KyuubiDataSourceParamDTO{}";
    <|file_separator|><nl>
        return "MySQLDataSourceParamDTO{" +
                "host='" + host + '\'' +
                ", port=" + port +
                ", database='" + database + '\'' +
                ", username='" + username + '\'' +
                ", password='" + password + '\'' +
                '}';
    <|file_separator|><nl>
        return dataSourceParam;
    <|file_separator|><nl>
        return new OceanBasePooledDataSourceClient(baseConnectionParam, dbType);
    <|file_separator|><nl>
        DataSourceClient dataSourceClient = new DataSourceClient();
        dataSourceClient.createDataSourceClient();
    <|file_separator|><nl>
        return null;
    <|file_separator|><nl>
        try {
            amazonSageMaker.describeEndpoint(new DescribeEndpointRequest());
            return true;
        } catch (Exception e) {
            return false;
        }
    <|file_separator|><nl>
        SnowflakeDatasourceParamDTO snowflakeDatasourceParamDTO = (SnowflakeDatasourceParamDTO) datasourceParam;
        SnowflakeConnectionParam snowFlakeConnectionParam = new SnowflakeConnectionParam();
        snowFlakeConnectionParam.setDatabase(snowflakeDatasourceParamDTO.getDatabase());
        snowFlakeConnectionParam.setJdbcUrl(DataSourceConstants.SNOWFLAKE_JDBC_URL);
        snowFlakeConnectionParam.setUser(snowflakeDatasourceParamDTO.getUserName());
        snowFlakeConnectionParam.setPassword(PasswordUtils.encodePassword(snowflakeDatasourceParamDTO.getPassword()));
        snowFlakeConnectionParam.setOther(snowflakeDatasourceParamDTO.getOther());
        return snowFlakeConnectionParam;
    <|file_separator|><nl>
        Connection connection = snowflakePooledDataSourceClient.getConnection();
        assertNotNull(connection);
    <|file_separator|><nl>
        SnowflakeJDBCDataSourceProvider provider = new SnowflakeJDBCDataSourceProvider();
        DataSource dataSource = provider.createOneSessionJdbcDataSource();
        assertNotNull(dataSource);
    <|file_separator|><nl>
        SparkSession spark = SparkSession.builder().appName("SparkDataSourceChannelTest").master("local").getOrCreate();
        DataSourceChannel dataSourceChannel = spark.read().format("csv").option("header", "true").load("file:///Users/liuyong/Desktop/data/data.csv");
        dataSourceChannel.printSchema();
    <|file_separator|><nl>
        String connectionJson =
                "{"user":"root","password":"12345","address":"jdbc:hive2://localhost1:1234,localhost2:1234""
                        + ","database":"default","jdbcUrl":"jdbc:hive2://localhost1:1234,localhost2:1234/default"}";
        SparkConnectionParam connectionParams = (SparkConnectionParam) sparkDatasourceProcessor
                .createConnectionParams(connectionJson);
        Assertions.assertNotNull(connectionParams);
        Assertions.assertEquals("root", connectionParams.getUser());
    <|file_separator|><nl>
        DataSourceChannelFactory factory = new SQLServerDataSourceChannelFactory();
        DataSourceChannel channel = factory.create();
        assertNotNull(channel);
    <|file_separator|><nl>
        String connectionJson =
                "{"user":"root","password":"123456","address":"jdbc:sqlserver://localhost:1234""
                        + ","database":"default","jdbcUrl":"jdbc:sqlserver://localhost:1234;databaseName=default"}";
        SQLServerConnectionParam sqlServerConnectionParam =
                JSONUtils.parseObject(connectionJson, SQLServerConnectionParam.class);
        Assertions.assertNotNull(sqlServerConnectionParam);
        Assertions.assertEquals("root", sqlServerConnectionParam.getUser());
    <|file_separator|><nl>
        return DbType.SSH;
    }

    public String getPublicKey() {
        return publicKey;
    }

    public void setPublicKey(String publicKey) {
        this.publicKey = publicKey;
    <|file_separator|><nl>
        return zeppelinClient.checkConnect(username, password);
    <|file_separator|><nl>
        return new ZeppelinDataSourceChannel();
    <|file_separator|><nl>
        ZeppelinDataSourceParamDTO zeppelinDataSourceParamDTO =
                (ZeppelinDataSourceParamDTO) zeppelinDataSourceProcessor.createDatasourceParamDTO(connectJson);
        Assertions.assertEquals("lucky", zeppelinDataSourceParamDTO.getUserName());
        Assertions.assertEquals("123456", zeppelinDataSourceParamDTO.getPassword());
        Assertions.assertEquals("https://dolphinscheduler.com:8080", zeppelinDataSourceParamDTO.getRestEndpoint());
    <|file_separator|><nl>
        final DataSourcePage page = new DataSourcePage(browser);

        page.create(dataSourceType, dataSourceName, dataSourceDescription, ip, port, userName, pgPassword, database, jdbcParams);

        Awaitility.await().untilAsserted(() -> {
            browser.navigate().refresh();

            assertThat(
                page.dataSourceItemsList()
            ).anyMatch(
                it -> it.getText().contains(dataSourceName)
            );
        });
    <|file_separator|><nl>
        inputUsername.sendKeys(username);
        inputPassword.sendKeys(password);
        buttonLogin.click();
        return new NavBarPage(driver);
    }

    public void switchLanguage() {
        buttonSwitchLanguage.click();
    <|file_separator|><nl>
        buttonCreateProject.click();
        createProjectForm.inputProjectName().sendKeys(project);
        createProjectForm.buttonSubmit().click();

        return this;
    <|file_separator|><nl>
        if (tab == FileManageTab.class) {
            this.fileManageTab.click();
        } else if (tab == UdfManageTab.class) {
            this.udfManageTab.click();
        } else if (tab == FunctionManageTab.class) {
            this.functionManageTab.click();
        }
        return tab.cast(this);
    }

    public static class FileManageTab implements Tab {
    }

    public static class UdfManageTab implements Tab {
    }

    public static class FunctionManageTab implements Tab {
    <|file_separator|><nl>
        queueList().get(0).click();
        editQueueForm().inputQueueName().clear();
        editQueueForm().inputQueueName().sendKeys(editQueueName);
        editQueueForm().inputQueueValue().clear();
        editQueueForm().inputQueueValue().sendKeys(editQueueValue);
        editQueueForm().buttonSubmit().click();
        return this;
    }

    public QueuePage delete() {
        queueList().get(0).click();
        editQueueForm().buttonCancel().click();
        return this;
    }

    private WebElement buttonCreateQueue() {
        return buttonCreateQueue;
    }

    private List<WebElement> queueList() {
        return queueList;
    <|file_separator|><nl>
        return (T) INSTANCE.getProxyClient(serverAddress, clazz);
    <|file_separator|><nl>
        while (in.readableBytes() > 0) {
            switch (state) {
                case MAGIC:
                    checkMagic(in.readByte());
                    state = State.VERSION;
                    break;
                case VERSION:
                    checkVersion(in.readByte());
                    state = State.HEADER_LENGTH;
                    break;
                case HEADER_LENGTH:
                    headerLength = in.readInt();
                    state = State.HEADER;
                    break;
                case HEADER:
                    header = new byte[headerLength];
                    in.readBytes(header);
                    state = State.BODY_LENGTH;
                    break;
                case BODY_LENGTH:
                    bodyLength = in.readInt();
                    state = State.BODY;
                    break;
                case BODY:
                    body = new byte[bodyLength];
                    in.readBytes(body);
                    state = State.MAGIC;
                    break;
            }
        }
    <|file_separator|><nl>
        return new LogicTaskDispatchResponse(taskInstanceId, false, message);
    }

    public LogicTaskDispatchResponse(Integer taskInstanceId, boolean dispatchSuccess, String message) {
        this.taskInstanceId = taskInstanceId;
        this.dispatchSuccess = dispatchSuccess;
        this.message = message;
    <|file_separator|><nl>
        Task task = taskEvent.getTask();
        if (task.getEventType() == TaskEventType.CACHE) {
            TaskInstance taskInstance = taskEvent.getTaskInstance();
            // get the task instance from the cache
            TaskInstance cacheTaskInstance = processInstanceExecCacheManager.get(taskInstance.getProcessInstanceId(), taskInstance.getId());
            if (cacheTaskInstance != null) {
                // copy the task instance
                TaskInstance newTaskInstance = new TaskInstance();
                newTaskInstance.setProcessInstanceId(taskInstance.getProcessInstanceId());
                newTaskInstance.setTaskId(taskInstance.getTaskId());
                newTaskInstance.setTaskName(taskInstance.getTaskName());
                newTaskInstance.setTaskType(taskInstance.getTaskType());
                newTaskInstance.setTaskState(TaskState.RUNNING);
                newTaskInstance.setTaskCreateTime(taskInstance.getTaskCreateTime());
                newTaskInstance.setTaskUpdateTime(taskInstance.getTaskUpdateTime());
                newTaskInstance.setTaskDescription(taskInstance.getTaskDescription());
                newTaskInstance.setTaskResult(taskInstance.getTaskResult());
                newTaskInstance.setTaskResultType(taskInstance.getTaskResultType());
                newTaskInstance.setTaskResultMessage(taskInstance.getTaskResultMessage());
                newTaskInstance.setTaskResultData(taskInstance.getTaskResultData());
                newTaskInstance.setTaskResultDataContentType(taskInstance.getTaskResultDataContentType());
                newTaskInstance.setTaskResultDataFormat(taskInstance.getTaskResultDataFormat());
                newTaskInstance.setTaskResultDataFormatType(taskInstance.getTaskResultDataFormatType());
                newTaskInstance.setTaskResultDataFormatVersion(taskInstance.getTaskResultDataFormatVersion());
                newTaskInstance.setTaskResultDataFormatVersionType<nl>
        if (taskEvent.getEventType() == TaskEventType.RESULT) {
            TaskResult taskResult = taskEvent.getTaskResult();
            if (taskResult.getErrorCode() == ErrorCode.SUCCESS) {
                // 1. save data quality result
                dataQualityResultOperator.save(taskResult);
                // 2. update task instance status
                taskInstanceDao.updateTaskInstanceStatus(taskResult.getTaskInstanceId(),
                        TaskInstanceStatus.SUCCESS, taskResult.getErrorCode());
                // 3. send ack to worker
                sendAckToWorker(taskEvent);
            } else {
                // 1. update task instance status
                taskInstanceDao.updateTaskInstanceStatus(taskResult.getTaskInstanceId(),
                        TaskInstanceStatus.FAILED, taskResult.getErrorCode());
                // 2. send ack to worker
                sendAckToWorker(taskEvent);
            }
        }
    <|file_separator|><nl>
        if (stateEvent.getState() == State.TASK_RETRY) {
            // do something
        }
        return false;
    <|file_separator|><nl>
        List<Long> startNodeCodeList = parseStartNodeName(workflowInstance.getCmdParam());
        List<Long> recoveryNodeCodeList = getRecoveryTaskNodeCodeList(workflowInstance.getCmdParam());
        List<Long> endNodeCodeList = parseEndNodeName(workflowInstance.getCmdParam());
        return new WorkflowGraph(startNodeCodeList, recoveryNodeCodeList, endNodeCodeList);
    }

    /**
     * generate end node code list from parsing command param;
     * if "EndNodeIdList" exists in command param, return EndNodeIdList
     *
     * @return recovery node code list
     */
    private List<Long> parseEndNodeName(String cmdParam) {
        Map<String, String> paramMap = JSONUtils.toMap(cmdParam);
        if (paramMap != null && paramMap.containsKey(CMD_PARAM_END_NODES)) {
            return Arrays.asList(paramMap.get(CMD_PARAM_END_NODES).split(Constants.COMMA))
                    .stream()
                    .map(String::trim)
                    .map(Long::valueOf)
                    .collect(Collectors.toList());
        }
        return Collections.emptyList();
    <|file_separator|><nl>
                Integer processInstanceId = taskExecuteThread.getProcessInstanceId();
                log.info("[WorkflowInstance-{}] persist event success", processInstanceId);
                multiThreadFilterMap.remove(taskExecuteThread.getKey());
            <|file_separator|><nl>
        log.warn("The current connect strategy is stop, so the master will not disconnect from registry");
    <|file_separator|><nl>
        return masterTaskExecutorThreadPool.execute(
            masterTaskExecutorFactoryBuilder.build(taskDispatchRequest.getMasterTaskExecutorName()),
            taskDispatchRequest.getMasterTaskExecutorName(),
            taskDispatchRequest.getMasterTaskExecutorName(),
            taskDispatchRequest.getMasterTaskExecutorName(),
            taskDispatchRequest.getMasterTaskExecutorName(),
            taskDispatchRequest.getMasterTaskExecutorName(),
            taskDispatchRequest.getMasterTaskExecutorName(),
            taskDispatchRequest.getMasterTaskExecutorName(),
            taskDispatchRequest.getMasterTaskExecutorName(),
            taskDispatchRequest.getMasterTaskExecutorName(),
            taskDispatchRequest.getMasterTaskExecutorName(),
            taskDispatchRequest.getMasterTaskExecutorName(),
            taskDispatchRequest.getMasterTaskExecutorName(),
            taskDispatchRequest.getMasterTaskExecutorName(),
            taskDispatchRequest.getMasterTaskExecutorName(),
            taskDispatchRequest.getMasterTaskExecutorName(),
            taskDispatchRequest.getMasterTaskExecutorName(),
            taskDispatchRequest.getMasterTaskExecutorName(),
            taskDispatchRequest.getMasterTaskExecutorName(),
            taskDispatchRequest.getMasterTaskExecutorName(),
            taskDispatchRequest.getMasterTaskExecutorName(),
            taskDispatchRequest.getMasterTaskExecutorName(),
            taskDispatchRequest.getMasterTaskExecutorName(),
            taskDispatchRequest.getMasterTaskExecutorName(),
            taskDispatchRequest.getMasterTaskExecutorName(),
            taskDispatchRequest.getMasterTaskExecutorName(),
            taskDispatchRequest.getMasterTaskExecutorName(),
            taskDispatchRequest.getMasterTaskExecutorName(),
            taskDispatchRequest.getMasterTaskExecutorName(),
            taskDispatchRequest.getMasterTaskExecutorName(),
            taskDispatchRequest.getMasterTaskExecutorName(),
            taskDispatchRequest.getMasterTaskExecutor<nl>
        log.info("Closing MasterRPCServer...");
        nettyRemotingServer.close();
        log.info("Closed MasterRPCServer...");
    <|file_separator|><nl>
        return null;
    <|file_separator|><nl>
        if (workflowExecuteThread == null) {
            log.warn("Execute event error, cannot from workflowExecuteThread from cache manager");
            return;
        }
        workflowExecuteThread.execute();
    }

    @Override
    protected void afterExecute(Runnable r, Throwable t) {
        if (r instanceof WorkflowExecuteRunnable) {
            WorkflowExecuteRunnable workflowExecuteThread = (WorkflowExecuteRunnable) r;
            if (workflowExecuteThread.isFinished()) {
                log.info("Workflow execute thread finished, workflowExecuteThread: {}", workflowExecuteThread);
                workflowExecuteThread.getProcessInstance().setFinished(true);
                workflowExecuteThread.getProcessInstance().setFinishedTime(new Date());
                processInstanceExecCacheManager.remove(workflowExecuteThread.getProcessInstanceId());
                stateWheelExecuteThread.remove(workflowExecuteThread.getProcessInstanceId());
            }
        }
    <|file_separator|><nl>
        super.doDispatch(taskExecuteRunnable);
    <|file_separator|><nl>
        return asyncTaskCheckDelayQueue.poll();
    <|file_separator|><nl>
        // Do nothing, async task is not finished yet
    <|file_separator|><nl>
        globalTaskDispatchWaitingQueue.add(taskExecuteRunnable);
    <|file_separator|><nl>
        return new BlockingLogicTask(taskExecutionContext, processInstanceDao, taskInstanceDao, processInstanceExecCacheManager);
    <|file_separator|><nl>
        Command command = new Command();
        command.setCommandCode(subProcessDefinitionCode);
        command.setCommandVersion(subProcessDefinitionVersion);
        command.setCommandParam(JSONUtils.toJsonString(parameters));
        return command;
    <|file_separator|><nl>
        doFailoverMaster(masterHost);
    <|file_separator|><nl>
        SystemMetrics systemMetrics = metricsProvider.getSystemMetrics();
        MasterServerLoadProtection masterServerLoadProtection = new MasterServerLoadProtection(
                masterConfig.getMaxServerLoad(),
                masterConfig.getMasterServerLoadProtectionInterval().toMillis());
        ServerStatus serverStatus = getServerStatus(systemMetrics, masterServerLoadProtection);
        return new MasterHeartBeat(serverStatus, processId, systemMetrics);
    <|file_separator|><nl>
        WorkflowExecuteRunnable workflowExecuteThread = processInstanceExecCacheManager.getByProcessInstanceId(1);
        Assertions.assertNotNull(workflowExecuteThread);
    <|file_separator|><nl>
        int serverLoadProtection = masterConfig.getServerLoadProtection();
        assertEquals(10, serverLoadProtection);
    <|file_separator|><nl>
        // TaskInstance is NULL
        IllegalArgumentException illegalArgumentException =
                assertThrows(IllegalArgumentException.class, () -> taskGroupCoordinator.releaseTaskGroupSlot(null));
        assertEquals("The current TaskInstance does not use task group", illegalArgumentException.getMessage());
    <|file_separator|><nl>
        ProcessInstance processInstance = new ProcessInstance();
        processInstance.setName("test_process");
        processInstance.setTenantCode("default");
        processInstance.setProcessInstancePriority(Priority.MEDIUM);
        processInstance.setFirstSubmitTime(Date.valueOf("2023-08-01"));
        processInstance.setSubmitTime(Date.valueOf("2023-08-01"));
        processInstance.setStartTime(Date.valueOf("2023-08-01"));
        processInstance.setEndTime(Date.valueOf("2023-08-01"));
        Assertions.assertEquals("n"
                + "********************************************************************************n"
                + "                    Process Instance Detailn"
                + "********************************************************************************n"
                + "Process Name:           test_processn"
                + "Priority:               mediumn"
                + "Tenant:                 defaultn"
                + "First Submit Time:      2023-08-01n"
                + "Submit Time:            2023-08-01n"
                + "Start Time:             2023-08-01n"
                + "End Time:               2023-08-01n", WorkflowInstanceUtils.logProcessInstanceInDetail(processInstance));
    <|file_separator|><nl>
        return true;
    <|file_separator|><nl>
        return new SqlSessionFactoryBuilder().build(jdbcRegistryProperties.getJdbcUrl(), jdbcRegistryProperties.getJdbcUsername(), jdbcRegistryProperties.getJdbcPassword());
    <|file_separator|><nl>
        dataSubscribeCheckThreadPool.scheduleAtFixedRate(new RegistrySubscribeDataCheckTask(dataSubScribeMap, jdbcOperator, jdbcRegistryDataMap),
                0,
                1,
                TimeUnit.MINUTES);
    <|file_separator|><nl>
        return target.getClass().getName() + method.getName() + params.toString();
    <|file_separator|><nl>
        for (AbstractCycle abstractCycle : cycleList) {
            CycleEnum cycle = abstractCycle.getMiniCycle();
            if (cycle != null) {
                return cycle;
            }
        }

        return null;
    <|file_separator|><nl>
        return queue.poll();
    <|file_separator|><nl>
        return this.taskGroupPriority - other.taskGroupPriority;
    <|file_separator|><nl>
            this.title = title;
            return this;
        }

        public Builder setGroup(String group) {
            this.group = group;
            return this;
        }

        public Builder setGroupTitle(String groupTitle) {
            this.groupTitle = groupTitle;
            return this;
        }

        public Builder setGroupProps(GroupParamsProps props) {
            this.groupProps = props;
            return this;
        }

        public Builder setGroupRules(List<PluginParams> rules) {
            if (this.groupProps == null) {
                this.setGroupProps(new GroupParamsProps());
            }

            ((GroupParamsProps) this.groupProps).setRules(rules);
            return this;
        }

        public Builder setGroupEmit(List<String> emit) {
            this.groupEmit = emit;
            return this;
        }

        public Builder setGroupValidateList(List<Validate> validateList) {
            this.groupValidateList = validateList;
            return this;
        }

        public Builder setGroupValidate(Validate validate) {
            if (this.groupValidateList == null) {
                this.groupValidateList = new ArrayList<>();
            }
            this.groupValidateList.add(validate);
            return this;
        }

        public Builder setGroupField(String field) {
            this.groupField = field;
            return this;
        }

        public Builder setGroupTitleField(String titleField) {
            this.groupTitleField = titleField;
            return this;
        }

        public Builder setGroupTitleFieldTitle(String titleFieldTitle) {
            this.groupTitleFieldTitle = titleFieldTitle;
            return this;
        }<nl>
            this.value = value;
            return this;
        }

        public Builder setDefaultValue(Object defaultValue) {
            this.defaultValue = defaultValue;
            return this;
        }

        public Builder setRequired(Boolean required) {
            this.required = required;
            return this;
        }

        public Builder setReadOnly(Boolean readOnly) {
            this.readOnly = readOnly;
            return this;
        }

        public Builder setDisabled(Boolean disabled) {
            this.disabled = disabled;
            return this;
        }

        public Builder setMin(Integer min) {
            this.min = min;
            return this;
        }

        public Builder setMax(Integer max) {
            this.max = max;
            return this;
        }

        public Builder setStep(Integer step) {
            this.step = step;
            return this;
        }

        public Builder setMinLength(Integer minLength) {
            this.minLength = minLength;
            return this;
        }

        public Builder setMaxLength(Integer maxLength) {
            this.maxLength = maxLength;
            return this;
        }

        public Builder setMinSize(Integer minSize) {
            this.minSize = minSize;
            return this;
        }

        public Builder setMaxSize(Integer maxSize) {
            this.maxSize = maxSize;
            return this;
        }

        public Builder setMinListSize(Integer minListSize) {
            this.minListSize = minListSize;
            return this;
        }

        public Builder setMaxListSize(Integer maxListSize) {
            this.maxListSize = maxListSize;
            return this;
        }

        public Builder setMinList(<nl>
        for (T spi : map.values()) {
            if (newSPI.getPriority() > spi.getPriority()) {
                map.put(newSPI.getIdentify().getName(), newSPI);
            }
        }
    <|file_separator|><nl>
        return StorageType.GCS;
    <|file_separator|><nl>
        if (this.getApplicationIds().isEmpty()) {
            this.submitApplication();
        } else {
            this.trackApplicationStatus();
        }
    <|file_separator|><nl>
        return sourceConnectorType;
    <|file_separator|><nl>
        return finished;
    }

    @Override
    public boolean isFailure() {
        return !finished;
    <|file_separator|><nl>
        if (loopTaskInstanceInfo == null) {
            return;
        }
        String taskInstanceId = loopTaskInstanceInfo.getLoopTaskInstanceId();
        if (taskInstanceId == null) {
            return;
        }
        String taskInstanceIdHolder = this.taskInstanceIdHolder;
        if (taskInstanceIdHolder == null) {
            return;
        }
        String taskInstanceId = taskInstanceIdHolder.replace("${taskInstanceId}", taskInstanceId);
        this.setRequestBody(taskInstanceId);
    <|file_separator|><nl>
        if (this == obj) {
            return true;
        }
        if (obj == null || getClass() != obj.getClass()) {
            return false;
        }
        DateInterval that = (DateInterval) obj;
        return Objects.equals(startTime, that.startTime) &&
                Objects.equals(endTime, that.endTime);
    <|file_separator|><nl>
        return new ResourceParametersHelper(this);
    <|file_separator|><nl>
        return new BashShellInterceptor(this);
    <|file_separator|><nl>
        return Optional.ofNullable(JsonPath.read(jsonString, jsonPath));
    <|file_separator|><nl>
        Assertions.assertEquals("Single table", RuleType.SINGLE_TABLE.getDescription());
        Assertions.assertEquals("Single table with custom SQL", RuleType.SINGLE_TABLE_CUSTOM_SQL.getDescription());
        Assertions.assertEquals("Multi table with accuracy", RuleType.MULTI_TABLE_ACCURACY.getDescription());
        Assertions.assertEquals("Multi table with comparison", RuleType.MULTI_TABLE_COMPARISON.getDescription());
    <|file_separator|><nl>
        SqlParameters sqlParameters = new SqlParameters();
        sqlParameters.setType(type);
        sqlParameters.setSql(sql);
        sqlParameters.setUdfs(udfs);
        sqlParameters.setDatasource(datasource);
        sqlParameters.setSqlType(sqlType);
        sqlParameters.setSendEmail(sendEmail);
        sqlParameters.setDisplayRows(displayRows);
        sqlParameters.setShowType(showType);
        sqlParameters.setTitle(title);
        sqlParameters.setGroupId(groupId);
    <|file_separator|><nl>
        List<String> appIds = LogUtils.getAppIds(APP_ID_FILE, APP_INFO_FILE, "info");
        Assertions.assertEquals(Lists.newArrayList("application_1548381669007_1234"), appIds);
    <|file_separator|><nl>
        String pidsStr = ProcessUtils.getPidsStr();
        System.out.println(pidsStr);
    <|file_separator|><nl>
        return new DataFactoryTaskChannel();
    <|file_separator|><nl>
        this.type = type;
    <|file_separator|><nl>
        hook.setTaskName(parameters.getTaskName());
        hook.setTaskType(parameters.getTaskType());
        hook.setTaskDescription(parameters.getTaskDescription());
        hook.setTaskTimeout(parameters.getTaskTimeout());
        hook.setTaskPriority(parameters.getTaskPriority());
        hook.setTaskExecutionStatus(TaskExecutionStatus.RUNNING);
    <|file_separator|><nl>
        return "Dinky";
    <|file_separator|><nl>
        return AmazonElasticMapReduceClientBuilder.standard()
                .withCredentials(new AWSStaticCredentialsProvider(new BasicAWSCredentials(emrParameters.getAccessKey(), emrParameters.getSecretKey())))
                .withRegion(emrParameters.getRegion())
                .build();
    }

    /**
     * create emr client from AWSProfileCredentialsProvider
     *
     * @return AmazonElasticMapReduce
     */
    protected AmazonElasticMapReduce createEmrClient(String profileName) {
        return AmazonElasticMapReduceClientBuilder.standard()
                .withCredentials(new AWSProfileCredentialsProvider(profileName))
                .withRegion(emrParameters.getRegion())
                .build();
    }

    /**
     * create emr client from AWSProfileCredentialsProvider
     *
     * @return AmazonElasticMapReduce
     */
    protected AmazonElasticMapReduce createEmrClient(String profileName, String region) {
        return AmazonElasticMapReduceClientBuilder.standard()
                .withCredentials(new AWSProfileCredentialsProvider(profileName))
                .withRegion(region)
                .build();
    }

    /**
     * create emr client from AWSProfileCredentialsProvider
     *
     * @return AmazonElasticMapReduce
     */
    protected AmazonElasticMapReduce createEmrClient(String profileName, String region, String accessKey, String secretKey) {
        return AmazonElasticMapReduceClientBuilder.standard()
                .withCredentials(new AWSProfileCredentialsProvider(profileName))
                .withRegion(region)
                .build();
    }

    /**
     * create emr client from AWSProfileCredentialsProvider
     *
     * @return AmazonElasticMapReduce
     */
    protected AmazonElasticMapReduce createEmrClient(String profileName, String region<nl>
        return new EmrParameters();
    <|file_separator|><nl>
        List<String> list = new FlinkParameters().getResourceFilesList();
        System.out.println(list);
    <|file_separator|><nl>
        List<String> commandLine = FlinkArgsUtils.buildRunCommandLine(buildTestTaskExecutionContext(), flinkParameters);
        Assertions.assertEquals("flink run-local /opt/job.jar", joinStringListWithSpace(commandLine));
    <|file_separator|><nl>
        return null;
    <|file_separator|><nl>
        return JSONUtils.parseObject(parametersNode.get("parameters"), K8sTaskParameters.class);
    <|file_separator|><nl>
        LinkisParameters linkisParameters = new LinkisParameters();
        List<LinkisParameters.Param> paramList = new ArrayList<>();
        paramList.add(new LinkisParameters.Param("engineType", "spark-2.4.3"));
        linkisParameters.setParamScript(paramList);
        return linkisParameters;
    <|file_separator|><nl>
        return new MlflowTaskChannel();
    <|file_separator|><nl>
        List<String> args = new ArrayList<>();
        args.add(param.getMapperClass());
        args.add(param.getReducerClass());
        args.add(param.getInputPath());
        args.add(param.getOutputPath());
        args.add(param.getReducerCount());
        args.add(param.getReducerMemory());
        args.add(param.getMapperMemory());
        args.add(param.getReducerMemory());
        args.add(param.getReducerMemory());
        args.add(param.getReducerMemory());
        args.add(param.getReducerMemory());
        args.add(param.getReducerMemory());
        args.add(param.getReducerMemory());
        args.add(param.getReducerMemory());
        args.add(param.getReducerMemory());
        args.add(param.getReducerMemory());
        args.add(param.getReducerMemory());
        args.add(param.getReducerMemory());
        args.add(param.getReducerMemory());
        args.add(param.getReducerMemory());
        args.add(param.getReducerMemory());
        args.add(param.getReducerMemory());
        args.add(param.getReducerMemory());
        args.add(param.getReducerMemory());
        args.add(param.getReducerMemory());
        args.add(param.getReducerMemory());
        args.add(param.getReducerMemory());
        args.add(param.getReducerMemory());
        args.add(param.getReducerMemory());
        args.add(param.getReducerMemory());
        args.add(param.getReducerMemory());
        args.add(param.getReducerMemory());
        args.add(param<nl>
        super.init();
        mapreduceParameters = new MapReduceParameters(taskExecutionContext);
    <|file_separator|><nl>
        return connectionParams;
    <|file_separator|><nl>
        PythonTask pythonTask = new PythonTask();
        pythonTask.setPythonLauncher("python");
        return pythonTask;
    <|file_separator|><nl>
        return new ResourceParametersHelper(this);
    }

    @Override
    public String getRawScript() {
        return rawScript;
    }

    @Override
    public void setRawScript(String rawScript) {
        this.rawScript = rawScript;
    }

    @Override
    public String getType() {
        return type;
    }

    @Override
    public void setType(String type) {
        this.type = type;
    }

    @Override
    public int getDatasource() {
        return datasource;
    }

    @Override
    public void setDatasource(int datasource) {
        this.datasource = datasource;
    <|file_separator|><nl>
        this.client = createClient();
        this.utils = new PipelineUtils(taskExecutionContext);
        this.sagemakerConnectionParam = new SagemakerConnectionParam(taskExecutionContext);
        this.parameters = new SagemakerParameters(taskExecutionContext);
    <|file_separator|><nl>
        try {
            dataSourceUtilsStaticMock = Mockito.mockStatic(DataSourceUtils.class);
            dataSourceUtilsStaticMock.when(() -> DataSourceUtils.getDataSource(Mockito.anyString(),
                    Mockito.anyString(), Mockito.anyString(), Mockito.anyString(), Mockito.anyString(),
                    Mockito.anyString(), Mockito.anyString(), Mockito.anyString(), Mockito.anyString(),
                    Mockito.anyString(), Mockito.anyString(), Mockito.anyString(), Mockito.anyString(),
                    Mockito.anyString(), Mockito.anyString(), Mockito.anyString(), Mockito.anyString(),
                    Mockito.anyString(), Mockito.anyString(), Mockito.anyString(), Mockito.anyString(),
                    Mockito.anyString(), Mockito.anyString(), Mockito.anyString(), Mockito.anyString(),
                    Mockito.anyString(), Mockito.anyString(), Mockito.anyString(), Mockito.anyString(),
                    Mockito.anyString(), Mockito.anyString(), Mockito.anyString(), Mockito.anyString(),
                    Mockito.anyString(), Mockito.anyString(), Mockito.anyString(), Mockito.anyString(),
                    Mockito.anyString(), Mockito.anyString(), Mockito.anyString(), Mockito.anyString(),
                    Mockito.anyString(), Mockito.anyString(), Mockito.anyString(), Mockito.anyString(),
                    Mockito.anyString(), Mockito.anyString(), Mockito.anyString(), Mockito.anyString(),
                    Mockito.anyString(), Mockito.anyString(), Mockito.anyString(), Mockito.anyString(),
                    Mockito.anyString(), Mockito.anyString(), Mockito.anyString(), Mockito.anyString(),
                    Mockito.anyString(), Mockito.anyString(), Mockito.anyString(), Mockito.anyString(),
                    Mockito.anyString(), Mockito.anyString(), Mockito.anyString(), Mockito.anyString(),
                    Mockito.anyString<nl>
        seatunnelParameters = (SeatunnelSparkParameters) getParameters();
    <|file_separator|><nl>
        sqlTask = new SqlTask();
    <|file_separator|><nl>
        return "Hello World";
    <|file_separator|><nl>
        logger.info("Generating target for Hana");
        return "target";<|file_separator|><nl>
        return "OracleTargetGenerator";
    <|file_separator|><nl>
        return NETWORK.newContainer()
                .withNetwork(NETWORK)
                .withExposedPorts(3306)
                .withEnv("MYSQL_ROOT_PASSWORD", dataSourceContainer.getPassword())
                .withEnv("MYSQL_DATABASE", dataSourceContainer.getDatabase())
                .withEnv("MYSQL_USER", dataSourceContainer.getUsername())
                .withEnv("MYSQL_PASSWORD", dataSourceContainer.getPassword())
                .withWaitStrategy(Wait.forListeningPort())
                .withReuse(true);
    <|file_separator|><nl>
        DolphinSchedulerManager dolphinSchedulerManager = new DolphinSchedulerManager();
        dolphinSchedulerManager.initializeWithMysqlProfile();
    <|file_separator|><nl>
        DolphinSchedulerManager.upgradeDatabase(dataSource);
    <|file_separator|><nl>
        return WorkerConfig.class.isAssignableFrom(clazz);
    }

    @Override
    public void validate(Object target) {
        validate(target, new BeanPropertyBindingResult(target, "workerConfig"));
    <|file_separator|><nl>
        try {
            if (taskExecutionContext.isResourcesDownloaded()) {
                return taskExecutionContext.getResourceContext();
            }
            return storageOperate.downloadResourcesIfNeeded(tenant, taskChannel, taskExecutionContext);
        } catch (Throwable ex) {
            throw new TaskException("Download resources failed", ex);
        }
    <|file_separator|><nl>
        String key = url.getPath();
        Router router = routerMap.get(key);
        if (router == null) {
            router = createRouter(url);
            routerMap.put(key, router);
        }
        return router;
    <|file_separator|><nl>
        ScopeBeanFactory beanFactory = frameworkModel.getBeanFactory();
        beanFactory.registerBean(ClusterScope.class);
        beanFactory.registerBean(ClusterScopeManager.class);
    <|file_separator|><nl>
    <|file_separator|><nl>
        return value.isMatch(url.getQueryParameter(key));
    <|file_separator|>class StringMatch.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class StringMatch {
    private String value;
    private StringMatchType type;

    public String getValue() {
        return value;
    }

    public void setValue(String value) {
        this.value = value;
    }

    public StringMatchType getType() {
        return type;
    }

    public void setType(StringMatchType type) {
        this.type = type;
    }

    public boolean isMatch(String value) {
        if (type == StringMatchType.EXACT) {
            return this.value.equals(value);
        } else if (type == StringMatchType.REGEX) {
            return value.matches(this.value);
        } else {
            return false;
        }
    }

    @Override
    public String toString() {
        return "StringMatch{" + "value='" + value + ''' + ", type=" + type + '}';
    }
}<|file_separator|>class StringMatchType.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public enum StringMatchType {
    EXACT, REGEX
}<|file_separator|>class URL.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class URL {
    private String query;

    public String getQuery() {
        return query;
    }

    public void setQuery(String query) {
        this.query = query;
    }

    public String getQueryParameter(String key) {
        return query.split("&")[0].split("=")[1];
    }
}<|file_separator|><nl>
        if (singleRouterChain == null) {
            return invokers;
        }
        List<Invoker<T>> result = new ArrayList<>();
        for (Invoker<T> invoker : invokers) {
            if (singleRouterChain.isAvailable(invoker)) {
                result.add(invoker);
            }
        }
        return result;
    <|file_separator|><nl>
        final Observation observation = getObservation(invocation);
        if (observation == null) {
            return;
        }
        observation.stop();
    <|file_separator|><nl>
        if (RpcContext.getServiceContext().isNeedPrintRouterSnapshot()) {
            logger.info("RouterSnapshotFilter: " + switcher.getRouterSnapshot());
        }
        return invoker.invoke(invocation);
    <|file_separator|><nl>
        if (pattern.equals(DOES_NOT_FOUND_VALUE)) {
            return !value.equals(DOES_NOT_FOUND_VALUE);
        }
        for (ValuePattern valuePattern : valueMatchers) {
            if (valuePattern.isMatch(pattern, value, url, invocation, isWhenCondition)) {
                return true;
            }
        }
        return false;
    <|file_separator|><nl>
        MeshAppRuleListener meshAppRuleListener = APP_RULE_LISTENERS.get(app);
        if (meshAppRuleListener == null) {
            meshAppRuleListener = new MeshAppRuleListener(app);
            APP_RULE_LISTENERS.put(app, meshAppRuleListener);
        }
        // Add listener to rule repository ( dynamic configuration )
        ruleRepository.addListener(app + MESH_RULE_DATA_ID_SUFFIX, DynamicConfiguration.DEFAULT_GROUP, meshAppRuleListener);

        // Add listener to env ( kubernetes, xDS )
        for (MeshEnvListener envListener : envListeners) {
            if (envListener.isEnable()) {
                envListener.onSubscribe(app);
            }
        }
        return meshAppRuleListener;
    <|file_separator|><nl>
        return new StandardMeshRuleRouter(interfaceClass, url);
    <|file_separator|><nl>
        return "DubboRoute{" +
                "name='" + name + '\'' +
                ", services=" + services +
                ", routedetail=" + routedetail +
                '}';
    <|file_separator|><nl>
        for (TracingContextProvider contextProvider : contextProviders) {
            if (contextProvider.isMatch(invocation)) {
                return true;
            }
        }
        return false;
    <|file_separator|><nl>
        return new Bindings(invokers, invocation);
    <|file_separator|><nl>
        this.script = script;
    }

    @Override
    public String getRawRule() {
        return super.getRawRule();
    }

    @Override
    public void setRawRule(String rawRule) {
        super.setRawRule(rawRule);
    }

    @Override
    public void parseFromMap0(Map<String, Object> map) {
        super.parseFromMap0(map);
    }

    @Override
    public void parseFromMap1(Map<String, Object> map) {
        super.parseFromMap1(map);
    }

    @Override
    public void parseFromMap2(Map<String, Object> map) {
        super.parseFromMap2(map);
    }

    @Override
    public void parseFromMap3(Map<String, Object> map) {
        super.parseFromMap3(map);
    }

    @Override
    public void parseFromMap4(Map<String, Object> map) {
        super.parseFromMap4(map);
    }

    @Override
    public void parseFromMap5(Map<String, Object> map) {
        super.parseFromMap5(map);
    }

    @Override
    public void parseFromMap6(Map<String, Object> map) {
        super.parseFromMap6(map);
    }

    @Override
    public void parseFromMap7(Map<String, Object> map) {
        super.parseFromMap7(map);
    }

    @Override
    public void parseFromMap8(Map<String, Object> map) {
        super.parseFromMap8(map);
    }

    @Override
    public void parseFromMap9(Map<String, Object> map) {
        super.parseFromMap9<nl>
        if (tags != null) {
            for (Tag tag : tags) {
                tag.init(router);
            }
        }
    }

    public void parseFromMap0(Map<String, Object> map) {
        super.parseFromMap0(map);

        Object tags = map.get(TAGS_KEY);
        if (tags != null && List.class.isAssignableFrom(tags.getClass())) {
            this.tags = ((List<Map<String, Object>>) tags)
                    .stream()
                            .map(objMap -> Tag.parseFromMap(objMap, this.getVersion()))
                            .collect(Collectors.toList());
        }
    }

    public void addTag(Tag tag) {
        if (tag != null) {
            this.tags.add(tag);
        }
    }

    public void addTag(String name, String address) {
        if (name != null && address != null) {
            Tag tag = new Tag(name, address);
            this.tags.add(tag);
        }
    }

    public void addTag(String name, String address, String... tagnames) {
        if (name != null && address != null && tagnames != null) {
            Tag tag = new Tag(name, address);
            this.tags.add(tag);
            for (String tagname : tagnames) {
                if (tagname != null) {
                    tag.addTagname(tagname);
                }
            }
        }
    }

    public void addTag(String name, String address, String[] tagnames, String[] addresses) {
        if (name != null && address != null && tagnames != null && addresses != null) {
            Tag tag = new<nl>
        int failPercent = getFailPercent();
        if (failPercent > 0 && failPercent < MAX_BROADCAST_FAIL_PERCENT) {
            logger.warn("Broadcast fail percent is " + failPercent + "%, " +
                    "so do not broadcast to other nodes");
            return Result.failure(getRpcException(new RpcException("Broadcast fail")));
        }
        return super.doInvoke(invocation, invokers, loadbalance);
    }

    private int getFailPercent() {
        int failPercent = getConfiguration().getInt(BROADCAST_FAIL_PERCENT_KEY, 0);
        if (failPercent > MAX_BROADCAST_FAIL_PERCENT) {
            failPercent = MAX_BROADCAST_FAIL_PERCENT;
        } else if (failPercent < MIN_BROADCAST_FAIL_PERCENT) {
            failPercent = MIN_BROADCAST_FAIL_PERCENT;
        }
        return failPercent;
    <|file_separator|><nl>
        AbsentConfigurator configurator = new AbsentConfigurator(URL.valueOf("override://foo@0.0.0.0/com.foo.BarService?timeout=200"));
        URL url = configurator.configure(URL.valueOf(UrlConstant.URL_CONSUMER));
        Assertions.assertEquals("200", url.getParameter("timeout"));
    <|file_separator|><nl>
        applicationModel = new ApplicationModel();
        applicationModel.setInterfaceName(INTERFACE_NAME);
        applicationModel.setMethod(METHOD_NAME);
        applicationModel.setGroup(GROUP);
        applicationModel.setVersion(VERSION);
        applicationModel.setInvoker(invoker);
    }

    @Test
    public void testFilter() throws Exception {
        setupConfig();
        filter = createFilter(applicationModel);
        initParam();
        filter.filter(invocation);
    <|file_separator|><nl>
        int runs = 10000;
        Map<Invoker, AtomicLong> counter = getInvokeCounter(runs, LeastActiveLoadBalance.NAME);
        for (Map.Entry<Invoker, AtomicLong> entry : counter.entrySet()) {
            Long count = entry.getValue().get();
            //            System.out.println(count);
            Assertions.assertTrue(
                    Math.abs(count - runs / (0f + invokers.size())) < runs / (0f + invokers.size()),
                    "abs diff should < avg");
        }
    <|file_separator|><nl>
        int loop = 10000;
        Map<Invoker, InvokeResult> resultMap = getWeightedInvokeResult(loop, RoundRobinLoadBalance.NAME);
        assertStrictWRRResult(loop, resultMap);
    <|file_separator|><nl>
        return null;
    <|file_separator|><nl>
        resetInvokerToNoException();
        FailsafeClusterInvoker<DemoService> invoker = new FailsafeClusterInvoker<DemoService>(dic);
        Result ret = invoker.invoke(invocation);
        Assertions.assertSame(result, ret);
    <|file_separator|><nl>
        AbstractClusterInvokerChain chain = new AbstractClusterInvokerChain();
        chain.add(new DemoCluster());
        chain.add(new DemoCluster());
        chain.add(new DemoCluster());
        chain.add(new DemoCluster());
    <|file_separator|><nl>
        assertInterfaceArray(ics);
        assertInterfaceArray(dcs);
        return new Mixin(ics, dcs, cl);
    }

    private final Class<?>[] ics;
    private final Class<?>[] dcs;
    private final ClassLoader cl;
    private final String mixinClassName;
    private final int mixinClassCounter;
    private final Object[] mixinInstances;

    private Mixin(Class<?>[] ics, Class<?>[] dcs, ClassLoader cl) {
        this.ics = ics;
        this.dcs = dcs;
        this.cl = cl;
        this.mixinClassName = PACKAGE_NAME + ".Mixin" + mixinClassCounter;
        this.mixinClassCounter = (int) (MIXIN_CLASS_COUNTER.incrementAndGet() & 0x7fffffff);
        this.mixinInstances = new Object[ics.length];
    }

    /**
     * mixin interface and delegates.
     * all class must be public.
     *
     * @param ics interface class array.
     * @param dc  delegate class.
     * @return Mixin instance.
     */
    public static Mixin mixin(Class<?>[] ics, Class<?> dc) {
        return mixin(ics, new Class[] {dc});
    }

    /**
     * mixin interface and delegates.
     * all class must be public.
     *
     * @param ics interface class array.
     * @param dc  delegate class.
     * @param cl  class loader.
     * @return Mixin instance.
     */
    public static Mixin mixin(Class<?>[] ics, Class<?> dc, ClassLoader cl) {
        return mixin(ics<nl>
        return Collections.emptyMap();
    <|file_separator|><nl>
        if (BEFORE_METHOD == null) {
            return null;
        }
        try {
            Object result = BEFORE_METHOD.invoke(annotation);
            if (result instanceof String[]) {
                return (String[]) result;
            } else {
                return null;
            }
        } catch (Throwable e) {
            return null;
        }
    <|file_separator|><nl>
        this.className = className;
    <|file_separator|><nl>
        if (sourceType == null || targetType == null) {
            return null;
        }
        if (sourceType == targetType) {
            return null;
        }
        if (sourceType.isAssignableFrom(targetType)) {
            return getConverter(targetType, sourceType);
        }
        return null;
    }

    /**
     * Get the Converter instance from {@link ExtensionLoader} with the specified source and target type
     *
     * @param sourceType the source type
     * @param targetType the target type
     * @return
     * @see ExtensionLoader#getSupportedExtensionInstances()
     */
    public Converter<?, ?> getConverter(Class<?> sourceType, Class<?> targetType) {
        if (sourceType == null || targetType == null) {
            return null;
        }
        if (sourceType == targetType) {
            return null;
        }
        if (sourceType.isAssignableFrom(targetType)) {
            return getConverter(targetType, sourceType);
        }
        return null;
    <|file_separator|><nl>
        return Boolean.parseBoolean(source);
    <|file_separator|><nl>
        if (targetType == String[].class) {
            return segments;
        }
        return converterUtil.convert(segments, size, targetType, elementType);
    <|file_separator|><nl>
        return new ArrayBlockingQueue<>(size);
    <|file_separator|><nl>
        Map<String, String> extraAttributes = new HashMap<>();
        extraAttributes.put("DUBBO_LABELS", "tag=pre;key=value");
        extraAttributes.put("DUBBO_KEY1", "value1");
        extraAttributes.put("DUBBO_KEY2", "value2");
        return extraAttributes;
    <|file_separator|><nl>
        enableSimpleProfiler.set(false);
    <|file_separator|><nl>
        return Status.OK;
    <|file_separator|><nl>
        if (waiter.get() == SHUTDOWN) {
            return;
        }
        if (waiter.get() == null) {
            waiter.set(Thread.currentThread());
        }
        while (true) {
            if (queue.isEmpty()) {
                if (waiter.get() == SHUTDOWN) {
                    return;
                }
                if (waiter.get() == null) {
                    waiter.set(Thread.currentThread());
                }
                throwIfInterrupted();
                continue;
            }
            Runnable runnable = queue.poll();
            if (runnable == null) {
                throw new RejectedExecutionException();
            }
            try {
                runnable.run();
            } catch (Throwable t) {
                logger.info(t);
            }
            if (System.currentTimeMillis() > deadline) {
                throw new TimeoutException();
            }
        }
    <|file_separator|><nl>
        if (atomicBoolean.compareAndSet(false, true)) {
            executor.execute(this);
        } else {
            if (removable != null) {
                runQueue.remove(removable);
            }
        }
    <|file_separator|><nl>
        String value = null;
        if (overrideURL != null) {
            value = overrideURL.getParameterStrict(key);
        }
        if (StringUtils.isEmpty(value)) {
            value = super.getParameter(key);
        }
        return value;
    <|file_separator|><nl>
        byte[] address = inetAddress.getAddress();
        byte[] prefix = toBytes(address, 4);
        byte[] prefixBytes = toBytes(prefix, 4);

        int prefixLength = this.prefixLength;
        int mask = 0xffffffff << (32 - prefixLength);
        byte[] maskBytes = toBytes(prefixBytes, 4);
        maskBytes[3] = (byte) (maskBytes[3] & mask);

        byte[] networkBytes = toBytes(prefixBytes, 4);
        networkBytes[3] = (byte) (networkBytes[3] & mask);

        byte[] broadcastBytes = toBytes(prefixBytes, 4);
        broadcastBytes[3] = (byte) (broadcastBytes[3] | (mask ^ 0xffffffff));

        this.startAddress = InetAddress.getByAddress(networkBytes);
        this.endAddress = InetAddress.getByAddress(broadcastBytes);
    <|file_separator|><nl>
        Set<URL> resources = new LinkedHashSet<>();
        try {
            Map<ClassLoader, Map<String, Set<URL>>> classLoaderResources = getClassLoaderResourcesCache().get();
            if (classLoaderResources == null) {
                classLoaderResources = new ConcurrentHashMap<>();
                synchronized (ClassLoaderResourceLoader.class) {
                    if (classLoaderResourcesCache == null) {
                        classLoaderResourcesCache = new SoftReference<>(classLoaderResources);
                    }
                }
            }
            Map<String, Set<URL>> classLoaderResourcesMap = classLoaderResources.get(currentClassLoader);
            if (classLoaderResourcesMap == null) {
                classLoaderResourcesMap = new ConcurrentHashMap<>();
                classLoaderResources.put(currentClassLoader, classLoaderResourcesMap);
            }
            Set<URL> classLoaderResourcesSet = classLoaderResourcesMap.get(fileName);
            if (classLoaderResourcesSet == null) {
                classLoaderResourcesSet = new LinkedHashSet<>();
                classLoaderResourcesMap.put(fileName, classLoaderResourcesSet);
            }
            for (URL url : currentClassLoader.getResources(fileName)) {
                if (url.getRef() == null) {
                    setRef(url);
                }
                classLoaderResourcesSet.add(url);
            }
            resources.addAll(classLoaderResourcesSet);
        } catch (Throwable ignore) {
        }
        return Collections.unmodifiableSet(resources);
    <|file_separator|><nl>
        this.cache = cache;
    <|file_separator|><nl>
    <|file_separator|><nl>
        return metaData.get(key);
    <|file_separator|><nl>
        this.enableRequest = enableRequest;
    <|file_separator|><nl>
        this.minExpectedMs = minExpectedMs;
    <|file_separator|><nl>
        return new CollectionTypeDefinition(type, clazz, typeCache);
    <|file_separator|><nl>
        providers.put(providerModel.getServiceKey(), providerModel);
        String keyWithoutGroup = keyWithoutGroup(providerModel.getServiceKey());
        providersWithoutGroup.putIfAbsent(keyWithoutGroup, new LinkedList<>());
        providersWithoutGroup.get(keyWithoutGroup).add(providerModel);
    <|file_separator|><nl>
        return this.attributeMap.get(key);
    <|file_separator|><nl>
        URL url1 = URL.valueOf(rawURL);
        URL url2 = URL.valueOf(rawURL);
        URL url3 = URL.valueOf("override://10.20.130.230:20880/context/path?version=1.0.0&application=morgan&timeout=2000&category=configurators&sayHello.overrideKey=override");
        assertEquals(url1, url2);
        assertNotEquals(url1, url3);
    <|file_separator|><nl>
        Assertions.assertTrue(
                ServiceKey.Matcher.isMatch(new ServiceKey(null, null, "DemoGroup"), new ServiceKey(null, null, null)));
        Assertions.assertTrue(
                ServiceKey.Matcher.isMatch(new ServiceKey(null, null, "DemoGroup"), new ServiceKey(null, null, "DemoGroup")));
        Assertions.assertTrue(
                ServiceKey.Matcher.isMatch(new ServiceKey(null, null, "DemoGroup"), new ServiceKey(null, null, "DemoGroup,DemoGroup")));
        Assertions.assertTrue(
                ServiceKey.Matcher.isMatch(new ServiceKey(null, null, "DemoGroup"), new ServiceKey(null, null, "DemoGroup,DemoGroup,DemoGroup")));
        Assertions.assertTrue(
                ServiceKey.Matcher.isMatch(new ServiceKey(null, null, "DemoGroup"), new ServiceKey(null, null, "DemoGroup,DemoGroup,DemoGroup,DemoGroup")));
    <|file_separator|><nl>
        BeanDefinitionBuilder beanDefinitionBuilder = BeanDefinitionBuilder.genericBeanDefinition(TestBean.class);
        beanDefinitionBuilder.addConstructorArgValue(scopeModelAccessor);
        BeanDefinition beanDefinition = beanDefinitionBuilder.getBeanDefinition();
        TestBean testBean = (TestBean) ApplicationContext.defaultContext().getBean(beanDefinition);
        assertThat(testBean.getScopeModelAccessor()).isEqualTo(scopeModelAccessor);
    <|file_separator|><nl>
        return scopeModel;
    <|file_separator|><nl>
        assertEquals(DEFAULT_GROUP, configuration.getDefaultGroup());
        assertEquals(-1L, configuration.getDefaultTimeout());
    <|file_separator|><nl>
        converter = new StringToDurationConverter();
    <|file_separator|><nl>
        MultiValueConverter converter = new MultiValueConverter();
        String[] values = converter.find("1,2,3");
        assertEquals(3, values.length);
    <|file_separator|><nl>
        Deque<String> deque = converter.convert(String.class, "abc");
        assertEquals("abc", deque.poll());
        assertEquals("abc", deque.poll());
    }

    @Test
    void testGetTargetType() {
        assertEquals(Deque.class, converter.getTargetType());
    <|file_separator|><nl>
        assertTrue(converter.accepts("1,2,3"));
        assertTrue(converter.accepts("1,2,3,"));
        assertTrue(converter.accepts("1,2,3,4"));
        assertTrue(converter.accepts("1,2,3,4,"));
        assertFalse(converter.accepts("1,2,3,4,5"));
        assertFalse(converter.accepts("1,2,3,4,5,"));
        assertFalse(converter.accepts("1,2,3,4,5,6"));
        assertFalse(converter.accepts("1,2,3,4,5,6,"));
        assertFalse(converter.accepts("1,2,3,4,5,6,7"));
        assertFalse(converter.accepts("1,2,3,4,5,6,7,"));
        assertFalse(converter.accepts("1,2,3,4,5,6,7,8"));
        assertFalse(converter.accepts("1,2,3,4,5,6,7,8,"));
        assertFalse(converter.accepts("1,2,3,4,5,6,7,8,9"));
        assertFalse(converter.accepts("1,2,3,4,5,6,7,8,9,"));
        assertFalse(converter.accepts("1,2,3,4,5,6,7,8,9,10"));
        assertFalse(converter.accepts("1,2,3,4,5,6,7,8,9,10,"));
        assertFalse(converter.accepts("1,2,3,4,5,6,7,8,9,10,11"));
        assertFalse(converter.accepts("1,2,3,4,5,6,7,<nl>
        String code = AdaptiveClassCodeGenerator.generate(
            "com.example.test",
            "Test",
            "Test",
            "Test",
            "Test",
            "Test",
            "Test",
            "Test",
            "Test",
            "Test",
            "Test",
            "Test",
            "Test",
            "Test",
            "Test",
            "Test",
            "Test",
            "Test",
            "Test",
            "Test",
            "Test",
            "Test",
            "Test",
            "Test",
            "Test",
            "Test",
            "Test",
            "Test",
            "Test",
            "Test",
            "Test",
            "Test",
            "Test",
            "Test",
            "Test",
            "Test",
            "Test",
            "Test",
            "Test",
            "Test",
            "Test",
            "Test",
            "Test",
            "Test",
            "Test",
            "Test",
            "Test",
            "Test",
            "Test",
            "Test",
            "Test",
            "Test",
            "Test",
            "Test",
            "Test",
            "Test",
            "Test",
            "Test",
            "Test",
            "Test",
            "Test",
            "Test",
            "Test",
            "Test",
            "Test",
            "Test",
            "Test",
            "Test",
            "Test",
            "Test",
            "Test",
            "Test",
            "Test",
            "Test",
            "Test",
            "Test",
            "Test<nl>
        this.applicationModel = applicationModel;
    <|file_separator|><nl>
        return "DuplicatedWithoutOverriddenExt1";
    <|file_separator|>class DuplicatedWithoutOverriddenExt2 implements DuplicatedWithoutOverriddenExt {

    @Override
    public String echo() {
        return "DuplicatedWithoutOverriddenExt2";
    }
}<|file_separator|>class DuplicatedWithOverriddenExt1 implements DuplicatedWithOverriddenExt {

    @Override
    public String echo() {
        return "DuplicatedWithOverriddenExt1";
    }
}<|file_separator|>class DuplicatedWithOverriddenExt2 implements DuplicatedWithOverriddenExt {

    @Override
    public String echo() {
        return "DuplicatedWithOverriddenExt2";
    }
}<|file_separator|>class DuplicatedWithOverriddenExt3 implements DuplicatedWithOverriddenExt {

    @Override
    public String echo() {
        return "DuplicatedWithOverriddenExt3";
    }
}<|file_separator|>class DuplicatedWithoutOverriddenExt3 implements DuplicatedWithoutOverriddenExt {

    @Override
    public String echo() {
        return "DuplicatedWithoutOverriddenExt3";
    }
}<|file_separator|>class DuplicatedWithOverriddenExt4 implements DuplicatedWithOverriddenExt {

    @Override
    public String echo() {
        return "DuplicatedWithOverriddenExt4";
    }
}<|file_separator|>class DuplicatedWithOverriddenExt5 implements DuplicatedWithOverriddenExt {

    @Override
    public String echo() {
        return "DuplicatedWithOverriddenExt5";
    }
}<|file_separator|>class DuplicatedWithoutOverriddenExt4 implements DuplicatedWithoutOverriddenExt {

    @Override
    public String echo() {
        return "DuplicatedWithoutOverriddenExt4";
    }
}<|file_separator|>class DuplicatedWithoutOverriddenExt5 implements DuplicatedWithoutOverriddenExt {

    @Override
    public String echo<nl>
        return "Ext1Impl2-yell";
    <|file_separator|><nl>
        return "Ext2Impl3-bang";
    <|file_separator|><nl>
        return "echo";
    <|file_separator|><nl>
        // TODO
    <|file_separator|><nl>
        Logger logger = LoggerFactory.getLogger(Slf4jLoggerTest.class);
        logger.info("Hello World");
    <|file_separator|><nl>
        return z;
    <|file_separator|><nl>
        this.personName = personName;
    <|file_separator|><nl>
        Status status = new Status(OK, "message");
        assertThat(status.getLevel(), is(OK));
        assertThat(status.getMessage(), equalTo("message"));
        assertThat(status.getDescription(), isEmptyOrNullString());
    <|file_separator|><nl>
        logger.info("test");
    <|file_separator|><nl>
        URL url = URL.valueOf("dubbo://127.0.0.1:23456/TestService");
        ExecutorService executorService = executorRepository.createExecutorIfAbsent(url);
        executorService.shutdown();
        executorService = executorRepository.createExecutorIfAbsent(url);
        Assertions.assertFalse(executorService.isShutdown());
    }

    @Test
    void testServiceExportExecutor() throws Exception {
        URL url = URL.valueOf("dubbo://127.0.0.1:23456/TestService?side=provider");
        ExecutorService executorService = executorRepository.createExecutorIfAbsent(url);
        executorService.shutdown();
        executorService = executorRepository.createExecutorIfAbsent(url);
        Assertions.assertFalse(executorService.isShutdown());
    }

    @Test
    void testServiceReferExecutor() throws Exception {
        URL url = URL.valueOf("dubbo://127.0.0.1:23456/TestService?side=consumer");
        ExecutorService executorService = executorRepository.createExecutorIfAbsent(url);
        executorService.shutdown();
        executorService = executorRepository.createExecutorIfAbsent(url);
        Assertions.assertFalse(executorService.isShutdown());
    <|file_separator|><nl>
        frameworkExecutorRepository.nextScheduledExecutor();
    <|file_separator|><nl>
        URL url = URL.valueOf("dubbo://10.20.130.230:20880/context/path?" + THREAD_NAME_KEY
                + "=demo&" + CORE_THREADS_KEY
                + "=1&" + THREADS_KEY
                + "=2&" + ALIVE_KEY
                + "=1000&" + QUEUES_KEY
                + "=0");
        ThreadPool threadPool = new CachedThreadPool();
        ThreadPoolExecutor executor = (ThreadPoolExecutor) threadPool.getExecutor(url);
        assertThat(executor.getCorePoolSize(), is(1));
        assertThat(executor.getMaximumPoolSize(), is(2));
        assertThat(executor.getQueue(), Matchers.<BlockingQueue<Runnable>>instanceOf(SynchronousQueue.class));
        assertThat(
                executor.getRejectedExecutionHandler(),
                Matchers.<RejectedExecutionHandler>instanceOf(AbortPolicyWithReport.class));
    <|file_separator|><nl>
        Map<String, String> map = new HashMap<String, String>();
        map.put("key", "value");

        Map<String, String> flipped = CollectionUtils.flip(map);
        assertEquals("value", flipped.get("key"));
    <|file_separator|><nl>
        return "Hello";
    <|file_separator|><nl>
        DefaultTypeBuilder.create(InnerClass.class);
    <|file_separator|><nl>
        return new ServiceDefinition(interfaceClass);
    <|file_separator|><nl>
        return new Mock2IsolationExecutorSupport(url);
    <|file_separator|><nl>
        this.scopeModel = scopeModel;
    <|file_separator|><nl>
        if (serviceVersion == null || serviceVersion.length() == 0) {
            return String.format("%s:%d", serviceName, port);
        }
        if (serviceGroup == null || serviceGroup.length() == 0) {
            return String.format("%s:%s:%d", serviceName, serviceVersion, port);
        }
        return String.format("%s:%s:%s:%d", serviceName, serviceVersion, serviceGroup, port);
    <|file_separator|><nl>
        return caches.computeIfAbsent(url.toString(), this::createCache);
    <|file_separator|><nl>
        super.setMonitor(monitor);
    <|file_separator|><nl>
        super.setApplication(application);
    }

    public void setVersion(String version) {
        super.setVersion(version);
    }

    public void setProtocol(com.alibaba.dubbo.config.ProtocolConfig protocol) {
        super.setProtocol(protocol);
    <|file_separator|><nl>
            return new Object[0];
        }

        @Override
        public String getAttachment(String key) {
            return null;
        }

        @Override
        public String getAttachment(String key, String defaultValue) {
            return null;
        }

        @Override
        public Invoker<?> getInvoker() {
            return null;
        }

        @Override
        public Object put(Object key, Object value) {
            return null;
        }

        @Override
        public Object get(Object key) {
            return null;
        }

        @Override
        public Map<Object, Object> getAttributes() {
            return null;
        }

        @Override
        public void addInvokedInvoker(org.apache.dubbo.rpc.Invoker<?> invoker) {}

        @Override
        public List<org.apache.dubbo.rpc.Invoker<?>> getInvokedInvokers() {
            return null;
        }
    }

    class NullInvocation implements Invocation {
        @Override
        public String getTargetServiceUniqueName() {
            return null;
        }

        @Override
        public String getProtocolServiceKey() {
            return null;
        }

        @Override
        public String getMethodName() {
            return null;
        }

        @Override
        public Class<?>[] getParameterTypes() {
            return new Class[0];
        }

        @Override
        public Object[] getArguments() {
            return new Object[0];
        <|file_separator|><nl>
        context.register(DubboConfigConfiguration.Multiple.class);
        context.refresh();

        // application
        ApplicationConfig applicationConfig = context.getBean("applicationBean", ApplicationConfig.class);
        Assertions.assertEquals("dubbo-demo-application", applicationConfig.getName());

        // module
        ModuleConfig moduleConfig = context.getBean("moduleBean", ModuleConfig.class);
        Assertions.assertEquals("dubbo-demo-module", moduleConfig.getName());

        // registry
        RegistryConfig registryConfig = context.getBean(RegistryConfig.class);
        Assertions.assertEquals("zookeeper://192.168.99.100:32770", registryConfig.getAddress());

        // protocol
        ProtocolConfig protocolConfig = context.getBean(ProtocolConfig.class);
        Assertions.assertEquals("dubbo", protocolConfig.getName());
        Assertions.assertEquals(Integer.valueOf(20880), protocolConfig.getPort());
    <|file_separator|><nl>
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
        context.register(TestConfig.class);
        context.refresh();

        RegistryConfig registry = context.getBean("registry", RegistryConfig.class);
        Assertions.assertEquals(2181, registry.getPort());

        ConfigManager configManager = ApplicationModel.defaultModel().getApplicationConfigManager();
        Collection<ProtocolConfig> protocolConfigs = configManager.getProtocols();
        Assertions.assertEquals(1, protocolConfigs.size());
    <|file_separator|><nl>
            this.demoServiceFromAncestor = demoServiceFromAncestor;
        <|file_separator|><nl>
        System.out.println("Hello World");
    <|file_separator|><nl>
        Compiler compiler = new Compiler();
        compiler.compile("test.txt");
    <|file_separator|><nl>
        return null;
    <|file_separator|><nl>
        myObjectOutput.flush();
        byteArrayInputStream = new ByteArrayInputStream(byteArrayOutputStream.toByteArray());
        myObjectInput = new MyObjectInput(byteArrayInputStream);
    <|file_separator|><nl>
        return new ApplicationConfig(this);
    <|file_separator|><nl>
        return new ArgumentConfig(index, type, callback);
    <|file_separator|>class ArgumentConfig.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class ArgumentConfig {
    private Integer index;
    private String type;
    private Boolean callback;

    public ArgumentConfig(Integer index, String type, Boolean callback) {
        this.index = index;
        this.type = type;
        this.callback = callback;
    }

    public Integer getIndex() {
        return index;
    }

    public String getType() {
        return type;
    }

    public Boolean getCallback() {
        return callback;
    }
}<|file_separator|><nl>
        // TODO: implement
    <|file_separator|>class ConfigValidator.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public interface ConfigValidator {
    void validate(AbstractConfig config);
}<|file_separator|>class ConfigValidatorFactory.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class ConfigValidatorFactory {
    public static ConfigValidator getValidator(String type) {
        // TODO: implement
    }
}<|file_separator|>class Config.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class Config {
    private String name;
    private String value;

    public Config(String name, String value) {
        this.name = name;
        this.value = value;
    }

    public String getName() {
        return name;
    }

    public String getValue() {
        return value;
    }
}<|file_separator|>class ConfigManager.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class ConfigManager {
    private static ConfigManager instance;
    private ConfigValidator validator;
    private Map<String, Config> configs;

    private ConfigManager() {
        // TODO: implement
    }

    public static ConfigManager getInstance() {
        if (instance == null) {
            instance = new ConfigManager();
        }
        return instance;
    }

    public void setValidator(ConfigValidator validator) {
        this.validator = validator;
    }

    public void addConfig(String name, String value) {
        // TODO: implement
    }

    public Config getConfig(String name) {
        // TODO: implement
    }
}<|file_separator|><nl>
        exportedExporters.add(exporter);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void exported(Class<?> serviceInterface, Object service) {
        if (serviceInterface.isAssignableFrom(getInterface())) {
            exported(new Exporter<>(serviceInterface, service));
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void exported(Class<?> serviceInterface, Object service, Filter filter) {
        if (serviceInterface.isAssignableFrom(getInterface())) {
            exported(new Exporter<>(serviceInterface, service, filter));
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void exported(Class<?> serviceInterface, Object service, Filter filter, FilterChainBuilder.CallbackRegistrationInvoker callbackRegistrationInvoker) {
        if (serviceInterface.isAssignableFrom(getInterface())) {
            exported(new Exporter<>(serviceInterface, service, filter, getFilterChainNode(callbackRegistrationInvoker)));
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void exported(Class<?> serviceInterface, Object service, Filter filter, FilterChainBuilder.CopyOfFilterChainNode filterChainNode) {
        if (serviceInterface.isAssignableFrom(getInterface())) {
            exported(new Exporter<>(serviceInterface, service, filter, filterChainNode));
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void exported(Class<?> serviceInterface, Object service, Filter filter, FilterChainBuilder.CopyOfFilterChainNode filterChainNode, FilterChainBuilder.CallbackRegistrationInvoker callbackRegistrationInvoker) {
        if (serviceInterface.isAssignableFrom(getInterface())) {
            exported(new Exporter<>(serviceInterface<nl>
        return RegistryCenterExporterListener.class;
    }

    /**
     * Returns the name of the exported service.
     */
    @Override
    protected String getServiceName() {
        return "registryCenterExporterListener";
    <|file_separator|><nl>
        return "Hello " + name;
    <|file_separator|><nl>
        return invokers.get(0);
    <|file_separator|><nl>
        return null;
    <|file_separator|><nl>

        if (!isOk()) {
            return null;
        }

        Method m = findSetMethod(key, value, proxieeClass);
        return invoke(m, value);
    <|file_separator|><nl>
        if (bean instanceof DubboConfigAlias) {
            BeanDefinition beanDefinition = registry.getBeanDefinition(beanName);
            beanDefinition.setBeanClassName(DubboConfigAlias.class.getName());
        }
        return bean;
    <|file_separator|><nl>
        return create(getAnnotationAttributes(reference, false, false), interfaceClass, environment);
    }

    public static ServiceBeanNameBuilder create(Service service, Class<?> interfaceClass) {
        return create(service, interfaceClass, Environment.DEFAULT);
    }

    public static ServiceBeanNameBuilder create(Reference reference, Class<?> interfaceClass) {
        return create(reference, interfaceClass, Environment.DEFAULT);
    }

    public static ServiceBeanNameBuilder create(Service service, Class<?> interfaceClass, Environment environment) {
        return create(getAnnotationAttributes(service, false, false), interfaceClass, environment);
    }

    public static ServiceBeanNameBuilder create(Reference reference, Class<?> interfaceClass, Environment environment) {
        return create(getAnnotationAttributes(reference, false, false), interfaceClass, environment);
    }

    public static ServiceBeanNameBuilder create(Service service, Class<?> interfaceClass, Environment environment) {
        return create(getAnnotationAttributes(service, false, false), interfaceClass, environment);
    }

    public static ServiceBeanNameBuilder create(Reference reference, Class<?> interfaceClass, Environment environment) {
        return create(getAnnotationAttributes(reference, false, false), interfaceClass, environment);
    }

    private static AnnotationAttributes getAnnotationAttributes(
            Service service, boolean checkInterface, boolean checkVersion) {
        return AnnotationUtils.getAnnotationAttributes(service, checkInterface, checkVersion);
    <|file_separator|><nl>
    <|file_separator|><nl>
        return this.customizers;
    <|file_separator|><nl>
        return (ServiceBean) getSource();
    <|file_separator|><nl>
        String packageValue = element.getAttribute("package");
        if (packageValue != null) {
            builder.addPropertyValue("package", packageValue);
        }
    <|file_separator|><nl>
        return doGetPropertySources(environment).entrySet().stream()
                .filter(entry -> entry.getValue() instanceof Map)
                .collect(Collectors.toMap(Map.Entry::getKey, entry -> ((Map) entry.getValue()).entrySet().stream()
                        .filter(entry1 -> entry1.getValue() != null)
                        .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue))));
    <|file_separator|><nl>

        processBeforeInitialization(bean, beanName);

        return bean;<|file_separator|><nl>
        return applicationContext.getBean(DUBBO_SINGLETON_MUTEX_KEY);
    <|file_separator|><nl>
        state = event.getState();
    <|file_separator|><nl>
        System.out.println("Before method execution");
        Object result = invocation.proceed();
        System.out.println("After method execution");
        return result;
    <|file_separator|><nl>
        return demoService.sayName(name);
    <|file_separator|><nl>
        Assertions.assertEquals("Hello World", helloService.sayHello("World"));
    }

    @Test
    void testApplicationContext() {
        Assertions.assertEquals("Hello World", applicationContext.getBean(HelloService.class).sayHello("World"));
    }

    @Order(Integer.MAX_VALUE)
    @Configuration
    public static class RawReferenceBeanConfiguration {

        @Bean
        public ReferenceBean<HelloService> helloService() {
            return new ReferenceBeanBuilder()
                    .setGroup("${myapp.group}")
                    .setInit(false)
                    .build();
        }
    <|file_separator|><nl>
        Assertions.assertEquals("Hello, world!", helloService.sayHello("world"));
    <|file_separator|><nl>
            return new DataSourceTransactionManager(dataSource());
        <|file_separator|><nl>
            return demoServiceFromChild;
        <|file_separator|><nl>
        return mockDao;
    <|file_separator|><nl>
        return new Box();
    <|file_separator|><nl>
        return helloService.sayHello(name);
    <|file_separator|><nl>
        // TODO: Implement invoke() method.
    <|file_separator|><nl>
        return false;<|file_separator|><nl>
        return new ZookeeperDynamicConfiguration(zookeeperTransporter, url);
    <|file_separator|><nl>
        ApplicationContext context = new AnnotationConfigApplicationContext(SpringContainerTest.class);
        assertNotNull(context);
    <|file_separator|><nl>
        return null;
    <|file_separator|><nl>
        logger.info("sayHello method called with name: {}", name);
        return "Hello " + name;<|file_separator|><nl>
        System.out.println("Hello World!");
    <|file_separator|><nl>
        String url = "http://localhost:8080/api/v1/users";
        String json = "{\"name\":\"test\",\"email\":john.c.calhoun@examplepetstore.com\",\"password\":\"test\"}";
        String response = RestProvider.post(url, json);
        System.out.println(response);
    }

    public static String post(String url, String json) throws Exception {
        URL obj = new URL(url);
        HttpURLConnection con = (HttpURLConnection) obj.openConnection();
        con.setRequestMethod("POST");
        con.setRequestProperty("Content-Type", "application/json");
        con.setDoOutput(true);
        DataOutputStream wr = new DataOutputStream(con.getOutputStream());
        wr.writeBytes(json);
        wr.flush();
        wr.close();
        int responseCode = con.getResponseCode();
        System.out.println("POST Response Code :: " + responseCode);
        if (responseCode == HttpURLConnection.HTTP_OK) { //success
            BufferedReader in = new BufferedReader(new InputStreamReader(
                    con.getInputStream()));
            String inputLine;
            StringBuffer response = new StringBuffer();
            while ((inputLine = in.readLine()) != null) {
                response.append(inputLine);
            }
            in.close();
            return response.toString();
        } else {
            return "POST request not worked";
        }
    <|file_separator|><nl>
        SpringApplication.run(SpringMvcRestProvider.class, args);
    <|file_separator|><nl>
        Cache cache = super.constructCache();
        cache.put("key", "value");
        cache.put("key2", "value2");
        cache.put("key3", "value3");
        cache.put("key4", "value4");
        cache.put("key5", "value5");
        cache.put("key6", "value6");
        cache.put("key7", "value7");
        cache.put("key8", "value8");
        cache.put("key9", "value9");
        cache.put("key10", "value10");
        cache.put("key11", "value11");
        cache.put("key12", "value12");
        cache.put("key13", "value13");
        cache.put("key14", "value14");
        cache.put("key15", "value15");
        cache.put("key16", "value16");
        cache.put("key17", "value17");
        cache.put("key18", "value18");
        cache.put("key19", "value19");
        cache.put("key20", "value20");
        cache.put("key21", "value21");
        cache.put("key22", "value22");
        cache.put("key23", "value23");
        cache.put("key24", "value24");
        cache.put("key25", "value25");
        cache.put("key26", "value26");
        cache.put("key27", "value27");
        cache.put<nl>
        return new JValidator(url);
    <|file_separator|><nl>
		if (arguments == null || arguments.isEmpty()) {
			return NO_ARGS;
		}
		return arguments.split(" ");
	<|file_separator|><nl>
        return excludedServiceParams;
    <|file_separator|><nl>
        return mediaType != null && mediaType.isCompatible(paramType);
    <|file_separator|><nl>
        if (headerName == null) {
            return;
        }
        if (defaultValue == null) {
            defaultValue = "";
        }
        if (defaultValue.length() == 0) {
            defaultValue = "";
        }
        if (defaultValue.length() > 0 && !defaultValue.startsWith("\"")) {
            defaultValue = "\"" + defaultValue + "\"";
        }
        if (defaultValue.length() > 0 && !defaultValue.endsWith("\"")) {
            defaultValue = defaultValue + "\"";
        }
        if (defaultValue.length() > 0 && !defaultValue.startsWith(" ")) {
            defaultValue = " " + defaultValue;
        }
        if (defaultValue.length() > 0 && !defaultValue.endsWith(" ")) {
            defaultValue = defaultValue + " ";
        }
        if (defaultValue.length() > 0 && !defaultValue.startsWith("null")) {
            defaultValue = "null " + defaultValue;
        }
        if (defaultValue.length() > 0 && !defaultValue.endsWith("null")) {
            defaultValue = defaultValue + " null";
        }
        if (defaultValue.length() > 0 && !defaultValue.startsWith("true")) {
            defaultValue = "true " + defaultValue;
        }
        if (defaultValue.length() > 0 && !defaultValue.endsWith("true")) {
            defaultValue = defaultValue + " true";
        }
        if (defaultValue.length() > 0 && !defaultValue.startsWith("false")) {
            defaultValue = "false " + defaultValue;
        }
        if (defaultValue.length() > 0 && !defaultValue.endsWith("false")) {
            defaultValue = defaultValue + " false";
        }
        if (defaultValue.length() > 0 && !defaultValue.startsWith("0")) {
            defaultValue = "<nl>
        return "RequestParam";<|file_separator|><nl>
        String uniqueKey = baseApplicationMetadataIdentifier.getUniqueKey("reversion");
        Assertions.assertEquals(uniqueKey, "app:reversion");
    <|file_separator|><nl>
        // TODO
    <|file_separator|><nl>
        this.id = id;
    <|file_separator|><nl>
        return type instanceof DeclaredType && type.isCollection();
    <|file_separator|><nl>
        TypeDefinition typeDefinition = builder.build(processingEnv, field);
        assertEquals(expectedType, typeDefinition.toString());
    <|file_separator|><nl>
        ServiceDefinition serviceDefinition = new ServiceDefinitionBuilder()
                .setServiceId("testServiceId")
                .setServiceType("testServiceType")
                .setServiceVersion("testServiceVersion")
                .setServiceDescription("testServiceDescription")
                .setServiceInterface("testServiceInterface")
                .setServiceImplementation("testServiceImplementation")
                .setServiceImplementationType("testServiceImplementationType")
                .setServiceImplementationType("testServiceImplementationType")
                .setServiceImplementationType("testServiceImplementationType")
                .setServiceImplementationType("testServiceImplementationType")
                .setServiceImplementationType("testServiceImplementationType")
                .setServiceImplementationType("testServiceImplementationType")
                .setServiceImplementationType("testServiceImplementationType")
                .setServiceImplementationType("testServiceImplementationType")
                .setServiceImplementationType("testServiceImplementationType")
                .setServiceImplementationType("testServiceImplementationType")
                .setServiceImplementationType("testServiceImplementationType")
                .setServiceImplementationType("testServiceImplementationType")
                .setServiceImplementationType("testServiceImplementationType")
                .setServiceImplementationType("testServiceImplementationType")
                .setServiceImplementationType("testServiceImplementationType")
                .setServiceImplementationType("testServiceImplementationType")
                .setServiceImplementationType("testServiceImplementationType")
                .setServiceImplementationType("testServiceImplementationType")
                .setServiceImplementationType("testServiceImplementationType")
                .setServiceImplementationType("testServiceImplementationType")
                .setServiceImplementationType("testServiceImplementationType")
                .setServiceImplementationType("testServiceImplementationType")
                .setServiceImplementationType("testServiceImplementationType")
                .setServiceImplementationType("testServiceImplementationType")
                .setServiceImplementationType("testService<nl>
        List<? extends Element> members = getAllDeclaredMembers(testType.asType());
        assertTrue(members.size() > 0);
    }

    @Test
    void testDeclaredMethods() {
        List<? extends Element> members = getAllDeclaredMembers(testType.asType());
        List<? extends ExecutableElement> methods = methodsIn(members);
        assertTrue(methods.size() > 0);
    }

    @Test
    void testDeclaredFields() {
        List<? extends Element> members = getAllDeclaredMembers(testType.asType());
        List<? extends VariableElement> fields = fieldsIn(members);
        assertTrue(fields.size() > 0);
    }

    @Test
    void testDeclaredConstructors() {
        List<? extends Element> members = getAllDeclaredMembers(testType.asType());
        List<? extends ExecutableElement> constructors = constructorsIn(members);
        assertTrue(constructors.size() > 0);
    }

    @Test
    void testDeclaredMethodsWithModifiers() {
        List<? extends Element> members = getAllDeclaredMembers(testType.asType());
        List<? extends ExecutableElement> methods = methodsIn(members);
        List<ExecutableElement> publicMethods = methods.stream().filter(ExecutableElement::isPublic).collect(Collectors.toList());
        assertTrue(publicMethods.size() > 0);
    }

    @Test
    void testDeclaredFieldsWithModifiers() {
        List<? extends Element> members = getAllDeclaredMembers(testType.asType());
        List<? extends VariableElement> fields = fieldsIn(members);
        List<VariableElement> publicFields = fields.stream().filter(VariableElement::isPublic).collect(Collectors.toList());
        assertTrue(publicFields.size() > <nl>
        if (data == null) {
            return null;
        }
        if (data.startsWith(INNERCLASS_SYMBOL) || data.startsWith(INNERCLASS_COMPATIBLE_SYMBOL)) {
            return data;
        }
        return INNERCLASS_SYMBOL + data;
    <|file_separator|><nl>
        return this.slidingWindow.currentPane().getValue();
    <|file_separator|><nl>
        return new TimePair(System.currentTimeMillis());
    <|file_separator|><nl>
        TimeWindowAggregator aggregator = new TimeWindowAggregator();
        aggregator.add(new TimeWindow(1, 10));
        aggregator.add(new TimeWindow(2, 10));
        aggregator.add(new TimeWindow(3, 10));
        aggregator.add(new TimeWindow(4, 10));
        aggregator.add(new TimeWindow(5, 10));
        aggregator.add(new TimeWindow(6, 10));
        aggregator.add(new TimeWindow(7, 10));
        aggregator.add(new TimeWindow(8, 10));
        aggregator.add(new TimeWindow(9, 10));
        aggregator.add(new TimeWindow(10, 10));
        aggregator.add(new TimeWindow(11, 10));
        aggregator.add(new TimeWindow(12, 10));
        aggregator.add(new TimeWindow(13, 10));
        aggregator.add(new TimeWindow(14, 10));
        aggregator.add(new TimeWindow(15, 10));
        aggregator.add(new TimeWindow(16, 10));
        aggregator.add(new TimeWindow(17, 10));
        aggregator.add(new TimeWindow(18, 10));
        aggregator.add(new TimeWindow(19, 10));
        aggregator.add(new TimeWindow(20, 10));
        aggregator.add(new TimeWindow(21, 10));
        aggregator.add(new TimeWindow(22, 10));<nl>
        if (postResult instanceof Throwable) {
            Throwable throwable = (Throwable) postResult;
            if (throwable instanceof InvocationTargetException) {
                throwable = ((InvocationTargetException) throwable).getTargetException();
            }
            if (throwable instanceof ServiceException) {
                ServiceException serviceException = (ServiceException) throwable;
                if (serviceException.getErrorCode() != null) {
                    putAttachment(MetricsConstants.INVOCATION_REQUEST_ERROR, serviceException.getErrorCode());
                }
            }
        }
    <|file_separator|><nl>
        MetricsInitEvent event = MetricsInitEvent.toMetricsInitEvent(
                applicationModel, new RpcInvocation("test", null, "test", "test", "test", null, null, null, null, null, null),
                MethodMetric.isServiceLevel(applicationModel));
        assertEquals(applicationModel, event.getApplicationModel());
        assertEquals("test", event.getInvocation().getInterfaceName());
        assertEquals("test", event.getInvocation().getMethodName());
        assertEquals("test", event.getInvocation().getInterfaceName());
        assertEquals("test", event.getInvocation().getProtocolServiceKey());
        assertEquals(MethodMetric.isServiceLevel(applicationModel), event.isServiceLevel());
    <|file_separator|><nl>
        MetricsEntity.add(name, tags, category, value);
    <|file_separator|><nl>
        this.success = success;
    <|file_separator|><nl>
        URL url = URL.valueOf("dubbo://10.10.10.10:2181")
                .addParameter(Constants.ACCESS_KEY_ID_KEY, "ak")
                .addParameter(Constants.SECRET_ACCESS_KEY_KEY, "sk")
                .addParameter(CommonConstants.APPLICATION_KEY, "test")
                .addParameter(Constants.SERVICE_AUTH, false);
        Invoker invoker = mock(Invoker.class);
        Invocation invocation = mock(Invocation.class);
        when(invoker.getUrl()).thenReturn(url);
        ConsumerSignFilter consumerSignFilter = new ConsumerSignFilter(ApplicationModel.defaultModel());
        consumerSignFilter.invoke(invoker, invocation);
        verify(invocation, times(1)).setAttachment(eq(Constants.REQUEST_SIGNATURE_KEY), anyString());
    <|file_separator|><nl>
        String[] split = str.split(" ");
        String cmd = split[0];
        String[] args = reBuildInvokeCmdArgs(cmd);
        return new CommandContext(cmd, args);
    <|file_separator|><nl>
        return this.doOnline(servicePattern);
    }

    protected boolean doOnline(String servicePattern) {
        return false;
    <|file_separator|><nl>
        return null;
    <|file_separator|><nl>
        MockLivenessProbe.checkReturnValue = checkReturnValue;
    <|file_separator|><nl>
        DemoService demoService = repository.getProvider(DemoService.class).get();
        demoService.execute();
    <|file_separator|><nl>
        ExtensionLoader.getExtensionLoader(Protocol.class)
                .getExtension(DubboProtocol.NAME)
                .export(mockInvoker);
        String result = change.telnet(mockChannel, "com.xxx.XxxService");
        assertEquals("Used the com.xxx.XxxService as default.rnYou can cancel default service by command: cd /", result);
    <|file_separator|><nl>
        this.age = age;
    }

    public void writeObject(ObjectOutputStream out) throws IOException {
        out.defaultWriteObject();
        out.writeObject(name);
        out.writeInt(age);
    }

    public void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
        in.defaultReadObject();
        name = (String) in.readObject();
        age = in.readInt();
    <|file_separator|><nl>
        TTable table = new TTable(4);
        table.addRow(1, "one", "uno", "un");
        table.addRow(2, "two", "dos", "deux");
        table.addRow(3, "three", "tres", "trois");
        String result = table.rendering();
        String expected = "+-+---+---+----+" + System.lineSeparator() + "|1|one|uno|un  |"
                + System.lineSeparator() + "+-+---+---+----+"
                + System.lineSeparator() + "|2|two|dos|deux|"
                + System.lineSeparator() + "+-+---+---+----+"
                + System.lineSeparator() + "|3|three|tres|trois|"
                + System.lineSeparator() + "+-+---+---+----+"
                + System.lineSeparator();
        assertThat(result, equalTo(expected));
        System.out.println(result);
    <|file_separator|><nl>
                                    emitter.success(tResponse);
                                <|file_separator|><nl>
        if (invocation.getArguments().length > 0) {
            if (invocation.getArguments()[0] instanceof SecurityContext) {
                SecurityContext securityContext = (SecurityContext) invocation.getArguments()[0];
                SecurityContextHolder.setContext(securityContext);
            }
        }
    <|file_separator|><nl>
                            return Collections.singletonList(serviceInfo);
                        <|file_separator|><nl>
        SubMigrationRule rule = new SubMigrationRule();
        rule.setServiceKey(map.get("serviceKey").toString());
        rule.setStep(MigrationStep.valueOf(map.get("step").toString()));
        rule.setThreshold(Float.parseFloat(map.get("threshold").toString()));
        rule.setProportion(Integer.parseInt(map.get("proportion").toString()));
        rule.setDelay(Integer.parseInt(map.get("delay").toString()));
        rule.setForce(Boolean.parseBoolean(map.get("force").toString()));
        return rule;
    <|file_separator|>class MigrationStep.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public enum MigrationStep {
    PRE_MIGRATION,
    MIGRATION,
    POST_MIGRATION
}<|file_separator|><nl>
        listener.onFailedSubscribed(url);
    <|file_separator|>class AbstractRetryTask.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>import java.net.URL;

public abstract class AbstractRetryTask implements RetryTask {

    private final URL url;
    private final FailbackRegistry registry;
    private final String name;

    public AbstractRetryTask(URL url, FailbackRegistry registry, String name) {
        if (url == null) {
            throw new IllegalArgumentException();
        }
        if (registry == null) {
            throw new IllegalArgumentException();
        }
        if (name == null) {
            throw new IllegalArgumentException();
        }
        this.url = url;
        this.registry = registry;
        this.name = name;
    }

    @Override
    public void retry(Timeout timeout) {
        doRetry(url, registry, timeout);
    }

    protected abstract void doRetry(URL url, FailbackRegistry registry, Timeout timeout);

    @Override
    public String getName() {
        return name;
    }
}<|file_separator|>class RetryTask.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public interface RetryTask {

    void retry(Timeout timeout);

    String getName();
}<|file_separator|>class RetryTaskManager.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>import java.util.List;

public class RetryTaskManager {

    private final List<RetryTask> tasks;

    public RetryTaskManager(List<RetryTask> tasks) {
        if (tasks == null) {
            throw new IllegalArgumentException();
        }
        this.tasks = tasks;
    }

    public void retry(Timeout timeout) {
        for (RetryTask task : tasks) {
            task.retry(timeout);
        }
    }
}<|file_separator|>class RetryTaskFactory.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>import java.net.URL<nl>
        registry.unregister(url);
    <|file_separator|>class AbstractRetryTask.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>import java.net.URL;
import java.util.concurrent.TimeUnit;

public abstract class AbstractRetryTask implements Runnable {

    private final URL url;
    private final FailbackRegistry registry;
    private final String name;
    private final Timeout timeout;

    public AbstractRetryTask(URL url, FailbackRegistry registry, String name) {
        this.url = url;
        this.registry = registry;
        this.name = name;
        this.timeout = new Timeout(TimeUnit.SECONDS.toMillis(10));
    }

    public void run() {
        try {
            doRetry(url, registry, timeout);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    protected abstract void doRetry(URL url, FailbackRegistry registry, Timeout timeout);
}<|file_separator|>class FailbackRegistry.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>import java.net.URL;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

public class FailbackRegistry {

    private final ConcurrentMap<URL, URL> failbacks = new ConcurrentHashMap<>();

    public void register(URL url, URL failback) {
        failbacks.put(url, failback);
    }

    public void unregister(URL url) {
        failbacks.remove(url);
    }

    public URL getFailback(URL url) {
        return failbacks.get(url);
    }
}<|file_separator|>class Timeout.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>import java.util.concurrent.TimeUnit;

public class Timeout {

    private final long timeout;

    public Timeout(long timeout) {
        this.timeout = timeout;
    }<nl>
        return this;
    <|file_separator|><nl>
        children.clear();
    }

    public void setStringUrls(Map<URL, Map<String, ServiceAddressURL>> stringUrls) {
        this.stringUrls = stringUrls;
    }

    public void setStringAddress(Map<String, URLAddress> stringAddress) {
        this.stringAddress = stringAddress;
    }

    public void setStringParam(Map<String, URLParam> stringParam) {
        this.stringParam = stringParam;
    <|file_separator|><nl>
        delegate.onUnregister(url, registry);
    <|file_separator|><nl>
        return new String[] {GROUP_KEY, "params-filter"};
    <|file_separator|><nl>
        MetaCacheManager cacheManager = new MetaCacheManager();
        try {
            cacheManager.dump();
        } finally {
            cacheManager.destroy();
        }
    <|file_separator|><nl>
        return null;
    <|file_separator|><nl>
        URL url = URL.valueOf("dubbo://" + NetUtils.getLocalAddress().getHostAddress() + ":8080?nacos.check=false&nacos.namespace=test");
        String registryCacheKey1 = nacosRegistryFactory.createRegistryCacheKey(url);
        String registryCacheKey2 = nacosRegistryFactory.createRegistryCacheKey(url);
        Assertions.assertEquals(registryCacheKey1, registryCacheKey2);
    <|file_separator|><nl>
        // register
        DefaultServiceInstance serviceInstance =
                createServiceInstance(SERVICE_NAME, LOCALHOST, NetUtils.getAvailablePort());
        // register
        nacosServiceDiscovery.doRegister(serviceInstance);

        List<ServiceInstance> serviceInstances = nacosServiceDiscovery.getServices();
        assertEquals(1, serviceInstances.size());
    }
<|file_separator|><nl>
        return phase == 0;
    <|file_separator|><nl>
        return realHandler;
    }

    public void handle(ChannelHandlerContext ctx) throws Exception {
        realHandler.handle(ctx);
    <|file_separator|><nl>
        return buffer.writerIndex() - startIndex;
    }

    @Override
    public void close() throws IOException {
        buffer.writerIndex(buffer.writerIndex() - startIndex);
    }

    @Override
    public void flush() throws IOException {
    <|file_separator|><nl>
        handlerDispatcher.removeChannelHandler(handler);
        return this;
    }

    public <T> ExchangeHandlerDispatcher addChannelHandler(Class<T> type, ChannelHandler<T> handler) {
        handlerDispatcher.addChannelHandler(type, handler);
        return this;
    }

    public <T> ExchangeHandlerDispatcher removeChannelHandler(Class<T> type) {
        handlerDispatcher.removeChannelHandler(type);
        return this;
    }

    public <T> ExchangeHandlerDispatcher addReplier(Class<T> type, Replier<T> replier, ChannelHandler<T> handler) {
        replierDispatcher.addReplier(type, replier);
        handlerDispatcher.addChannelHandler(type, handler);
        return this;
    }

    public <T> ExchangeHandlerDispatcher removeReplier(Class<T> type, ChannelHandler<T> handler) {
        replierDispatcher.removeReplier(type);
        handlerDispatcher.removeChannelHandler(type);
        return this;
    <|file_separator|><nl>
        return server.getLocalAddress();
    }

    @Override
    public InetSocketAddress getRemoteAddress() {
        return server.getRemoteAddress();
    }

    @Override
    public void send(Object message, InetSocketAddress remoteAddress) throws RemotingException {
        server.send(message, remoteAddress);
    <|file_separator|><nl>
        return new MultiMessage();
    <|file_separator|><nl>
        if (commandEnabled(channel.getUrl(), message)) {
            return extensionLoader.getExtension(channel.getUrl()).telnet(channel, message);
        }
        return null;<|file_separator|><nl>
        super.reset(url);
        this.codec = getChannelCodec(url);
    <|file_separator|><nl>
        if (message instanceof Map) {
            Map map = (Map) message;
            if (map.containsKey("data")) {
                Object data = map.get("data");
                if (data instanceof String) {
                    map.put("data", new String((String) data));
                }
            }
        }
    <|file_separator|><nl>
        try {
            handler.handle(channel, state, message, exception);
        } catch (Throwable t) {
            logger.error("Error while handling channel event", t);
        }
    <|file_separator|><nl>
        ExecutorService executor = getSharedExecutorService();
        try {
            executor.execute(new ChannelEventRunnable(channel, handler, ChannelState.RECEIVED, message));
        } catch (Throwable t) {
            throw new ExecutionException("received event", channel, getClass() + " error when process received event .", t);
        }
    <|file_separator|><nl>
        return handler;<|file_separator|><nl>
        if (message instanceof ExecutionRequest) {
            ExecutionRequest request = (ExecutionRequest) message;
            ExecutionResponse response = new ExecutionResponse();
            response.setRequestId(request.getRequestId());
            response.setResponse(request.getCommand().execute());
            channel.send(response);
        } else {
            super.received(channel, message);
        }<|file_separator|><nl>
        return url.getParameter(Constants.SERIALIZATION_KEY, DefaultSerializationSelector.getDefaultRemotingSerialization())
                .getBytes(Constants.UTF_8)
                .get(0);
    <|file_separator|><nl>
        return client;
    <|file_separator|><nl>
        return new ChannelBuffer[]{buffer};
    <|file_separator|><nl>
        return new DirectChannelBuffer(capacity);
    <|file_separator|><nl>
        return attributes.containsKey(key);
    <|file_separator|><nl>
        channel = new MockChannel();
        closeTimer = new HashedWheelTimer();
        closeTimerTask = new CloseTimerTask(channel, closeTimer);
    <|file_separator|><nl>
                return url;
            <|file_separator|><nl>
        URL url = URL.valueOf("dubbo://127.0.0.1:12345?close=10000");
        Assertions.assertEquals(10000, UrlUtils.getCloseTimeout(url));
    <|file_separator|><nl>
        return client;
    <|file_separator|><nl>
        this.writeTimeout = writeTimeout;
    <|file_separator|><nl>
        if (logger.isWarnEnabled()) {
            logger.warn(COMMON_UNEXPECTED_EXCEPTION, "", "", throwable.getMessage(), throwable);
        }
    }

    @Override
    public void error(String msg, Object... objects) {
        if (logger.isErrorEnabled()) {
            logger.error(COMMON_UNEXPECTED_EXCEPTION, "", "", this.format(msg, objects));
        }
    }

    @Override
    public void error(Throwable throwable) {
        if (logger.isErrorEnabled()) {
            logger.error(COMMON_UNEXPECTED_EXCEPTION, "", "", throwable.getMessage(), throwable);
        }
    }

    @Override
    public void error(String msg, Throwable throwable) {
        if (logger.isErrorEnabled()) {
            logger.error(COMMON_UNEXPECTED_EXCEPTION, "", "", msg, throwable);
        }
    <|file_separator|><nl>
        try {
            int responseCode = connection.getResponseCode();
            String responseMessage = connection.getResponseMessage();
            InputStream inputStream = connection.getInputStream();
            return new RestResult(responseCode, responseMessage, inputStream);
        } catch (IOException e) {
            return new RestResult(e);
        }
    <|file_separator|><nl>
        RequestTemplate requestTemplate = new RequestTemplate(null, "POST", "localhost:1234");
        RestClient restClient = new OKHttpRestClient(new HttpClientConfig());
        CompletableFuture<RestResult> send = restClient.send(requestTemplate);
        send.get();
    <|file_separator|><nl>
        return new NettyBackedChannelBuffer(ChannelBuffers.wrappedBuffer(nioBuffer));
    <|file_separator|><nl>
        <|file_separator|><nl>
        EventLoopGroup group = new NioEventLoopGroup();
        assertTrue(group instanceof EpollEventLoopGroup);
    }

    @Test
    void eventLoopGroup_noEpoll() {
        System.clearProperty(NETTY_EPOLL_ENABLE_KEY);
        EventLoopGroup group = new NioEventLoopGroup();
        assertTrue(group instanceof NioEventLoopGroup);
    }

    @Test
    void eventLoopGroup_epoll() {
        System.setProperty(NETTY_EPOLL_ENABLE_KEY, "true");
        EventLoopGroup group = new NioEventLoopGroup();
        assertTrue(group instanceof EpollEventLoopGroup);
    <|file_separator|><nl>
        return World.class;
    <|file_separator|><nl>
        return asyncContext != null;
    <|file_separator|><nl>
        return true;
    <|file_separator|><nl>
        return methodInvoker.invoke(instance, methodName, parameterTypes, arguments);
    <|file_separator|><nl>
        if (generic) {
            return proxyFactory.getProxy(invoker, generic);
        } else {
            return proxyFactory.getProxy(invoker);
        }
    }

    @Override
    public <T> T getProxy(Invoker<T> invoker, Class<T> type, URL url) throws RpcException {
        return export(proxyFactory.getProxy(invoker, type, url), type, url);
    <|file_separator|><nl>
        return CompletableFuture.supplyAsync(() -> {
            final T request = (T) arguments[0];
            final StreamObserver<R> responseObserver = (StreamObserver<R>) arguments[1];
            this.func.accept(request, responseObserver);
            return null;
        });
    <|file_separator|><nl>
        CancellationContext cancellationContext = new CancellationContext();
        CountDownLatch latch = new CountDownLatch(1);
        cancellationContext.addListener(rpcServiceContext -> {
            latch.countDown();
        });
        cancellationContext.cancel(null);
        latch.await();
    <|file_separator|><nl>
        int timeout = 3000;

        Invoker invoker = Mockito.mock(Invoker.class);
        when(invoker.invoke(any(Invocation.class))).thenReturn(new AppResponse("result"));
        when(invoker.getUrl())
                .thenReturn(
                        URL.valueOf("test://test:11/test?accesslog=true&group=dubbo&version=1.1&timeout=" + timeout));

        Invocation invocation = Mockito.mock(Invocation.class);
        when(invocation.getMethodName()).thenReturn("testInvokeWithTimeout");

        Result result = timeoutFilter.invoke(invoker, invocation);
        Assertions.assertEquals("result", result.getValue());
    <|file_separator|><nl>
        StubProxyFactoryWrapper stubProxyFactoryWrapper = new StubProxyFactoryWrapper();
        stubProxyFactoryWrapper.getProxy(new ClassA());
    <|file_separator|><nl>
        return "MyInvoker{" +
                "url=" + url +
                ", type=" + type +
                ", hasException=" + hasException +
                ", destroyed=" + destroyed +
                '}';
    <|file_separator|><nl>
        return new Status(true, "Server is up and running");
    <|file_separator|><nl>
        URL url = new URL("http://www.baidu.com");
        Response response = new Response();
        response.setResult(new Result(new Object()));
        ChannelBuffer buffer = writeBuffer(url, response, CodecSupport.getSerializationById(DUBBO_VERSION_PROTO_ID).getId(), false);
        ChannelBufferInputStream inputStream = new ChannelBufferInputStream(buffer);
        ObjectInput in = CodecSupport.getSerializationById(DUBBO_VERSION_PROTO_ID).deserialize(url, inputStream);
        Result result = (Result) in.readObject();
        assertEquals(result.getValue(), new Object());
    <|file_separator|><nl>
        connectionCreateContext.setConnectionProperty("header", "value");
    <|file_separator|><nl>
        parseContext.addPath(argInfo.getArgName());
    <|file_separator|><nl>
        outputStream.write(unSerializedBody.toString().getBytes());
    <|file_separator|><nl>
        CertManager certManager =
                url.getOrDefaultFrameworkModel().getBeanFactory().getBean(CertManager.class);
        Cert providerConnectionConfig = certManager.getProviderConnectionConfig(providerConnectionConfig);
        if (providerConnectionConfig == null) {
            return null;
        }

        SslContextBuilder builder = SslContextBuilder.forServer();
        InputStream serverTrustCertCollectionPath = null;
        InputStream serverCertChainFilePath = null;
        InputStream serverPrivateKeyFilePath = null;
        try {
            serverTrustCertCollectionPath = providerConnectionConfig.getTrustCertInputStream();
            if (serverTrustCertCollectionPath != null) {
                builder.trustManager(serverTrustCertCollectionPath);
            }

            serverCertChainFilePath = providerConnectionConfig.getKeyCertChainInputStream();
            serverPrivateKeyFilePath = providerConnectionConfig.getPrivateKeyInputStream();
            if (serverCertChainFilePath != null && serverPrivateKeyFilePath != null) {
                String password = providerConnectionConfig.getPassword();
                if (password != null) {
                    builder.keyManager(serverCertChainFilePath, serverPrivateKeyFilePath, password);
                } else {
                    builder.keyManager(serverCertChainFilePath, serverPrivateKeyFilePath);
                }
            }
        } catch (Exception e) {
            throw new IllegalArgumentException("Could not find certificate file or find invalid certificate.", e);
        } finally {
            safeCloseStream(serverTrustCertCollectionPath);
            safeCloseStream(serverCertChainFilePath);
            safeCloseStream(serverPrivateKeyFilePath);
        }
        return builder.sslProvider(findSslProvider()).build();
    <|file_separator|><nl><nl>
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        RegistrationResult that = (RegistrationResult) o;
        return Objects.equals(id, that.id);
    <|file_separator|><nl>
        return "Hello " + name;
    }

    @Override
    public String sayHello2(String name) {
        return "Hello " + name;
    }

    @Override
    public String sayHello3(String name) {
        return "Hello " + name;
    }

    @Override
    public String sayHello4(String name) {
        return "Hello " + name;
    }

    @Override
    public String sayHello5(String name) {
        return "Hello " + name;
    }

    @Override
    public String sayHello6(String name) {
        return "Hello " + name;
    }

    @Override
    public String sayHello7(String name) {
        return "Hello " + name;
    }

    @Override
    public String sayHello8(String name) {
        return "Hello " + name;
    }

    @Override
    public String sayHello9(String name) {
        return "Hello " + name;
    }

    @Override
    public String sayHello10(String name) {
        return "Hello " + name;
    }

    @Override
    public String sayHello11(String name) {
        return "Hello " + name;
    }

    @Override
    public String sayHello12(String name) {
        return "Hello " + name;
    }

    @Override
    public String sayHello13(String name) {
        return "Hello " + name;
    }

    @Override
    public String sayHello14(String name) {
        return "Hello " + name;
    }

    @Override
    public String sayHello15(String name) {
        <nl>
            return parseFrom(data, 0, data.length);
        }

        public static TripleResponseWrapper parseFrom(byte[] data, int offset, int length) {
            int serializeTypeTag = varIntDecode(data, offset);
            int serializeTypeTagLength = varIntDecode(data, offset + 5);
            String serializeType = new String(data, offset + 6, serializeTypeTagLength, StandardCharsets.UTF_8);
            int dataTag = varIntDecode(data, offset + 6 + serializeTypeTagLength);
            int dataLength = varIntDecode(data, offset + 6 + serializeTypeTagLength + 5);
            byte[] dataBytes = new byte[dataLength];
            System.arraycopy(data, offset + 6 + serializeTypeTagLength + 5, dataBytes, 0, dataLength);
            int typeTag = varIntDecode(data, offset + 6 + serializeTypeTagLength + 5 + dataLength);
            int typeTagLength = varIntDecode(data, offset + 6 + serializeTypeTagLength + 5 + dataLength + 5);
            String type = new String(data, offset + 6 + serializeTypeTagLength + 5 + dataLength + 6, typeTagLength, StandardCharsets.UTF_8);
            return new Builder()
                    .setSerializeType(serializeType)
                    .setData(dataBytes)
                    .setType(type)
                    .build();
        <|file_separator|><nl>
        return path2Invoker.put(path, invoker);
    <|file_separator|><nl>
        future.start(call);
    <|file_separator|><nl>
        this.streamChannelFuture.getNow().write(this.streamChannelFuture.getNow().read());
    <|file_separator|><nl>
        healthService.setStatus(service, status);
    <|file_separator|><nl>
        this.cause = cause;
        return super.completeExceptionally(cause);
    }

    @Override
    public boolean complete(Http2StreamChannel result) {
        this.cause = null;
        return super.complete(result);
    <|file_separator|><nl>
        Executor executor = executorSupport.getExecutor(msg.headers());
        tripleServerStream.setExecutor(executor);
        tripleServerStream.transportObserver.onData(msg.data(), msg.isEndStream());
    <|file_separator|><nl>
        return new ServiceKey(data.getClass(), data.getClass().getName());
    <|file_separator|><nl>
        return new TripleIsolationExecutorSupport(url);
    <|file_separator|><nl>
        try {
            Channel channel = item.channel();
            item.run(channel);
        } catch (CompletionException e) {
            item.promise().tryFailure(e.getCause());
        }
    <|file_separator|><nl>
        String str = "Exception1";
        String str1 = "Exception2";
        String str2 = "Exception3";
        String str3 = "Exception4";
        String str4 = "Exception5";
        String str5 = "Exception6";
        String str6 = "Exception7";
        String str7 = "Exception8";
        String str8 = "Exception9";
        String str9 = "Exception10";
        String str10 = "Exception11";
        String str11 = "Exception12";
        String str12 = "Exception13";
        String str13 = "Exception14";
        String str14 = "Exception15";
        String str15 = "Exception16";
        String str16 = "Exception17";
        String str17 = "Exception18";
        String str18 = "Exception19";
        String str19 = "Exception20";
        String str20 = "Exception21";
        String str21 = "Exception22";
        String str22 = "Exception23";
        String str23 = "Exception24";
        String str24 = "Exception25";
        String str25 = "Exception26";
        String str26 = "Exception27";
        String str27 = "Exception28";
        String str28 = "Exception29";
        String str29 = "Exception30";
        String str30 = "Exception31";
        String str31 = "Exception32";
        String str32 = "Exception33";
        String str33 = "Exception34";
        String str34 = "Exception35";<nl>
        if (close) return;
        if (dataCount == 0) {
            lastData = data;
            dataCount = data.length;
        } else {
            if (dataCount == data.length) {
                if (Arrays.equals(lastData, data)) {
                    close = true;
                }
            }
        }
    <|file_separator|><nl>
        throw new IGreeterException("I am self define exception");
    <|file_separator|><nl>
        if (classLoader == null) {
            classLoader = SYSTEM_CLASSLOADER_KEY;
        }
        readerMap.put(classLoader, new ObjectReaderCreatorASM());
        writerMap.put(classLoader, new ObjectWriterCreatorASM());
    }

    public ObjectReaderCreatorASM getReaderCreator(ClassLoader classLoader) {
        return readerMap.get(classLoader);
    }

    public ObjectWriterCreatorASM getWriterCreator(ClassLoader classLoader) {
        return writerMap.get(classLoader);
    <|file_separator|><nl>
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        TrustedPojo2 that = (TrustedPojo2) o;
        return Double.compare(that.data, data) == 0;
    <|file_separator|>class TrustedPojo1 implements Serializable {

    private final double data;

    public TrustedPojo1(double data) {
        this.data = data;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        TrustedPojo1 that = (TrustedPojo1) o;
        return Double.compare(that.data, data) == 0;
    }

    @Override
    public int hashCode() {
        return Objects.hash(data);
    }
}<|file_separator|><nl>
        return 0x00;
    <|file_separator|><nl>
        return new EnvironmentPropertyResolver(environment);
    <|file_separator|><nl>
        ApplicationContext applicationContext = springApplication.run(new String[]{});
        Assert.assertEquals(1, applicationContext.getBeanDefinitionCount());
    <|file_separator|><nl>
        return dubboScanBasePackagesPropertyResolver(environment).getPropertyValues().getProperty("basePackages", new LinkedHashSet<>());
    <|file_separator|><nl>
        Environment environment = beanFactory.getBean(Environment.class);
        String[] beanNames = beanFactory.getBeanNamesForType(ApplicationConfig.class);
        if (beanNames.length == 1) {
            String beanName = beanNames[0];
            if (isConfiguredApplicationConfigBeanName(environment, beanName)) {
                registry.removeBeanDefinition(beanName);
            }
        }
    <|file_separator|><nl>
        String zookeeperVersion = context.getZookeeperVersion();
        String zookeeperBinaryUrl = String.format(ZOOKEEPER_BINARY_URL_FORMAT, zookeeperVersion);
        Path zookeeperBinaryPath = Paths.get(TEMPORARY_DIRECTORY, String.format(ZOOKEEPER_FILE_NAME_FORMAT, zookeeperVersion));
        if (checkFile(zookeeperBinaryPath)) {
            logger.info("The zookeeper binary file already exists, skip download zookeeper binary file.");
        } else {
            try {
                download(zookeeperBinaryUrl, zookeeperBinaryPath);
            } catch (Exception e) {
                logger.error(
                        TESTING_REGISTRY_FAILED_TO_DOWNLOAD_ZK_FILE,
                        "",
                        "",
                        "Failed to download the file, download url: " + zookeeperBinaryUrl);
                throw new DubboTestException(e);
            }
        }
    <|file_separator|><nl>
        unpack(context, context.getClientPort());
    <|file_separator|><nl>
        ShardingContexts shardingContexts = createShardingContexts();
        assertThat(shardingContexts.getShardingItem()).isEqualTo(0);
    <|file_separator|><nl>
        final Properties props = new Properties();
        props.setProperty(EmailPropertiesConstants.HOST, "test");
        TypedSPILoader.getService(JobErrorHandlerPropertiesValidator.class, "EMAIL").validate(props);
    <|file_separator|><nl>
        return "ignore";<|file_separator|><nl>
        return false;
    <|file_separator|><nl>
        HttpPost httpPost = new HttpPost(webhook);
        httpPost.setEntity(new StringEntity(getJsonParameter(getErrorMessage(jobName, cause)), Charset.forName("UTF-8")));
        httpPost.setHeader("Content-Type", "application/json");
        httpPost.setHeader("Accept", "application/json");
        httpPost.setConfig(RequestConfig.custom().setConnectTimeout(connectTimeoutMilliseconds).setSocketTimeout(readTimeoutMilliseconds).build());
        return httpPost;
    <|file_separator|><nl>
        List<String> data = Arrays.asList("DataflowJob1", "DataflowJob2");
        when(jobConfig.getProps()).thenReturn(properties);
        when(properties.getOrDefault(DataflowJobProperties.STREAM_PROCESS_KEY, false)).thenReturn("true");
        when(elasticJob.fetchData(shardingContext)).thenReturn(data);
        jobExecutor.process(elasticJob, jobConfig, jobRuntimeService, shardingContext);
        verify(elasticJob, times(1)).processStreamingData(shardingContext, data);
    <|file_separator|><nl>
        when(jobConfig.getProps().getProperty(HttpJobProperties.URI_KEY)).thenReturn(getRequestUri("/post"));
        when(jobConfig.getProps().getProperty(HttpJobProperties.METHOD_KEY)).thenReturn("POST");
        when(jobConfig.getProps().getProperty(HttpJobProperties.DATA_KEY)).thenReturn("name=elasticjob");
        when(jobConfig.getProps().getProperty(HttpJobProperties.CONNECT_TIMEOUT_KEY, "3000")).thenReturn("4000");
        when(jobConfig.getProps().getProperty(HttpJobProperties.READ_TIMEOUT_KEY, "5000")).thenReturn("5000");
        jobExecutor.process(elasticJob, jobConfig, jobRuntimeService, shardingContext);
    <|file_separator|><nl>
        return ScriptJobProperties.TYPE;
    <|file_separator|><nl>
        return "Foo(" + id + ", " + location + ", " + status + ")";
    <|file_separator|><nl>
        jobExecutor.execute(context);
    <|file_separator|><nl>
        return Pattern.compile(jobNodePath.getFullPath(ServerNode.ROOT) + "/" + IpUtils.IP_REGEX).matcher(path).matches() && path.equals(jobNodePath.getFullPath(ServerNode.ROOT));
    }
    
    /**
     * Get server node path.
     *
     * @return server node path
     */
    public String getServerNodePath() {
        return jobNodePath.getFullPath(ServerNode.ROOT);
    }
    
    /**
     * Get server node path for localhost.
     *
     * @return server node path for localhost
     */
    public String getLocalServerNodePath() {
        return jobNodePath.getFullPath(ServerNode.ROOT);
    <|file_separator|><nl>
        JobRegistry.getInstance().setJobRunning(jobName, false);
    <|file_separator|><nl>
        if (isRegistered) {
            return;
        }
        isRegistered = true;
        eventBus.register(tracingConfig);
    <|file_separator|><nl>
        JobExecutionEnvironmentException exception = new JobExecutionEnvironmentException("Test");
        assertEquals("Test", exception.getMessage());
    <|file_separator|><nl>
        when(jobNodeStorage.getJobNodeData(ConfigurationNode.ROOT)).thenReturn(YamlConstants.getJobYaml());
        JobConfiguration actual = configService.load(true);
        assertThat(actual.getJobName(), is("test_job"));
        assertThat(actual.getCron(), is("0/1 * * * * ?"));
        assertThat(actual.getShardingTotalCount(), is(3));
    <|file_separator|><nl>
        assertTrue(leaderNode.isLeaderInstancePath("/test_job/leader/election/instance1"));
    <|file_separator|><nl>
        when(jobNodeStorage.isJobNodeExisted("guarantee/started")).thenReturn(false);
        assertFalse(guaranteeService.isAllStarted());
    <|file_separator|><nl>
        shutdownListenerManager = new ShutdownListenerManager(jobNodeStorage, instanceService, schedulerFacade);
    <|file_separator|><nl>
        listenerManager.setElectionListenerManager(electionListenerManager);
        listenerManager.setShardingListenerManager(shardingListenerManager);
        listenerManager.setFailoverListenerManager(failoverListenerManager);
        listenerManager.setMonitorExecutionListenerManager(monitorExecutionListenerManager);
        listenerManager.setShutdownListenerManager(shutdownListenerManager);
        listenerManager.setTriggerListenerManager(triggerListenerManager);
        listenerManager.setRescheduleListenerManager(rescheduleListenerManager);
        listenerManager.setGuaranteeListenerManager(guaranteeListenerManager);
        listenerManager.setRegCenterConnectionStateListener(regCenterConnectionStateListener);
    <|file_separator|><nl>
        when(configService.load(true)).thenReturn(JobConfiguration.newBuilder("test_job", 3).cron("0/1 * * * * ?").reconcileIntervalMinutes(1).build());
        when(shardingService.isNeedSharding()).thenReturn(true);
        when(shardingService.hasShardingInfoInOfflineServers()).thenReturn(true);
        when(regCenter.getChildrenKeys("/test_job/sharding")).thenReturn(Lists.newArrayList("0"));
        reconcileService.runOneIteration();
        verify(shardingService).isNeedSharding();
        verify(shardingService).hasShardingInfoInOfflineServers();
        verify(shardingService).setReshardingFlag();
    <|file_separator|><nl>
        JobClassNameProvider jobClassNameProvider = new DefaultJobClassNameProvider();
        String result = jobClassNameProvider.getJobClassName(new LambdaFooJob());
        assertThat(result, is("org.apache.shardingsphere.elasticjob.kernel.fixture.job.LambdaFooJob"));
    <|file_separator|><nl>
        setUpFacade.tearDown();
        verify(reconcileService).reconcile();
        verify(instanceService).persistOnline(false);
        verify(serverService).persistOnline(false);
        verify(listenerManager).stopAllListeners();
    <|file_separator|><nl>
        assertThat(new JobInstance().getJobInstanceId(), is("id"));
    <|file_separator|><nl>
        shardingContexts = new ShardingContexts(Arrays.asList(0, 1), 0, 1);
        distributeOnceElasticJobListener = new TestDistributeOnceElasticJobListener();
    }
    
    @Test
    void assertBeforeJobExecutedWhenIsAllStartedAndNotTimeout() {
        when(guaranteeService.isRegisterStartSuccess(Sets.newHashSet(0, 1))).thenReturn(true);
        when(guaranteeService.isAllStarted()).thenReturn(true);
        when(timeService.getCurrentMillis()).thenReturn(0L);
        distributeOnceElasticJobListener.beforeJobExecuted(shardingContexts);
        verify(guaranteeService).registerStart(Sets.newHashSet(0, 1));
        verify(guaranteeService, times(0)).clearAllStartedInfo();
    <|file_separator|><nl>
        Set<String> servers = new HashSet<>();
        for (String jobName : regCenter.getChildrenKeys("/")) {
            JobNodePath jobNodePath = new JobNodePath(jobName);
            servers.addAll(regCenter.getChildrenKeys(jobNodePath.getServerNodePath()));
        }
        return servers.stream()
                .map(serverName -> new ServerBriefInfo(serverName, regCenter.getNodeValue(serverName)))
                .collect(Collectors.toList());
    <|file_separator|><nl>
        assertThat(ShardingInfo.ShardingStatus.getShardingStatus(true, true, false), is(ShardingInfo.ShardingStatus.SHARDING_ERROR));
    <|file_separator|><nl>
        TransactionOperation actual = TransactionOperation.opUpdate("key", "value");
        assertThat(actual.getType(), is(Type.UPDATE));
        assertThat(actual.getKey(), is("key"));
        assertThat(actual.getValue(), is("value"));
    <|file_separator|><nl>
        return Collections.singletonList(CuratorException.class);
    <|file_separator|><nl>
        return new ExceptionHandleResult(ex, HttpStatus.INTERNAL_SERVER_ERROR);
    <|file_separator|><nl>
        return "Hello World";
    <|file_separator|><nl>
    <|file_separator|><nl>
        log.info("CustomTestJob execute");
        
        final String shardingItem = shardingContext.getShardingItem();
        final String shardingItem1 = shardingContext.getShardingItem(1);
        
        log.info("shardingItem: " + shardingItem);
        log.info("shardingItem1: " + shardingItem1);
        
        final Bar bar = barRepository.findOne(shardingItem);
        
        log.info("bar: " + bar);
    <|file_separator|><nl>
        String baseBeanName = generateBaseBeanName(annoMeta);
        String jobBeanName = baseBeanName + "Job";
        String jobBeanClassName = annoAttrs.getString("jobBeanClass");
        if (StringUtils.hasText(jobBeanClassName)) {
            BeanDefinitionBuilder jobBeanBuilder = BeanDefinitionBuilder.genericBeanDefinition(jobBeanClassName);
            jobBeanBuilder.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
            BeanDefinition jobBeanDef = jobBeanBuilder.getBeanDefinition();
            registry.registerBeanDefinition(jobBeanName, jobBeanDef);
        }
    <|file_separator|><nl>
        EMBED_TESTING_SERVER.stop();
    <|file_separator|><nl>
        REGISTRY_CENTER.start();
    <|file_separator|><nl>
        // TODO
    <|file_separator|><nl>
        assertThat(getREGISTRY_CENTER().get("/" + getJobName() + "/servers/" + JobRegistry.getInstance().getJobInstance(getJobName()).getServerIp()), is(ServerStatus.ENABLED.name()));
    }
    
    private void assertDisabledRegCenterInfo() {
        assertThat(getREGISTRY_CENTER().get("/" + getJobName() + "/servers/" + JobRegistry.getInstance().getJobInstance(getJobName()).getServerIp()), is(ServerStatus.DISABLED.name()));
    <|file_separator|><nl>
        if (notExist()) {
            syncDataService.sync();
        }
    <|file_separator|><nl>
        return new ConsulClient(consulProperties.getUri());
    <|file_separator|><nl>
        context.register(configuration);
        context.refresh();
        if (inlinedProperties != null && inlinedProperties.length > 0) {
            for (String property : inlinedProperties) {
                context.getEnvironment().getPropertySources().addFirst(new MapPropertySource("inlined", new HashMap<String, Object>() {
                    {
                        put(property, "inlined");
                    }
                }));
            }
        }
    <|file_separator|><nl>
        String dataId = "test";
        String group = "test";
        String content = "test";
        configService.publishConfig(dataId, group, content);
    <|file_separator|><nl>
        com.tencent.polaris.api.config.Configuration configuration = ConfigAPIFactory.defaultConfig();
        configuration.getConfigFile().getServerConnector().setAddresses(Collections.singletonList(polarisProperties.getUrl()));
        return ConfigFileServiceFactory.createConfigFileService(configuration);
    <|file_separator|><nl>
        return !this.configFileService.dataIdExist(pluginDataId);
    }

    @Override
    protected void create() {
        this.configFileService.createDataIdFile(this.polarisProperties.getPluginDataId());
        this.configFileService.createPluginDataFile(this.polarisProperties.getPluginDataId());
        this.configFileService.createAuthDataIdFile(this.polarisProperties.getPluginDataId());
        this.configFileService.createMetaFile(this.polarisProperties.getPluginDataId());
        this.configFileService.createProxySelectorFile(this.polarisProperties.getPluginDataId());
    <|file_separator|><nl>
        return new ZookeeperDataChangedInit(zkClient);
    <|file_separator|><nl>
        return ShenyuAdminResult.success(ShenyuResultMessage.UPDATE_SUCCESS, dashboardUserService.update(dashboardUserDTO));
    <|file_separator|><nl>
        DataChangedEvent dataChangedEvent = new DataChangedEvent(ConfigGroupEnum.PROXY_SELECTOR, DataEventTypeEnum.REMOVE,
                Collections.singletonList(DiscoveryTransfer.INSTANCE.mapToData(proxySelectorDTO)));
        eventPublisher.publishEvent(dataChangedEvent);
    <|file_separator|><nl>
        DisruptorProvider<DataTypeParent> provider = providerManage.getProvider();
        provider.onData(data);
    <|file_separator|><nl>
        final Map<String, List<URIRegisterDTO>> map = new HashMap<>();
        for (URIRegisterDTO data : dataList) {
            final String selectorName = data.getSelectorName();
            final List<URIRegisterDTO> list = map.get(selectorName);
            if (Objects.isNull(list)) {
                list = new LinkedList<>();
                map.put(selectorName, list);
            }
            list.add(data);
        }
        return map;
    <|file_separator|><nl>
        super.modifyHandshake(sec, request, response);
        final String originHeaderValue = request.getHeaders().get(ORIGIN);
        if (StringUtils.isNotEmpty(originHeaderValue)) {
            sec.getUserProperties().put(ORIGIN, originHeaderValue);
        }
    <|file_separator|><nl>
        WebsocketData<AppAuthData> configData =
                new WebsocketData<>(ConfigGroupEnum.APP_AUTH.name(), eventType.name(), appAuthDataList);
        WebsocketCollector.send(GsonUtils.getInstance().toJson(configData), eventType);
    <|file_separator|><nl>
        TRANSACTION_INFO_HOLDER.set(status);
    <|file_separator|><nl>
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        final AuthPathDTO that = (AuthPathDTO) o;
        return Objects.equals(appName, that.appName) &&
                Objects.equals(path, that.path) &&
                Objects.equals(enabled, that.enabled);
    <|file_separator|><nl>
        this.pluginName = pluginName;
    <|file_separator|><nl>
            this.component = component;
            return this;
        <|file_separator|><nl>
        this.name = name;
    <|file_separator|><nl>
            this.isRoute = isRoute;
            return this;
        <|file_separator|><nl>
            this.matchMode = matchMode;
            return this;
        <|file_separator|><nl>
            this.dateCreated = dateCreated;
            return this;
        <|file_separator|><nl>
        return this.source;
    <|file_separator|>class DictChangedEvent extends Event {
    
    
    /**
     * Create a new {@code DictChangedEvent}.
     *
     * @param source   Current dict state
     * @param before   before dict state
     * @param type     type
     * @param operator operator
     */
    public DictChangedEvent(final ShenyuDictDO source, final ShenyuDictDO before, final EventTypeEnum type, final String operator) {
        super(type);
        this.source = source;
        this.before = before;
        this.operator = operator;
    }
    
    /**
     * the update dict.
     *
     * @return dict
     */
    public ShenyuDictDO getDict() {
        return this.source;
    }
    
    /**
     * the before dict.
     *
     * @return dict
     */
    public ShenyuDictDO getBefore() {
        return this.before;
    }
    
    /**
     * the operator.
     *
     * @return operator
     */
    public String getOperator() {
        return this.operator;
    }
    
    /**
     * the current dict.
     */
    private ShenyuDictDO source;
    
    /**
     * the before dict.
     */
    private ShenyuDictDO before;
    
    /**
     * the operator.
     */
    private String operator;
    
}<|file_separator|><nl>
        return String.format("user[%s] %s", getChangedUser().getUserName(), contrast());
    <|file_separator|><nl>

        return pageParameter;
    }

    /**
     * setName.
     *
     * @param name name
     */
    public void setName(final String name) {

        this.name = name;
    }

    /**
     * setPageParameter.
     *
     * @param pageParameter pageParameter
     */
    public void setPageParameter(final PageParameter pageParameter) {

        this.pageParameter = pageParameter;
    }

    /**
     * toString.
     *
     * @return String
     */
    @Override
    public String toString() {

        return "ProxySelectorQuery [name=" + name + ", pageParameter=" + pageParameter + "]";
    <|file_separator|><nl>
        return appParam;
    <|file_separator|><nl>
        return super.equals(o);
    <|file_separator|><nl>
        this.weight = weight;
    <|file_separator|><nl>
        this.paramValue = paramValue;
    <|file_separator|><nl>
        return "";<|file_separator|><nl>
        try {
            unionFailResponse(servletResponse);
        } catch (final Exception e) {
            LOG.error("unionFailResponse error", e);
        }
        return false;<|file_separator|><nl>
        UserInfo userInfo = (UserInfo) SecurityUtils.getSubject().getPrincipal();
        if (Objects.nonNull(userInfo) && ADMIN_NAME.equals(userInfo.getUserName())) {
            return new SimpleAuthorizationInfo();
        }
        return super.getAuthorizationInfo(principalCollection);
    <|file_separator|><nl>
        isTrue(collection != null && !collection.isEmpty(), message);
    }
    
    /**
     * assert collection is empty.
     *
     * @param collection obj
     * @param message    error message
     */
    public static void isEmpty(final Collection<?> collection, final String message) {
        isTrue(collection == null || collection.isEmpty(), message);
    }
    
    /**
     * assert map is not empty.
     *
     * @param map     map
     * @param message error message
     */
    public static void notEmpty(final Map<?, ?> map, final String message) {
        isTrue(map != null && !map.isEmpty(), message);
    }
    
    /**
     * assert map is empty.
     *
     * @param map     map
     * @param message error message
     */
    public static void isEmpty(final Map<?, ?> map, final String message) {
        isTrue(map == null || map.isEmpty(), message);
    }
    
    /**
     * assert list is not empty.
     *
     * @param list    list
     * @param message error message
     */
    public static void notEmpty(final List<?> list, final String message) {
        isTrue(list != null && !list.isEmpty(), message);
    }
    
    /**
     * assert list is empty.
     *
     * @param list    list
     * @param message error message
     */
    public static void isEmpty(final List<?> list, final String message) {
        isTrue(list == null || list.isEmpty(), message);
    }
    
    /**
     * assert obj is not empty.
     *
     * @param obj     obj
     * @<nl>
        return visitor().isAdmin();
    }
    
    /**
     * current user is app.
     *
     * @return boolean
     */
    public static boolean isApp() {
        return visitor().isApp();
    }
    
    /**
     * current user is bootstrap.
     *
     * @return boolean
     */
    public static boolean isBootstrap() {
        return visitor().isBootstrap();
    <|file_separator|><nl>
        final PageParameter pageParameter = new PageParameter();
        when(point.getArgs()).thenReturn(new Object[]{pageParameter});
        when(point.proceed()).thenReturn(new Page());
        final Page page = pageableAspect.mapperAround(point);
        assertEquals(page.getPageNum(), pageParameter.getCurrentPage());
        assertEquals(page.getPageSize(), pageParameter.getPageSize());
        assertEquals(page.getPages(), pageParameter.getTotalPage());
        assertEquals(page.getTotal(), pageParameter.getTotalCount());
        assertEquals(page.getPageSize(), pageParameter.getOffset());
    <|file_separator|><nl>
        DataBaseConfiguration dataBaseConfiguration = new DataBaseConfiguration();
        dataBaseConfiguration.setDriverClassName("com.mysql.jdbc.Driver");
        dataBaseConfiguration.setUrl("jdbc:mysql://localhost:3306/test");
        dataBaseConfiguration.setUsername("root");
        dataBaseConfiguration.setPassword("root");
        assertEquals("com.mysql.jdbc.Driver", dataBaseConfiguration.getDriverClassName());
        assertEquals("jdbc:mysql://localhost:3306/test", dataBaseConfiguration.getUrl());
        assertEquals("root", dataBaseConfiguration.getUsername());
        assertEquals("root", dataBaseConfiguration.getPassword());
    <|file_separator|><nl>
        JwtProperties jwtProperties = new JwtProperties();
        assertEquals("secret", jwtProperties.getSecret());
        assertEquals("token", jwtProperties.getToken());
    <|file_separator|><nl>
        AppAuthDO appAuthDO = new AppAuthDO();
        appAuthDO.setAppKey("appKey");
        appAuthDO.setAppSecret("appSecret");
        appAuthDO.setPhone("phone");
        appAuthDO.setPhoneSecret("phoneSecret");
        appAuthDO.setAppSecretSecret("appSecretSecret");
        appAuthDO.setAppSecretSecret("appSecretSecret");
        appAuthDO.setAppSecretSecret("appSecretSecret");
        appAuthDO.setAppSecretSecret("appSecretSecret");
        appAuthDO.setAppSecretSecret("appSecretSecret");
        appAuthDO.setAppSecretSecret("appSecretSecret");
        appAuthDO.setAppSecretSecret("appSecretSecret");
        appAuthDO.setAppSecretSecret("appSecretSecret");
        appAuthDO.setAppSecretSecret("appSecretSecret");
        appAuthDO.setAppSecretSecret("appSecretSecret");
        appAuthDO.setAppSecretSecret("appSecretSecret");
        appAuthDO.setAppSecretSecret("appSecretSecret");
        appAuthDO.setAppSecretSecret("appSecretSecret");
        appAuthDO.setAppSecretSecret("appSecretSecret");
        appAuthDO.setAppSecretSecret("appSecretSecret");
        appAuthDO.setAppSecretSecret("appSecretSecret");
        appAuthDO.setAppSecretSecret("appSecretSecret");
        appAuthDO.setAppSecretSecret("appSecretSecret");
        appAuthDO.setAppSecretSecret("appSecretSecret");
        appAuthDO.setAppSecretSecret("appSecretSecret");
        appAuthDO.setAppSecretSecret("appSecretSecret");
        appAuthDO.setAppSecretSecret("appSecretSecret");
        appAuthDO.<nl>
        RuleDO ruleDO = buildRuleDO();
        int insert = ruleMapper.insert(ruleDO);
        assertThat(insert, equalTo(1));

        RuleQuery ruleQuery = new RuleQuery();
        ruleQuery.setSelectorId(ruleDO.getSelectorId());
        int count = ruleMapper.countByQuery(ruleQuery);
        assertThat(count, equalTo(1));

        int delete = ruleMapper.delete(ruleDO.getId());
        assertThat(delete, equalTo(1));
    <|file_separator|><nl>
        TagDO record = buildTagDO();
        int count = tagMapper.insertSelective(record);
        assertEquals(count, 1);
        record.setName("222");
        int update = tagMapper.updateByPrimaryKey(record);
        assertEquals(update, 1);
        int delete = tagMapper.deleteByPrimaryKey(record.getId());
        assertEquals(delete, 1);
    <|file_separator|><nl>
        final DocParameter docParameter1 = new DocParameter();
        docParameter1.setId(0);
        docParameter1.setModule("shenyuSetModule");
        docParameter1.setName("shenyuName");
        docParameter1.setRequired(true);
        docParameter1.setType("shenyuType");
        docParameter1.setXExample("shenyuXExample");

        final DocParameter docParameter2 = new DocParameter();
        docParameter2.setId(0);
        docParameter2.setModule("shenyuSetModule");
        docParameter2.setName("shenyuName");
        docParameter2.setRequired(true);
        docParameter2.setType("shenyuType");
        docParameter2.setXExample("shenyuXExample");

        assertEquals(docParameter1, docParameter2);
    }

    @Test
    public void testToString() {
        assertEquals("DocParameter(id=0, module=shenyuSetModule, name=shenyuName, required=true, type=shenyuType, xExample=shenyuXExample)", docParameter.toString());
    }

    @Test
    public void testHashCode() {
        final DocParameter docParameter1 = new DocParameter();
        docParameter1.setId(0);
        docParameter1.setModule("shenyuSetModule");
        docParameter1.setName("shenyuName");
        docParameter1.setRequired(true);
        docParameter1.setType("shenyuType");
        docParameter1.setXExample("shenyuXExample");

        final DocParameter docParameter2 = new DocParameter();
        docParameter2.setId(0);
        docParameter2.setModule("shenyuSetModule");
        docParameter2.setName("shenyuName");
        docParameter<nl>
        one = new ShenyuDictDO();
        one.setDictId("one");
        one.setDictName("one");
        one.setDictType(DictTypeEnum.DICT_TYPE_1);
        one.setDictStatus(DictStatusEnum.DICT_STATUS_1);
        one.setDictDesc("one");
        one.setDictCode("one");
        one.setDictValue("one");
        one.setDictValueDesc("one");
        one.setDictValueCode("one");
        one.setDictValueCodeDesc("one");
        one.setDictValueCodeType(DictValueCodeTypeEnum.DICT_VALUE_CODE_TYPE_1);
        one.setDictValueCodeValue("one");
        one.setDictValueCodeValueDesc("one");
        one.setDictValueCodeValueCode("one");
        one.setDictValueCodeValueCodeDesc("one");
        one.setDictValueCodeValueCodeType(DictValueCodeValueCodeTypeEnum.DICT_VALUE_CODE_VALUE_CODE_TYPE_1);
        one.setDictValueCodeValueCodeValue("one");
        one.setDictValueCodeValueCodeValueDesc("one");
        one.setDictValueCodeValueCodeValueCode("one");
        one.setDictValueCodeValueCodeValueCodeDesc("one");
        one.setDictValueCodeValueCodeValueCodeType(DictValueCodeValueCodeValueCodeTypeEnum.DICT_VALUE_CODE_VALUE_CODE_VALUE_CODE_TYPE_1);
        one.setDictValueCodeValueCodeValueCodeValue("one");
        one.setDictValueCodeValueCodeValueCodeValueDesc("one");
        one.setDictValueCodeValueCodeValueCodeValueCode("one");
        one.setDictValueCodeValueCodeValue<nl>
        BatchChangePluginHandleContext context = new BatchChangePluginHandleContext();
        context.addPluginHandleDO(one);
        context.addPluginHandleDO(two);
        context.setPluginHandleDOList(Arrays.asList(one, two));
        context.setPluginHandleDOList(Arrays.asList(one, two));
        context.setPluginHandleDOList(Arrays.asList(one, two));
        context.setPluginHandleDOList(Arrays.asList(one, two));
    <|file_separator|><nl>
        resourceDO = new ResourceDO();
    <|file_separator|><nl>
        UserCreatedEvent userCreatedEvent = new UserCreatedEvent(dashboardUserDO);
        assertEquals("1", userCreatedEvent.getId());
        assertEquals("adminTest", userCreatedEvent.getUserName());
        assertEquals("123456", userCreatedEvent.getPassword());
        assertEquals(1, userCreatedEvent.getRole());
        assertEquals(true, userCreatedEvent.isEnabled());
    <|file_separator|><nl>
        before = new DashboardUserDO();
        before.setUserName("test-user");
        before.setPassword("test-password");
        before.setRole("test-role");
        before.setEnabled(true);

        after = new DashboardUserDO();
        after.setUserName("test-user");
        after.setPassword("test-password");
        after.setRole("test-role");
        after.setEnabled(true);
    <|file_separator|><nl>
        return AppAuthVO.class;
    }

    @Override
    protected Object getTestObject() {
        return new AppAuthVO();
    <|file_separator|><nl>
        assertEquals(StringUtils.EMPTY, shenyuClientRegisterMotanService.selectorHandler());
    <|file_separator|><nl>
        List<URIRegisterDTO> list = new ArrayList<>();
        list.add(URIRegisterDTO.builder().appName("test1").rpcType(RpcTypeEnum.TARS.getName()).host("localhost").port(8090).build());
        SelectorDO selectorDO = mock(SelectorDO.class);
        when(selectorDO.getHandle()).thenReturn("[{\"weight\":1,\"warmup\":10,\"upstreamUrl\":\"localhost:8090\",\"status\":true,\"timestamp\":1637826588267}]");
        List<TarsUpstream> resultList = shenyuClientRegisterTarsService.buildTarsUpstreamList(list, selectorDO);
        assertEquals(resultList.size(), 1);
    <|file_separator|><nl>
            return Optional.ofNullable(apiMethod)
                    .map(m -> m.getAnnotation(annotationClass))
                    .orElse(null);
        <|file_separator|><nl>
        return new ShenyuClientRegisterRepository(shenyuRegisterCenterConfig);
    <|file_separator|><nl>
        final List<ApiBean> apiBeans = new ArrayList<>();
        for (final RpcApiBeansExtractor rpcApiBeansExtractor : rpcApiBeansExtractors) {
            apiBeans.addAll(rpcApiBeansExtractor.extract(applicationContext));
        }
        return apiBeans;
    <|file_separator|><nl>
        return "{}";
    <|file_separator|><nl>
            try {
                while (true) {
                    Thread.sleep(1000);
                    System.out.println("TakeoverOtherHooksThread");
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        <|file_separator|><nl>
        return delegate().getAttributes();
    }

    @Override
    public void setAttributes(final Attributes attributes) {
        delegate().setAttributes(attributes);
    }

    @Override
    public void setTimeout(final Duration timeout) {
        delegate().setTimeout(timeout);
    }

    @Override
    public void setDeadline(final Deadline deadline) {
        delegate().setDeadline(deadline);
    }

    @Override
    public void setCompression(final Compression compression) {
        delegate().setCompression(compression);
    }

    @Override
    public void setCompression(final Compression.Type type) {
        delegate().setCompression(type);
    }

    @Override
    public void setCompression(final Compression.Algorithm algorithm) {
        delegate().setCompression(algorithm);
    }

    @Override
    public void setCompression(final Compression.Algorithm algorithm, final int level) {
        delegate().setCompression(algorithm, level);
    }

    @Override
    public void setCompression(final Compression.Algorithm algorithm, final int level, final int maxMessageSize) {
        delegate().setCompression(algorithm, level, maxMessageSize);
    }

    @Override
    public void setCompression(final Compression.Algorithm algorithm, final int level, final int maxMessageSize,
            final int maxHeaderSize) {
        delegate().setCompression(algorithm, level, maxMessageSize, maxHeaderSize);
    }

    @Override
    public void setCompression(final Compression.Algorithm algorithm, final int level, final int maxMessageSize,
            final int maxHeaderSize, final int maxMetadataSize) {
        delegate().setCompression(algorithm, level, maxMessageSize, maxHeaderSize, maxMetadataSize);
    }

    @Override
    public void setCompression(final<nl>
        try {
            delegate.onMessage(message);
        } catch (final Throwable t) {
            LOG.error("Error while processing message", t);
        }
    }

    @Override
    public void onReady() {
        super.onReady();
    }

    @Override
    public void onCancel() {
        super.onCancel();
    }

    @Override
    public void onHalfClose() {
        super.onHalfClose();
    }

    @Override
    public void onCompleted(final Status status) {
        super.onCompleted(status);
    }

    @Override
    public void onReady() {
        super.onReady();
    }

    @Override
    public void onCancel() {
        super.onCancel();
    }

    @Override
    public void onHalfClose() {
        super.onHalfClose();
    }

    @Override
    public void onCompleted(final Status status) {
        super.onCompleted(status);
    }

    @Override
    public void onReady() {
        super.onReady();
    }

    @Override
    public void onCancel() {
        super.onCancel();
    }

    @Override
    public void onHalfClose() {
        super.onHalfClose();
    }

    @Override
    public void onCompleted(final Status status) {
        super.onCompleted(status);
    }

    @Override
    public void onReady() {
        super.onReady();
    }

    @Override
    public void onCancel() {
        super.onCancel();
    }

    @Override
    public void onHalfClose() {
        super.onHalfClose();
    }

    @Override
    public void onCompleted<nl>
        TestRequest testRequest = new TestRequest();
        testRequest.setTestString("test");
        testRequest.setTestInt(1);
        testRequest.setTestBoolean(true);
        testRequest.setTestDouble(1.1);
        testRequest.setTestLong(1L);
        testRequest.setTestFloat(1.1f);
        testRequest.setTestByte(1);
        testRequest.setTestShort(1);
        testRequest.setTestEnum(TestEnum.TEST_ENUM_1);
        testRequest.setTestList(Arrays.asList(1, 2, 3));
        testRequest.setTestMap(new HashMap<String, String>() {{
            put("test", "test");
        }});
        testRequest.setTestObject(new TestObject() {{
            setTestString("test");
            setTestInt(1);
            setTestBoolean(true);
            setTestDouble(1.1);
            setTestLong(1L);
            setTestFloat(1.1f);
            setTestByte(1);
            setTestShort(1);
            setTestEnum(TestEnum.TEST_ENUM_1);
            setTestList(Arrays.asList(1, 2, 3));
            setTestMap(new HashMap<String, String>() {{
                put("test", "test");
            }});
        }});
        TestResponse testResponse = new TestResponse();
        testResponse.setTestString("test");
        testResponse.setTestInt(1);
        testResponse.setTestBoolean(true);
        testResponse.setTestDouble(1.1);
        testResponse.setTestLong(1L);
        testResponse.setTestFloat(1.1<nl><nl>
        return new SpringMvcApiBeansExtractor();
    <|file_separator|><nl>
        queue.remove(e);
    <|file_separator|><nl>
        this.md5 = md5;
        return this;
    <|file_separator|><nl>
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        final MotanRegisterConfig that = (MotanRegisterConfig) o;
        return Objects.equals(registerProtocol, that.registerProtocol)
                && Objects.equals(registerAddress, that.registerAddress)
                && Objects.equals(threadpool, that.threadpool)
                && Objects.equals(corethreads, that.corethreads)
                && Objects.equals(threads, that.threads)
                && Objects.equals(queues, that.queues);
    <|file_separator|><nl>
        return "RewriteHandle{" +
                "regex='" + regex + '\'' +
                ", replace='" + replace + '\'' +
                ", percentage=" + percentage +
                ", rewriteMetaData=" + rewriteMetaData +
                '}';
    <|file_separator|><nl>
        return "WafHandle{" +
                "permission='" + permission + '\'' +
                ", statusCode='" + statusCode + '\'' +
                '}';
    <|file_separator|><nl>
        return Objects.hash(upstreamHost, protocol, upstreamUrl);
    <|file_separator|><nl>
        return rpcType.toLowerCase();
    <|file_separator|><nl>
        String mockPlugin = "MockPlugin";
        String mokPluginInfoKey = RedisKeyConstants.pluginSelectorKey(mockPlugin);
        assertThat(mockPlugin, notNullValue());
        assertThat(String.join("", mockPlugin, PLUGIN_SELECTOR), equalTo(mokPluginInfoKey));
    <|file_separator|><nl>
        AuthPathData authPathData = AuthPathData.builder().appName("appName").enabled(true).path("path").build();
        
        assertThat(authPathData.getAppName(), is("appName"));
        assertThat(authPathData.getPath(), is("path"));
        assertThat(authPathData.isEnabled(), is(true));
    <|file_separator|><nl>
        RequestHandle handle = new RequestHandle();
        RequestHandle.ShenyuRequestParameter parameter = handle.new ShenyuRequestParameter(
                ImmutableMap.of("addKey", "addValue"), ImmutableMap.of("replaceKey", "newKey"),
                ImmutableMap.of("setKey", "newValue"), Sets.newSet("removeKey")
        );
        
        assertThat(parameter.isNotEmptyConfig(), is(true));
        assertThat(parameter.getAddParameters(), hasEntry("addKey", "addValue"));
        assertThat(parameter.getReplaceParameterKeys(), hasEntry("replaceKey", "newKey"));
        assertThat(parameter.getSetParameters(), hasEntry("setKey", "newValue"));
        assertThat(parameter.getRemoveParameterKeys(), hasItems("removeKey"));
        
        RequestHandle.ShenyuRequestParameter parameter1 = handle.new ShenyuRequestParameter();
        parameter1.setAddParameters(ImmutableMap.of("addKey", "addValue"));
        parameter1.setReplaceParameterKeys(ImmutableMap.of("replaceKey", "newKey"));
        parameter1.setSetParameters(ImmutableMap.of("setKey", "newValue"));
        parameter1.setRemoveParameterKeys(ImmutableSet.of("removeKey"));
        
        assertThat(ImmutableSet.of(parameter, parameter1), hasSize(1));
    <|file_separator|><nl>
        
    <|file_separator|><nl>
        DivideRuleHandle handle = new DivideRuleHandle();
        
        handle.setRule(new DivideRule());
        
        assertThat(handle.getRule(), is(new DivideRule()));
    <|file_separator|><nl>
        SofaRuleHandle handle = new SofaRuleHandle();
        
        handle.setRuleId(1);
        handle.setRuleName("test");
        handle.setRuleType(1);
        handle.setRuleStatus(1);
        handle.setRuleDesc("test");
        handle.setRuleContent("test");
        handle.setRuleContent("test");
        handle.setRuleContent("test");
        handle.setRuleContent("test");
        handle.setRuleContent("test");
        handle.setRuleContent("test");
        handle.setRuleContent("test");
        handle.setRuleContent("test");
        handle.setRuleContent("test");
        handle.setRuleContent("test");
        handle.setRuleContent("test");
        handle.setRuleContent("test");
        handle.setRuleContent("test");
        handle.setRuleContent("test");
        handle.setRuleContent("test");
        handle.setRuleContent("test");
        handle.setRuleContent("test");
        handle.setRuleContent("test");
        handle.setRuleContent("test");
        handle.setRuleContent("test");
        handle.setRuleContent("test");
        handle.setRuleContent("test");
        handle.setRuleContent("test");
        handle.setRuleContent("test");
        handle.setRuleContent("test");
        handle.setRuleContent("test");
        handle.setRuleContent("test");
        handle.setRuleContent("test");
        handle.setRuleContent("test");
        handle.setRuleContent("test");
        handle.setRuleContent("test");
        handle.setRuleContent("test");
        handle.setRuleContent("test");
        handle.setRule<nl>
        ZombieUpstream upstream1 = ZombieUpstream.builder().selectorId("id").zombieCheckTimes(10)
                .commonUpstream(new CommonUpstream()).build();
        
        ZombieUpstream upstream2 = ZombieUpstream.builder().selectorId("id").zombieCheckTimes(10)
                .commonUpstream(new CommonUpstream()).build();
        
        assertThat(upstream1, is(upstream2));
        assertThat(upstream1.hashCode(), is(upstream2.hashCode()));
    <|file_separator|><nl>
        assertEquals("ADMIN_RESOURCE", AdminResourceEnum.ADMIN_RESOURCE.getCode());
    <|file_separator|><nl>
        PluginHandlerEventEnum event = PluginHandlerEventEnum.ON_LOAD;
        assertEquals(event.name(), "ON_LOAD");
    <|file_separator|><nl>
        WheelTimerFactory wheelTimerFactory = WheelTimerFactory.getShared();
        assertNotNull(wheelTimerFactory);
    <|file_separator|><nl>
        assertTrue(ObjectTypeUtils.isBasicType(String.class));
    <|file_separator|><nl>
        String uri = PathUtils.decoratorContextPath(URI);
        assertThat(uri, is(URI + AdminConstants.URI_SUFFIX));

        uri = PathUtils.decoratorContextPath(URI_WRAPPER);
        assertThat(uri, is(URI + AdminConstants.URI_SUFFIX));
    <|file_separator|><nl>
        String ret = UriUtils.appendScheme("http", "https");
        assertEquals("https", ret);

        ret = UriUtils.appendScheme("https", "http");
        assertEquals("https", ret);
    }

    @Test
    void appendPath() {
        String ret = UriUtils.appendPath("http", "https");
        assertEquals("/https", ret);

        ret = UriUtils.appendPath("https", "http");
        assertEquals("/http", ret);
    }

    @Test
    void appendQuery() {
        String ret = UriUtils.appendQuery("http", "https");
        assertEquals("https", ret);

        ret = UriUtils.appendQuery("https", "http");
        assertEquals("https", ret);
    }

    @Test
    void appendFragment() {
        String ret = UriUtils.appendFragment("http", "https");
        assertEquals("https", ret);

        ret = UriUtils.appendFragment("https", "http");
        assertEquals("https", ret);
    }

    @Test
    void removeScheme() {
        String ret = UriUtils.removeScheme("http");
        assertEquals("", ret);

        ret = UriUtils.removeScheme("https");
        assertEquals("", ret);
    }

    @Test
    void removePath() {
        String ret = UriUtils.removePath("http");
        assertEquals("", ret);

        ret = UriUtils.removePath("https");
        assertEquals("", ret);
    }

    @Test
    void removeQuery() {
        String ret = UriUtils.removeQuery("http");
        assertEquals("", ret);

        ret = UriUtils.removeQuery("https");
        assertEquals("", ret);
    }

    @Test
    void removeFragment() {
        String<nl>
        return applicationName;
    <|file_separator|><nl>
        return data;
    <|file_separator|><nl>
        try {
            ringBuffer.publishEvent(translatorOneArg, data);
        } catch (Exception ex) {
            logger.error("ex", ex);
        }
    <|file_separator|><nl>
        final Thread thread = new Thread(THREAD_GROUP, runnable, namePrefix + THREAD_NUMBER.getAndIncrement(), 0);
        thread.setDaemon(daemon);
        thread.setPriority(priority);
        return thread;
    <|file_separator|><nl>
            this.name2id = name2id;
        <|file_separator|><nl>
        return name + "." + scenarioId;
    <|file_separator|><nl>
            resources.add(new Resource(selector, bindingData, ImmutableList.<RuleData>builder().add(rules).build()));
            return this;
        <|file_separator|><nl>
            this.retryStrategy = retryStrategy;
            return this;
        <|file_separator|><nl>
        this.weight = weight;
    <|file_separator|><nl>
            this.deleteWaiting = Waiting.of(checker);
            return this;
        <|file_separator|>class ShenYuAfterEachSpec.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.extension.ExtendWith;
import org.junit.jupiter.api.extension.ExtensionContext;
import org.junit.jupiter.api.extension.TestWatcher;
import org.junit.jupiter.api.extension.TestTemplateInvocationContext;
import org.junit.jupiter.api.extension.TestTemplateInvocationContextProvider;
import org.junit.jupiter.api.extension.TestTemplateInvocationContextProvider.DynamicTestCreator;
import org.junit.jupiter.api.extension.TestTemplateInvocationContextProvider.DynamicTestCreator.DynamicTestCreatorContext;
import org.junit.jupiter.api.extension.TestTemplateInvocationContextProvider.DynamicTestCreator.DynamicTestCreatorContext.DynamicTestCreatorContextBuilder;
import org.junit.jupiter.api.extension.TestTemplateInvocationContextProvider.DynamicTestCreator.DynamicTestCreatorContext.DynamicTestCreatorContextBuilder.DynamicTestCreatorContextBuilderBuilder;
import org.junit.jupiter.api.extension.TestTemplateInvocationContextProvider.DynamicTestCreator.DynamicTestCreatorContext.DynamicTestCreatorContextBuilder.DynamicTestCreatorContextBuilderBuilder.DynamicTestCreatorContextBuilderBuilderBuilder;
import org.junit.jupiter.api.extension.TestTemplateInvocationContextProvider.DynamicTestCreator.DynamicTestCreatorContext.DynamicTestCreatorContextBuilder.DynamicTestCreatorContextBuilderBuilder.DynamicTestCreatorContextBuilderBuilderBuilder.DynamicTestCreatorContextBuilderBuilderBuilderBuilder;
import org.junit.jupiter.api.extension.TestTemplateInvocationContextProvider.DynamicTestCreator.DynamicTestCreatorContext.DynamicTestCreatorContextBuilder.DynamicTestCreatorContextBuilderBuilder<nl>
        try {
            final Socket socket = new Socket();
            socket.connect(new InetSocketAddress(host, port), timeout);
            socket.close();
            return true;
        } catch (final IOException e) {
            LOG.error("check url error", e);
            return false;
        }
    <|file_separator|><nl>
        System.out.println("Hello World!");
    <|file_separator|><nl>
        return new StreamObserver<HelloRequest>() {
            @Override
            public void onNext(HelloRequest value) {
                LOG.info("Received: " + value.getData());
                responseObserver.onNext(HelloResponse.newBuilder().setData("hello: " + value.getData()).build());
            }

            @Override
            public void onError(Throwable t) {
                LOG.error("Error: " + t.getMessage());
            }

            @Override
            public void onCompleted() {
                responseObserver.onCompleted();
            }
        };
    <|file_separator|><nl>
        LOG.info("Received request: {}", request);
        final EchoResponse response = EchoResponse.newBuilder()
            .setHostname(getHostname())
            .setMessage(request.getMessage())
            .build();
        LOG.info("Sending response: {}", response);
        responseObserver.onNext(response);
        responseObserver.onCompleted();
    <|file_separator|><nl>
                builder.setText("clientStreamingFun onCompleted");
                responseObserver.onNext(builder.build());
                responseObserver.onCompleted();
            <|file_separator|><nl>
        return "OAuth2DTO{" +
                "token='" + token + '\'' +
                '}';
    <|file_separator|><nl>
        return children;
    <|file_separator|><nl>
        return "OrderDTO{" +
                "id='" + id + '\'' +
                ", name='" + name + '\'' +
                '}';
    <|file_separator|><nl>
        return "SofaSimpleTypeBean [id=" + id + ", name=" + name + "]";
    <|file_separator|><nl>
        return new SofaSimpleTypeBean(String.valueOf(new Random().nextInt()), "hello world shenyu Sofa , insert");<|file_separator|><nl>
        return name;
    <|file_separator|><nl>
        return "OrderDTO [id=" + id + ", name=" + name + "]";
    <|file_separator|><nl>
        this.data = data;
    <|file_separator|><nl>
        return SESSION_POOL.remove(key);
    <|file_separator|><nl>
        DubboTest dubboTest = new DubboTest();
        dubboTest.setName("test");
        dubboTest.setId("1");
        String result = HttpHelper.INSTANCE.postToGateway("/dubbo/insert", dubboTest);
        assertEquals("success", result);
    <|file_separator|><nl>
        return SERVICE;
    <|file_separator|><nl>
        String res = HttpHelper.INSTANCE.postGateway("/http/post", java.lang.String.class);
        assertEquals("post! I'm Shenyu-Gateway System. Welcome!", res);
    <|file_separator|><nl>
        Files.copy(new File("1.txt").toPath(), Paths.get(FILE_PATH_NOE));
        Files.copy(new File("2.txt").toPath(), Paths.get(FILE_PATH_TWO));
    <|file_separator|><nl>
        shenyuRequestLog.setMethod("GET");
        shenyuRequestLog.setUri("/test");
        shenyuRequestLog.setHost("localhost");
        shenyuRequestLog.setPort(8080);
        shenyuRequestLog.setProtocol("http");
        shenyuRequestLog.setRemoteAddr("127.0.0.1");
        shenyuRequestLog.setRemotePort(8080);
        shenyuRequestLog.setRemoteUser("admin");
        shenyuRequestLog.setRemoteHost("localhost");
        shenyuRequestLog.setRemoteAddr("127.0.0.1");
        shenyuRequestLog.setRemotePort(8080);
        shenyuRequestLog.setRemoteUser("admin");
        shenyuRequestLog.setRemoteHost("localhost");
        shenyuRequestLog.setRemoteAddr("127.0.0.1");
        shenyuRequestLog.setRemotePort(8080);
        shenyuRequestLog.setRemoteUser("admin");
        shenyuRequestLog.setRemoteHost("localhost");
        shenyuRequestLog.setRemoteAddr("127.0.0.1");
        shenyuRequestLog.setRemotePort(8080);
        shenyuRequestLog.setRemoteUser("admin");
        shenyuRequestLog.setRemoteHost("localhost");
        shenyuRequestLog.setRemoteAddr("127.0.0.1");
        shenyuRequestLog.setRemotePort(8080);
        shenyuRequestLog.setRemoteUser("admin");
        shenyuRequestLog.setRemoteHost("localhost");
        shenyuRequestLog.setRemoteAddr("127.0.0.1");
<nl>
        List<ShenyuMemoryConfig> shenyuMemoryConfigList = new ArrayList<>();
        if (ingress.getSpec().getRules() != null) {
            contextPathParse(ingress, shenyuMemoryConfigList, coreV1Api);
        }
        return shenyuMemoryConfigList;
    <|file_separator|><nl>
        task.start();
    }

    /**
     * Gets check enable.
     *
     * @return the check enable
     */
    public Boolean getCheckEnable() {
        return checkEnable;
    }

    /**
     * Gets print enable.
     *
     * @return the print enable
     */
    public Boolean getPrintEnable() {
        return printEnable;
    }

    /**
     * Gets print interval.
     *
     * @return the print interval
     */
    public Integer getPrintInterval() {
        return printInterval;
    <|file_separator|><nl>
        List<Upstream> upstreamList =
                Stream.of(10, 20, 70)
                        .map(weight -> Upstream.builder()
                .url("upstream-" + weight)
                .weight(weight)
                .build())
                        .collect(Collectors.toList());
        Map<String, Integer> countMap = new HashMap<>();
        IntStream.range(0, 120).forEach(i -> {
            Upstream result = LoadBalancerFactory.selector(upstreamList, LoadBalanceEnum.ROUND_ROBIN.getName(), "");
            int count = countMap.getOrDefault(result.getUrl(), 0);
            countMap.put(result.getUrl(), ++count);
        });
        assertEquals(12, countMap.get("upstream-10").intValue());
    <|file_separator|><nl>
        return new DefaultShenyuEntity(code, message, object);
    }

    @Override
    public DefaultShenyuEntity success(final int code, final String message, final Object object) {
        return new DefaultShenyuEntity(code, message, object);
    <|file_separator|><nl>
        return shenyuResult().error(exchange, shenyuResult.getCode(), shenyuResult.getMsg(), object);
    <|file_separator|><nl>
        if (paramType.equals("String")) {
            return new StringParameterData();
        } else if (paramType.equals("Integer")) {
            return new IntegerParameterData();
        } else if (paramType.equals("Long")) {
            return new LongParameterData();
        } else if (paramType.equals("Double")) {
            return new DoubleParameterData();
        } else if (paramType.equals("Float")) {
            return new FloatParameterData();
        } else if (paramType.equals("Boolean")) {
            return new BooleanParameterData();
        } else if (paramType.equals("Date")) {
            return new DateParameterData();
        } else if (paramType.equals("Time")) {
            return new TimeParameterData();
        } else if (paramType.equals("DateTime")) {
            return new DateTimeParameterData();
        } else if (paramType.equals("Timestamp")) {
            return new TimestampParameterData();
        } else if (paramType.equals("UUID")) {
            return new UUIDParameterData();
        } else if (paramType.equals("ByteArray")) {
            return new ByteArrayParameterData();
        } else if (paramType.equals("File")) {
            return new FileParameterData();
        } else if (paramType.equals("MultipartFile")) {
            return new MultipartFileParameterData();
        } else if (paramType.equals("Object")) {
            return new ObjectParameterData();
        } else {
            throw new IllegalArgumentException("Parameter type not found: " + paramType);
        }
    <|file_separator|><nl>
        return realData.contains(conditionData.getCondition());
    <|file_separator|>class PredicateJudge.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public interface PredicateJudge {
    Boolean judge(ConditionData conditionData, String realData);
}<|file_separator|>class ConditionData.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class ConditionData {
    private String condition;
    private String data;

    public ConditionData(String condition, String data) {
        this.condition = condition;
        this.data = data;
    }

    public String getCondition() {
        return condition;
    }

    public String getData() {
        return data;
    }
}<|file_separator|>class ContainsPredicate.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class ContainsPredicate implements Predicate {
    @Override
    public PredicateJudge getPredicateJudge() {
        return new ContainsPredicateJudge();
    }
}<|file_separator|>class Predicate.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public interface Predicate {
    PredicateJudge getPredicateJudge();
}<|file_separator|>class ContainsPredicateJudge.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class ContainsPredicateJudge implements PredicateJudge {
    @Override
    public Boolean judge(ConditionData conditionData, String realData) {
        return realData.contains(conditionData.getCondition());
    }
}<|file_separator|><nl>
        final ShenyuTrie trie = ShenyuTrie.getInstance();
        final List<String> uriPaths = event.getUriPaths();
        final T data = event.getData();
        final TrieCacheTypeEnum cacheTypeEnum = event.getCacheTypeEnum();
        switch (event.getEventType()) {
            case INSERT:
                insertTrieNode(uriPaths, data, cacheTypeEnum, trie);
                break;
            case UPDATE:
                updateTrieNode(uriPaths, data, cacheTypeEnum, trie);
                break;
            case REMOVE:
                removeTrieNode(uriPaths, data, cacheTypeEnum, trie);
                break;
        }
    <|file_separator|><nl>
        return SpringBeanUtils.getInstance().getBean(RemoteAddressResolver.class).resolve(exchange).getIpString();
    <|file_separator|><nl>
        return MediaType.APPLICATION_OCTET_STREAM.equals(mediaType) || MediaType.IMAGE_JPEG.equals(mediaType) || MediaType.IMAGE_PNG.equals(mediaType);
    <|file_separator|><nl>
        // test matching with *'s
        assertTrue(PathMatchUtils.pathMatch("test*", "test"));
        assertTrue(PathMatchUtils.pathMatch("test*", "testTest"));
        assertFalse(PathMatchUtils.pathMatch("test*aaa", "testblaaab"));
        // test matching with **'s
        assertTrue(PathMatchUtils.pathMatch("/**", "/testing/testing"));
        assertTrue(PathMatchUtils.pathMatch("/test/**", "/test/test"));
    <|file_separator|><nl>
        this.closeCacheIfNeed();
    <|file_separator|><nl>
        contextPathPluginDataHandler.removeRule(RuleData.builder().handle("{}").build());
    <|file_separator|><nl>
        executionSemaphorePerCircuit.remove(commandKey);
    <|file_separator|><nl>
        HystrixCommand.Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey("hystrix-test"))
                .andCommandKey(HystrixCommandKey.Factory.asKey("hystrix-test"))
                .andThreadPoolKey(HystrixThreadPoolKey.Factory.asKey("hystrix-test"))
                .andThreadPoolPropertiesDefaults(HystrixThreadPoolProperties.Setter()
                        .withCoreSize(10)
                        .withMaxQueueSize(100)
                        .withQueueSizeRejectionThreshold(100))
                .andCommandPropertiesDefaults(HystrixCommandProperties.Setter()
                        .withExecutionIsolationStrategy(HystrixCommandProperties.ExecutionIsolationStrategy.SEMAPHORE)
                        .withExecutionIsolationSemaphoreMaxConcurrentRequests(100))
                .andCommandPropertiesDefaults(HystrixCommandProperties.Setter()
                        .withExecutionTimeoutInMilliseconds(1000))
                .andThreadPoolPropertiesDefaults(HystrixThreadPoolProperties.Setter()
                        .withCoreSize(10)
                        .withMaxQueueSize(100)
                        .withQueueSizeRejectionThreshold(100))
                .andThreadPoolPropertiesDefaults(HystrixThreadPoolProperties.Setter()
                        .withCoreSize(10)
                        .withMaxQueueSize(100)
                        .withQueueSizeRejectionThreshold(100))
                .andThreadPoolPropertiesDefaults(HystrixThreadPoolProperties.Setter()
                        .withCoreSize(10)
                        .withMaxQueueSize(100)
                        .withQueueSizeRejectionThreshold(100))
                .andThreadPoolPropertiesDefaults(HystrixThreadPoolProperties.Setter()
                        .withCoreSize(10)
                        .withMaxQueueSize(100)
                        .withQueueSizeRejectionThreshold(10<nl>
        return List.of(getKeyName() + id);
    <|file_separator|><nl>
        if (name == null) {
            throw new IllegalArgumentException("name is null");
        }
        
        if (name.equals("fixed-window")) {
            return new FixedWindowRateLimiterAlgorithm();
        }
        
        if (name.equals("sliding-window")) {
            return new SlidingWindowRateLimiterAlgorithm();
        }
        
        throw new IllegalArgumentException("name is not supported");
    <|file_separator|><nl>
        return exchange.getRequest().getPath().toString();
    <|file_separator|><nl>
        this.chain = new ShenyuPluginChain();
        this.globalPlugin = new GlobalPlugin();
    <|file_separator|><nl>
        metaDataCacheSubscriber.metaDataAllSubscriber(metaData);
        assertEquals(metaDataCache.getMetaDataList().size(), 1);
    <|file_separator|><nl>
        this.projectName = config.getProjectName();
        this.logStore = config.getLogStore();
        this.topic = config.getTopic();
        this.producer = createProducer(config, config.getProjectConfig());
        this.threadExecutor = createThreadPoolExecutor(config);
    <|file_separator|><nl>
        aliyunSlsLogCollectClient.initClient(aliyunSlsLogConfig);
        aliyunSlsLogCollectClient.consume(logs);
        aliyunSlsLogCollectClient.close();
    <|file_separator|><nl>
        Assertions.assertEquals(loggingClickHousePluginDataHandler.handlerPlugin(), "loggingClickHouse");
    <|file_separator|><nl>
        if (data == null || data.length() < maskNum) {
            return data;
        }
        final StringBuilder builder = new StringBuilder();
        for (int i = 0; i < data.length(); i++) {
            if (i < data.length() - maskNum) {
                builder.append(DESENSITIZI_CHARACTER);
            } else {
                builder.append(data.charAt(i));
            }
        }
        return builder.toString();
    <|file_separator|><nl>
        return new LogCollector<ShenyuRequestLog>() {
            @Override
            public void collect(final ShenyuRequestLog log, final ServerWebExchange exchange, final SelectorData selector, final RuleData rule) {
                log.setIp(exchange.getRequest().getRemoteAddress().getHostString());
                log.setMethod(exchange.getRequest().getMethod());
                log.setUri(exchange.getRequest().getURI().getPath());
                log.setParams(exchange.getRequest().getQueryParams());
                log.setHeaders(exchange.getRequest().getHeaders());
                log.setResponse(exchange.getResponse());
                log.setSelector(selector);
                log.setRule(rule);
            }
        };
    <|file_separator|><nl>
        return pulsarLogConfig;
    <|file_separator|><nl>
        loggingPulsarPluginDataHandler = new LoggingPulsarPluginDataHandler();
    }

    @Test
    public void testHandlerSelector() {
        loggingPulsarPluginDataHandler.handlerSelector(selectorData);
        Assertions.assertEquals(selectorData.getTopic(), "topic");
        Assertions.assertEquals(selectorData.getTopic(), "topic");
        Assertions.assertEquals(selectorData.getTopic(), "topic");
    }

    @Test
    public void testHandlerCondition() {
        loggingPulsarPluginDataHandler.handlerCondition(conditionData);
        Assertions.assertEquals(conditionData.getTopic(), "topic");
        Assertions.assertEquals(conditionData.getTopic(), "topic");
        Assertions.assertEquals(conditionData.getTopic(), "topic");
    <|file_separator|><nl>
        loggingRabbitmqPlugin = new LoggingRabbitmqPlugin();
        exchange = Mockito.mock(ServerWebExchange.class);
        ruleData = Mockito.mock(RuleData.class);
        selectorData = Mockito.mock(SelectorData.class);
        chain = Mockito.mock(ShenyuPluginChain.class);
    <|file_separator|><nl>
            this.producerGroup = producerGroup;
        <|file_separator|><nl>
        TENCENT_CLS_LOG_COLLECT_CLIENT.setLogConfig(globalLogConfig);
    <|file_separator|><nl>
        tencentClsLogConfig.setLogCollectorConfigHost("127.0.0.1");
    <|file_separator|><nl>
        Field field = LoggingTencentClsPluginDataHandler.class.getDeclaredField("pluginData");
        field.setAccessible(true);
        field.set(loggingTencentClsPluginDataHandler, pluginData);
        Assertions.assertEquals(loggingTencentClsPluginDataHandler.handlerPlugin(), true);
    <|file_separator|><nl>
        return new String[]{"en", "d"};
    <|file_separator|><nl>
        return rule.matches("^[0-9]+-[0-9]+$");
    <|file_separator|><nl>
        return data[RandomUtil.randomInt(0, data.length - 1)];
    <|file_separator|><nl>
        String generate = arrayGenerator.generate("array|${array|10|3}", null);
        assertEquals("[10,10,10]", generate);
    <|file_separator|><nl>
        return this.operatorMap.get(mediaType.toString());
    <|file_separator|><nl>
        this.exchange = MockWebExchange.create(new MockServerWebExchange(new MockServerWebExchange.Builder(new MockServerWebExchange.MockServerWebExchangeBuilder(new MockServerWebExchange.MockServerWebExchangeBuilder.Builder(new MockServerWebExchange.MockServerWebExchangeBuilder.Builder(new MockServerWebExchange.MockServerWebExchangeBuilder.Builder(new MockServerWebExchange.MockServerWebExchangeBuilder.Builder(new MockServerWebExchange.MockServerWebExchangeBuilder.Builder(new MockServerWebExchange.MockServerWebExchangeBuilder.Builder(new MockServerWebExchange.MockServerWebExchangeBuilder.Builder(new MockServerWebExchange.MockServerWebExchangeBuilder.Builder(new MockServerWebExchange.MockServerWebExchangeBuilder.Builder(new MockServerWebExchange.MockServerWebExchangeBuilder.Builder(new MockServerWebExchange.MockServerWebExchangeBuilder.Builder(new MockServerWebExchange.MockServerWebExchangeBuilder.Builder(new MockServerWebExchange.MockServerWebExchangeBuilder.Builder(new MockServerWebExchange.MockServerWebExchangeBuilder.Builder(new MockServerWebExchange.MockServerWebExchangeBuilder.Builder(new MockServerWebExchange.MockServerWebExchangeBuilder.Builder(new MockServerWebExchange.MockServerWebExchangeBuilder.Builder(new MockServerWebExchange.MockServerWebExchangeBuilder.Builder(new MockServerWebExchange.MockServerWebExchangeBuilder.Builder(new MockServerWebExchange.MockServerWebExchangeBuilder.Builder(new MockServerWebExchange.MockServerWebExchangeBuilder.Builder(new MockServerWebExchange.MockServerWebExchangeBuilder.Builder(new MockServerWebExchange.MockServerWebExchangeBuilder.Builder(new MockServerWebExchange.MockServerWebExchangeBuilder.Builder(new MockServerWebExchange.MockServerWebExchangeBuilder.Builder(new MockServerWebExchange.MockServerWebExchangeBuilder.<nl>
        mqttPluginDataHandlerUnderTest.enableConfiguration();
        assertTrue(isPortUsing());
    <|file_separator|><nl>
        if (StringUtils.isBlank(loadBalance)) {
            return select(invokers, url, invocation);
        }
        if (Constants.LOAD_BALANCE_RANDOM.equals(loadBalance)) {
            return RandomInvokerSelector.select(invokers, url, invocation);
        }
        if (Constants.LOAD_BALANCE_ROUND_ROBIN.equals(loadBalance)) {
            return RoundRobinInvokerSelector.select(invokers, url, invocation);
        }
        if (Constants.LOAD_BALANCE_WEIGHT.equals(loadBalance)) {
            return WeightInvokerSelector.select(invokers, url, invocation);
        }
        if (Constants.LOAD_BALANCE_CONSISTENT_HASH.equals(loadBalance)) {
            return ConsistentHashInvokerSelector.select(invokers, url, invocation);
        }
        if (Constants.LOAD_BALANCE_HASH.equals(loadBalance)) {
            return HashInvokerSelector.select(invokers, url, invocation);
        }
        if (Constants.LOAD_BALANCE_LEAST_CONN.equals(loadBalance)) {
            return LeastConnInvokerSelector.select(invokers, url, invocation);
        }
        if (Constants.LOAD_BALANCE_AVAILABLE_RANDOM.equals(loadBalance)) {
            return AvailableRandomInvokerSelector.select(invokers, url, invocation);
        }
        if (Constants.LOAD_BALANCE_AVAILABLE_WEIGHT.equals(loadBalance)) {
            return AvailableWeightInvokerSelector.select(invokers, url, invocation);
        }
        if (Constants.LOAD_BALANCE_AVAILABLE_CONSISTENT_HASH.equals(loadBalance)) {
            return AvailableConsistentHashInvokerSelector.select(invokers, url, invocation);
        }
        if (Constants.LOAD_BALANCE_AVAILABLE_HASH<nl>
        GrpcRegisterConfig config = Singleton.INST.get(GrpcRegisterConfig.class);
        if (null == config) {
            throw new ShenyuException("config is null");
        }
        final String address = Optional.ofNullable(config.getAddress()).orElse(Constants.DEFAULT_ADDRESS);
        final String port = Optional.ofNullable(config.getPort()).orElse(Constants.DEFAULT_PORT);
        final String selector = Optional.ofNullable(config.getSelector()).orElse(Constants.DEFAULT_SELECTOR);
        final String threadpool = Optional.ofNullable(config.getThreadpool()).orElse(Constants.CACHED);
        final String nameResolver = Optional.ofNullable(config.getNameResolver()).orElse(Constants.DEFAULT_NAMERESOLVER);
        final String loadBalancer = Optional.ofNullable(config.getLoadBalancer()).orElse(Constants.DEFAULT_LOADBALANCER);
        final String timeout = Optional.ofNullable(config.getTimeout()).orElse(Constants.DEFAULT_TIMEOUT);
        final String retry = Optional.ofNullable(config.getRetry()).orElse(Constants.DEFAULT_RETRY);
        final String retryInterval = Optional.ofNullable(config.getRetryInterval()).orElse(Constants.DEFAULT_RETRY_INTERVAL);
        final String retryMax = Optional.ofNullable(config.getRetryMax()).orElse(Constants.DEFAULT_RETRY_MAX);
        final String retryMaxInterval = Optional.ofNullable(config.getRetryMaxInterval()).orElse(Constants.DEFAULT_RETRY_MAX_INTERVAL);
        final String retryMaxIntervalUnit = Optional.ofNullable(config.getRetryMaxIntervalUnit()).orElse(Constants.DEFAULT_RETRY_MAX_INTERVAL_UNIT);
        final String retryMaxIntervalUnitValue = Optional.ofNullable(config.getRetryMaxIntervalUnitValue()).orElse(Constants.DEFAULT_RETRY_MAX_<nl>
        return true;
    <|file_separator|><nl>
        return true;
    <|file_separator|><nl>
        return DynamicMessage.newBuilder(messageDescriptor).mergeFrom(inputStream).build();
    <|file_separator|><nl>
        SubChannels subChannels = new SubChannels();
        subChannels.setChannelId(1);
        subChannels.setChannelName("test");
        subChannels.setChannelUrl("test");
        subChannels.setChannelType(1);
        subChannels.setChannelStatus(1);
        subChannels.setChannelOrder(1);
        subChannels.setChannelIcon("test");
        subChannels.setChannelDesc("test");
        subChannels.setChannelCreateTime(new Date());
        subChannels.setChannelUpdateTime(new Date());
        subChannels.setChannelIsDel(1);
        subChannels.setChannelIsShow(1);
        subChannels.setChannelIsHot(1);
        subChannels.setChannelIsRecommend(1);
        subChannels.setChannelIsHot(1);
        subChannels.setChannelIsRecommend(1);
        subChannels.setChannelIsHot(1);
        subChannels.setChannelIsRecommend(1);
        subChannels.setChannelIsHot(1);
        subChannels.setChannelIsRecommend(1);
        subChannels.setChannelIsHot(1);
        subChannels.setChannelIsRecommend(1);
        subChannels.setChannelIsHot(1);
        subChannels.setChannelIsRecommend(1);
        subChannels.setChannelIsHot(1);
        subChannels.setChannelIsRecommend(1);
        subChannels.setChannelIsHot(1);
        subChannels.setChannelIsRecommend(1);
        subChannels.setChannelIsHot(1);
        subChannels.setChannelIsRecommend(1);
        subChannels.setChannelIsHot(1);
        subChannels.setChannelIsRecommend(1);
        subChannels.setChannelIsHot(1);
<nl>
        CompositeStreamObserver compositeStreamObserverMock = mock(CompositeStreamObserver.class);
        doNothing().when(compositeStreamObserverMock).onError(any(Throwable.class));
        compositeStreamObserverMock.onError(new Exception());
    <|file_separator|><nl>
        final DynamicMessage dynamicMessage = new DynamicMessage();
        final OutputStream outputStream = new ByteArrayOutputStream();
        dynamicMessageMarshaller.stream(dynamicMessage, outputStream);
        assertNotNull(outputStream);
    <|file_separator|><nl>
        assertEquals("shenyu", shenyuNameResolverProvider.getDefaultScheme());
    <|file_separator|><nl>
        return RpcTypeEnum.MOTAN.getName();
    <|file_separator|><nl>
        Object[] param = new Object[paramTypes.length];
        for (int i = 0; i < paramTypes.length; i++) {
            if (paramTypes[i].equals(String.class)) {
                param[i] = body;
            } else {
                param[i] = PRIMITIVE_TYPE.get(paramTypes[i].getName()).getFunc().apply(paramNames[i]);
            }
        }
        return param;
    <|file_separator|><nl>
        return Mono.from(DataBufferUtils.join(serverHttpRequest.getBody())
                .flatMap(data -> Mono.just(Optional.of(data)))
                .defaultIfEmpty(Optional.empty())
                .flatMap(body -> {
                    body.ifPresent(dataBuffer -> exchange.getAttributes().put(Constants.PARAM_TRANSFORM, HttpParamConverter.ofString(() -> HttpParamConverter.parseForm(dataBuffer))));
                    return chain.execute(exchange);
                }));
    <|file_separator|><nl>
        MetaData metaData = null;
        ShenyuContext shenyuContext = new ShenyuContext();
        springCloudShenyuContextDecorator.decorator(shenyuContext, metaData);
        Assertions.assertEquals(shenyuContext.getRpcType(), "springCloud");
    <|file_separator|><nl>
        List<Upstream> upstreams = new ArrayList<>();
        for (DiscoveryUpstreamData upstreamData : upstreamList) {
            upstreams.add(convertUpstream(upstreamData));
        }
        return upstreams;
    }

    private Upstream convertUpstream(final DiscoveryUpstreamData upstreamData) {
        Upstream upstream = new Upstream();
        upstream.setSelectorId(upstreamData.getSelectorId());
        upstream.setHost(upstreamData.getHost());
        upstream.setPort(upstreamData.getPort());
        upstream.setProtocol(upstreamData.getProtocol());
        upstream.setUri(upstreamData.getUri());
        upstream.setMetadata(upstreamData.getMetadata());
        return upstream;
    <|file_separator|><nl>
        exchange = MockServerWebExchange.from(MockServerWebExchange.builder().build());
        rpcMessageWriter = new RPCMessageWriter();
    <|file_separator|><nl>
        this.defaultHandleJson = defaultHandleJson;
    }

    /**
     * serialize.
     *
     * @return String.
     */
    public String serialize() {
        return "BasicAuthConfig{" + "defaultHandleJson='" + defaultHandleJson + '\'' + '}';
    }

    /**
     * deserialize.
     *
     * @param json json.
     */
    public void deserialize(final String json) {
        final JSONObject jsonObject = new JSONObject(json);
        this.defaultHandleJson = jsonObject.getString("defaultHandleJson");
    <|file_separator|><nl>
        return 1000;
    <|file_separator|><nl>
        return chain.next(exchange, selectorData, rule).doOnNext(
                (final ServerWebExchange exchange) -> {
                    // get original body
                    final String originalBody = exchange.getRequest().getBody().buffer().toString();
                    // get url params
                    final VerifyResult verifyResult = signVerifyWithBody(originalBody, exchange);
                    // verify
                    if (!verifyResult.isSuccess()) {
                        // return
                        exchange.getResponse().setStatusCode(verifyResult.getHttpStatus());
                        exchange.getResponse().getHeaders().set(verifyResult.getHeaderName(), verifyResult.getHeaderValue());
                        return;
                    }
                    // get sign
                    final String sign = exchange.getRequest().getHeaders().getFirst(verifyResult.getHeaderName());
                    // verify
                    if (!signService.verify(sign, originalBody)) {
                        // return
                        exchange.getResponse().setStatusCode(verifyResult.getHttpStatus());
                        exchange.getResponse().getHeaders().set(verifyResult.getHeaderName(), verifyResult.getHeaderValue());
                        return;
                    }
                }
        );
    <|file_separator|><nl>
        CACHED_HANDLE.get().removeHandle(CacheKeyUtils.INST.getKey(ruleData));
    <|file_separator|><nl>
        SignAuthDataCache.getInstance().unCacheAuthData(appAuthData);
    <|file_separator|><nl>

        HttpRequest httpRequest = MockServerHttpRequest
                .get("http://localhost:9195/springcloud/class/annotation/get?id=1&id=1")
                .header("timestamp", "1660659201000")
                .header("appKey", "BD7980F5688A4DE6BCF1B5327FE07F5C")
                .header("version", VERSION_2)
                .header("sign", "BF485842D2C08A3378308BA9992A309F")
                .build();

        SignParameters signParameters = new SignParameters(VERSION_2, "BD7980F5688A4DE6BCF1B5327FE07F5C", "1660659201000",
                "BF485842D2C08A3378308BA9992A309F", httpRequest.getURI(), "MD5");
        assertThat(extractor.extract(httpRequest).toString(), is(signParameters.toString()));
    <|file_separator|><nl>
        this.model = model;
    <|file_separator|><nl>
        super.getWasmExtern(REMOVE_SELECTOR_METHOD_NAME)
                .ifPresent(handlerPlugin -> callWASI(selectorData, handlerPlugin));
    <|file_separator|><nl>
        if (channel.isOpen()) {
            channel.close();
        }
    <|file_separator|><nl>
        final MqttConnectMessage connectMessage = new MqttConnectMessage(msg);
        final MqttConnectResponse response = new MqttConnectResponse(connectMessage);
        response.send(ctx);
    }

    /**
     * disconnect.
     */
    public void disconnect() {
        final MqttDisconnectMessage disconnectMessage = new MqttDisconnectMessage(msg);
        final MqttDisconnectResponse response = new MqttDisconnectResponse(disconnectMessage);
        response.send(ctx);
    }

    /**
     * publish.
     */
    public void publish() {
        final MqttPublishMessage publishMessage = new MqttPublishMessage(msg);
        final MqttPublishResponse response = new MqttPublishResponse(publishMessage);
        response.send(ctx);
    }

    /**
     * subscribe.
     */
    public void subscribe() {
        final MqttSubscribeMessage subscribeMessage = new MqttSubscribeMessage(msg);
        final MqttSubscribeResponse response = new MqttSubscribeResponse(subscribeMessage);
        response.send(ctx);
    }

    /**
     * unsubscribe.
     */
    public void unsubscribe() {
        final MqttUnsubscribeMessage unsubscribeMessage = new MqttUnsubscribeMessage(msg);
        final MqttUnsubscribeResponse response = new MqttUnsubscribeResponse(unsubscribeMessage);
        response.send(ctx);
    }

    /**
     * pingreq.
     */
    public void pingreq() {
        final MqttPingreqMessage pingreqMessage = new MqttPingreqMessage(msg);
        final MqttPingreqResponse response = new MqttPingreqResponse(pingreqMessage);
        response.send(ctx);
    }

    /**
     * pingresp.
     */
    public void pingresp() {<nl>
        MqttFixedHeader fixedHeader = new MqttFixedHeader(MqttMessageType.SUBACK, false, AT_MOST_ONCE, true, 0);
        MqttSubAckVariableHeader varHeader = new MqttSubAckVariableHeader(packetId);
        MqttSubAckMessage mqttSubAckMessage = new MqttSubAckMessage(fixedHeader, varHeader, ackTopics);
        channel.writeAndFlush(mqttSubAckMessage);
    <|file_separator|><nl>
        return cache.getOrDefault(pluginSelectorName, Collections.emptyList());
    <|file_separator|><nl>
        //Get the failback registry.
        final FailbackRegistry failbackRegistry = this.registerRepository.getFailbackRegistry(key);
        //If the failback registry is not null.
        if (failbackRegistry != null) {
            //Get the failback.
            final Failback failback = failbackRegistry.getFailback();
            //If the failback is not null.
            if (failback != null) {
                //Get the failback registry.
                final FailbackRegistry failbackRegistry1 = this.registerRepository.getFailbackRegistry(key);
                //If the failback registry is not null.
                if (failbackRegistry1 != null) {
                    //Get the failback.
                    final Failback failback1 = failbackRegistry1.getFailback();
                    //If the failback is not null.
                    if (failback1 != null) {
                        //Set the failback.
                        failbackRegistry.setFailback(failback1);
                    }
                }
            }
        }
    <|file_separator|><nl>
        try {
            final String pid = getPidByPort(port);
            if (pid != null) {
                return Optional.of(pid);
            }
        } catch (final Exception e) {
            LOGGER.error("Failed to get PID by port {}.", port, e);
        }
        return Optional.empty();
    }

    /**
     * Get the PID of the listening port.
     *
     * @param port the port
     * @return PID
     */
    public static String getPidByPort(final int port) {
        try {
            final String pid = getPidByPort(port, getNestatOptions());
            if (pid != null) {
                return pid;
            }
        } catch (final Exception e) {
            LOGGER.error("Failed to get PID by port {}.", port, e);
        }
        return null;
    }

    /**
     * Get the PID of the listening port.
     *
     * @param port the port
     * @param options the options
     * @return PID
     */
    public static String getPidByPort(final int port, final String options) {
        try {
            final String pid = getPidByPort(port, options, getPidOptions());
            if (pid != null) {
                return pid;
            }
        } catch (final Exception e) {
            LOGGER.error("Failed to get PID by port {}.", port, e);
        }
        return null;
    }

    /**
     * Get the PID of the listening port.
     *
     * @param port the port
     * @param options the options
     * @param pidOptions the pid options
     * @return PID
     */
    <nl>
        this.props = props;
    <|file_separator|><nl>
        return String.join(SEPARATOR, ROOT_PATH, "instance", serviceName);
    }

    /**
     * Build instance child path string.
     * build child path of "/shenyu/register/instance/serviceName/instanceId
     *
     * @param serviceName serviceName
     * @param instanceId instanceId
     * @return the string
     */
    public static String buildInstanceChildPath(final String serviceName, final String instanceId) {
        return String.join(SEPARATOR, buildInstanceParentPath(serviceName), instanceId);
    }

    /**
     * Build instance child path string.
     * build child path of "/shenyu/register/instance/serviceName/instanceId/instanceName
     *
     * @param serviceName serviceName
     * @param instanceId instanceId
     * @param instanceName instanceName
     * @return the string
     */
    public static String buildInstanceChildPath(final String serviceName, final String instanceId, final String instanceName) {
        return String.join(SEPARATOR, buildInstanceChildPath(serviceName, instanceId), instanceName);
    }

    /**
     * Build instance child path string.
     * build child path of "/shenyu/register/instance/serviceName/instanceId/instanceName/instancePort
     *
     * @param serviceName serviceName
     * @param instanceId instanceId
     * @param instanceName instanceName
     * @param instancePort instancePort
     * @return the string
     */
    public static String buildInstanceChildPath(final String serviceName, final String instanceId, final String instanceName, final int instancePort) {
        return String.join(SEPARATOR, buildInstanceChildPath(serviceName, instanceId, instanceName), instancePort);
    }

    /**
     * Build instance child path string.
<nl>
        String instancePath = InstancePathConstants.buildInstanceParentPath(selectKey);
        String realNode = InstancePathConstants.buildRealNode(instancePath);
        List<InstanceEntity> instanceList = new ArrayList<>();
        for (String node : client.getKeys(realNode)) {
            String nodeData = client.get(node);
            if (nodeData != null) {
                InstanceEntity instance = GsonUtils.getInstance().fromJson(nodeData, InstanceEntity.class);
                instanceList.add(instance);
            }
        }
        return instanceList;
    }

    @Override
    public void watchInstance(final String selectKey, final WatchCallback callback) {
        String instancePath = InstancePathConstants.buildInstanceParentPath(selectKey);
        String realNode = InstancePathConstants.buildRealNode(instancePath);
        if (!watcherInstanceRegisterMap.containsKey(realNode)) {
            watcherInstanceRegisterMap.put(realNode, new ArrayList<>());
        }
        List<InstanceEntity> instanceList = watcherInstanceRegisterMap.get(realNode);
        for (InstanceEntity instance : instanceList) {
            String instanceNodeName = buildInstanceNodeName(instance);
            String instancePath = InstancePathConstants.buildInstanceParentPath(instance.getAppName());
            String realNode = InstancePathConstants.buildRealNode(instancePath, instanceNodeName);
            client.watch(realNode, callback);
        }
    <|file_separator|><nl>
        return maxSleepTimeMilliseconds;
    <|file_separator|><nl>
        return reason;
    <|file_separator|>class ShenyuRequest.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>class ShenyuRequest {

    private final String method;

    private final String path;

    private final Map<String, Collection<String>> headers;

    private final String body;

    /**
     * ShenyuRequest.
     *
     * @param method method
     * @param path path
     * @param headers headers
     * @param body body
     */
    public ShenyuRequest(final String method, final String path, final Map<String, Collection<String>> headers,
                         final String body) {
        this.method = method;
        this.path = path;
        this.headers = headers;
        this.body = body;
    }

    /**
     * getMethod.
     *
     * @return {@link String}
     */
    public String getMethod() {
        return method;
    }

    /**
     * getPath.
     *
     * @return {@link String}
     */
    public String getPath() {
        return path;
    }

    /**
     * getHeaders.
     *
     * @return {@link Map}
     */
    public Map<String, Collection<String>> getHeaders() {
        return headers;
    }

    /**
     * getBody.
     *
     * @return {@link String}
     */
    public String getBody() {
        return body;
    }
}<|file_separator|><nl>
        final ShenyuSdkClient client = ShenyuSdkClientFactory.newInstance(
                "httpclient");
        assertNotNull(client);
    <|file_separator|><nl>
        Assert.assertNotNull(requestTemplate);
    <|file_separator|><nl>
    <|file_separator|><nl>
        if (arg instanceof MultipartBody) {
            shenyuRequest.setRequestBody((MultipartBody) arg);
        } else {
            shenyuRequest.setRequestBody(arg);
        }
        return true;
    <|file_separator|><nl>
        if (arg instanceof String) {
            shenyuRequest.setRequestParam((String) arg);
        }
        return true;
    <|file_separator|><nl>
        parseHeaders(requestTemplate, annotation);
    <|file_separator|><nl>
        final String headerName = "header";
        final RequestHeader header = spy(RequestHeader.class);
        when(header.value()).thenReturn(headerName);

        Map<String, String> map = Maps.newHashMap();
        map.put("header1", "value1");
        map.put("header2", "value2");
        processor.processArgument(request, header, map);

        assertTrue(request.getHeaders().get("header1").contains("value1"));
        assertTrue(request.getHeaders().get("header2").contains("value2"));
    <|file_separator|><nl>
        return null;
    <|file_separator|><nl>
        return list;
    }

    /**
     * Sets list.
     *
     * @param list the list
     */
    @Override
    public void setList(List<Object> list) {
        this.list = list;
    }

    /**
     * Add object.
     *
     * @param object the object
     */
    @Override
    public void add(Object object) {
        list.add(object);
    }

    /**
     * Remove object.
     *
     * @param object the object
     */
    @Override
    public void remove(Object object) {
        list.remove(object);
    }

    /**
     * Gets object.
     *
     * @param index the index
     * @return the object
     */
    @Override
    public Object getObject(int index) {
        return list.get(index);
    }

    /**
     * Gets size.
     *
     * @return the size
     */
    @Override
    public int getSize() {
        return list.size();
    }

    /**
     * Clear.
     */
    @Override
    public void clear() {
        list.clear();
    }

    /**
     * Contains boolean.
     *
     * @param object the object
     * @return the boolean
     */
    @Override
    public boolean contains(Object object) {
        return list.contains(object);
    }

    /**
     * Index of int.
     *
     * @param object the object
     * @return the int
     */
    @Override
    public int indexOf(Object object) {
        return list.indexOf(object);
    }

<nl>
        applicationContextRunner.run(context -> {
                DispatcherHandler handler = context.getBean("dispatcherHandler", DispatcherHandler.class);
                assertNotNull(handler);
            }
        );
    }

    @Test
    public void testWebHandler() {
        applicationContextRunner.run(context -> {
                WebHandler handler = context.getBean("webHandler", WebHandler.class);
                assertNotNull(handler);
            }
        );
    <|file_separator|><nl>
        return new CachePlugin();
    <|file_separator|><nl>
        applicationContextRunner.run(context -> {
                ShenyuPlugin cryptorRequestPlugin = context.getBean("cryptorRequestPlugin", ShenyuPlugin.class);
                assertNotNull(cryptorRequestPlugin);
                ShenyuPlugin cryptorResponsePlugin = context.getBean("cryptorResponsePlugin", ShenyuPlugin.class);
                assertNotNull(cryptorResponsePlugin);
            }
        );
    <|file_separator|><nl>
        applicationContextRunner.run(context -> {
                DefaultShenyuContextBuilder defaultShenyuContextBuilder = context.getBean("defaultShenyuContextBuilder", DefaultShenyuContextBuilder.class);
                assertNotNull(defaultShenyuContextBuilder);
            }
        );
    <|file_separator|><nl>
        applicationContextRunner = new ApplicationContextRunner();
    <|file_separator|><nl>
        applicationContextRunner.run((context) -> {
            assertThat(context).hasSingleBean(LoggingKafkaPluginConfiguration.class);
        });
    <|file_separator|><nl>
        applicationContextRunner
            .run(context -> {
                assertThat(context).hasSingleBean(OAuth2PluginConfiguration.class);
            });
    <|file_separator|><nl>
        return new ShenyuPlugin() {
            @Override
            public void transform(RpcParam rpcParam) {
                // TODO Auto-generated method stub
                
            }
        };
    <|file_separator|><nl>
        return new ReactorNettyWebSocketClient(shenyuConfig, httpClient);
    <|file_separator|><nl>
        return connectionTimeout;
    <|file_separator|><nl>
        final List<String> prefixes = new ArrayList<>();
        prefixes.add(ApolloPathConstants.PLUGIN_DATA_ID);
        prefixes.add(ApolloPathConstants.SELECTOR_DATA_ID);
        prefixes.add(ApolloPathConstants.RULE_DATA_ID);
        prefixes.add(ApolloPathConstants.AUTH_DATA_ID);
        prefixes.add(ApolloPathConstants.META_DATA_ID);
        prefixes.add(ApolloPathConstants.PROXY_SELECTOR_DATA_ID);
        prefixes.add(ApolloPathConstants.DISCOVERY_DATA_ID);
        configService.addChangeListener(new ConfigChangeListener() {
            @Override
            public void onChange(final ConfigChangeEvent changeEvent) {
                for (final String key : changeEvent.changedKeys()) {
                    if (prefixes.contains(key)) {
                        updateHandler.accept(key);
                    }
                }
            }
        });
    }

    private void startWatch() {
        watchConfigChangeListener = new ConfigChangeListener() {
            @Override
            public void onChange(final ConfigChangeEvent changeEvent) {
                for (final String key : changeEvent.changedKeys()) {
                    if (ApolloPathConstants.PLUGIN_DATA_ID.equals(key)) {
                        updateHandler.accept(ApolloPathConstants.PLUGIN_DATA_ID);
                    } else if (ApolloPathConstants.SELECTOR_DATA_ID.equals(key)) {
                        updateHandler.accept(ApolloPathConstants.SELECTOR_DATA_ID);
                    } else if (ApolloPathConstants.RULE_DATA_ID.equals(key)) {
                        updateHandler.accept(ApolloPathConstants.RULE_DATA_ID);
                    } else if (ApolloPathConstants.AUTH_DATA_ID.equals(key)) {
                        updateHandler.<nl>
        return data;
    <|file_separator|><nl>
        final ConfigFile configFile = configFileService.getConfigFile(polarisConfig.getNamespace(), polarisConfig.getFileGroup(), key);
        final ConfigFileChangeListener configFileChangeListener = new ConfigFileChangeListener(updateHandler, deleteHandler);
        configFile.addChangeListener(configFileChangeListener);
        watchCache.put(key, configFileChangeListener);
        return configFile.getValue();
    }

    @Override
    protected void doAddListener(final String addKey) {
        final ConfigFileChangeListener configFileChangeListener = watchCache.get(addKey);
        if (Objects.nonNull(configFileChangeListener)) {
            final ConfigFile configFile = configFileService.getConfigFile(polarisConfig.getNamespace(), polarisConfig.getFileGroup(), addKey);
            configFile.addChangeListener(configFileChangeListener);
        }
    <|file_separator|><nl>
        List<RuleData> ruleDataList = createFakeRuleDateObjects(3);
        ruleDataHandler.doUpdate(ruleDataList);
        ruleDataList.forEach(verify(subscriber)::onRuleSubscribe);
    <|file_separator|><nl>
        ZookeeperInstanceRegisterRepository zookeeperInstanceRegisterRepository = new ZookeeperInstanceRegisterRepository();
        zookeeperInstanceRegisterRepository.register("test", "test");
    }

    @Test
    public void testZookeeperInstanceRegisterRepository_whenInstanceRegister_thenInstanceRegister() throws Exception {
        ZookeeperInstanceRegisterRepository zookeeperInstanceRegisterRepository = new ZookeeperInstanceRegisterRepository();
        zookeeperInstanceRegisterRepository.register("test", "test");
        List<String> list = zookeeperInstanceRegisterRepository.get("test");
        Assert.assertEquals(list.size(), 1);
    }

    @Test
    public void testZookeeperInstanceRegisterRepository_whenInstanceRegister_thenInstanceRegister_whenInstanceRegister_thenInstanceRegister() throws Exception {
        ZookeeperInstanceRegisterRepository zookeeperInstanceRegisterRepository = new ZookeeperInstanceRegisterRepository();
        zookeeperInstanceRegisterRepository.register("test", "test");
        zookeeperInstanceRegisterRepository.register("test", "test");
        List<String> list = zookeeperInstanceRegisterRepository.get("test");
        Assert.assertEquals(list.size(), 1);
    }

    @Test
    public void testZookeeperInstanceRegisterRepository_whenInstanceRegister_thenInstanceRegister_whenInstanceRegister_thenInstanceRegister_whenInstanceRegister_thenInstanceRegister() throws Exception {
        ZookeeperInstanceRegisterRepository zookeeperInstanceRegisterRepository = new ZookeeperInstanceRegisterRepository();
        zookeeperInstanceRegisterRepository.register("test", "test");
        zookeeperInstanceRegisterRepository.register("test", "test");
        zookeeperInstanceRegisterRepository.register("test", "test");
        zookeeperInstanceRegisterRepository.register("test", "test");
        List<String> list = zookeeperInstanceRegisterRepository.get("test");
        Assert.assertEquals(list.size(), 1);
    }

<nl>
        return Mono.just(paths.contains(exchange.getRequest().getURI().getPath()));<|file_separator|><nl>
        List<ShenyuLoaderResult> results = new ArrayList<>();
        if (uploadedJarResource != null) {
            results.add(new ShenyuLoaderResult(uploadedJarResource));
        }
        List<PluginData> pluginDatas = shenyuConfig.getPluginDatas();
        if (CollectionUtils.isNotEmpty(pluginDatas)) {
            for (PluginData pluginData : pluginDatas) {
                results.add(new ShenyuLoaderResult(pluginData));
            }
        }
        loaderPlugins(results);
    <|file_separator|><nl>
        final ServerWebExchange exchange = MockServerWebExchange.from(MockServerHttpRequest.get("localhost")
                .remoteAddress(new InetSocketAddress(8090))
                .build());
        ShenyuConfig shenyuConfig = new ShenyuConfig();
        shenyuConfig.getScheduler().setEnabled(true);
        shenyuConfig.getScheduler().setType("elastic");
        ShenyuWebHandler shenyuWebHandler = new ShenyuWebHandler(listPlugins, shenyuLoaderService, shenyuConfig);
        shenyuWebHandler.onApplicationEvent(new ApplicationReadyEvent(exchange));
    <|file_separator|><nl>
        File jarFile = ShenyuPluginPathBuilder.getPluginFile("/testUrl");
        assertNotNull(jarFile);
    <|file_separator|><nl>
      // Body is replaced (injected) by JavassistProxyFactory
      throw new IllegalStateException("You need to run the CLI build and you need target/classes in your classpath to run.");
   <|file_separator|><nl>
      HikariJNDIFactory jndi = new HikariJNDIFactory();
      Context nameCtx = new BogusContext();
      try (HikariDataSource ds = (HikariDataSource) jndi.getObjectInstance(null, null, nameCtx, null)) {
         assertNotNull(ds);
      }
   <|file_separator|><nl>
      Class<?> clazz = Class.forName("com.example.TestJavassistCodegen");
      Method method = getMethod(clazz, "testCodegen");
      Object instance = clazz.newInstance();
      method.invoke(instance);
   <|file_separator|><nl>
        this.checkStyle("rule331nowildcard.java");
    <|file_separator|><nl>
        this.assertCheckStyleResult(
                "rule3sourcefile.java",
                "rule3sourcefile.xml",
                "rule3sourcefile.txt",
                "rule3sourcefile.html",
                "rule3sourcefile.md",
                "rule3sourcefile.log",
                "rule3sourcefile.properties",
                "rule3sourcefile.properties",
                "rule3sourcefile.properties",
                "rule3sourcefile.properties",
                "rule3sourcefile.properties",
                "rule3sourcefile.properties",
                "rule3sourcefile.properties",
                "rule3sourcefile.properties",
                "rule3sourcefile.properties",
                "rule3sourcefile.properties",
                "rule3sourcefile.properties",
                "rule3sourcefile.properties",
                "rule3sourcefile.properties",
                "rule3sourcefile.properties",
                "rule3sourcefile.properties",
                "rule3sourcefile.properties",
                "rule3sourcefile.properties",
                "rule3sourcefile.properties",
                "rule3sourcefile.properties",
                "rule3sourcefile.properties",
                "rule3sourcefile.properties",
                "rule3sourcefile.properties",
                "rule3sourcefile.properties",
                "rule3sourcefile.properties",
                "rule3sourcefile.properties",
                "rule3sourcefile.properties",
                "rule3sourcefile.properties",
                "rule3sourcefile.properties",
                "rule3sourcefile.properties",
                "rule3sourcefile.properties",
                "rule3sourcefile.properties",
                "rule3sourcefile.properties",
                "rule3sourcefile.properties",
<nl>
        final String[] expected = {
            "1:1: " + getCheckMessage(LeftCurlyCheck.class, MSG_KEY_LINE_PREVIOUS, "{", 1),
            "1:1: " + getCheckMessage(LeftCurlyCheck.class, MSG_KEY_LINE_PREVIOUS, "{", 1),
            "1:1: " + getCheckMessage(LeftCurlyCheck.class, MSG_KEY_LINE_PREVIOUS, "{", 1),
            "1:1: " + getCheckMessage(LeftCurlyCheck.class, MSG_KEY_LINE_PREVIOUS, "{", 1),
            "1:1: " + getCheckMessage(LeftCurlyCheck.class, MSG_KEY_LINE_PREVIOUS, "{", 1),
            "1:1: " + getCheckMessage(LeftCurlyCheck.class, MSG_KEY_LINE_PREVIOUS, "{", 1),
            "1:1: " + getCheckMessage(LeftCurlyCheck.class, MSG_KEY_LINE_PREVIOUS, "{", 1),
            "1:1: " + getCheckMessage(LeftCurlyCheck.class, MSG_KEY_LINE_PREVIOUS, "{", 1),
            "1:1: " + getCheckMessage(LeftCurlyCheck.class, MSG_KEY_LINE_PREVIOUS, "{", 1),
            "1:1: " + getCheckMessage(LeftCurlyCheck.class, MSG_KEY_LINE_PREVIOUS, "{", 1),
            "1:1: " + getCheckMessage(LeftCurlyCheck.class, MSG_KEY_LINE_PREVIOUS, "{", 1),
            "1:1: " + getCheckMessage(LeftCurlyCheck.class, MSG_KEY_LINE_PREVIOUS, "{", 1),
            "1:1: "<nl>
        this.test("operatorWrap", "operatorWrap.xml");
    <|file_separator|><nl>
        final String[] expected = {"4:10"};
        final Configuration checkConfig = getModuleConfig("WhitespaceAfter");
        final String filePath = getPath("InputWhitespaceAfterBad.java");

        final Integer[] warnList = getLinesWithWarn(filePath);
        verify(checkConfig, filePath, expected, warnList);
    <|file_separator|><nl>
        this.testRule("rule4822.java", "rule4822.java");
    <|file_separator|><nl>
        this.testRule("TypeName");
    <|file_separator|><nl>
        final String tagOrder = "[@param, @return, @throws, @deprecated]";
        final String msg = getCheckMessage(AtclauseOrderCheck.class, "at.clause.order", tagOrder);

        final String[] expected = {
            "19: " + msg,
            "26: " + msg,
            "59: " + msg,
            "67: " + msg,
            "78: " + msg,
            "85: " + msg,
            "92: " + msg,
        };

        final Configuration checkConfig = getModuleConfig("AtclauseOrder");
        final String filePath = getPath("InputIncorrectAtClauseOrderCheck1.java");

        final Integer[] warnList = getLinesWithWarn(filePath);
        verify(checkConfig, filePath, expected, warnList);
    <|file_separator|><nl>
        assertNoViolations();
    <|file_separator|><nl>
        this.checkDefault();
    <|file_separator|><nl>
        return findModuleCreationOption(moduleName, null);
    }

    @Override
    protected ModuleCreationOption findModuleCreationOption(String moduleName, String moduleId) {
        return findModuleCreationOption(moduleName, moduleId, null);
    }

    @Override
    protected ModuleCreationOption findModuleCreationOption(String moduleName, String moduleId, String moduleVersion) {
        return findModuleCreationOption(moduleName, moduleId, moduleVersion, null);
    }

    @Override
    protected ModuleCreationOption findModuleCreationOption(String moduleName, String moduleId, String moduleVersion, String moduleType) {
        return findModuleCreationOption(moduleName, moduleId, moduleVersion, moduleType, null);
    }

    @Override
    protected ModuleCreationOption findModuleCreationOption(String moduleName, String moduleId, String moduleVersion, String moduleType, String moduleDescription) {
        return findModuleCreationOption(moduleName, moduleId, moduleVersion, moduleType, moduleDescription, null);
    }

    @Override
    protected ModuleCreationOption findModuleCreationOption(String moduleName, String moduleId, String moduleVersion, String moduleType, String moduleDescription, String moduleVersionId) {
        return findModuleCreationOption(moduleName, moduleId, moduleVersion, moduleType, moduleDescription, moduleVersionId, null);
    }

    @Override
    protected ModuleCreationOption findModuleCreationOption(String moduleName, String moduleId, String moduleVersion, String moduleType, String moduleDescription, String moduleVersionId, String moduleVersionIdType) {
        return findModuleCreationOption(moduleName, moduleId, moduleVersion, moduleType, moduleDescription, moduleVersionId, moduleVersionIdType, null);
    }

    @Override
    protected ModuleCreationOption findModuleCreationOption(String moduleName, String<nl>
        final File fileToProcess =
                new File(getPath(
                        "InputXpathAnnotationOnSameLineField.java"));

        final DefaultConfiguration moduleConfig =
                createModuleConfig(AnnotationOnSameLineCheck.class);

        final String[] expectedViolation = {
            "7:5: " + getCheckMessage(AnnotationOnSameLineCheck.class,
                    AnnotationOnSameLineCheck.MSG_KEY_ANNOTATION_ON_SAME_LINE,
                    "Deprecated"),
        };

        final List<String> expectedXpathQueries = Arrays.asList(
                "/COMPILATION_UNIT/CLASS_DEF"
                        + "[./IDENT[@text='InputXpathAnnotationOnSameLineField']]"
                        + "/OBJBLOCK/VARIABLE_DEF[./IDENT[@text='names']]"
        );

        runVerifications(moduleConfig, fileToProcess, expectedViolation,
                expectedXpathQueries);
    <|file_separator|><nl>
        final File fileToProcess =
                new File(getPath("InputXpathAnonInnerLength.java"));

        final DefaultConfiguration moduleConfig =
                createModuleConfig(AnonInnerLengthCheck.class);

        final String[] expectedViolation = {
            "7:35: " + getCheckMessage(AnonInnerLengthCheck.class,
                    AnonInnerLengthCheck.MSG_KEY, 6),
        };

        final List<String> expectedXpathQueries = Arrays.asList(
                "/COMPILATION_UNIT/CLASS_DEF"
                        + "[./IDENT[@text='InputXpathAnonInnerLength']]"
                        + "/OBJBLOCK/METHOD_DEF[./IDENT[@text='compare']]/SLIST"
                        + "/VARIABLE_DEF[./IDENT[@text='comp']]/ASSIGN/EXPR",
                "/COMPILATION_UNIT/CLASS_DEF"
                        + "[./IDENT[@text='InputXpathAnonInnerLength']]"
                        + "/OBJBLOCK/METHOD_DEF[./IDENT[@text='compare']]/SLIST"
                        + "/VARIABLE_DEF[./IDENT[@text='comp']]/ASSIGN/EXPR"
                        + "/LITERAL_NEW[./IDENT[@text='Comparator']]"
        );

        runVerifications(moduleConfig, fileToProcess, expectedViolation,
                expectedXpathQueries);
    <|file_separator|><nl>
        final String filePath =
                getPath("InputXpathExecutableStatementCountDefaultConfig.java");
        final File fileToProcess = new File(filePath);

        final DefaultConfiguration moduleConfig =
                createModuleConfig(ExecutableStatementCountCheck.class);

        final String[] expectedViolations = {
            "4:5: " + getCheckMessage(ExecutableStatementCountCheck.class, MSG_KEY, 2, 0),
        };

        final List<String> expectedXpathQueries = Arrays.asList(
            "/COMPILATION_UNIT/CLASS_DEF[./IDENT["
            + "@text='InputXpathExecutableStatementCountDefaultConfig']]"
            + "/OBJBLOCK/CTOR_DEF[./IDENT["
            + "@text='InputXpathExecutableStatementCountDefaultConfig']]"
            + "/MODIFIERS",
            "/COMPILATION_UNIT/CLASS_DEF[./IDENT["
            + "@text='InputXpathExecutableStatementCountDefaultConfig']]"
            + "/OBJBLOCK/CTOR_DEF[./IDENT["
            + "@text='InputXpathExecutableStatementCountDefaultConfig']]"
            + "/MODIFIERS/LITERAL_PUBLIC"
        );

        runVerifications(moduleConfig, fileToProcess, expectedViolations, expectedXpathQueries);
    <|file_separator|><nl>
        final File fileToProcess =
                new File(getPath("SuppressionXpathRegressionIllegalThrowsTwo.java"));

        final DefaultConfiguration moduleConfig =
                createModuleConfig(IllegalThrowsCheck.class);

        final String[] expectedViolation = {
            "4:35: " + getCheckMessage(IllegalThrowsCheck.class,
                IllegalThrowsCheck.MSG_KEY, "RuntimeException"),
        };

        final List<String> expectedXpathQueries = Collections.singletonList(
            "/COMPILATION_UNIT/CLASS_DEF"
                + "[./IDENT[@text='SuppressionXpathRegressionIllegalThrowsTwo']]/OBJBLOCK"
                + "/METHOD_DEF[./IDENT[@text='sayHello']]/LITERAL_THROWS"
                + "/IDENT[@text='RuntimeException']"
        );

        runVerifications(moduleConfig, fileToProcess, expectedViolation,
                expectedXpathQueries);
    <|file_separator|><nl>
        final File fileToProcess =
                new File(getPath("SuppressionXpathRegressionImportControlFour.java"));

        final DefaultConfiguration moduleConfig =
                createModuleConfig(ImportControlCheck.class);
        moduleConfig.addProperty("file", getPath(
                "SuppressionXpathRegressionImportControlFour.xml"));

        final String[] expectedViolation = {
            "1:1: " + getCheckMessage(ImportControlCheck.class,
                ImportControlCheck.MSG_UNKNOWN_PKG),
        };

        final List<String> expectedXpathQueries = Arrays.asList(
                "/COMPILATION_UNIT", "/COMPILATION_UNIT/PACKAGE_DEF"
        );

        runVerifications(moduleConfig, fileToProcess, expectedViolation,
                expectedXpathQueries);
    <|file_separator|><nl>
        final File fileToProcess = new
                File(getPath("SuppressionXpathRegressionInnerAssignment2.java"));

        final DefaultConfiguration moduleConfig = createModuleConfig(InnerAssignmentCheck.class);

        final String[] expectedViolation = {
            "7:15: " + getCheckMessage(InnerAssignmentCheck.class, InnerAssignmentCheck.MSG_KEY),
        };

        final List<String> expectedXpathQueries = List.of(
                "/COMPILATION_UNIT"
                        + "/CLASS_DEF[./IDENT[@text='SuppressionXpathRegressionInnerAssignment2']]"
                        + "/OBJBLOCK/METHOD_DEF[./IDENT[@text='testMethod']]"
                        + "/SLIST/EXPR/ASSIGN[./IDENT[@text='a']]/ASSIGN[./IDENT[@text='b']]"
        );

        runVerifications(moduleConfig, fileToProcess, expectedViolation, expectedXpathQueries);
    <|file_separator|><nl>
        final File fileToProcess =
                new File(getPath("SuppressionXpathRegressionMethodLengthSingleToken.java"));

        final DefaultConfiguration moduleConfig = createModuleConfig(MethodLengthCheck.class);
        moduleConfig.addProperty("max", "5");
        moduleConfig.addProperty("countEmpty", "false");
        moduleConfig.addProperty("tokens", "METHOD_DEF");

        final String[] expectedViolations = {
            "15:5: " + getCheckMessage(MethodLengthCheck.class, MSG_KEY, 6, 5, "methodOne"),
        };

        final List<String> expectedXpathQueries = Arrays.asList(
                "/COMPILATION_UNIT/CLASS_DEF[./IDENT"
                        + "[@text='SuppressionXpathRegressionMethodLengthSingleToken']]"
                        + "/OBJBLOCK/METHOD_DEF[./IDENT[@text='methodOne']]",
                "/COMPILATION_UNIT/CLASS_DEF[./IDENT"
                        + "[@text='SuppressionXpathRegressionMethodLengthSingleToken']]"
                        + "/OBJBLOCK/METHOD_DEF[./IDENT[@text='methodOne']]/MODIFIERS",
                "/COMPILATION_UNIT/CLASS_DEF[./IDENT"
                        + "[@text='SuppressionXpathRegressionMethodLengthSingleToken']]"
                        + "/OBJBLOCK/METHOD_DEF[./IDENT[@text='methodOne']]"
                        + "/MODIFIERS/LITERAL_PROTECTED"
        );

        runVerifications(moduleConfig, fileToProcess, expectedViolations, expectedXpathQueries);
    <|file_separator|><nl>
        final File fileToProcess =
            new File(getPath("InputXpathNestedTryDepth.java"));

        final DefaultConfiguration moduleConfig =
            createModuleConfig(NestedTryDepthCheck.class);

        final String[] expectedViolation = {
            "9:25: " + getCheckMessage(NestedTryDepthCheck.class,
                NestedTryDepthCheck.MSG_KEY, 4, 3),
        };

        final List<String> expectedXpathQueries = Collections.singletonList(
            "/COMPILATION_UNIT/CLASS_DEF"
                + "[./IDENT[@text='InputXpathNestedTryDepth']]"
                + "/OBJBLOCK/METHOD_DEF[./IDENT[@text='test']]"
                + "/SLIST/LITERAL_TRY"
                + "/SLIST/LITERAL_TRY"
                + "/SLIST/LITERAL_TRY"
                + "/SLIST/LITERAL_TRY"
                + "/SLIST/LITERAL_TRY"
        );

        runVerifications(moduleConfig, fileToProcess, expectedViolation,
            expectedXpathQueries);
    <|file_separator|><nl>
        final File fileToProcess =
                new File(getPath("SuppressionXpathRegressionParameterNameDifferentPattern.java"));

        final String pattern = "^[a-z][a-zA-Z0-9]*$";
        final DefaultConfiguration moduleConfig =
                createModuleConfig(ParameterNameCheck.class);
        moduleConfig.addProperty("format", "^[a-z][a-zA-Z0-9]*$");

        final String[] expectedViolation = {
            "5:22: " + getCheckMessage(ParameterNameCheck.class,
                        AbstractNameCheck.MSG_INVALID_PATTERN, "v_1", pattern),
        };

        final List<String> expectedXpathQueries = Collections.singletonList(
                "/COMPILATION_UNIT"
                        + "/CLASS_DEF[./IDENT[@text"
                        + "='SuppressionXpathRegressionParameterNameDifferentPattern']]"
                        + "/OBJBLOCK/METHOD_DEF[./IDENT[@text='method1']]"
                        + "/PARAMETERS/PARAMETER_DEF/IDENT[@text='v_1']"
        );
        runVerifications(moduleConfig, fileToProcess, expectedViolation,
                expectedXpathQueries);
    <|file_separator|><nl>
        final File fileToProcess =
                new File(getPath("SuppressionXpathRegressionParenPadLeftFollowed.java"));

        final DefaultConfiguration moduleConfig =
                createModuleConfig(ParenPadCheck.class);

        final String[] expectedViolation = {
            "5:12: " + getCheckMessage(ParenPadCheck.class,
                    AbstractParenPadCheck.MSG_WS_FOLLOWED, "("),
        };

        final List<String> expectedXpathQueries = Collections.singletonList(
            "/COMPILATION_UNIT/CLASS_DEF"
                + "[./IDENT[@text='SuppressionXpathRegressionParenPadLeftFollowed']]"
                + "/OBJBLOCK/METHOD_DEF[./IDENT[@text='method']]/SLIST/LITERAL_IF/LPAREN"
        );

        runVerifications(moduleConfig, fileToProcess, expectedViolation,
                expectedXpathQueries);
    <|file_separator|><nl>
        final File fileToProcess =
                new File(getPath("SuppressionXpathRegressionRequireThisOne.java"));

        final DefaultConfiguration moduleConfig =
                createModuleConfig(RequireThisCheck.class);
        moduleConfig.addProperty("validateOnlyOverlapping", "false");

        final String[] expectedViolation = {
            "9:9: " + getCheckMessage(RequireThisCheck.class,
                RequireThisCheck.MSG_METHOD, "method1", ""),
        };

        final List<String> expectedXpathQueries = Collections.singletonList(
            "/COMPILATION_UNIT/CLASS_DEF"
                + "[./IDENT[@text='SuppressionXpathRegressionRequireThisOne']]/OBJBLOCK"
                + "/METHOD_DEF[./IDENT[@text='method2']]/SLIST/EXPR"
                + "/METHOD_CALL/IDENT[@text='method1']"
        );

        runVerifications(moduleConfig, fileToProcess, expectedViolation,
                expectedXpathQueries);
    <|file_separator|><nl>
        final File fileToProcess = new File(
            getPath(
                "SuppressionXpathRegressionSimplifyBooleanReturnIfBooleanReturnBoolean.java"));

        final DefaultConfiguration moduleConfig = createModuleConfig(CLASS);

        final String[] expectedViolation = {
            "6:9: " + getCheckMessage(CLASS, MSG_KEY),
        };

        final List<String> expectedXpathQueries = Collections.singletonList(
            "/COMPILATION_UNIT/CLASS_DEF[./IDENT[@text="
                + "'SuppressionXpathRegressionSimplifyBooleanReturnIfBooleanReturnBoolean']]"
                + "/OBJBLOCK/METHOD_DEF[./IDENT[@text='toTest']]/SLIST/LITERAL_IF"
        );

        runVerifications(moduleConfig, fileToProcess, expectedViolation,
            expectedXpathQueries);
    }

    @Test
    public void testIfBooleanReturnBooleanEqualsBoolean() throws Exception {
        final File fileToProcess = new File(
            getPath(
                "SuppressionXpathRegressionSimplifyBooleanReturnIfBooleanReturnBooleanEqualsBoolean.java"));

        final DefaultConfiguration moduleConfig = createModuleConfig(CLASS);

        final String[] expectedViolation = {
            "6:9: " + getCheckMessage(CLASS, MSG_KEY),
        };

        final List<String> expectedXpathQueries = Collections.singletonList(
            "/COMPILATION_UNIT/CLASS_DEF[./IDENT[@text="
                + "'SuppressionXpathRegressionSimplifyBooleanReturnIfBooleanReturnBooleanEqualsBoolean']]"
                + "/OBJBLOCK/METHOD_DEF[./IDENT[@text='toTest']]/SLIST/LITERAL_IF"
        );

        runVerifications(moduleConfig, fileToProcess, expectedViolation,
            expectedXpathQueries);
    }

<nl>
        final File fileToProcess = new File(getPath(
            "SuppressionXpathRegressionUnnecessarySemicolonAfterTypeMemberDeclarationDefault"
                + ".java"));
        final DefaultConfiguration moduleConfig = createModuleConfig(CLASS);

        final String[] expectedViolation = {
            "4:21: " + getCheckMessage(CLASS,
                UnnecessarySemicolonAfterTypeMemberDeclarationCheck.MSG_SEMI),
        };

        final List<String> expectedXpathQueries = Collections.singletonList(
            "/COMPILATION_UNIT/CLASS_DEF[."
                + "/IDENT[@text='SuppressionXpathRegressionUnnecessarySemicolonAfterTypeMember"
                    + "DeclarationDefault']]"
                + "/OBJBLOCK/SEMI[1]"
        );

        runVerifications(moduleConfig, fileToProcess, expectedViolation, expectedXpathQueries);
    <|file_separator|><nl>
    <|file_separator|>class InputOverloadMethodsDeclarationOrderPrivateAndStaticMethods.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class InputOverloadMethodsDeclarationOrderPrivateAndStaticMethods {
    public void testing() {
    }

    private void testing(int a) {
    }

    public void testing(int a, int b) {
    }

    public static void testing(String a) {
    }

    public void testing(String a, String b) {
    }
}<|file_separator|><nl>
            if (flag) {
                int[] b = {1, 2, 3, 4, };
            }
        <|file_separator|><nl>
        int mode = 0;
        switch (mode) {
            case 1:
                int x = 1;
                break;
            default:
                x = 0;
        } // ok
    <|file_separator|>class InputRightCurlySwitchCase2.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>class InputRightCurlySwitchCase2 {

    public static void method0() {
        int mode = 0;
        switch (mode) {
            case 1:
                int x = 1;
                break;
            default :
                x = 0; } // warn
    }

    public static void method1() {
        int mode = 0;
        switch (mode) {
        default :
               int x = 0; } // warn
    }

    public static void method2() {
        int mode = 0;
        switch (mode) {
            case 1:
                int x = 1;
                break;
            default:
                x = 0;
        } // ok
    }

    public static void method3() {
        int mode = 0;
        switch (mode) {
        default :
               int x = 0;
        } // ok
    }

    public static void method4() {
        int mode = 0;
        switch (mode) {
            case 1:
                int x = 1;
                break;
            default:
                x = 0;
        } // ok
    }
}<|file_separator|><nl>
            try {
               if (!flag) {
                   doSm();
               }
            } catch (Exception e) { /* ignore */ } //ok
            finally {/* ignore */} //ok
        }

        void foo2() {
            try {
               if (!flag) {
                   doSm();
               }
            } catch (Exception e) {}
            finally {} //warn
        }
    };<|file_separator|><nl>
                int a = 1;

                if (a == 1) {
                    System.identityHashCode("a");
                } else {
                    /*ignore*/
                }
            <|file_separator|><nl>
            Comparable
                <
                String
                >
                c = new String();
            Map<String, String> map = new HashMap<String, String>();
            boolean flag = false;

            int init = 9;

            /*ok*/ for (Map.Entry<String, String> entry :
                map.entrySet())
            {
                int i = flag == true ?
                        1 : 2;
            }

             if (init !=
                    9)
            {

            }

             while (init ==
                    10)
            {

            }

             if (init >
                    10)
            {

            } else {}

             while (init < 10 ||
                    !flag) {

            }
        }
    };<|file_separator|><nl>
        int i = 1;
        String s = "123";
        foo(i, s);
    <|file_separator|><nl> //indent:4 exp:4
      return conditionFirst("Loooooooooooooooooong", new //indent:6 exp:6
          SecondClassLongName("Loooooooooooooooooog"). //indent:10 exp:10
              getInteger(new FooReturnClass(), "Loooooooooooooooooog"), //indent:14 exp:>=10
              new InnerClassFoo()); //indent:14 exp:>=10
    <|file_separator|><nl>  //indent:4 exp:4
    // TODO Auto-generated method stub  //indent:6 exp:6
  }  //indent:2 exp:2
<|file_separator|>class InnerClass1  //indent:2 exp:2
       extends  //indent:7 exp:>=6
          SecondClassReturnWithVeryVeryVeryLongName {  //indent:10 exp:>=6
    public InnerClass1(String string) {  //indent:4 exp:4
      super();  //indent:6 exp:6
      // OOOO Auto-generated constructor stub //indent:6 exp:6
    }  //indent:4 exp:4
  }  //indent:2 exp:2

  @Override  //indent:2 exp:2
  public void run() {  //indent:4 exp:4
    // TODO Auto-generated method stub  //indent:6 exp:6
  }  //indent:2 exp:2
<|file_separator|>class InnerClass3  //indent:2 exp:2
       extends  //indent:7 exp:>=6
          SecondClassReturnWithVeryVeryVeryLongName {  //indent:10 exp:>=6
    public InnerClass3(String string) {  //indent:4 exp:4
      super();  //indent:6 exp:6
      // OOOO Auto-generated constructor stub //indent:6 exp:6
    }  //indent:4 exp:4
  }  //indent:2 exp:2

  @Override  //indent:2 exp:2
  public void run() {  //indent:4 exp:4
    // TODO Auto-generated method stub  //indent:6 exp:6
  }  //indent:2 exp:2
<|file_separator|><nl>
    }

    public void foo11() {
        String s = "";
        s.toString().toString().toString();
        // comment
    }

    public void foo12() {
        String s = "";
        s.toString().toString().toString();
        // comment
    }

    public void foo13() {
        String s = "";
        s.toString().toString().toString();
        // comment
    }

    public void foo14() {
        String s = "";
        s.toString().toString().toString();
        // comment
    }

    public void foo15() {
        String s = "";
        s.toString().toString().toString();
        // comment
    }

    public void foo16() {
        String s = "";
        s.toString().toString().toString();
        // comment
    }

    public void foo17() {
        String s = "";
        s.toString().toString().toString();
        // comment
    }

    public void foo18() {
        String s = "";
        s.toString().toString().toString();
        // comment
    }

    public void foo19() {
        String s = "";
        s.toString().toString().toString();
        // comment
    }

    public void foo20() {
        String s = "";
        s.toString().toString().toString();
        // comment
    }

    public void foo21() {
        String s = "";
        s.toString().toString().toString();
        // comment
    }

    public void foo22() {
        String s = "";
        s.toString().toString().toString();
        // comment
    }

    public void foo23() {
        String s<nl>}

    /** Valid: public and one char long */
    public void e(int p) {<|file_separator|><nl>} //warn
        };
<|file_separator|><nl>}

        /**
         * An especially short bit of Javadoc.
         */
        void foo7() {}

        /**
         * An especially short bit of Javadoc.
         */
        void foo8() {}

        /**
         * An especially short bit of Javadoc.
         */
        void foo9() {}

        /**
         * An especially short bit of Javadoc.
         */
        void foo10() {}

        /**
         * An especially short bit of Javadoc.
         */
        void foo11() {}

        /**
         * An especially short bit of Javadoc.
         */
        void foo12() {}

        /**
         * An especially short bit of Javadoc.
         */
        void foo13() {}

        /**
         * An especially short bit of Javadoc.
         */
        void foo14() {}

        /**
         * An especially short bit of Javadoc.
         */
        void foo15() {}

        /**
         * An especially short bit of Javadoc.
         */
        void foo16() {}

        /**
         * An especially short bit of Javadoc.
         */
        void foo17() {}

        /**
         * An especially short bit of Javadoc.
         */
        void foo18() {}

        /**
         * An especially short bit of Javadoc.
         */
        void foo19() {}

        /**
         * An especially short bit of Javadoc.
         */
        void foo20() {}

        /**
         * An especially short bit of Javadoc.
         */
        void foo21() {}

        /**
         * An especially short bit of Javadoc.
         */
        void foo22() {}

        <nl>
        return 1;
    <|file_separator|><nl> // warn

    }<|file_separator|>class InnerPublic. // warn.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class InnerPublic { // warn

    }

    public enum MyEnumPublic { // warn

    }

    public interface MyInterfacePublic {  // warn

    }

    public @interface MyAnnotationPublic { //warn

    }

    public void myMethod() { // warn

    }<|file_separator|>class InnerPrivate. // warn.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>private class InnerPrivate { // warn

    }

    private enum MyEnumPrivate { // warn

    }

    private interface MyInterfacePrivate {  // warn

    }

    private @interface MyAnnotationPrivate { //warn

    }

    public void myMethod() { // warn

    }<|file_separator|><nl>
        // @formatter:off
        // @formatter:on
    <|file_separator|><nl>
        if (true) {
            System.out.println("Hello");
        }
    <|file_separator|><nl>
        if (bad == 0) {
            return;
        }
        if (good == 0) {
            return;
        }
    <|file_separator|>class InputXpathEmptyForIteratorPadNotFollowed.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>class InputXpathEmptyForIteratorPadNotFollowed {
    void method(int bad, int good) {
        if (bad == 0) {
            return;
        }
        if (good == 0) {
            return;
        }
    }
}<|file_separator|><nl>
        if (true) {
            // do something
        }
    <|file_separator|><nl>
    <|file_separator|><nl>
        // code
    <|file_separator|><nl>
        // code
    <|file_separator|><nl>
        return null;
    <|file_separator|><nl>
        String b = "StringContents";
        String b1 = "unchecked"; // warn
    <|file_separator|><nl>
        this.anonymous = anonymous;
    <|file_separator|>class SuppressionXpathRegressionOverloadMethodsDeclarationOrder1 {
    private SuppressionXpathRegressionOverloadMethodsDeclarationOrder1 anonymous
            = new MySuppressionXpathRegressionOverloadMethodsDeclarationOrder1();

    public SuppressionXpathRegressionOverloadMethodsDeclarationOrder1 getAnonymous() {
        return anonymous;
    }

    public void setAnonymous(SuppressionXpathRegressionOverloadMethodsDeclarationOrder1 anonymous) {
        this.anonymous = anonymous;
    }

    private static class MySuppressionXpathRegressionOverloadMethodsDeclarationOrder1
            extends SuppressionXpathRegressionOverloadMethodsDeclarationOrder1 {
        public void overloadMethod(int i) {
            //do stuff
        }

        public void overloadMethod(String s) {
            //do more stuff
        }

        public void separatorMethod() {
            //do other stuff
        }

        //violation because overloads shouldn't be separated
        public void overloadMethod(String s, Boolean b, int i) { //warn
            //do stuff
        }
    }
}<|file_separator|><nl>
        SomeInterface obj2 = q -> q++; // warn
    <|file_separator|><nl>
                    new Object() {
                        void method() {
                            new Object() {
                                void method() {
                                    new Object() {
                                        void method() {
                                            new Object() {
                                                void method() {
                                                    new Object() {
                                                        void method() {
                                                            new Object() {
                                                                void method() {
                                                                    new Object() {
                                                                        void method() {
                                                                            new Object() {
                                                                                void method() {
                                                                                    new Object() {
                                                                                        void method() {
                                                                                            new Object() {
                                                                                                void method() {
                                                                                                    new Object() {
                                                                                                        void method() {
                                                                                                            new Object() {
                                                                                                                void method() {
                                                                                                                    new Object() {
                                                                                                                        void method() {
                                                                                                                            new Object() {
                                                                                                                                void method() {
                                                                                                                                    new Object() {
                                                                                                                                        void method() {
                                                                                                                                            new Object() {
                                                                                                                                                void method() {
                                                                                                                                                    new Object() {
                                                                                                                                                        void method() {
                                                                                                                                                            new Object() {
                                                                                                                                                                void method() {
                                                                                                                                                                    new Object() {
                                                                                                                                                                        void method() {
                                                                                                                                                                            new Object() {
                                                                                                                                                                                void method() {
                                                                                                                                                                                    new Object() {
                                                                                                                                                                                        void method() {
                                                                                                                                                                                            new Object() {
                                                                                                                                                                                                void method() {
                                                                                                                                                                                                    new Object<nl>
        // TODO: Implement this method
    <|file_separator|><nl>
        if (a == 1) {
            if (b == 1) {
                // do something
            }
        }
    <|file_separator|>class SuppressionXpathRegressionUnnecessaryParentheses10 {
    void foo(int a, int b) {
        if (a == 1) {
            if (b == 1) {
                // do something
            }
        }
    }
}<|file_separator|>class SuppressionXpathRegressionUnnecessaryParentheses11 {
    void foo(int a, int b) {
        if (a == 1) {
            if (b == 1) {
                // do something
            }
        }
    }
}<|file_separator|>class SuppressionXpathRegressionUnnecessaryParentheses1 {
    void foo(int a, int b) {
        if (a == 1) {
            if (b == 1) {
                // do something
            }
        }
    }
}<|file_separator|>class SuppressionXpathRegressionUnnecessaryParentheses12 {
    void foo(int a, int b) {
        if (a == 1) {
            if (b == 1) {
                // do something
            }
        }
    }
}<|file_separator|>class SuppressionXpathRegressionUnnecessaryParentheses13 {
    void foo(int a, int b) {
        if (a == 1) {
            if (b == 1) {
                // do something
            }
        }
    }
}<|file_separator|>class SuppressionXpathRegressionUnnecessaryParentheses14 {
    void foo(int a, int b) {
        if (a == 1) {
            if (b == 1) {
                // do something
            }
        }
    }
}<|file_separator|>class<nl>
    <|file_separator|><nl>
        final RandomAccessFile fileStream = new RandomAccessFile(file, "r");
        try {
            final boolean endsWithNewline = endsWithNewline(fileStream, lineSeparator);
            if (!endsWithNewline) {
                log(1, MSG_KEY_NO_NEWLINE_EOF, file.getPath());
            }
        }
        finally {
            fileStream.close();
        }
    }

    /**
     * Enumeration of line separators.
     */
    private enum LineSeparatorOption {
        /**
         * Line separator is '\n'.
         */
        LF("\n"),
        /**
         * Line separator is '\r'.
         */
        CR("\r"),
        /**
         * Line separator is '\r\n'.
         */
        CR_LF("\r\n"),
        /**
         * Line separator is '\n\r'.
         */
        LF_CR("\n\r"),
        /**
         * Line separator is '\n\r\n'.
         */
        LF_CR_CRLF("\n\r\n"),
        /**
         * Line separator is the platform specific line separator.
         */
        SYSTEM("\n");

        private final String separator;

        LineSeparatorOption(String separator) {
            this.separator = separator;
        }

        public String getSeparator() {
            return separator;
        }

        public int length() {
            return separator.length();
        }

        public boolean matches(byte[] bytes) {
            return separator.equals(new String(bytes));
        }
    <|file_separator|><nl>
        final UniqueProperties uniqueProperties = new UniqueProperties();
        for (int index = 0; index < fileText.size(); index++) {
            final String line = fileText.get(index);
            final Matcher matcher = getKeyPattern(line).matcher(line);
            if (matcher.matches()) {
                final String key = matcher.group(1);
                final int lineNumber = getLineNumber(fileText, key);
                uniqueProperties.put(key, lineNumber);
            }
        }
        final Map<String, AtomicInteger> duplicatedKeys = uniqueProperties
                .getDuplicatedKeys();
        if (!duplicatedKeys.isEmpty()) {
            for (final Map.Entry<String, AtomicInteger> entry : duplicatedKeys
                    .entrySet()) {
                final String key = entry.getKey();
                final int lineNumber = entry.getValue().get();
                report(file, MSG_KEY, key, lineNumber);
            }
        }
    <|file_separator|><nl>
        final String packageName = ast.getPackage();
        if (packageName != null) {
            final String[] parts = packageName.split("\\.");
            if (parts.length > 1) {
                final String lastPart = parts[parts.length - 1];
                if (lastPart.startsWith("R$")) {
                    return;
                }
            }
        }
        final String message = get(MSG_KEY);
        final String[] parts = message.split("\\|");
        final String[] parts2 = parts[1].split("\\.");
        final String lastPart = parts2[parts2.length - 1];
        if (lastPart.startsWith("R$")) {
            return;
        }
        final String[] parts3 = parts[0].split("\\.");
        final String lastPart2 = parts3[parts3.length - 1];
        if (lastPart2.startsWith("R$")) {
            return;
        }
        final String[] parts4 = parts[2].split("\\.");
        final String lastPart3 = parts4[parts4.length - 1];
        if (lastPart3.startsWith("R$")) {
            return;
        }
        final String[] parts5 = parts[3].split("\\.");
        final String lastPart4 = parts5[parts5.length - 1];
        if (lastPart4.startsWith("R$")) {
            return;
        }
        final String[] parts6 = parts[4].split("\\.");
        final String lastPart5 = parts6[parts6.length - 1];
        if (lastPart5.startsWith("R$")) {
            return;
        }
        final String[] parts7 = parts[5].split("\\.");
<nl>
        return paramNode != null
                && paramNode.getFirstChild() != null
                && paramNode.getFirstChild().getType() == TokenTypes.IDENT
                && paramNode.getFirstChild().getText().equals("Object");
    <|file_separator|><nl>
        if (ast.tokenType == TokenTypes.LITERAL_TRUE) {
            ast.tokenType = TokenTypes.LITERAL_TRUE;
        } else if (ast.tokenType == TokenTypes.LITERAL_FALSE) {
            ast.tokenType = TokenTypes.LITERAL_FALSE;
        }
    <|file_separator|><nl>
        return "super.clone()";
    <|file_separator|><nl>
        if (ast.getType() == TokenTypes.TYPE_DEF) {
            checkTypeDefinition(ast);
        } else if (ast.getType() == TokenTypes.TYPE_MEMBER) {
            checkTypeMember(ast);
        } else if (ast.getType() == TokenTypes.VARIABLE_DEF) {
            checkVariableDefinition(ast);
        } else if (ast.getType() == TokenTypes.ENUM_CONSTANT_DEF) {
            checkEnumConstant(ast);
        }
    <|file_separator|><nl>
        final BufferedReader reader = new BufferedReader(headerReader);
        readerLines.addAll(reader.lines().collect(Collectors.toList()));
    <|file_separator|><nl>
        final int headerSize = getHeaderLines().size();
        for (int lineNum = 0; lineNum < headerSize; lineNum++) {
            final String line = getHeaderLines().get(lineNum);
            if (isMatch(line, lineNum)) {
                if (isMultiLine(lineNum)) {
                    log(1, MSG_HEADER_MISMATCH);
                }
            }
            else {
                log(1, MSG_HEADER_MISSING);
            }
        }
        logFirstSinglelineLine(0, headerSize);
    <|file_separator|><nl>
        if (parent == null) {
            return localCheckAccess(inPkg, inFileName, forImport);
        }
        return parent.checkAccess(inPkg, inFileName, forImport);
    <|file_separator|><nl>
        allowStaticMemberImports = allow;
    <|file_separator|><nl>
        return IndentLevel.INDENT_CASE;
    <|file_separator|>class IndentLevel.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public enum IndentLevel {
    INDENT_CASE,
    INDENT_DEFAULT,
    INDENT_ELSE,
    INDENT_ELSE_IF,
    INDENT_IF,
    INDENT_SWITCH,
    INDENT_WHILE,
    INDENT_FOR,
    INDENT_DO,
    INDENT_TRY,
    INDENT_CATCH,
    INDENT_FINALLY,
    INDENT_RETURN,
    INDENT_BREAK,
    INDENT_CONTINUE,
    INDENT_THROW,
    INDENT_NEW,
    INDENT_THIS,
    INDENT_SUPER,
    INDENT_INSTANCEOF,
    INDENT_NULL,
    INDENT_THIS_TYPE,
    INDENT_THIS_INSTANCE,
    INDENT_THIS_CLASS,
    INDENT_THIS_METHOD,
    INDENT_THIS_FIELD,
    INDENT_THIS_CONSTRUCTOR,
    INDENT_THIS_STATIC,
    INDENT_THIS_STATIC_METHOD,
    INDENT_THIS_STATIC_FIELD,
    INDENT_THIS_STATIC_CONSTRUCTOR,
    INDENT_THIS_STATIC_CLASS,
    INDENT_THIS_STATIC_INSTANCE,
    INDENT_THIS_STATIC_METHOD_INSTANCE,
    INDENT_THIS_STATIC_FIELD_INSTANCE,
    INDENT_THIS_STATIC_CONSTRUCTOR_INSTANCE,
    INDENT_THIS_STATIC_CLASS_INSTANCE,
    INDENT_THIS_STATIC_INSTANCE_METHOD,
    INDENT_THIS_STATIC_INSTANCE_FIELD,
    INDENT_THIS_STATIC_INSTANCE_CONSTRUCTOR,
    INDENT_THIS<nl>
        checkCondExpr();
        super.checkIndentation();
    <|file_separator|><nl>
        if (getIndentCheck().isIndentation(getIndent())) {
            getIndentCheck().error(getIndent(), "else must be on a new line");
        }
    <|file_separator|>class IndentationCheck.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class IndentationCheck {

    /**
     * Check if the given line is indented.
     *
     * @param line the line to check
     * @return true if the line is indented, false otherwise
     */
    public boolean isIndentation(String line) {
        return line.trim().length() == 0;
    }

    /**
     * Check if the given line is indented.
     *
     * @param line the line to check
     * @return true if the line is indented, false otherwise
     */
    public boolean isIndentation(int line) {
        return isIndentation(getLine(line));
    }

    /**
     * Get the line of the given index.
     *
     * @param index the index of the line
     * @return the line of the given index
     */
    public String getLine(int index) {
        return getLines()[index];
    }

    /**
     * Get the lines of the given file.
     *
     * @return the lines of the given file
     */
    public String[] getLines() {
        return getLines();
    }

    /**
     * Get the lines of the given file.
     *
     * @return the lines of the given file
     */
    public String[] getLines() {
        return getLines();
    }

    /**
     * Get the lines of the given file.
     *
     * @return the lines of the given file
     */
    public String[] getLines<nl>
        return new int[] {
            Token.CLASS,
            Token.METHOD,
            Token.CONSTRUCTOR,
            Token.FIELD,
            Token.VARIABLE,
            Token.PARAMETER,
            Token.TYPE,
            Token.TYPE_PARAMETER,
            Token.TYPE_USE,
            Token.TYPE_PARAMETER_USE,
            Token.TYPE_PARAMETER_BOUND,
            Token.TYPE_PARAMETER_BOUND_USE,
            Token.TYPE_PARAMETER_BOUND_USE_TYPE,
            Token.TYPE_PARAMETER_BOUND_USE_TYPE_PARAMETER,
            Token.TYPE_PARAMETER_BOUND_USE_TYPE_PARAMETER_USE,
            Token.TYPE_PARAMETER_BOUND_USE_TYPE_PARAMETER_USE_TYPE,
            Token.TYPE_PARAMETER_BOUND_USE_TYPE_PARAMETER_USE_TYPE_PARAMETER,
            Token.TYPE_PARAMETER_BOUND_USE_TYPE_PARAMETER_USE_TYPE_PARAMETER_USE,
            Token.TYPE_PARAMETER_BOUND_USE_TYPE_PARAMETER_USE_TYPE_PARAMETER_USE_TYPE,
            Token.TYPE_PARAMETER_BOUND_USE_TYPE_PARAMETER_USE_TYPE_PARAMETER_USE_TYPE_PARAMETER,
            Token.TYPE_PARAMETER_BOUND_USE_TYPE_PARAMETER_USE_TYPE_PARAMETER_USE_TYPE_PARAMETER_USE,
            Token.TYPE_PARAMETER_BOUND_USE_TYPE_PARAMETER_USE_TYPE_PARAMETER_USE_TYPE_PARAMETER_USE_TYPE,
            Token.TYPE_PARAMETER_BOUND_USE_TYPE_PARAMETER_USE_TYPE_PARAMETER_USE_TYPE_PARAMETER_USE_TYPE_PARAMETER,
            Token.TYPE_PARAMETER_BOUND_USE_TYPE_PARAMETER_USE_TYPE_PARAMETER_USE_TYPE_PARAMETER_USE_TYPE_PARAMETER_USE,
            <nl>
        return new int[]{TokenTypes.IDENTIFIER};
    <|file_separator|><nl>
        this.format = pattern;
    <|file_separator|><nl>
        return minimum;
    <|file_separator|><nl>
        final int length = getLength(ast);
        if (length > max) {
            addFailure(ast, String.format(messages.getString(MSG_KEY), max));
        }
    <|file_separator|><nl>
        if (ast.getType() == TokenTypes.METHOD_DEF) {
            visitMethodDef(ast);
        }
    }

    /**
     * Visit a method definition.
     *
     * @param ast the method definition AST
     */
    public void visitMethodDef(DetailAST ast) {
        // Get the method name
        String methodName = ast.getName();
        // Get the method parameters
        List<DetailAST> params = ast.getChildren(TokenTypes.PARAM_DEF);
        // Get the method return type
        DetailAST returnType = ast.getChild(TokenTypes.TYPE_NAME);
        // Get the method body
        DetailAST body = ast.getChild(TokenTypes.METHOD_BODY);
        // Get the method body's first line
        DetailAST firstLine = body.getChild(0);
        // Get the method body's last line
        DetailAST lastLine = body.getChild(body.getChildCount() - 1);
        // Get the method body's first line's first token
        DetailAST firstToken = firstLine.getChild(0);
        // Get the method body's last line's last token
        DetailAST lastToken = lastLine.getChild(lastLine.getChildCount() - 1);
        // Get the method body's first line's first token's line number
        int firstLineNum = firstToken.getLine();
        // Get the method body's last line's last token's line number
        int lastLineNum = lastToken.getLine();
        // Get the method body's first line's first token's column number
        int firstTokenNum = firstToken.getColumn();
        // Get the method body's last line's last token's column number
        int<nl>
        final int[] tokenLine = targetAST.getLineNo() - 1;
        if (tokenLine == null) {
            return false;
        }
        final int[] tokenCodePoints = getLineCodePoints(tokenLine);
        if (tokenCodePoints == null) {
            return false;
        }
        final int[] targetCodePoints = getLineCodePoints(targetAST.getLineNo() - 1);
        if (targetCodePoints == null) {
            return false;
        }
        return CommonUtil.isFollowedByWhitespace(line, targetCodePoints);
    <|file_separator|><nl>
        <|file_separator|><nl>
        pModel.setParseTree(parseTree);
    <|file_separator|><nl>
        return treeTableModel.getValueAt(row, column);
    }

    @Override
    public void setValueAt(Object value, int row, int column) {
        treeTableModel.setValueAt(value, row, column);
    }

    @Override
    public boolean isCellEditable(int row, int column) {
        return treeTableModel.isCellEditable(row, column);
    <|file_separator|><nl>
        if (Files.isSymbolicLink(directory)) {
            Path resolvedPath = Files.readSymbolicLink(directory);
            if (!Files.isDirectory(resolvedPath)) {
                throw new IOException("The resolved symbolic link is not a directory: " + resolvedPath);
            }
            directory = resolvedPath;
        }
        if (!Files.exists(directory)) {
            Files.createDirectories(directory);
        }
    <|file_separator|><nl>
    <|file_separator|><nl>
        return Collections.unmodifiableList(violations);
    <|file_separator|><nl>
        final String[] expected = {
            "14:11: " + getCheckMessage(MSG_KEY, "RuntimeException"),
            "15:11: " + getCheckMessage(MSG_KEY, "Exception"),
            "16:11: " + getCheckMessage(MSG_KEY, "Throwable"),
            "22:11: " + getCheckMessage(MSG_KEY, "java.lang.RuntimeException"),
            "23:11: " + getCheckMessage(MSG_KEY, "java.lang.Exception"),
            "24:11: " + getCheckMessage(MSG_KEY, "java.lang.Throwable"),
        };

        verifyWithInlineConfigParser(
                getPath("InputIllegalCatchCheckMultipleExceptions.java"), expected);
    }

    @Test
    public void testIllegalCatchCheckMultipleExceptionsWithException() throws Exception {
        final String[] expected = {
            "14:11: " + getCheckMessage(MSG_KEY, "RuntimeException"),
            "15:11: " + getCheckMessage(MSG_KEY, "Exception"),
            "16:11: " + getCheckMessage(MSG_KEY, "Throwable"),
            "22:11: " + getCheckMessage(MSG_KEY, "java.lang.RuntimeException"),
            "23:11: " + getCheckMessage(MSG_KEY, "java.lang.Exception"),
            "24:11: " + getCheckMessage(MSG_KEY, "java.lang.Throwable"),
        };

        verifyWithInlineConfigParser(
                getPath("InputIllegalCatchCheckMultipleExceptionsWithException.java"), expected);
    }

    @Test
    public void testIllegalCatchCheckMultipleExceptionsWithThrowable<nl>
        assertCheck("src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/noarraytrailingcomma/NoArrayTrailingCommaCheckTest.java",
            "src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/noarraytrailingcomma/NoArrayTrailingCommaCheckTest.java:11:1: No trailing comma in array initializer\n" +
            "11 |     int[] a = {1, 2, 3};\n" +
            "   |     ^");
    <|file_separator|><nl>
        final InnerTypeLastCheck obj = new InnerTypeLastCheck();
        final int[] expected = {
            TokenTypes.CLASS_DEF,
            TokenTypes.INTERFACE_DEF,
            TokenTypes.RECORD_DEF,
        };
        assertWithMessage("Default acceptable tokens are invalid")
            .that(obj.getRequiredTokens())
            .isEqualTo(expected);
    <|file_separator|><nl>
        final String[] expected = {
            "Missing whitespace after asterisk",
        };

        verifyWithInlineConfigParser(
                getPath("InputJavadocMissingWhitespaceAfterAsteriskInvalid.java"), expected);
    <|file_separator|><nl>
        final String format = "(?i)^(?!(record|yield|var|permits|sealed)$).+$";

        final String[] expected = {
            "11:11: " + getCheckMessage(MSG_INVALID_PATTERN, "record", format),
            "12:11: " + getCheckMessage(MSG_INVALID_PATTERN, "record", format),
            "13:11: " + getCheckMessage(MSG_INVALID_PATTERN, "record", format),
            "14:11: " + getCheckMessage(MSG_INVALID_PATTERN, "record", format),
            "15:11: " + getCheckMessage(MSG_INVALID_PATTERN, "record", format),
            "16:11: " + getCheckMessage(MSG_INVALID_PATTERN, "record", format),
            "17:11: " + getCheckMessage(MSG_INVALID_PATTERN, "record", format),
        };
        verifyWithInlineConfigParser(
                getNonCompilablePath("InputIllegalIdentifierNameDefault.java"), expected);
    <|file_separator|><nl>

        final String[] expected = CommonUtil.EMPTY_STRING_ARRAY;
        verifyWithInlineConfigParser(
                getPath("InputLocalFinalVariableNameTryResources.java"), expected);
    <|file_separator|><nl>
        return "com.intellij.codeInspection.checkMethod";
    <|file_separator|><nl>
        final String[] expected = CommonUtil.EMPTY_STRING_ARRAY;
        verifyWithInlineConfigParser(
                getPath("InputParameterNameSpecified.java"), expected);
    <|file_separator|><nl>
        final String[] expected = {
            "19:36: " + getCheckMessage(MSG_INVALID_PATTERN, "value_123", "^[a-z0-9]+$"),
            "20:15: " + getCheckMessage(MSG_INVALID_PATTERN, "Values", "^[a-z0-9]+$"),
            "23:37: " + getCheckMessage(MSG_INVALID_PATTERN, "V", "^[a-z0-9]+$"),
            "24:9: " + getCheckMessage(MSG_INVALID_PATTERN, "$age", "^[a-z0-9]+$"),
        };
        verifyWithInlineConfigParser(
                getNonCompilablePath("InputRecordComponentName.java"), expected);
    <|file_separator|><nl>
        final String[] expected = {
            "1: " + getCheckMessage(MSG_REGEXP_MAXIMUM, "1000", "r"),
        };

        verifyWithInlineConfigParser(
                getPath("InputRegexpSinglelineSemantic7.java"), expected);
    <|file_separator|><nl>
        final ExecutableStatementCountCheck checkObj =
            new ExecutableStatementCountCheck();
        final DetailAstImpl ast = new DetailAstImpl();
        ast.initialize(
            new CommonToken(TokenTypes.ENUM, "ENUM"));
        try {
            checkObj.visitToken(ast);
            assertWithMessage("exception expected").fail();
        }
        catch (IllegalStateException ex) {
            assertWithMessage("Invalid exception message")
                .that(ex.getMessage())
                .isEqualTo("ENUM[0x-1]");
        }
    <|file_separator|><nl>
        final String[] expected = {
            "15:10: " + getCheckMessage(MSG_KEY, 7, 8),
            "20:10: " + getCheckMessage(MSG_KEY, 7, 8),
        };
        verifyWithInlineConfigParser(
                getPath("InputParameterNumber.java"), expected);
    <|file_separator|><nl>
        final RecordComponentNumberCheck checkObj = new RecordComponentNumberCheck();
        final int[] actual = checkObj.getAcceptableTokens();
        final int[] expected = {
            TokenTypes.RECORD_DEF,
        };

        assertWithMessage("Default acceptable tokens are invalid")
            .that(actual)
            .isEqualTo(expected);
    <|file_separator|><nl>
        final String[] suppressed = {
            "25: " + MESSAGE,
        };
        verifySuppressedWithParser(getPath("InputSuppressionSingleFilter8.java"), suppressed);
    <|file_separator|><nl>
        return "com.github.javaparser.examples.java14";<|file_separator|><nl>
        verifyAst(
                getNonCompilablePath(
                        "ExpectedStringTemplateMultiLineWithComments.txt"),
                getNonCompilablePath(
                        "InputStringTemplateMultiLineWithComments.java"));
    <|file_separator|><nl>
        final String[] expected = CommonUtil.EMPTY_STRING_ARRAY;
        verifyWithInlineConfigParser(getPath("InputAnnotations11.java"), expected);
    <|file_separator|><nl>
        final NodeList sections = getSectionsFromXdoc("src/xdocs/cmdline.xml.vm");
        final Set<String> usage = getListById(sections.item(1), "Usage");
        assertWithMessage("Usage section should contain 'Usage' keyword")
                .that(usage)
                .contains("Usage");
    }

    @Test
    public void validateCliUsageSectionParameters() throws Exception {
        final NodeList sections = getSectionsFromXdoc("src/xdocs/cmdline.xml.vm");
        final Set<String> usage = getListById(sections.item(1), "Usage");
        final Set<String> parameters = getParameters(usage.iterator().next(),
                "Usage: (\\w+\\s+){1,2}(\\w+\\s+){1,2}");
        assertWithMessage("Usage section should contain 'Usage' keyword")
                .that(parameters)
                .contains("checkstyle", "checkstyle", "checkstyle");
    <|file_separator|><nl>
        final Map<String, List<String>> checksNamesMap = getXdocsMap();
        final XdocsUrl xdocsUrl = new XdocsUrl(AVAILABLE_CHECKS_PATH);
        final List<List<String>> checkNamesList = xdocsUrl.getCheckNamesList();
        assertEquals(checksNamesMap, checkNamesList);
    <|file_separator|><nl>
        final Set<Configuration> result = new HashSet<>();

        for (Configuration child : config.getChildren()) {
            if ("Module".equals(child.getName())) {
                result.add(child);
            }
        }

        return result;
    <|file_separator|><nl>
        <|file_separator|><nl>
            System.out.println("foo");
        }
    }
<|file_separator|><nl>
        switch (k)
        { // violation ''{' at column 9 should be on the previous line'
            case 1:
                { // violation ''{' at column 17 should be on the previous line'

            }

            case 2:
                { // violation ''{' at column 17 should be on the previous line'

            }

            case 3:
                { // violation ''{' at column 17 should be on the previous line'

            }
            default:
                {   // violation ''{' at column 17 should be on the previous line'

            }
        }
        return k;
    <|file_separator|><nl>
            return true; }
    }

    record MyTestRecord2(String one, String two, String three) {
        public MyTestRecord2{
            int x = 5;} // violation ''}' at column 23 should have line break before'
        public static void main(String... args) {
            System.out.print("ok"); } // violation ''}' at column 37 should have line break before'
    }

    record MyTestRecord3(Integer i, Node node) {
        public MyTestRecord3{
            int x = 5;} // violation ''}' at column 23 should have line break before'
        public static void main(String... args) {
            System.out.print("ok"); } // violation ''}' at column 37 should have line break before'
    }

    record MyTestRecord4() {} // ok, same line

    record MyTestRecord5() {
        static MyTestRecord mtr =
                new MyTestRecord("my string", new MyTestRecord4());}
                // violation above ''}' at column 68 should be alone on a line'
    class MyTestClass {
        private MyTestRecord mtr =
                new MyTestRecord("my string", new MyTestRecord4());}

    record MyTestRecord(String string, Record rec) {
        private boolean inRecord(Object obj) {
            return true; }
    }

    record MyTestRecord2(String one, String two, String three) {
        public MyTestRecord2{
            int x = 5;} // violation ''}' at column 23 should have line break before'
        public static void main(String... args) {
            System.out.print("ok"); } // violation ''}' at column 3<nl>
    return this;
  <|file_separator|><nl>
        value = "test";
    <|file_separator|><nl>
        return switch (a) {
            case 1 -> 1;
            case 2 -> 2;
            default -> 0;
        };
    }

    public void invalidAssign(String result) {
        result = switch ("in") {
            case "correct" -> "true";
            default -> "also correct";
        };
    <|file_separator|>class InputParameterAssignmentWithSwitch {

    int method(int a) {
        return switch (a) {
            case 1 -> 1;
            case 2 -> 2;
            default -> 0;
        };
    }

    public void invalidAssign(String result) {
        result = switch ("in") {
            case "correct" -> "true";
            default -> "also correct";
        };
    }

    public void validAssign(String result) {
        result = switch ("in") {
            case "correct" -> "true";
            default -> "also correct";
        };
    }
}<|file_separator|><nl>
    return switch (k) {
      case 1 -> {
        MathOp2 e = (a, b) -> (a + b); // violation 'parentheses around assignment right-hand side'
        yield e;
      }
      case (2) -> { // violation 'Unnecessary parentheses around literal '2''
        MathOp2 f = (int a, int b) -> (a + b); // violation 'paren.* around assignment right.*side'
        yield f;
      }
      case 3 -> {
        MathOp2 g = (int a, int b) -> {
          return (a + b); // violation 'Unnecessary parentheses around return value'
        };
        yield (g); // violation 'Unnecessary parentheses around identifier 'g''
      }
      default -> {
        MathOp2 h = (int x, int y) -> {
          return (x + y); // violation 'Unnecessary parentheses around return value'
        };
        yield h;
      }
    };
  <|file_separator|>class InputUnnecessaryParenthesesCheckSwitchExpression2.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>class InputUnnecessaryParenthesesCheckSwitchExpression2 {
  MathOp2 tooManyParens(int k) {
    return switch (k) {
      case 1 -> {
        MathOp2 e = (a, b) -> (a + b); // violation 'parentheses around assignment right-hand side'
        yield e;
      }
      case (2) -> { // violation 'Unnecessary parentheses around literal '2''
        MathOp2 f = (int a, int b) -> (a + b); // violation 'paren.* around assignment right.*side'
        yield f;
      }
      case 3 -> {
        MathOp2 g = (int a<nl>
        try {
            //block comment
        } catch (Exception e) {
            //block comment
        } finally {
            //block comment
        }
    }
}
<|file_separator|><nl>} // violation
    }

    record myRECORD2(String STRING) { // 1 violation
        int INTEGER = 2; // violation
    }

    record myRECORD3(String STRING) { // 1 violation
        int INTEGER = 2; // violation
    }<|file_separator|><nl>
        return "InputLineLengthLongPackageStatement";
    <|file_separator|>class InputLineLengthLongPackageStatement.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class InputLineLengthLongPackageStatement {
    @Override
    public String toString() {
        return "InputLineLengthLongPackageStatement";
    }
}<|file_separator|><nl>
        @SuppressWarnings(unusedLocalVariableCheck)
        int a;
    <|file_separator|><nl>
        @SuppressWarnings(InputSuppressWarningsHolder2.unusedLocalVariableCheck)
        int a;
    <|file_separator|><nl>
        // violation 'There is more than 1 empty line after this line.'
    <|file_separator|>class InputEmptyLineSeparatorRecordsAndCompactCtorsNoEmptyLines.cs
<|fim_prefix|><|fim_suffix|>
    }
}<|fim_middle|>using System;

namespace ConsoleApp1
{
    public class InputEmptyLineSeparatorRecordsAndCompactCtorsNoEmptyLines
    {
        public void foo()
        {
            // violation 'There is more than 1 empty line after this line.'
        }

        public record MyRecord1()
        {
            public MyRecord1()
            { // violation 'There is more than 1 empty line after this line.'
            }
        }<|file_separator|><nl>
    <|file_separator|><nl>
        switch (o) {
            case 1:
                break;
            case 2:
                break;
            case 3:
                break;
            case 4:
                break;
            case 5:
                break;
            case 6:
                break;
            case 7:
                break;
            case 8:
                break;
            case 9:
                break;
            case 10:
                break;
            case 11:
                break;
            case 12:
                break;
            case 13:
                break;
            case 14:
                break;
            case 15:
                break;
            case 16:
                break;
            case 17:
                break;
            case 18:
                break;
            case 19:
                break;
            case 20:
                break;
            case 21:
                break;
            case 22:
                break;
            case 23:
                break;
            case 24:
                break;
            case 25:
                break;
            case 26:
                break;
            case 27:
                break;
            case 28:
                break;
            case 29:
                break;
            case 30:
                break;
            case 31:
                break;
            case 32:
                break;
            case 33:
                break;
            case 34:
                break;
            case 35:
                break;
            case 36:
                break;
            case 37<nl> System.out.println(o); <|file_separator|><nl>
        // Note that pattern variable cannot be cast to generic type
        switch (o) {
            case List list1 when (list1.size() >= 0
                    && list1.size() < 10) || list1.equals(new ArrayList<>()) ->
                    return "list1";
            case List list2 when (list2.size() >= 0
                    && list2.size() < 20) || list2.equals(new LinkedList()) ->
                    return "list2";
            case List list3 when list3.size() >= 0
                    && list3.size() < 45 || list3.equals(new LinkedList()) ->
                    return "list3";
            case Set set when "test".equals(set.toString()) ->
                    return "set";
            default -> throw new IllegalStateException(
                    "Unexpected value: " + o);
        }
    }

    static <T> void m4(Object o) {
        // Note that pattern variable cannot be cast to generic type
        switch (o) {
            case List list1 when (list1.size() >= 0
                    && list1.size() < 10) || list1.equals(new ArrayList<>()) ->
                    System.out.println(list1);
            case List list2 when (list2.size() >= 0
                    && list2.size() < 20) || list2.equals(new LinkedList()) ->
                    System.out.println("list2");
            case List list3 when list3.size() >= 0
                    && list3.size() < 45 || list3.equals(new LinkedList()) ->
                    System.out.println("list3");
            case Set set when "test".equals(set.<nl>
        return when.toString();
    }
    
    public static void main(String[] args) {
        System.out.println(m1(new Object() {
            public String toString() {
                return "Hello";
            }
        })<|file_separator|><nl>
        if (v instanceof VarArgs(String... s)) {
            System.out.println(s);
        }
    }

    static void test6(VarArgs v) {
        if (v instanceof VarArgs(String... s)) {
            System.out.println(s);
        }
    }

    static void test7(VarArgs v) {
        if (v instanceof VarArgs(String... s)) {
            System.out.println(s);
        }
    }<|file_separator|><nl>
    <|file_separator|><nl>
        <|file_separator|><nl>
        Foo foo = new Foo();
        foo.bar(new Bar<Foo>() {
            @Override
            public void foo() {
            }
        });
    <|file_separator|><nl>
    r.run();
  <|file_separator|>class InputMissingOverrideGoodAnnotation
{
  Runnable r = new Runnable() {

    /**
     * {@inheritDoc}
     */
    public void run() {// violation 'include.*@java.lang.Override.*when.*'@inheritDoc''
      Throwable t = new Throwable() {

        /**
         * {@inheritDoc}
         */
        public String toString() {// violation 'include.*@java.lang.Override.*when.*'@inheritDoc''
          return "junk";
        }
      };
    }
  };

  void doFoo(Runnable r) {
    r.run();
  }
}<|file_separator|><nl>
            System.out.println("foo");
        }
    }
<|file_separator|><nl>
            System.out.println("foo");
        }
    }<|file_separator|><nl>
        }
    }
<|file_separator|><nl>
    }

    public static void mainC(String aC[][]) // violation
    {
    <|file_separator|><nl>
        switch (a) {
            case 1:
            case 2:
            case 3:
            default:
        }
    <|file_separator|><nl>
        try {
            throw new Exception();
        } catch (Exception e) {
            throw new Exception();
        }
    }

    void exHandlerTest2()
    {
        try {
            throw new Exception();
        } catch (Exception e) {
            throw new Exception();
        }
    }

    void exHandlerTest3()
    {
        try {
            throw new Exception();
        } catch (Exception e) {
            throw new Exception();
        }
    }

    void exHandlerTest4()
    {
        try {
            throw new Exception();
        } catch (Exception e) {
            throw new Exception();
        }
    }

    void exHandlerTest5()
    {
        try {
            throw new Exception();
        } catch (Exception e) {
            throw new Exception();
        }
    }

    void exHandlerTest6()
    {
        try {
            throw new Exception();
        } catch (Exception e) {
            throw new Exception();
        }
    }

    void exHandlerTest7()
    {
        try {
            throw new Exception();
        } catch (Exception e) {
            throw new Exception();
        }
    }

    void exHandlerTest8()
    {
        try {
            throw new Exception();
        } catch (Exception e) {
            throw new Exception();
        }
    }

    void exHandlerTest9()
    {
        try {
            throw new Exception();
        } catch (Exception e) {
            throw new Exception();
        }
    }

    void exHandlerTest10()
    {
        try {
            throw new Exception();
        } catch (Exception e) {
            <nl>
        try {
            throw new Exception();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    void exHandlerTest2()
    {
        try {
            throw new Exception();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    void exHandlerTest3()
    {
        try {
            throw new Exception();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    void exHandlerTest4()
    {
        try {
            throw new Exception();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    void exHandlerTest5()
    {
        try {
            throw new Exception();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    void exHandlerTest6()
    {
        try {
            throw new Exception();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    void exHandlerTest7()
    {
        try {
            throw new Exception();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    void exHandlerTest8()
    {
        try {
            throw new Exception();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    void exHandlerTest9()
    {
        try {
            throw new Exception();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    void exHandlerTest10()
    {
        try {
            throw new Exception();
        } catch (Exception e) {
            <nl>
        try {
            throw new IOException();
        } catch (IOException e) {
            //This is expected
            // some comment
        }
    <|file_separator|><nl>
            System.out.println("Hello World");
        <|file_separator|><nl>
            System.out.println("Hello World");
        <|file_separator|><nl>
        switch (1) {
            case 1:
                break;
            case 2:
                break;
            case 3:
                break;
            default:
                break;
        }
    <|file_separator|><nl>
        switch (value) {
            default:
        }
    <|file_separator|>class InputNeedBracesTestSingleLineCaseDefault1.cs
<|fim_prefix|><|fim_suffix|>
    }
}<|fim_middle|>class InputNeedBracesTestSingleLineCaseDefault1 {
    int value;
    private void main() {
        switch (value) {
            default:
        }
    }
    private void main1() {
        switch (value) {
            default:
        }<|file_separator|>class InputNeedBracesTestSingleLineCaseDefault2.cs
<|fim_prefix|><|fim_suffix|>
    }
}<|fim_middle|>class InputNeedBracesTestSingleLineCaseDefault2 {
    int value;
    private void main() {
        switch (value) {
            default:
        }
    }
    private void main1() {
        switch (value) {
            default:
        }<|file_separator|>class InputNeedBracesTestSingleLineCaseDefault1.int.cs
<|fim_prefix|><|fim_suffix|>   }
    private void main1() {
        switch (value) {
            default:
        }
    }
}<|fim_middle|>class InputNeedBracesTestSingleLineCaseDefault1 {
    int value;
    private void main() {
        switch (value) {
            default:
        }
 <|file_separator|>class InputNeedBracesTestSingleLineCaseDefault1.int.cs
<|fim_prefix|><|fim_suffix|>   }
    private void main1() {
        switch (value) {
            default:
        }
    }
}<|fim_middle|>class InputNeedBracesTestSingleLineCaseDefault1 {
    int value;
    private void main() {
        switch (value) {
            default:
        }
 <|file_separator|>class InputNeedBracesTestSingleLineCaseDefault2.int.cs
<|fim_prefix|><|fim_suffix|>  }
    private void main1() {
        switch (value<nl>
        int mode = 0;
        switch (mode) {
            case 1:
                int x = 1;
                break;
            default :
                x = 0;
        }
    <|file_separator|>class InputRightCurlyTestSwitchCase1.java
<|fim_prefix|><|fim_suffix|>

    public static void method10() {
        int mode = 0;
        int x = 0;
        switch (mode) {
            case 0:
                if(0>9) {
                    x = 9;
                }
                break;
            case 80:
                x = 1;
                break;
        }
    }
}<|fim_middle|>class InputRightCurlyTestSwitchCase1 {

    public static void method0() {
        int mode = 0;
        switch (mode) {
            case 1:
                int x = 1;
                break;
            default :
                x = 0; } // violation '}' at column 24 should be alone on a line'
    }

    public static void method1() {
        int mode = 0;
        switch (mode) {
            case 1:
                int x = 1;
                break;
            default :
                x = 0;
        }
    }

    public static void method2() {
        int mode = 0;
        switch (mode) {
        default :
               int x = 0;
        }
    }

    public static void method3() {
        int mode = 0;
        switch (mode) { default : int x = 0; }
    }

    public static void method4() {
        int mode = 0;
        switch (mode) { default : int x =<nl>
        try (InputStream in = new FileInputStream("file.txt")) {
            int c = in.read();
        }
    <|file_separator|>class InputRightCurlyTestTryWithResourceSame2.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;

class InputRightCurlyTestTryWithResourceSame2 {
    void test() throws IOException {
        try (InputStream in = new FileInputStream("file.txt")) {
            int c = in.read();
        }
    }
}<|file_separator|><nl>
        param.equals(""); // violation 'left .* of .* equals'
    <|file_separator|><nl>
            return a == 1;
        <|file_separator|><nl>
        switch (i) {
            case 0:
                i++;
                /* comment */
                /* fall thru */
        }
    <|file_separator|>class InputFallThrough1.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>class InputFallThrough1 {
    void methodLastLine(int i) {
        while (true) {
            switch (i) {
                case 0:
                    i++;
                    /* block */ // comment
                    // fall thru
                case 1:
                    i++;
                    break;
                case 2:
                    i++;
                    /* comment */ /* fall thru */ /* comment */
                case 3: // violation 'Fall through from previous branch of the switch statement'
                    i--;
                    break;
            }
        }
    }

    void testLastCase(int i) {
        switch (i) {
            case 0:
                i++;
                /* comment */
                /* fall thru */
        }
    }

    void testLastCase2(int i) {
        switch (i) {
            case 0:
                i++;
                /* comment */ /* fall thru */ /* comment */
        }
    }
}<|file_separator|>class InputFallThrough2.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>class InputFallThrough2 {
    void methodLastLine(int i) {
        while (true) {
            switch (i) {
                case 0:
                    i++;
                    /* block */ // comment
                    // fall thru
                case 1:
                    i++;
                    break;
                case 2:
                    i++;
                    /* comment */ /* fall thru */ /* comment */
                case 3: // violation 'Fall through from previous branch of the switch statement'
                    i--;
                    break;
            }
        }
    <nl>
        switch (arg) {
            case "a":
                return 1;
            case "b":
                return 2;
            case "c":
                return 3;
            default:
                return 0;
        }
    <|file_separator|><nl>
        try {
            int a = 10;
            int b = 0;
            int c = a / b;
        } catch (ArithmeticException | ArrayIndexOutOfBoundsException e) {
            System.out.println("Exception caught");
        }
    <|file_separator|>class InputFinalLocalVariableMultiCatch.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class InputFinalLocalVariableMultiCatch {
    public void demo() throws Throwable {
        try {
            int a = 10;
            int b = 0;
            int c = a / b;
        } catch (ArithmeticException | ArrayIndexOutOfBoundsException e) {
            System.out.println("Exception caught");
        }
    }
}<|file_separator|><nl>
        System.out.println("foo");
    <|file_separator|><nl>
        this.prop = prop;
    <|file_separator|>class PropertySetter12
{
    private int prop;

    /** setter */
    public void setProp(int prop) // violation
    {
        this.prop = prop;
    }

    /** violation - incorrect method name */
    public void setprop(int prop) // violation
    {
        this.prop = prop;
    }

    /** violation - more than one parameter */
    public void setProp(int prop, int extra) // violation
    {
        this.prop = prop;
    }
}<|file_separator|>class PropertySetter11
<|fim_prefix|><|fim_suffix|>
    public void setProp(int prop, int extra) // violation
    {
        this.prop = prop;
    }
}<|fim_middle|>class PropertySetter11
{
    private int prop;

    /** setter */
    public void setProp(int prop) // violation
    {
        this.prop = prop;
    }

    /** violation - incorrect method name */
    public void setprop(int prop) // violation
    {
        this.prop = prop;
    }

    /** violation - more than one parameter */<|file_separator|>class PropertySetter10
<|fim_prefix|><|fim_suffix|>
    public void setProp(int prop, int extra) // violation
    {
        this.prop = prop;
    }
}<|fim_middle|>class PropertySetter10
{
    private int prop;

    /** setter */
    public void setProp(int prop) // violation
    {
        this.prop = prop;
    }

    /** violation - incorrect method name */
    public void setprop(int prop) // violation
    {
        this.prop = prop;
    }

    /** violation - more than one parameter */<|file_separator|>class PropertySetter14
<|fim_prefix|><|fim_suffix|><nl> // violation
    <|file_separator|>class InputIllegalThrowsTestDefault.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>import java.lang.RuntimeException;

public class InputIllegalThrowsTestDefault {
    public void methodOne() throws RuntimeException {
    }

    public void methodTwo() throws RuntimeException {
    }
}<|file_separator|><nl>
            return "MyNonAbstractClass";<|file_separator|><nl>
        return null;
    }

    @Override
    public HashMap<?, ?> bar(HashMap<?, ?> buffer) {
        return null;
    }

    @Override
    public HashMap<?, ?> bar(HashMap<?, ?> buffer, HashMap<?, ?> buffer2) {
        return null;
    }
}<|file_separator|><nl>} // ignore

    @Override
    public void foo(HashMap<?, ?> buffer) {} // ignore

    @Override
    public HashMap<?, ?> foo() {} // ignore

    @Override
    public void foo(HashMap<?, ?> buffer) {} // ignore

    @Override
    public HashMap<?, ?> foo() {} // ignore

    @Override
    public void foo(HashMap<?, ?> buffer) {} // ignore

    @Override
    public HashMap<?, ?> foo() {} // ignore
<|file_separator|><nl>
        int a = 10;
        int b = 20;
        int c = a + b;
    <|file_separator|><nl>
        int i = 1;
        while (i < 10) {
            if (i == 1) {
                i++;
                continue;
            }
            System.out.println(i);
            i++;
        }
    <|file_separator|><nl>
            int x = 1;
        <|file_separator|><nl> <|file_separator|><nl> <|file_separator|><nl> <|file_separator|>class InputMatchXpath2.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class InputMatchXpath2 {
    public void test() { } // violation

    public void foo() { } // violation

    public void correct() { }
}<|file_separator|><nl>
      try {
         throw new IOException();
      } catch (IOException e) {
      }
   <|file_separator|><nl>
        int a = 1;
        int b = 2;
        int c = 3;
        int d = 4;
        int e = 5;
        int f = 6;
        int g = 7;
        int h = 8;
        int i = 9;
        int j = 10;
        int k = 11;
        int l = 12;
        int m = 13;
        int n = 14;
        int o = 15;
        int p = 16;
        int q = 17;
        int r = 18;
        int s = 19;
        int t = 20;
        int u = 21;
        int v = 22;
        int w = 23;
        int x = 24;
        int y = 25;
        int z = 26;
        int aa = 27;
        int bb = 28;
        int cc = 29;
        int dd = 30;
        int ee = 31;
        int ff = 32;
        int gg = 33;
        int hh = 34;
        int ii = 35;
        int jj = 36;
        int kk = 37;
        int ll = 38;
        int mm = 39;
        int nn = 40;
        int oo = 41;
        int pp = 42;
        int qq = 43;
        int rr = 44;
        int ss = 45;
        int tt<nl>
        for(int n = 0,
            k = 1
            ; n<5
            ;
            n++, k--) { var1++; }
    <|file_separator|><nl>
        new RuntimeException() {
            public void run() {
                System.out.println("Hello");
            }
        }.run();
    <|file_separator|><nl>
        try {
            throw ex;
        } catch (Throwable ex) {
            exceptional(ex);
        }
    <|file_separator|><nl>
        Object plus = "" + id;
        Object minus = 1 - length;
        Object multi = 1 * length;
        Object div = 1 / length;
        Object mod = 1 % length;
        Object lt = 1 < length;
        Object gt = 1 > length;
        Object le = 1 <= length;
        Object ge = 1 >= length;
        Object equal = false == b;
        Object notEqual = false != b;
        Object sl = 1 << length;
        Object sr = 1 >> length;
        Object bsr = 1 >>> length;
        Object and = 1 & length;
        Object xor = 1 ^ length;
        Object bor = 1 | length;
        Object lor = false || b;
        Object land = false && b;

        Object fields = arr.length + length;
    <|file_separator|><nl>
        return Optional.of(number).filter(i -> {
            if (i > 0) return true;
            else return false;
        });
    }

    Optional<Integer> methodWithOneReturnWithLambdas(int number) {
        return Optional.of(number).filter(i -> {
            if (i > 0) return true;
            else return false;
        });
    <|file_separator|><nl>
        System.out.println("closeBlock");
    <|file_separator|><nl>
        try (InputStream inputStream = new FileInputStream("file.txt")) {
            // do something
        }
    <|file_separator|>class InputUnnecessarySemicolonInTryWithResourcesNoBraceAfterAllowed.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>class InputUnnecessarySemicolonInTryWithResourcesNoBraceAfterAllowed {

    void method() throws IOException {
        try (InputStream inputStream = new FileInputStream("file.txt")) {
            // do something
        }
    }
}<|file_separator|><nl>
                anotherVariable += 1;
            }
        };
        obj2.getClass();
    }
}<|file_separator|><nl>
        System.out.println("Hello");
    <|file_separator|><nl>
        int a = 1;
        int b = 2;
        int c = a + b;
    <|file_separator|><nl>
        // do something
    <|file_separator|>class InputDescendantTokenIllegalTokens1
{
    public void methodWithPreviouslyIllegalTokens()
    {
        // do something
    }

    public native void nativeMethod();
}<|file_separator|>class InputDescendantTokenIllegalTokens2
<|fim_prefix|><|fim_suffix|>
    }

    public native void nativeMethod();
}<|fim_middle|>class InputDescendantTokenIllegalTokens2
{
    public void methodWithPreviouslyIllegalTokens()
    {
        // do something<|file_separator|>class InputDescendantTokenIllegalTokens3
{
    public void methodWithPreviouslyIllegalTokens()
    {
        // do something
    }

    public native void nativeMethod();
}<|file_separator|>class InputDescendantTokenIllegalTokens5
{
    public void methodWithPreviouslyIllegalTokens()
    {
        // do something
    }

    public native void nativeMethod();
}<|file_separator|>class InputDescendantTokenIllegalTokens4
{
    public void methodWithPreviouslyIllegalTokens()
    {
        // do something
    }

    public native void nativeMethod();
}<|file_separator|><nl>
        try {
            System.currentTimeMillis();
        } catch (Exception e) { // violation 'Return from catch is not allowed'
            if (System.currentTimeMillis() == 0) {
                return; // return from if statement
            }
        }
    <|file_separator|>class ReturnFromCatch {
    public void foo() {
        try {
            System.currentTimeMillis();
        } catch (Exception e) { // violation 'Return from catch is not allowed'
            if (System.currentTimeMillis() == 0) {
                return; // return from if statement
            }
        }
    }

    public void bar() {
        try {
            System.currentTimeMillis();
        } catch (Exception e) { // violation 'Return from catch is not allowed'
            if (System.currentTimeMillis() == 0) {
                return; // return from if statement
            }
        }
    }
}<|file_separator|>class ReturnFromFinally {
    public void foo() {
        try {
            System.currentTimeMillis();
        } catch (Exception e) { // violation 'Return from finally is not allowed'
            if (System.currentTimeMillis() == 0) {
                return; // return from if statement
            }
        } finally {
            System.currentTimeMillis();
        }
    }

    public void bar() {
        try {
            System.currentTimeMillis();
        } catch (Exception e) { // violation 'Return from finally is not allowed'
            if (System.currentTimeMillis() == 0) {
                return; // return from if statement
            }
        } finally {
            System.currentTimeMillis();
        }
    }
}<|file_separator|>class ReturnFromFinallyWithReturn {
    public void foo() {
        try {
            System.<nl>
        try {
            System.currentTimeMillis();
        } finally {
            return;
        }
    <|file_separator|><nl>
        try {
            System.currentTimeMillis();
        } finally {
            return;
        }
    <|file_separator|>class InputDescendantTokenReturnFromFinally3 {
    public void foo() {
        try {
            System.currentTimeMillis();
        } finally {
            return;
        }
    }

    public void bar() {
        try {
            System.currentTimeMillis();
        } finally {
            return;
        }
    }
    public void thisNull() {
        boolean result = (this == null) || (null == this); // 2 violations
        boolean result2 = (this != null) && (null != this); // 2 violations
        boolean result3 = (this.getClass().getName()
            == String.valueOf(null == System.getProperty("abc")));
    }
}<|file_separator|>class InputDescendantTokenReturnFromFinally2 {
    public void foo() {
        try {
            System.currentTimeMillis();
        } finally {
            return;
        }
    }

    public void bar() {
        try {
            System.currentTimeMillis();
        } finally {
            return;
        }
    }
    public void thisNull() {
        boolean result = (this == null) || (null == this); // 2 violations
        boolean result2 = (this != null) && (null != this); // 2 violations
        boolean result3 = (this.getClass().getName()
            == String.valueOf(null == System.getProperty("abc")));
    }
}<|file_separator|>class InputDescendantTokenReturnFromFinally1 {
    public void foo() {
        try {
            System.currentTimeMillis();
        } finally {
            return;
        }
    }

    public void bar() {
        try {
            <nl>
            System.out.println("Paper");
        <|file_separator|><nl>
            throw new java.lang.Exception("test");
        <|file_separator|><nl>
    <|file_separator|>class InputThrowsCountCustomMaxCount2 {
    void method1() throws Exception
    {
    }

    void method2() throws AWTException
    {
    }

    void method3() throws Exception, AWTException, SQLException,
            FileNotFoundException, EOFException
    {
    }

    void method4() throws Exception, AWTException, SQLException,
            FileNotFoundException, EOFException
    {
    }

    void method5() throws Exception, AWTException, Throwable, SQLException, // violation
            FileNotFoundException, EOFException
    {
    }

    void method6() {
    }

    private void method7() throws Exception, AWTException, SQLException,
            FileNotFoundException, EOFException {
    }
}<|file_separator|>class InputThrowsCountCustomMaxCount3 {
    void method1() throws Exception
    {
    }

    void method2() throws AWTException
    {
    }

    void method3() throws Exception, AWTException, SQLException,
            FileNotFoundException, EOFException
    {
    }

    void method4() throws Exception, AWTException, SQLException,
            FileNotFoundException, EOFException
    {
    }

    void method5() throws Exception, AWTException, Throwable, SQLException, // violation
            FileNotFoundException, EOFException
    {
    }

    void method6() {
    }

    private void method7() throws Exception, AWTException, SQLException,
            FileNotFoundException, EOFException {
    }
}<|file_separator|><nl>return s.iterator();<|file_separator|>class InputVisibilityModifiersNullModifiers.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>class InputVisibilityModifiersNullModifiers {
    private final Set<Map.Entry<Integer,Integer>> s;
    public InputVisibilityModifiersNullModifiers(Set<Map.Entry<Integer,Integer>> s) {this.s = s;}
    public Iterator<Map.Entry<String,String>> iterator() {return s.iterator();}
}<|file_separator|><nl>
        mousePress(InputEvent.BUTTON1_MASK);
        delay();
    <|file_separator|><nl>
        return 1;
    <|file_separator|><nl>
        if (true) {
            String.CASE_INSENSITIVE_ORDER.equals("");
        }
        else {

        }
        /*
         comment
         */
        /*
         comment
         */
    <|file_separator|>class InputCommentsIndentationCommentIsAtTheEndOfBlockOne.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>class InputCommentsIndentationCommentIsAtTheEndOfBlockOne {

    void foo1() {
        if (true) {
            String.CASE_INSENSITIVE_ORDER.equals("");
        }
        else {

        }
        /*
         comment
         */
        /*
         comment
         */
    }
    void foo2() {
        if (true) {
            String.CASE_INSENSITIVE_ORDER.equals("");
        }
        else {

        }
        /*
         comment
         */
        /*
         comment
         */
    }
    void foo3() {
        if (true) {
            String.CASE_INSENSITIVE_ORDER.equals("");
        }
        else {

        }
        /*
         comment
         */
        /*
         comment
         */
    }
    void foo4() {
        if (true) {
            String.CASE_INSENSITIVE_ORDER.equals("");
        }
        else {

        }
        /*
         comment
         */
        /*
         comment
         */
    }
    void foo5() {
        if (true) {
            String.CASE_INSENSITIVE_ORDER.equals("");
        }
        else {

        }
        /*
         comment
         */
        /*
         comment
         */
    }
    void foo6() {
        if (true) {
            String.CASE_INSENS<nl>
        int a = 5, b = 3, v = 6;
        if (a == b
            && v == b || (a == 1
            && b == 1)) {
            // comment
        }
    <|file_separator|><nl>
        int a = 2;
        String s = "";
        switch (a) {
            case 1:
            case 2:
                // comment
                // comment
                foo1();
                // comment
            case 3:
                // comment
                // comment
                s.toString().toString().toString();
                // comment
            case 4:
                // comment
                // comment
                foo1();
                // comment
            default:
        }
    <|file_separator|>class InputCommentsIndentationInSwitchBlockTwo {

    private static void foo1() {
        if (true) {
            switch(1) {
                case 0:

                case 1:
                        // violation '.* incorrect .* level 24, expected is 20,.*same.* as line 19.'
                    int b = 10;
                default:
                 // comment
            }

        }
    }

    public void foo7() {
        int a = 2;
        String s = "";
        switch (a) {
            case 1:
            case 2:
                // comment
                // comment
                foo1();
                // comment
            case 3:
                // comment
                // comment
                s.toString().toString().toString();
                // comment
            case 4:
      // violation '.* incorrect .* level 6, expected is 12, 12, .* same .* as line 73, 75.'
            default:
        }
    }

    public void foo8() {
        int a = 2;
        String s = "";
        switch (a) {
            case 1:
            case 2:
                // comment
                // comment
                foo1<nl>
        return s1.equals(s2);
    <|file_separator|>class InputCommentsIndentationWithInMethodCallWithSameIndent.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>class InputCommentsIndentationWithInMethodCallWithSameIndent {
    String s1 = "ONE", s2 = "TWO", s3 = "THREE";
    private final boolean isEqualsOne = equals(
        // Some comment here
        s1,
        s2
        // ok
    );

    private final boolean isEqualsTwo = equals(
        // Some comment here
        s1,
        s2
      // violation '.* incorrect .* level 6, expected is 4, .* same .* as line 24.'
    );

    private final boolean isEqualsThree = equals(
        // Some comment here
        s1,
        s2
          // violation '.* incorrect .* level 10, expected is 4, .* same .* as line 31.'
    );

    private boolean equals(String s1, String s2) {
        return s1.equals(s2);
    }
}<|file_separator|><nl>} //indent:4 exp:4
} //indent:0 exp:0

<|file_separator|>class InputIndentation15Extensions //indent:0 exp:0
{ //indent:0 exp:0

} //indent:0 exp:0

enum Enum1 //indent:0 exp:0
{ //indent:0 exp:0
    A, B, C; //indent:4 exp:4
    Enum1() {} //indent:4 exp:4
    public String toString() {} //indent:4 exp:4
} //indent:0 exp:0

<|file_separator|><nl> //indent:2 exp:2
    return asBytes(0); //indent:4 exp:4
  } //indent:2 exp:2

  public byte[] asBytes(int offset) { //indent:2 exp:2
    return asBytes(offset, 0); //indent:4 exp:4
  } //indent:2 exp:2

  public byte[] asBytes(int offset, int length) { //indent:2 exp:2
    return asBytes(offset, length, 0); //indent:4 exp:4
  } //indent:2 exp:2

  public byte[] asBytes(int offset, int length, int capacity) { //indent:2 exp:2
    return asBytes(offset, length, capacity, 0); //indent:4 exp:4
  } //indent:2 exp:2

  public byte[] asBytes(int offset, int length, int capacity, int flags) { //indent:2 exp:2
    return asBytes(offset, length, capacity, flags, 0); //indent:4 exp:4
  } //indent:2 exp:2

  public byte[] asBytes(int offset, int length, int capacity, int flags, int size) { //indent:2 exp:2
    return asBytes(offset, length, capacity, flags, size, 0); //indent:4 exp:4
  } //indent:2 exp:2

  public byte[] asBytes(int offset, int length, int capacity, int flags, int size, int flags2) { //indent:2 exp:2
    return asBytes(offset, length, capacity, flags, size, flags2, 0); //indent:4 exp:4
  } //indent:2 exp:2

  public byte[] asBytes(int<nl> //indent:4 exp:4
    <|file_separator|>class InputIndentationDifficultAnnotations.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>class InputIndentationDifficultAnnotations { //indent:0 exp:0

    @DifficultAnnotation({ //indent:4 exp:4
        @MyType(value = Boolean.class, name = "boolean"), //indent:8 exp:8
        @MyType(value = String.class, name = "string") }) //indent:8 exp:8
    @SimpleAnnotation //indent:4 exp:4
    String foo = "foo"; //indent:4 exp:4

    @DifficultAnnotation({ //indent:4 exp:4
        @MyType(value = Boolean.class, name = "boolean"), //indent:8 exp:8
        @MyType(value = String.class, name = "string") }) //indent:8 exp:8
    @SimpleAnnotation //indent:4 exp:4
    void foo() { //indent:4 exp:4
    } //indent:4 exp:4
}<|file_separator|>class InputIndentationDifficultAnnotations.kt
<|fim_prefix|><|fim_suffix|>indent:4 exp:4
    void foo() { //indent:4 exp:4
    } //indent:4 exp:4
}<|fim_middle|>class InputIndentationDifficultAnnotations { //indent:0 exp:0

    @DifficultAnnotation({ //indent:4 exp:4
        @MyType(value = Boolean.class, name = "boolean"), //indent:8 exp:8
        @MyType(value = String.class, name = "string") }) //indent:8 exp:8
    @SimpleAnnotation //indent:4 exp:4
    String foo = "foo"; //<|file_separator|><nl> //indent:4 exp:4
    } //indent:4 exp:4

    public void method2() { //indent:4 exp:4
    } //indent:4 exp:4

    public void method3() { //indent:4 exp:4
    } //indent:4 exp:4

    public void method4() { //indent:4 exp:4
    } //indent:4 exp:4

    public void method5() { //indent:4 exp:4
    } //indent:4 exp:4

    public void method6() { //indent:4 exp:4
    } //indent:4 exp:4

    public void method7() { //indent:4 exp:4
    } //indent:4 exp:4

    public void method8() { //indent:4 exp:4
    } //indent:4 exp:4

    public void method9() { //indent:4 exp:4
    } //indent:4 exp:4

    public void method10() { //indent:4 exp:4
    } //indent:4 exp:4

    public void method11() { //indent:4 exp:4
    } //indent:4 exp:4

    public void method12() { //indent:4 exp:4
    } //indent:4 exp:4

    public void method13() { //indent:4 exp:4
    } //indent:4 exp:4

    public void method14() { //indent:4 exp:4
    } //indent:4 exp:4

    public void method15() { //indent:4 exp:4
    } //indent:4 exp:4

    public void method16() { //indent:4 exp:4
    } //indent:4 exp:4

<nl> //indent:2 exp:2
    IN: //indent:4 exp:4
    if (true) { //indent:4 exp:4
    } //indent:4 exp:4
  } //indent:2 exp:2

  void foooo() { //indent:2 exp:2
    IN: do {} while (true); //indent:4 exp:4
  } //indent:2 exp:2

  void foooo1() { //indent:2 exp:2
    IN: //indent:4 exp:4
    do {} while (true); //indent:4 exp:4
  <|file_separator|>class InputIndentationLabels2 { //indent:0 exp:0
  void foo() { //indent:2 exp:2
//    OUT: //indent:0 exp:0
    while (true) { //indent:4 exp:4
    } //indent:4 exp:4
  } //indent:2 exp:2

  void foo2() { //indent:2 exp:2
    positions: while (true) { //indent:4 exp:4
    } //indent:4 exp:4
  } //indent:2 exp:2

  void foo3() { //indent:2 exp:2
    OUT1: //indent:4 exp:4
    for (;;) { //indent:4 exp:4
      if (true){ //indent:6 exp:6
        break OUT1; //indent:8 exp:8
      } //indent:6 exp:6
    } //indent:4 exp:4
  } //indent:2 exp:2

  void foo4() { //indent:2 exp:2
    OUT1: for (;;) { //indent:4 exp:4
      if (true){ //indent:6 exp:6
        break OUT<nl> //indent:4 exp:4
		return (x) -> { //indent:8 exp:8
			return x; //indent:12 exp:12
		}; //indent:8 exp:8
	<|file_separator|>class InputIndentationLambda3 { //indent:0 exp:0
	public <T> Consumer<Integer> par(Consumer<Integer> f1, Consumer<Integer> f2) { //indent:4 exp:4
		return f2; //indent:8 exp:8
	} //indent:4 exp:4

	private void print(int i) { //indent:4 exp:4
	} //indent:4 exp:4

	public Consumer<Integer> returnFunctionOfLambda() { //indent:4 exp:4
		return (x) -> { //indent:8 exp:8
			return x; //indent:12 exp:12
		}; //indent:8 exp:8
	} //indent:4 exp:4

	public static <T> BinaryOperator<T> returnLambda() { //indent:4 exp:4
		return (t1, t2) -> { //indent:8 exp:8
			return t1; //indent:12 exp:12
		}; //indent:8 exp:8
	} //indent:4 exp:4

	class TwoParams { //indent:4 exp:4
		TwoParams(Consumer<Integer> c1, Consumer<Integer> c2) { //indent:8 exp:8
		} //indent:8 exp:8
	} //indent:4 exp:4

	public void makeTwoParams() { //indent:4 exp:4
		TwoParams t0 = new TwoParams( //indent:8 exp:8
				(x) -> print(x * 1),<nl> //indent:2 exp:2
    return true; //indent:4 exp:4
  <|file_separator|>class FirstFieldClassWithVeryVeryVeryLongName { //indent:0 exp:0

  public FirstFieldClassWithVeryVeryVeryLongName(String string) { //indent:2 exp:2

  } //indent:2 exp:2

  String getString(InputIndentationMembers instance, int integer) { //indent:2 exp:2
    return "String"; //indent:4 exp:4
  } //indent:2 exp:2

  int getInteger(InputIndentationMembers instance, String string) { //indent:2 exp:2
    return -1;   //indent:4 exp:4
  } //indent:2 exp:2

  boolean getBoolean(InputIndentationMembers instance, boolean flag) { //indent:2 exp:2
    return true; //indent:4 exp:4
  } //indent:2 exp:2

  FirstFieldClassWithVeryVeryVeryLongName getInstance() { //indent:2 exp:2
    return new FirstFieldClassWithVeryVeryVeryLongName("VeryLoooooooooo" //indent:4 exp:4
        + "oongString"); //indent:8 exp:8
  } //indent:2 exp:2
}<|file_separator|><nl> //indent:1 exp:1
        final Asset asset = Asset.get(assetId); //indent:2 exp:2
        if (asset != null) { //indent:3 exp:3
            asset.delete(); //indent:4 exp:4
        } //indent:5 exp:5
    <|file_separator|><nl> //indent:2 exp:2
    for (int i = 0; i < UNSECURED_PATHS.length; i++) { //indent:4 exp:4
      String path = UNSECURED_PATHS[i]; //indent:6 exp:6
      if (path.equals("/health")) { //indent:8 exp:8
        // do something
      } else if (path.equals("/version")) { //indent:8 exp:8
        // do something
      }
    }
  <|file_separator|>class InputIndentationValidArrayInitIndentOne { //indent:0 exp:0
  private static final String[] UNSECURED_PATHS = { //indent:2 exp:2
    "/health", //indent:4 exp:4
    "/version", //indent:4 exp:4
  }; //indent:2 exp:2

  int[] array3 = new int[] { //indent:2 exp:2
    1, //indent:4 exp:4
    2, //indent:4 exp:4
    3 //indent:4 exp:4
  }; //indent:2 exp:2

  void test() { //indent:2 exp:2
    for (int i = 0; i < UNSECURED_PATHS.length; i++) { //indent:4 exp:4
      String path = UNSECURED_PATHS[i]; //indent:6 exp:6
      if (path.equals("/health")) { //indent:8 exp:8
        // do something
      } else if (path.equals("/version")) { //indent:8 exp:8
        // do something
      }
    }
  } //indent:2 exp:2
}<|file_separator|>class InputIndentationValidArrayInitIndentThree { //indent:0 exp:0
  <nl>}

    /** {@customTag} */ // ok
    void customTag3() {}

    /** {@customTag} */ // ok
    void customTag4() {}

    /** {@customTag} */ // ok
    void customTag5() {}

    /** {@customTag} */ // ok
    void customTag6() {}

    /** {@customTag} */ // ok
    void customTag7() {}

    /** {@customTag} */ // ok
    void customTag8() {}

    /** {@customTag} */ // ok
    void customTag9() {<|file_separator|><nl>
    <|file_separator|><nl>}
    }

    public class PackageOuter {
        public PackageInner pi;
        protected PackageInner pi2;
        PackageInner pi3;
        private PackageInner pi4;

        public void foo() {
            pi.i1 = 1;
            pi.i2 = 2;
            pi.i3 = 3;
            pi.i4 = 4;
            pi.foo1();
            pi.foo2();
            pi.foo3();
            pi.foo4();
        <|file_separator|><nl> // ok
        return new Thread() {
            @Override
            public void run() {
                System.out.println("Hello");
            }
        };
    }
<|file_separator|><nl>
        if (x > 0) {
            // violation below 'Expected @throws tag for 'UnsupportedOperationException'.'
            throw new UnsupportedOperationException("");
        }
        if (x < 0) {
            // violation below 'Expected @throws tag for 'IllegalArgumentException'.'
            throw new IllegalArgumentException("");
        }
    <|file_separator|><nl>}<|file_separator|><nl>}

    // violation below 'Javadoc has empty description section'
    /**
     * @param a A parameter
     */
    public void method20(String a) {}

    // violation below 'Javadoc has empty description section'
    /**
     * @param a A parameter
     */
    public void method21(String a) {}

    // violation below 'Javadoc has empty description section'
    /**
     * @param a A parameter
     */
    public void method22(String a) {}

    // violation below 'Javadoc has empty description section'
    /**
     * @param a A parameter
     */
    public void method23(String a) {<|file_separator|><nl>}

    /**
     * @param a A parameter
     * @param b Another parameter
     */
    public void method18(String a, String b) {<|file_separator|><nl>
        return false;
    }

    /**
     * Javadoc.
     *
     * @param x this line is normal
     * {@code this} line is wrongly indented // violation
     */
    public void multipleLines3(int x) {
        // do stuff
    <|file_separator|><nl>
                System.identityHashCode("click");
            <|file_separator|><nl>
        return 666;
    <|file_separator|>class InputMissingJavadocMethodSetterGetter3 {

    private int mNumber;

    public void setNumber(final int number) throws Exception {
        mNumber = number; // violation above 'Missing a Javadoc comment'
    }

    public int Cost1() // violation 'Missing a Javadoc comment'
    {
        return 666;
    }

    public int getCost1(int forMe) // violation 'Missing a Javadoc comment'
    {
        return 666;
    }
}<|file_separator|>class InputMissingJavadocMethodSetterGetter1 {

    private int mNumber;

    public void setNumber(final int number) throws Exception {
        mNumber = number; // violation above 'Missing a Javadoc comment'
    }

    public int Cost1() // violation 'Missing a Javadoc comment'
    {
        return 666;
    }
}<|file_separator|>class InputMissingJavadocMethodSetterGetter2 {

    private int mNumber;

    public void setNumber(final int number) throws Exception {
        mNumber = number; // violation above 'Missing a Javadoc comment'
    }

    public int Cost1() // violation 'Missing a Javadoc comment'
    {
        return 666;
    }

    public int getCost1(int forMe) // violation 'Missing a Javadoc comment'
    {
        return 666;
    }
}<|file_separator|><nl>
    <|file_separator|>class InputMissingJavadocMethodsNotSkipWritten.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>/**
 * Description.
 *
 * @param BAD
 *            This param doesn't exist.
 */
public void InputMissingJavadocMethodsNotSkipWritten() {
}

/**
 * Description.
 *
 * @param BAD
 *            This param doesn't exist.
 */
public void test() {
}

/** Description. */
public void test2() {
}

/** Description. */
public String test3(int a) throws Exception {
    return "";
}<|file_separator|><nl>
        throw new IOException("to make compiler happy");
    <|file_separator|>class InputMissingJavadocTypeTags1Two // violation
{
    /**
     * Documenting different causes for the same exception
     * in separate tags is OK (bug 540384).
     *
     * @throws java.io.IOException if A happens
     * @throws java.io.IOException if B happens
     **/
    void method15()
       throws java.io.IOException
    {
    }

    //**********************************************************************/
    // Method Name: method16
    /**
     * handle the case of an elaborate header surrounding javadoc comments
     *
     * @param aOne valid parameter content
     */
    //**********************************************************************/
    void method16(int aOne)
    {
    }


    /**
     * @throws ThreadDeath although bad practice, should be silently ignored
     * @throws ArrayStoreException another r/t subclass
     * @throws IllegalMonitorStateException should be told to remove from throws
     */
    void method17()
        throws IllegalMonitorStateException
    {
    }

    /**
     * declaring the imported version of an Exception and documenting
     * the full class name is OK (bug 658805).
     * @throws java.io.IOException if bad things happen.
     */
    void method18()
        throws IOException
    {
        throw new IOException("to make compiler happy");
    }

    /**
     * reverse of bug 658805.
     * @throws IOException if bad things happen.
     */
    void method19()
        throws java.io.IOException
    {
        throw new IOException("to make compiler happy");
    }

    /**<nl>
        return false;
    <|file_separator|><nl>
    <|file_separator|><nl>
        return 0;
    <|file_separator|><nl>
    <|file_separator|><nl>
    <|file_separator|><nl>
        if (true) {
            if (true) {
                if (true) {
                    if (true) {
                        if (true) {
                            if (true) {
                                if (true) {
                                    if (true) {
                                        if (true) {
                                            if (true) {
                                                if (true) {
                                                    if (true) {
                                                        if (true) {
                                                            if (true) {
                                                                if (true) {
                                                                    if (true) {
                                                                        if (true) {
                                                                            if (true) {
                                                                                if (true) {
                                                                                    if (true) {
                                                                                        if (true) {
                                                                                            if (true) {
                                                                                                if (true) {
                                                                                                    if (true) {
                                                                                                        if (true) {
                                                                                                            if (true) {
                                                                                                                if (true) {
                                                                                                                    if (true) {
                                                                                                                        if (true) {
                                                                                                                            if (true) {
                                                                                                                                if (true) {
                                                                                                                                    if (true) {
                                                                                                                                        if (true) {
                                                                                                                                            if (true) {
                                                                                                                                                if (true) {
                                                                                                                                                    if (true) {
                                                                                                                                                        if (true) {
                                                                                                                                                            if (true) {
                                                                                                                                                                if (true) {
                                                                                                                                                                    if (true) {
                                                                                                                                                                        if (true) {
                                                                                                                                                                            if (true) {
                                                                                                                                                                                <nl>
        throw new NamingException();
    <|file_separator|><nl>
        // ...
    <|file_separator|>class InputThrows.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>class InputThrows { // violation

    public void get() throws NamingException, IllegalArgumentException {
        // ...
    }
}<|file_separator|><nl>
    }

    private final void methodPrivateFinal() {
    }

    private static void methodPrivateStatic() {
    }

    private static final void methodPrivateStaticFinal() {
    }

    private static void methodPrivateStatic() {
    }

    private static final void methodPrivateStaticFinal() {
    }

    private static void methodPrivateStatic() {
    }

    private static final void methodPrivateStaticFinal() {
    }

    private static void methodPrivateStatic() {
    }

    private static final void methodPrivateStaticFinal() {
    }

    private static void methodPrivateStatic() {
    }

    private static final void methodPrivateStaticFinal() {
    }

    private static void methodPrivateStatic() {
    }

    private static final void methodPrivateStaticFinal() {
    }

    private static void methodPrivateStatic() {
    }

    private static final void methodPrivateStaticFinal() {
    }

    private static void methodPrivateStatic() {
    }

    private static final void methodPrivateStaticFinal() {
    }

    private static void methodPrivateStatic() {
    }

    private static final void methodPrivateStaticFinal() {
    }

    private static void methodPrivateStatic() {
    }

    private static final void methodPrivateStaticFinal() {
    }

    private static void methodPrivateStatic() {
    }

    private static final void methodPrivateStaticFinal() {
    }

    private static void methodPrivateStatic() {
    }

    private static final void methodPrivateStaticFinal() {
    }

    private static void methodPrivateStatic() {
    }

    private static final void methodPrivateStaticFinal() {
    }

    private static void methodPrivateStatic() {
    }

    private static final void method<nl>
                return str.equals("test");
            <|file_separator|><nl>
    <|file_separator|><nl>
                System.out.println("marazmaticMETHODName");
            <|file_separator|>class WellNamedFACTORY.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class WellNamedFACTORY { // violation
            public void marazmaticMETHODName() {
                System.out.println("marazmaticMETHODName");
            }
        }<|file_separator|><nl>
        try (final Lock lock = LOCK) {
            // do something
        }
    <|file_separator|><nl>
        return code;
    }
}<|file_separator|><nl>}
}

class InputOuterTypeFilename15Extensions
{
    public static void Main()
    {
        Enum1 e = Enum1.A;
        Console.WriteLine(e);
    }
}<|file_separator|><nl>
        Boolean x = new Boolean(true);
        Boolean[] y = new Boolean[]{Boolean.TRUE, Boolean.FALSE};
    <|file_separator|><nl>
        try {
            throw new Exception();
        } catch (Exception e) {
            // do something
        }
    }

    void test()
    {
        // instantiation of classes in the same package
        Object o1 = new InputBraces();
        Object o2 = new InputModifier();
        // classes in another package with .* import
        ByteArrayOutputStream s = new ByteArrayOutputStream();
        File f = new File("/tmp");
        // classes in another package with explicit import
        Dimension dim = new Dimension();
        Color col = new Color(0, 0, 0);
    <|file_separator|><nl>
        try {
            throw new Exception();
        } catch (Exception e) {
            // do something
        }
    }

    void test()
    {
        // test
        int a = 1;
        int b = 2;
        int c = 3;
        int d = 4;
        int e = 5;
        int f = 6;
        int g = 7;
        int h = 8;
        int i = 9;
        int j = 10;
        int k = 11;
        int l = 12;
        int m = 13;
        int n = 14;
        int o = 15;
        int p = 16;
        int q = 17;
        int r = 18;
        int s = 19;
        int t = 20;
        int u = 21;
        int v = 22;
        int w = 23;
        int x = 24;
        int y = 25;
        int z = 26;
        int aa = 27;
        int ab = 28;
        int ac = 29;
        int ad = 30;
        int ae = 31;
        int af = 32;
        int ag = 33;
        int ah = 34;
        int ai = 35;
        int aj = 36;
        int ak = 37;
        int al = 38;
        int am = 39;
        int an = 40;
        int ao = 4<nl>
        /* comment before text */int z;
        /* int y */int y/**/;
    <|file_separator|>class InputRegexpTrailingComment11 { // ok
    int i; // don't use trailing comments :)
    // it fine to have comment w/o any statement
    /* good c-style comment. */
    int j; /* bad c-style comment. */
    void method1() {
        /* comment before text */int z;
        /* int y */int y/**/;
    } // we should allow this
    /*
      Let's check multi-line comments.
    */
    /* c-style */ // cpp-style
    /* c-style 1 */ /*c-style 2 */

    void method2(long ms /* we should ignore this */) {
        /* comment before text */int z;
        /* int y */int y/**/;
    }

    /**
     * comment with trailing space
     */
    final static public String NAME="Some Name"; // NOI18N
}<|file_separator|>class InputRegexpTrailingComment12 { // ok
    int i; // don't use trailing comments :)
    // it fine to have comment w/o any statement
    /* good c-style comment. */
    int j; /* bad c-style comment. */
    void method1() {
        /* comment before text */int z;
        /* int y */int y/**/;
    } // we should allow this
    /*
      Let's check multi-line comments.
    */
    /* c-style */ // cpp-style
    /* c-style 1 */ /*c-style 2 */

    void method2(long ms /* we should ignore this */) {
        /* comment before text */int z;
        /* int<nl> // violation below
// abc - violation
// def
// abc
    <|file_separator|><nl>
        Boolean x = new Boolean(true);
        Boolean[] y = new Boolean[]{Boolean.TRUE, Boolean.FALSE};
    }

    /** test **/
    private static final long IGNORE = 666l + 666L;

    /** test **/
    private static final long IGNORE = 666l + 666L;

    /** test **/
    private static final long IGNORE = 666l + 666L;

    /** test **/
    private static final long IGNORE = 666l + 666L;

    /** test **/
    private static final long IGNORE = 666l + 666L;

    /** test **/
    private static final long IGNORE = 666l + 666L;

    /** test **/
    private static final long IGNORE = 666l + 666L;

    /** test **/
    private static final long IGNORE = 666l + 666L;

    /** test **/
    private static final long IGNORE = 666l + 666L;

    /** test **/
    private static final long IGNORE = 666l + 666L;

    /** test **/
    private static final long IGNORE = 666l + 666L;

    /** test **/
    private static final long IGNORE = 666l + 666L;

    /** test **/
    private static final long IGNORE = 666l + 666L;

    /** test **/
    private static final long IGNORE = 666l + 666L;

    /** test **/
<nl>
        try {
            // no exception
        } catch (Exception e) {
            // no exception
        }
    <|file_separator|><nl>
        try {
            throw new Exception();
        } catch (Exception e) {
            // do nothing
        }
    }

    void test()
    {
        // instantiation of classes in the same package
        Object o1 = new InputBraces();
        Object o2 = new InputModifier();
        // classes in another package with .* import
        ByteArrayOutputStream s = new ByteArrayOutputStream();
        File f = new File("/tmp");
        // classes in another package with explicit import
        Dimension dim = new Dimension();
        Color col = new Color(0, 0, 0);
    <|file_separator|><nl>
        // comment before text
        int z;
        // int y
        int y/**/;
    <|file_separator|><nl>
        // we should ignore this
    <|file_separator|><nl>
        return "InputLineLengthLongImportStatements";
    <|file_separator|><nl>
        // a line
        // a line
        // a line
        // a line
        // a line
        // a line
        // a line
        // a line
        // a line
        // a line
        // a line
        // a line
        // a line
        // a line
        // a line
        // a line
        // a line
        // a line
    <|file_separator|><nl>
            System.out.println("Hello World");
        <|file_separator|><nl>
        if (this.optionProperty == null) {
            throw new InputEmptyForIteratorPadToCheckUppercaseFunctionInOptionProperty();
        }
    <|file_separator|><nl>
        int number = 0;
        return 0;
    <|file_separator|><nl>
        String s = "sas"; // violation ''VARIABLE_DEF' has more than 1 empty lines before.'
    <|file_separator|><nl>
        new <@A Inner> @A Inner<@A Inner>(); // violation, ''>' is followed by whitespace.'
    }<|file_separator|><nl>
  }
}
<|file_separator|><nl>
            return new Integer[i][j][];
        <|file_separator|><nl>
        for (int i = 0; i < 10; i++) {
            if (i == 0) {
                continue;
            }
        }
    <|file_separator|><nl>
        int x
            = 0; //violation when checking assignment operators with EOL wrap option
        int y =
            0;
    <|file_separator|><nl>
        // no whitespace before ellipses
    }

    public static void testNoWhitespaceAfterEllipses(String ... args) {
        // no whitespace after ellipses
    }

    public static void testNoWhitespaceBeforeParenPad(String ... args) {
        // no whitespace before paren pad
    }

    public static void testNoWhitespaceAfterParenPad(String ... args) {
        // no whitespace after paren pad
    }

    public static void testNoWhitespaceBeforeParenPad(String ... args) {
        // no whitespace before paren pad
    }

    public static void testNoWhitespaceAfterParenPad(String ... args) {
        // no whitespace after paren pad
    }

    public static void testNoWhitespaceBeforeParenPad(String ... args) {
        // no whitespace before paren pad
    }

    public static void testNoWhitespaceAfterParenPad(String ... args) {
        // no whitespace after paren pad
    }

    public static void testNoWhitespaceBeforeParenPad(String ... args) {
        // no whitespace before paren pad
    }

    public static void testNoWhitespaceAfterParenPad(String ... args) {
        // no whitespace after paren pad
    }

    public static void testNoWhitespaceBeforeParenPad(String ... args) {
        // no whitespace before paren pad
    }

    public static void testNoWhitespaceAfterParenPad(String ... args) {
        // no whitespace after paren pad
    }

    public static void testNoWhitespaceBeforeParenPad(String ... args) {
        // no whitespace before paren pad
    }

    public static void testNoWhitespaceAfterParenPad(String ... args) {
        // no whitespace after paren pad
    }

    public static void testNoWhitespaceBeforeParenPad(String ... args) {
        // no whitespace before paren pad<nl>
        java.util.function.Consumer a = (o) -> { o.toString(); }; // ok

        java.util.function.Consumer b = o -> { o.toString(); }; // ok

        java.util.function.Consumer c = ( o ) -> { o.toString(); }; // ok

        java.util.function.Consumer d = (o ) -> { o.toString(); }; // ok

        java.util.function.Consumer e = ( o) -> { o.toString(); }; // ok

        java.util.stream.Stream.of().forEach(( o ) -> o.toString()); // ok

        java.util.stream.Stream.of().forEach(( Object o ) -> o.toString()); // ok

        java.util.stream.Stream.of().forEach(o -> o.toString( )); // 2 violations
    <|file_separator|><nl>
        for ( int i = 0; i < 10; i++ )
        {
            System.out.println ( i );
        }
    <|file_separator|><nl>

    <|file_separator|><nl>
        int i = 0;
        int j = 0;
        int k = 0;
    <|file_separator|><nl>
        if (s.substring(0).equals("da")) {
            if ("".isEmpty()) {
            } else {
            }
        }
    <|file_separator|><nl>
        do {
            // do something
        } while (condition());
    <|file_separator|>class InputWhitespaceAfterFor {

    void testFor() {
        for (int i = 0; i < 10; i++) {
            // do something
        }
    }
}<|file_separator|>class InputWhitespaceAfterIf {

    void testIf() {
        if (true) {
            // do something
        }
    }
}<|file_separator|>class InputWhitespaceAfterWhile {

    void testWhile() {
        while (true) {
            // do something
        }
    }
}<|file_separator|>class InputWhitespaceAfterSwitch {

    void testSwitch() {
        switch (1) {
            case 1:
                // do something
                break;
            case 2:
                // do something
                break;
        }
    }
}<|file_separator|>class InputWhitespaceAfterTry {

    void testTry() {
        try {
            // do something
        } catch (Exception e) {
            // do something
        }
    }
}<|file_separator|>class InputWhitespaceAfterCatch {

    void testCatch() {
        try {
            // do something
        } catch (Exception e) {
            // do something
        }
    }
}<|file_separator|>class InputWhitespaceAfterElse {

    void testElse() {
        if (true) {
            // do something
        } else {
            // do something
        }
    }
}<|file_separator|>class InputWhitespaceAfterForIn {

    void testForIn() {
        for (int i in [1, 2, 3]) {
            // do something
        }
    }
}<|file_separator|>class InputWhitespaceAfterForOf {

    void testForOf() {
        for (int i of [1, 2,<nl>
        int a = 1;
        int b = 2;
        int c = 3;
        int d = 4;
        int e = 5;
        int f = 6;
        int g = 7;
        int h = 8;
        int i = 9;
        int j = 10;
        int k = 11;
        int l = 12;
        int m = 13;
        int n = 14;
        int o = 15;
        int p = 16;
        int q = 17;
        int r = 18;
        int s = 19;
        int t = 20;
        int u = 21;
        int v = 22;
        int w = 23;
        int x = 24;
        int y = 25;
        int z = 26;
    <|file_separator|><nl>
        var x = 1;
        var y = 2;
        var z = 3;
        var w = 4;
        var t = 5;
        var u = 6;
        var v = 7;
        var s = 8;
        var r = 9;
        var q = 10;
        var p = 11;
        var o = 12;
        var n = 13;
        var m = 14;
        var l = 15;
        var k = 16;
        var j = 17;
        var i = 18;
        var h = 19;
        var g = 20;
        var f = 21;
        var e = 22;
        var d = 23;
        var c = 24;
        var b = 25;
        var a = 26;
        var aa = 27;
        var aaa = 28;
        var aaaa = 29;
        var aaaaa = 30;
        var aaaaaa = 31;
        var aaaaaaa = 32;
        var aaaaaaaa = 33;
        var aaaaaaaaa = 34;
        var aaaaaaaaaa = 35;
        var aaaaaaaaaaa = 36;
        var aaaaaaaaaaaa = 37;
        var aaaaaaaaaaaaa = 38;
        var aaaaaaaaaaaaaa = 39;
        var aaaaaaaaaaaaaaa = 40;
        var aaaaaaaaaaaaaaaa = 41;
        var aaaaaaaaaaaaaaaaa = 42;
        var aaaaaaaaaaaaaaaaaa<nl>
        String s = "a";
        switch (s) {
            case "a":
                System.out.println("a");
                break;
            case "b":
                System.out.println("b");
                break;
            default:
                System.out.println("default");
        }
    <|file_separator|><nl>
            return null;
        }
    }
<|file_separator|><nl>
        int w = 1;
    <|file_separator|><nl>
        test.doSmth();
    <|file_separator|><nl>
                System.out.println("close");
            }
        };
        public final AutoCloseable finalField2 = new AutoCloseable() {
            @Override
            public void close() throws Exception {
                System.out.println("close");
            <|file_separator|><nl>
				return "InputMainSuppressionsStringPrinter";
			<|file_separator|><nl>

    <|file_separator|><nl>
        final String[] expected = {
            "1: " + getCheckMessage(MSG_KEY_NO_CODE),
        };

        verifyWithInlineConfigParser(getPath("Example2.java"), expected);
    }

    @Test
    public void testExample3() throws Exception {
        final String[] expected = {
            "1: " + getCheckMessage(MSG_KEY_NO_CODE),
        };

        verifyWithInlineConfigParser(getPath("Example3.java"), expected);
    <|file_separator|><nl>
        return "OrderedPropertiesCheckExamples";<|file_separator|><nl>
        final String[] expected = {
            "31:3: " + getCheckMessage(MSG_KEY_ANNOTATION_LOCATION_ALONE, "SuppressWarnings"),
            "33:3: " + getCheckMessage(MSG_KEY_ANNOTATION_LOCATION_ALONE, "SuppressWarnings"),
            "35:12: " + getCheckMessage(MSG_KEY_ANNOTATION_LOCATION_ALONE, "Mock"),
        };

        verifyWithInlineConfigParser(getPath("Example3.java"), expected);
    <|file_separator|><nl>
        final String[] expected = {
            "19:16: " + getCheckMessage(MSG_KEY_BLOCK_EMPTY, "if"),
        };

        verifyWithInlineConfigParser(getPath("Example1.java"), expected);
    <|file_separator|><nl>
        check("example1.xml");
    <|file_separator|><nl>
        check("example1.java", "1");
    <|file_separator|><nl>
        assertCheck("example1.java", "No trailing comma in array initialization");
    <|file_separator|><nl>
        assertCheck("example1.java", "NoEnumTrailingCommaCheck.xml");
    <|file_separator|><nl>
        return "unnecessary-semicolon-after-outer-type-declaration-check-examples";
    <|file_separator|><nl>
        return "unnecessary-semicolon-in-try-with-resources-check-examples";
    <|file_separator|><nl>
        check("example1.xml", "example1.java");
    <|file_separator|><nl>
        final String[] expected = {

        };

        verifyWithInlineConfigParser(getPath("Example2.txt"), expected);
    <|file_separator|><nl>
        assertCheck("example1.xml", "example1.java");
    <|file_separator|><nl>
        final String[] expected = {

        };

        verifyWithInlineConfigParser(getPath("Example2.txt"), expected);
    <|file_separator|><nl>
        final String[] expected = {
            "19:12: " + getCheckMessage(MSG_KEY, "."),
        };

        verifyWithInlineConfigParser(getPath("Example1.java"), expected);
    <|file_separator|><nl>
        final String[] expected = {

        };

        verifyWithInlineConfigParser(getPath("Example2.txt"), expected);
    <|file_separator|><nl>
        final String[] expected = {

        };

        verifyWithInlineConfigParser(getPath("Example10.txt"), expected);
    }

    @Test
    public void testExample11() throws Exception {
        final String[] expected = {

        };

        verifyWithInlineConfigParser(getPath("Example11.txt"), expected);
    }

    @Test
    public void testExample12() throws Exception {
        final String[] expected = {

        };

        verifyWithInlineConfigParser(getPath("Example12.txt"), expected);
    }

    @Test
    public void testExample13() throws Exception {
        final String[] expected = {

        };

        verifyWithInlineConfigParser(getPath("Example13.txt"), expected);
    }

    @Test
    public void testExample14() throws Exception {
        final String[] expected = {

        };

        verifyWithInlineConfigParser(getPath("Example14.txt"), expected);
    }

    @Test
    public void testExample15() throws Exception {
        final String[] expected = {

        };

        verifyWithInlineConfigParser(getPath("Example15.txt"), expected);
    }

    @Test
    public void testExample16() throws Exception {
        final String[] expected = {

        };

        verifyWithInlineConfigParser(getPath("Example16.txt"), expected);
    }

    @Test
    public void testExample17() throws Exception {
        final String[] expected = {

        };

        verifyWithInlineConfigParser(getPath("Example17.txt"), expected);
    }

    @Test
    public void testExample18() throws Exception {
        final String[] expected = {

        };

        verifyWithInline<nl>
    return 1;
  <|file_separator|><nl>
    System.out.println("Hello World");
  <|file_separator|><nl>
    for (int i = 0; i < 10; i++) {
      // do nothing
    }
  <|file_separator|><nl>
    try {
      throw new RuntimeException();
    } catch (RuntimeException o) {
    } // violation above
  <|file_separator|><nl>
    try {
      throw new RuntimeException();
    } catch (RuntimeException myException) {
    }
  <|file_separator|><nl>
    bar();
  <|file_separator|>class Example3.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class Example3 {
  public void test() {
    bar();
  }

  private void bar() {
  }
}<|file_separator|><nl>
    if (parameter <= 0 ) {
      throw new IllegalArgumentException("A positive value is expected");
    }
    parameter -= 2;  // violation
    return parameter;
  }
}

class Example2 {
  int methodOne(int parameter) {
    if (parameter <= 0 ) {
      throw new IllegalArgumentException("A positive value is expected");
    }
    parameter -= 2;  // violation
    return parameter;
  }

  int methodTwo(int parameter) {
    if (parameter <= 0 ) {
      throw new IllegalArgumentException("A positive value is expected");
    }
    parameter -= 2;  // violation
    return parameter;
  <|file_separator|><nl>
    return (SuperCloneB) super.clone();
  <|file_separator|>class SuperCloneA {
  private int a;

  // violation below, "Method 'clone' should call 'super.clone'."
  public SuperCloneA clone() {
    return (SuperCloneA) super.clone();
  }
}<|file_separator|><nl>
    System.out.println(CURRENT_COUNTER); // OK, only definitions are checked
  <|file_separator|>class Example1.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>class Example1 {
  int CURRENT_COUNTER; // OK, camel case
  static int GLOBAL_COUNTER;
  final Set<String> stringsFOUND = new HashSet<>(); // OK, final is ignored

  public void printCOUNTER() {
    System.out.println(CURRENT_COUNTER); // OK, only definitions are checked
  }
  void incrementCOUNTER() {
    CURRENT_COUNTER++; // OK, only definitions are checked
  }
  static void incrementGLOBAL() {
    GLOBAL_COUNTER++; // OK, only definitions are checked
  }
}<|file_separator|><nl>}
  public void Example4(int i) {<|file_separator|>class Example2.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class Example2 {
  public Example2() {}
  public void Example2() {}
  public void Example2(int i) {} // violation
}<|file_separator|>class Example3.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class Example3 {
  public Example3() {}
  public void Example3() {}
  public void Example3(int i) {} // violation
}<|file_separator|><nl>
    System.out.println("Hello World");
  <|file_separator|><nl>
    i = 10;
    x = 20;
  <|file_separator|><nl>
    i = 10;
  <|file_separator|><nl>}
  void method3() {<|file_separator|><nl>}
  void method3() {<|file_separator|>class Example1.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>class Example1 {
  int var1 = 1;
  int var2 = 2;
  int var3 = 3;
  int var4 = 4;
  int var5 = 5;
  int var6 = 6;
  int var7 = 7;
  int var8 = 8;
  int var9 = 9;
  int var10 = 10;
  int var11 = 11;
  int var12 = 12;
  int var13 = 13;
  int var14 = 14;
  int var15 = 15;
  int var16 = 16;
  int var17 = 17;
  int var18 = 18;
  int var19 = 19;
  int var20 = 20;
  int var21 = 21;
  int var22 = 22;
  int var23 = 23;
  int var24 = 24;
  int var25 = 25;
  int var26 = 26;
  int var27 = 27;
  int var28 = 28;
  int var29 = 29;
  int var30 = 30;
  int var31 = 31;
  int var32 = 32;
  int var33 = 33;
  int var34 = 34;
  int var35 = 35;
  int var36 = 36;<nl>
    int a = 10;
    int b = 20;
    int c = a + b;
    print(c);
  <|file_separator|><nl> // violation above 'void', should be on a new line
  <|file_separator|>class Example1.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>class Example1 {
  int a,
    b; // violation above 'int', should be on a new line

  void foo(int a,
                int b) { // violation above 'void', should be on a new line
  }

  void bar(int p
                , int q) { // OK, because it is on a new line
  }
}<|file_separator|>class Example2.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>class Example2 {
  int a,
    b; // violation above 'int', should be on a new line

  void foo(int a,
                int b) { // violation above 'void', should be on a new line
  }

  void bar(int p
                , int q) { // OK, because it is on a new line
  }
}<|file_separator|><nl> // violation 'Use a single space'
    return 1; // violation 'Use a single space'
  <|file_separator|><nl>
    int x = 10;
    if (x > 0) {
      int y = 100;
      x = y;
    }
    y = x;
  <|file_separator|>class Example1.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>class Example1 {
  int x = 10;
  void example() {
    int y = 100;
    x = y;
  }
}<|file_separator|>class Example2.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>class Example2 {
  int x = 10;
  void example() {
    int y = 100;
    x = y;
  }
}<|file_separator|>class Example3.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>class Example3 {
  int x = 10;
  void example() {
    int y = 100;
    x = y;
  }
}<|file_separator|>class Example4.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>class Example4 {
  int x = 10;
  void example() {
    int y = 100;
    x = y;
  }
}<|file_separator|>class Example5.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>class Example5 {
  int x = 10;
  void example() {
    int y = 100;
    x = y;
  }
}<|file_separator|>class Example6.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>class Example6 {
  int y = 0;
  void example() {
    int x = 10;
    if (x > 0) {
      int y = 100;
      x = y;
    }
    y = x;
  }
}<|file_separator|><nl>
    if (mv != null) {
      mv.visitUse(service);
    }
  <|file_separator|><nl>
		return reader.read(caret, opts);
	<|file_separator|><nl>
	int hash = 0;
	int n = 0;
	for(Object x : xs)
		{
		hash += Util.hasheq(x);
		++n;
		}	

	return mixCollHash(hash, n);
<|file_separator|><nl>
        return i < basecnt || extmap.hasNext();
    <|file_separator|><nl>
	return this.val;
<|file_separator|><nl>
	return seq != null;
<|file_separator|><nl>return "int-int-int";}
    public static String staticDoppelganger(int a, int b) {return "int-int";<|file_separator|><nl>
		return m_projectService.buildContactInfo(domainName);
	<|file_separator|><nl>
		boolean result = false;
		try {
			String weixin = receiver;
			String content = message.getContent();
			String title = message.getTitle();
			String url = message.getUrl();
			String image = message.getImage();
			String mediaId = message.getMediaId();
			String mediaType = message.getMediaType();
			String mediaUrl = message.getMediaUrl();
			String mediaName = message.getMediaName();
			String mediaSize = message.getMediaSize();
			String mediaType2 = message.getMediaType2();
			String mediaUrl2 = message.getMediaUrl2();
			String mediaName2 = message.getMediaName2();
			String mediaSize2 = message.getMediaSize2();
			String mediaType3 = message.getMediaType3();
			String mediaUrl3 = message.getMediaUrl3();
			String mediaName3 = message.getMediaName3();
			String mediaSize3 = message.getMediaSize3();
			String mediaType4 = message.getMediaType4();
			String mediaUrl4 = message.getMediaUrl4();
			String mediaName4 = message.getMediaName4();
			String mediaSize4 = message.getMediaSize4();
			String mediaType5 = message.getMediaType5();
			String mediaUrl5 = message.getMediaUrl5();
			String mediaName5 = message.getMediaName5();
			String mediaSize5 = message.getMediaSize5();
			String mediaType6 = message.getMediaType6();
			String mediaUrl6 = message.getMediaUrl6();
			String mediaName6 = message.getMediaName6();
			String mediaSize6 = message.getMediaSize6();
			String mediaType7 = message.getMediaType<nl>
		return ID;
	<|file_separator|><nl>
		return content;
	<|file_separator|><nl>
      int result = 17;

      result = 31 * result + (getInterval() != null ? getInterval().hashCode() : 0);
      result = 31 * result + getDuration();
      result = 31 * result + (getAlertType() != null ? getAlertType().hashCode() : 0);
      result = 31 * result + (getSubConditions() != null ? getSubConditions().hashCode() : 0);

      return result;
   <|file_separator|><nl>
      m_id = id;
      return this;
   <|file_separator|><nl>
      if (value == null) {
         return null;
      }

      if (value instanceof String) {
         return (String) value;
      }

      if (value instanceof Number) {
         return ((Number) value).toString();
      }

      return value.toString();
   }

   @Override
   public void visitAlert(Alert alert) {
      startTag(ENTITY_ALERT, null, ATTR_ID, alert.getId());

      if (!alert.getTypes().isEmpty()) {
         for (Type type : alert.getTypes().values()) {
            type.accept(m_visitor);
         }
      }

      endTag(ENTITY_ALERT);
   <|file_separator|><nl>
      String id = attributes.getValue(ATTR_ID);
      String available = attributes.getValue(ATTR_AVAILABLE);
      Config config = new Config(id);

      if (available != null) {
         config.setAvailable(convert(Boolean.class, available, null));
      }

      return config;
   }

   @Override
   public ConditionItem buildConditionItem(Attributes attributes) {
      String conditionItemText = attributes.getValue(ATTR_CONDITIONITEMTEXT);
      String conditionItemText2 = attributes.getValue(ATTR_CONDITIONITEMTEXT2);
      ConditionItem conditionItem = new ConditionItem();

      if (conditionItemText != null) {
         conditionItem.setConditionItemText(conditionItemText);
      }

      if (conditionItemText2 != null) {
         conditionItem.setConditionItemText2(conditionItemText2);
      }

      return conditionItem;
   <|file_separator|><nl>
		return new Domain();
	<|file_separator|><nl>
		if (m_stack.isEmpty()) {
			throw new RuntimeException("Stack is empty!");
		} else {
			m_stack.pop();
		}
	<|file_separator|><nl>
			for (int i = 0; i < data.length; i++) {
				byte b = data[i];

				if (b == 0) {
					buf.writeByte(0);
					buf.writeByte(0);
				} else if (b == 1) {
					buf.writeByte(0);
					buf.writeByte(1);
				} else if (b == 2) {
					buf.writeByte(0);
					buf.writeByte(2);
				} else if (b == 3) {
					buf.writeByte(0);
					buf.writeByte(3);
				} else if (b == 4) {
					buf.writeByte(0);
					buf.writeByte(4);
				} else if (b == 5) {
					buf.writeByte(0);
					buf.writeByte(5);
				} else if (b == 6) {
					buf.writeByte(0);
					buf.writeByte(6);
				} else if (b == 7) {
					buf.writeByte(0);
					buf.writeByte(7);
				} else if (b == 8) {
					buf.writeByte(0);
					buf.writeByte(8);
				} else if (b == 9) {
					buf.writeByte(0);
					buf.writeByte(9);
				} else if (b == 10) {
					buf.writeByte(0);
					buf.writeByte(10);
				} else if (b == 11) {
					buf.writeByte(0);
					buf.writeByte(11);
				} else if (b == 12) {
					buf.writeByte(0);
					buf.writeByte(12);
				} else<nl>
		super.setCompleted(startInMillis);
	}

	@Override
	public void complete(long startInMillis, long endInMillis) {
		super.setCompleted(startInMillis, endInMillis);
	}

	@Override
	public void complete(long startInMillis, long endInMillis, Throwable e) {
		super.setCompleted(startInMillis, endInMillis);
		if (e != null) {
			setStatus("ERROR");
			addData(e.getClass().getName());
			addData(e.getMessage());
			addData(e.getStackTrace().toString());
		}
	<|file_separator|><nl>
      if (other.getId() != null) {
         setId(other.getId());
      }

      if (other.getValue() != 0) {
         setValue(other.getValue());
      }

      if (other.getDynamicAttributes() != null) {
         for (Map.Entry<String, String> entry : other.getDynamicAttributes().entrySet()) {
            setDynamicAttribute(entry.getKey(), entry.getValue());
         }
      }
   <|file_separator|><nl>
      return m_count;
   <|file_separator|><nl>
      m_gcs.add(gc);
      return this;
   }

   public MemoryInfo addGc(long time, long size) {
      m_gcs.add(new GcInfo(time, size));
      return this;
   }

   public MemoryInfo addGc(long time, long size, long count) {
      m_gcs.add(new GcInfo(time, size, count));
      return this;
   <|file_separator|><nl>
		String message = event.getMessage().toString();
		String threadName = event.getThreadName();
		String loggerName = event.getLoggerName();
		String sourceClassName = event.getSourceClassName();
		String sourceMethodName = event.getSourceMethodName();
		String sourceFileName = event.getSourceFileName();
		int lineNumber = event.getSourceLineNumber();
		String[] parameters = event.getArgumentArray();
		Throwable throwable = event.getThrowable();
		String[] throwableArray = event.getThrowableArray();
		String[] throwableStringArray = event.getThrowableStringArray();
		String[] throwableStringArray2 = event.getThrowableStringArray2();
		String[] throwableStringArray3 = event.getThrowableStringArray3();
		String[] throwableStringArray4 = event.getThrowableStringArray4();
		String[] throwableStringArray5 = event.getThrowableStringArray5();
		String[] throwableStringArray6 = event.getThrowableStringArray6();
		String[] throwableStringArray7 = event.getThrowableStringArray7();
		String[] throwableStringArray8 = event.getThrowableStringArray8();
		String[] throwableStringArray9 = event.getThrowableStringArray9();
		String[] throwableStringArray10 = event.getThrowableStringArray10();
		String[] throwableStringArray11 = event.getThrowableStringArray11();
		String[] throwableStringArray12 = event.getThrowableStringArray12();
		String[] throwableStringArray13 = event.getThrowableStringArray13();
		String[] throwableStringArray14 = event.getThrowableStringArray14();
		String[] throwableStringArray15 = event.getThrowableStringArray15();
		String[] throwableStringArray16 = event.getThrowableStringArray16();
		String<nl>
		// TODO
	<|file_separator|><nl>
			m_metric = metric;
		<|file_separator|><nl>
		TraceContext ctx = TraceContextHelper.threadLocal();

		Assert.assertNotNull(ctx);

		HttpServletRequest req = null;

		TraceContextHelper.extractFrom(req);
	<|file_separator|><nl>
		assertEquals("Hello World", "Hello World");
	<|file_separator|><nl>
		super.visitCrossReport(crossReport);
	<|file_separator|><nl>
		return new MatrixReport(domain, startTime, duration);
	<|file_separator|><nl>
		old.setCount(old.getCount() + segment.getCount());
	<|file_separator|><nl>
		if (key == null) {
			return null;
		}
		if (key.length() > s_lengthLimit) {
			return key.substring(0, s_lengthLimit);
		}
		return key;
	<|file_separator|><nl>
		BusinessReportMerger merger = new BusinessReportMerger();
		BusinessReport report1 = new BusinessReport();
		BusinessReport report2 = new BusinessReport();
		BusinessReport report3 = new BusinessReport();
		BusinessReport report4 = new BusinessReport();
		BusinessReport report5 = new BusinessReport();
		BusinessReport report6 = new BusinessReport();
		BusinessReport report7 = new BusinessReport();
		BusinessReport report8 = new BusinessReport();
		BusinessReport report9 = new BusinessReport();
		BusinessReport report10 = new BusinessReport();
		BusinessReport report11 = new BusinessReport();
		BusinessReport report12 = new BusinessReport();
		BusinessReport report13 = new BusinessReport();
		BusinessReport report14 = new BusinessReport();
		BusinessReport report15 = new BusinessReport();
		BusinessReport report16 = new BusinessReport();
		BusinessReport report17 = new BusinessReport();
		BusinessReport report18 = new BusinessReport();
		BusinessReport report19 = new BusinessReport();
		BusinessReport report20 = new BusinessReport();
		BusinessReport report21 = new BusinessReport();
		BusinessReport report22 = new BusinessReport();
		BusinessReport report23 = new BusinessReport();
		BusinessReport report24 = new BusinessReport();
		BusinessReport report25 = new BusinessReport();
		BusinessReport report26 = new BusinessReport();
		BusinessReport report27 = new BusinessReport();
		BusinessReport report28 = new BusinessReport();
		BusinessReport report29 = new BusinessReport();
		BusinessReport report30 = new BusinessReport();
		BusinessReport report31 = new BusinessReport();
		BusinessReport report32 = new BusinessReport();
		BusinessReport report33 = new BusinessReport<nl>
		int count = 100000;
		for (int i = 0; i < count; i++) {
			String domain = "domain" + i;
			String ip = "192.168.1." + i;
			lookup(StorageService.class).writeDomainIp(domain, ip);
		}
	}

	@Test
	public void testManyDomainIpRead() throws Exception {
		int count = 100000;
		for (int i = 0; i < count; i++) {
			String domain = "domain" + i;
			String ip = "192.168.1." + i;
			lookup(StorageService.class).writeDomainIp(domain, ip);
		}

		for (int i = 0; i < count; i++) {
			String domain = "domain" + i;
			String ip = "192.168.1." + i;
			lookup(StorageService.class).readDomainIp(domain);
		}
	<|file_separator|><nl>
		return Arrays.asList(
			new Component(EventAnalyzerTest.class, "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "eventAnalyzer", "event<nl>
		MessageTree tree = new MessageTree();
		Message message = new Message();
		message.setCategory("cat");
		message.setCategory("cat");
		message.setCategory("cat");
		message.setCategory("cat");
		message.setCategory("cat");
		message.setCategory("cat");
		message.setCategory("cat");
		message.setCategory("cat");
		message.setCategory("cat");
		message.setCategory("cat");
		message.setCategory("cat");
		message.setCategory("cat");
		message.setCategory("cat");
		message.setCategory("cat");
		message.setCategory("cat");
		message.setCategory("cat");
		message.setCategory("cat");
		message.setCategory("cat");
		message.setCategory("cat");
		message.setCategory("cat");
		message.setCategory("cat");
		message.setCategory("cat");
		message.setCategory("cat");
		message.setCategory("cat");
		message.setCategory("cat");
		message.setCategory("cat");
		message.setCategory("cat");
		message.setCategory("cat");
		message.setCategory("cat");
		message.setCategory("cat");
		message.setCategory("cat");
		message.setCategory("cat");
		message.setCategory("cat");
		message.setCategory("cat");
		message.setCategory("cat");
		message.setCategory("cat");
		message.setCategory("cat");
		message.setCategory("cat");
		message.setCategory("cat");
		message.setCategory("cat");
		message.setCategory("cat");
		message.setCategory("cat");
		message.<nl>
		return Arrays.asList(
				new Component(StateAnalyzerTest.class, "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "stateAnalyzer", "state<nl>
		DatabaseParser parser = lookup(DatabaseParser.class);
		Database database = parser.parseDatabase("jdbc:oracle:thin:@localhost:1521:orcl");

		Assert.assertEquals("localhost", database.getIp());
		Assert.assertEquals("orcl", database.getName());
	<|file_separator|><nl>
		return Arrays.asList(
			new Component(TopDelegate.class, "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate", "topDelegate<nl>
      int hash = 1;
      hash = hash * 31 + getId().hashCode();
      return hash;
   <|file_separator|><nl>
      for (Range range : machine.getRanges().values()) {
         visitRange(range);
      }

      if (machine.getGraphTrend() != null) {
         visitGraphTrend(machine.getGraphTrend());
      }

      for (StatusCode statusCode : machine.getStatusCodes().values()) {
         visitStatusCode(statusCode);
      }
   <|file_separator|><nl>
      for (Runnable job : m_deferedJobs) {
         job.run();
      }
   }

   @Override
   public boolean onEvent(final EventReport parent, final EventReport event) {
      if (m_deferrable) {
         m_deferedJobs.add(new Runnable() {
            @Override
            public void run() {
               parent.addEvent(event);
            }
         });
      } else {
         parent.addEvent(event);
      }

      return true;
   }

   @Override
   public boolean onEvent(final EventName parent, final EventName event) {
      if (m_deferrable) {
         m_deferedJobs.add(new Runnable() {
            @Override
            public void run() {
               parent.addEvent(event);
            }
         });
      } else {
         parent.addEvent(event);
      }

      return true;
   }

   @Override
   public boolean onEvent(final EventType parent, final EventName event) {
      if (m_deferrable) {
         m_deferedJobs.add(new Runnable() {
            @Override
            public void run() {
               parent.addEvent(event);
            }
         });
      } else {
         parent.addEvent(event);
      }

      return true;
   }

   @Override
   public boolean onEvent(final EventName parent, final EventName event) {
      if (m_deferrable) {
         m_deferedJobs.add(new Runnable() {
            @Override
            public void run() {
               parent.addEvent(event);
            }
         });
      } else {
         parent.addEvent(event);
      }

      return<nl>
      if (obj == null) {
         return false;
      }

      if (obj == this) {
         return true;
      }

      if (obj.getClass() != getClass()) {
         return false;
      }

      Machine other = (Machine) obj;

      if (!other.getIp().equals(getIp())) {
         return false;
      }

      return true;
   <|file_separator|><nl>
      if (this == obj) {
         return true;
      }

      if (obj == null) {
         return false;
      }

      if (getClass() != obj.getClass()) {
         return false;
      }

      final JavaThread other = (JavaThread) obj;
      if (!Objects.equals(this.m_id, other.m_id)) {
         return false;
      }

      return true;
   <|file_separator|><nl>
      ProcessDomain to = (ProcessDomain) m_objs.peek();

      mergeProcessDomain(to, from);
      visitProcessDomainChildren(to, from);
   <|file_separator|><nl>
      m_domain = domain;
      return this;
   <|file_separator|><nl>
   <|file_separator|><nl>
      for (Local local : crossReport.getLocals().values()) {
         visitLocal(local);
      }
   <|file_separator|><nl>
      if (other.getDomain() != null) {
         setDomain(other.getDomain());
      }

      if (other.getDomainNames() != null) {
         for (String domain : other.getDomainNames()) {
            addDomain(domain);
         }
      }

      if (other.getIps() != null) {
         for (String ip : other.getIps()) {
            addIp(ip);
         }
      }

      if (other.getLocals() != null) {
         for (Map.Entry<String, Local> entry : other.getLocals().entrySet()) {
            addLocal(entry.getValue());
         }
      }

      if (other.getStartTime() != null) {
         setStartTime(other.getStartTime());
      }

      if (other.getEndTime() != null) {
         setEndTime(other.getEndTime());
      }
   <|file_separator|><nl>
      m_totalCount += totalCount;
      return this;
   }

   public Index incSum(double sum) {
      m_sum += sum;
      return this;
   }

   public Index incSum(double sum, long count) {
      m_sum += sum * count;
      return this;
   <|file_separator|><nl>
      if (m_deferrable) {
         m_deferedJobs.add(new Runnable() {
            @Override
            public void run() {
               parent.addOperation(operation);
            }
         });
      } else {
         parent.addOperation(operation);
      }

      return true;
   }

   @Override
   public boolean onSegment(final Machine parent, final Segment segment) {
      if (m_deferrable) {
         m_deferedJobs.add(new Runnable() {
            @Override
            public void run() {
               parent.addSegment(segment);
            }
         });
      } else {
         parent.addSegment(segment);
      }

      return true;
   <|file_separator|><nl>
      if (value == null || value.length() == 0) {
         return defaultValue;
      }

      try {
         return type.cast(value);
      } catch (ClassCastException e) {
         throw new RuntimeException(String.format("Unable to convert value(%s) to type(%s)!", value, type), e);
      }
   <|file_separator|><nl>
      try {
         return m_in.readByte();
      } catch (IOException e) {
         throw new RuntimeException(e);
      }
   <|file_separator|><nl>
      m_domain = domain;
      return this;
   <|file_separator|><nl>
		return m_aggregationMessageFormat.parse(input);
	<|file_separator|>class Format.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public abstract class Format {
	public abstract String parse(String input) throws ParseException;
}<|file_separator|>class ParseException.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class ParseException extends Exception {
	public ParseException(String message) {
		super(message);
	}
}<|file_separator|>class AggregationMessageFormat.java
<|fim_prefix|><|fim_suffix|><|fim_middle|>public class AggregationMessageFormat {
	public String parse(String input) throws ParseException {
		return input;
	}
}<|file_separator|><nl>
			final int prime = 31;
			int result = 1;
			result = prime * result + getOuterType().hashCode();
			result = prime * result + m_ch;
			result = prime * result + (m_isPrefix ? 1231 : 1237);
			return result;
		<|file_separator|><nl>
		return m_logger.log("Fetching config " + configName);
	}

	@Override
	public String getLocalResourceContent(String resourceName) {
		return m_logger.log("Fetching local resource " + resourceName);
	<|file_separator|><nl>
        return dataFilePath + IDX_EXTENSION_TYPE;
    }
    public static String getDataNameByIdxFile(String idxFilePath){
        return idxFilePath.substring(0, idxFilePath.length() - IDX_EXTENSION_TYPE.length()) + DATA_EXTENSION_TYPE;
    <|file_separator|><nl>
		if (buf.isReadable()) {
			buf.release();
		}
	<|file_separator|><nl>
		try {
			return new DataInputStream(new ByteArrayInputStream(buf));
		} catch (Exception e) {
			return null;
		}
	<|file_separator|><nl>
		m_port = port;
	<|file_separator|><nl>
		return true;
	<|file_separator|><nl>
		String path = "/messages/12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012<nl>
		ServerStatisticManager manager = new ServerStatisticManager();
		Statistic state = findState(manager, 1000);
		state.addMessageSize("cat", 30);
		state.addMessageSize("cat", 30);
		state.addMessageSize("cat", 30);
		state.addMessageSize("cat", 30);
		state.addMessageSize("cat", 30);
		state.addMessageSize("cat", 30);
		state.addMessageSize("cat", 30);
		state.addMessageSize("cat", 30);
		state.addMessageSize("cat", 30);
		state.addMessageSize("cat", 30);
		state.addMessageSize("cat", 30);
		state.addMessageSize("cat", 30);
		state.addMessageSize("cat", 30);
		state.addMessageSize("cat", 30);
		state.addMessageSize("cat", 30);
		state.addMessageSize("cat", 30);
		state.addMessageSize("cat", 30);
		state.addMessageSize("cat", 30);
		state.addMessageSize("cat", 30);
		state.addMessageSize("cat", 30);
		state.addMessageSize("cat", 30);
		state.addMessageSize("cat", 30);
		state.addMessageSize("cat", 30);
		state.addMessageSize("cat", 30);
		state.addMessageSize("cat", 30);
		state.addMessageSize("cat", 30);
		state.addMessageSize("cat", 30);
		state.addMessageSize("cat", 30);
		state.addMessageSize("cat<nl>
      String id = attributes.getValue(ATTR_ID);
      String title = attributes.getValue(ATTR_TITLE);
      String description = attributes.getValue(ATTR_DESCRIPTION);
      String version = attributes.getValue(ATTR_VERSION);
      String build = attributes.getValue(ATTR_BUILD);
      String buildType = attributes.getValue(ATTR_BUILD_TYPE);
      String buildDate = attributes.getValue(ATTR_BUILD_DATE);
      String buildTime = attributes.getValue(ATTR_BUILD_TIME);
      String buildUser = attributes.getValue(ATTR_BUILD_USER);
      String buildMachine = attributes.getValue(ATTR_BUILD_MACHINE);
      String buildHost = attributes.getValue(ATTR_BUILD_HOST);
      String buildOS = attributes.getValue(ATTR_BUILD_OS);
      String buildOSVersion = attributes.getValue(ATTR_BUILD_OS_VERSION);
      String buildOSArch = attributes.getValue(ATTR_BUILD_OS_ARCH);
      String buildOSArchBit = attributes.getValue(ATTR_BUILD_OS_ARCH_BIT);
      String buildOSArchBit64 = attributes.getValue(ATTR_BUILD_OS_ARCH_BIT_64);
      String buildOSArchBit64Native = attributes.getValue(ATTR_BUILD_OS_ARCH_BIT_64_NATIVE);
      String buildOSArchBit64Native64 = attributes.getValue(ATTR_BUILD_OS_ARCH_BIT_64_NATIVE_64);
      String buildOSArchBit64Native6464 = attributes.getValue(ATTR_BUILD_OS_ARCH_BIT_64_NATIVE_64_64);
      String buildOSArchBit64Native646464 = attributes.getValue(ATTR_BUILD_OS_ARCH_BIT_<nl>
      if (m_deferrable) {
         m_deferedJobs.add(new Runnable() {
            @Override
            public void run() {
               parent.addProperty(property);
            }
         });
      } else {
         parent.addProperty(property);
      }

      return true;
   }

   @Override
   public boolean onValue(final Property parent, final Value value) {
      if (m_deferrable) {
         m_deferedJobs.add(new Runnable() {
            @Override
            public void run() {
               parent.addValue(value);
            }
         });
      } else {
         parent.addValue(value);
      }

      return true;
   <|file_separator|><nl>
      return new Class<?>[] { DailyReportContent.class, DailyReport.class, Hostinfo.class, MonthlyReportContent.class, MonthlyReport.class, Project.class, HourlyReport.class, HourlyReportContent.class, Task.class, WeeklyReportContent.class, WeeklyReport.class };
   <|file_separator|><nl>
      setFieldUsed(KEY_ID, true);
      m_keyId = keyId;
      return this;
   <|file_separator|><nl>
      HourlyReport proto = new HourlyReport();

      proto.setPeriod(period);
      proto.setDomain(domain);
      proto.setName(name);

      List<HourlyReport> result = getQueryEngine().queryMultiple(
            HourlyReportEntity.FIND_ALL_BY_DOMAIN_NAME_PERIOD, 
            proto,
            readset);
      
      return result;
   }
   
   public List<HourlyReport> findAllByDomainName(String domain, String name, Readset<HourlyReport> readset) throws DalException {
      HourlyReport proto = new HourlyReport();

      proto.setDomain(domain);
      proto.setName(name);

      List<HourlyReport> result = getQueryEngine().queryMultiple(
            HourlyReportEntity.FIND_ALL_BY_DOMAIN_NAME, 
            proto,
            readset);
      
      return result;
   }
   
   public List<HourlyReport> findAllByPeriod(java.util.Date period, Readset<HourlyReport> readset) throws DalException {
      HourlyReport proto = new HourlyReport();

      proto.setPeriod(period);

      List<HourlyReport> result = getQueryEngine().queryMultiple(
            HourlyReportEntity.FIND_ALL_BY_PERIOD, 
            proto,
            readset);
      
      return result;
   }
   
   public List<HourlyReport> findAllByDomain(String domain, Readset<HourlyReport> readset) throws DalException {
      HourlyReport proto = new HourlyReport();

      proto.setDomain(domain);

      List<HourlyReport> result = getQueryEngine().queryMultiple(
            HourlyReportEntity.FIND_ALL_BY_DOMAIN, 
            proto,
            readset);
      
      return<nl>
      return "WeeklyReportContent [m_content=" + m_content + ", m_contentLength=" + m_contentLength + ", m_creationDate="
            + m_creationDate + ", m_keyReportId=" + m_keyReportId + ", m_reportId=" + m_reportId + ", m_startId="
            + m_startId + "]";
   <|file_separator|><nl>
		m_indexFile.seek(index * MessageBlock.BLOCK_SIZE);
		byte[] buf = new byte[MessageBlock.BLOCK_SIZE];
		m_indexFile.readFully(buf);
		return buf;
	}

	public MessageBlock readMessageBlock(int index) throws IOException {
		byte[] buf = readMessage(index);
		return new MessageBlock(buf);
	}

	public MessageBlock readMessageBlock(int index, int offset, int length) throws IOException {
		byte[] buf = readMessage(index);
		return new MessageBlock(buf, offset, length);
	}

	public MessageBlock readMessageBlock(int index, int offset, int length, boolean snappy) throws IOException {
		byte[] buf = readMessage(index);
		return new MessageBlock(buf, offset, length, snappy);
	}

	public MessageBlock readMessageBlock(int index, int offset, int length, boolean snappy, boolean gzip) throws IOException {
		byte[] buf = readMessage(index);
		return new MessageBlock(buf, offset, length, snappy, gzip);
	}

	public MessageBlock readMessageBlock(int index, int offset, int length, boolean snappy, boolean gzip, boolean deflate) throws IOException {
		byte[] buf = readMessage(index);
		return new MessageBlock(buf, offset, length, snappy, gzip, deflate);
	}

	public MessageBlock readMessageBlock(int index, int offset, int length, boolean snappy, boolean gzip, boolean deflate, boolean lz4) throws IOException {
		byte[] buf = readMessage(index);
		return new MessageBlock(buf, offset, length, snappy, gzip, deflate, lz4);
	<|file_separator|><nl>
		super.initialize(dataFile, date);
	<|file_separator|><nl>
		if (m_configManager.isHdfsOn()) {
			HdfsIndex index = m_buckets.get(id.getDomain());
			if (index == null) {
				index = new HdfsIndex(id.getDomain());
				m_buckets.put(id.getDomain(), index);
			}
			return index.readMessage(id, ips);
		}
		return null;
	<|file_separator|><nl>
		if (m_file == null) {
			m_file = m_manager.open(m_bulider.build(ip, hour), "r");
		}

		m_block = 0;
		m_data = null;

		m_file.skipBytes(hour * BLOCK_SIZE);

		m_data = Unpooled.buffer(BLOCK_SIZE);

		m_file.readBytes(m_data);

		loadFrom(m_data, m_data.readableBytes());
	}

	@Override
	public void open(int hour, String ip, int index) throws IOException {
		if (m_file == null) {
			m_file = m_manager.open(m_bulider.build(ip, hour), "r");
		}

		m_block = index;
		m_data = null;

		m_file.skipBytes(hour * BLOCK_SIZE);

		m_data = Unpooled.buffer(BLOCK_SIZE);

		m_file.readBytes(m_data);

		loadFrom(m_data, m_data.readableBytes());
	}

	@Override
	public void open(int hour, String ip, int index, int length) throws IOException {
		if (m_file == null) {
			m_file = m_manager.open(m_bulider.build(ip, hour), "r");
		}

		m_block = index;
		m_data = null;

		m_file.skipBytes(hour * BLOCK_SIZE);

		m_data = Unpooled.buffer(length);

		m_file.readBytes(m_data);

		loadFrom(m_data, m_data.readableBytes());
	}<nl>
		for (Map.Entry<Pair<Integer, String>, TokenMapping> entry : m_cache.entrySet()) {
			if (entry.getKey().getKey() < hour) {
				entry.getValue().close();
			}
		}
	<|file_separator|><nl>
		m_baseDataDir = baseDataDir;
	<|file_separator|><nl>
		if (map == null) {
			map = new LinkedHashMap<Integer, Map<String, Bucket>>();
			m_buckets.put(hour, map);
		}

		return map;
	<|file_separator|><nl>
		return Arrays.asList(
			new Component("cat_database_configurator", "Cat Database Configurator", "Cat Database Configurator", "Cat Database Configurator", "Cat Database Configurator", "Cat Database Configurator", "Cat Database Configurator", "Cat Database Configurator", "Cat Database Configurator", "Cat Database Configurator", "Cat Database Configurator", "Cat Database Configurator", "Cat Database Configurator", "Cat Database Configurator", "Cat Database Configurator", "Cat Database Configurator", "Cat Database Configurator", "Cat Database Configurator", "Cat Database Configurator", "Cat Database Configurator", "Cat Database Configurator", "Cat Database Configurator", "Cat Database Configurator", "Cat Database Configurator", "Cat Database Configurator", "Cat Database Configurator", "Cat Database Configurator", "Cat Database Configurator", "Cat Database Configurator", "Cat Database Configurator", "Cat Database Configurator", "Cat Database Configurator", "Cat Database Configurator", "Cat Database Configurator", "Cat Database Configurator", "Cat Database Configurator", "Cat Database Configurator", "Cat Database Configurator", "Cat Database Configurator", "Cat Database Configurator", "Cat Database Configurator", "Cat Database Configurator", "Cat Database Configurator", "Cat Database Configurator", "Cat Database Configurator", "Cat Database Configurator", "Cat Database Configurator", "Cat Database Configurator", "Cat Database Configurator", "Cat Database Configurator", "Cat Database Configurator", "Cat Database Configurator", "Cat Database Configurator", "Cat Database Configurator", "Cat Database Configurator", "Cat Database Configurator", "Cat Database Configurator", "Cat Database Configurator", "Cat Database Configurator", "Cat Database Configurator", "Cat Database Configurator", "Cat Database Configurator", "Cat Database Configurator", "Cat Database Configurator", "Cat Database<nl>
		super.initialize(request, response);
		this.report = (Report) request.getAttribute(Report.class.getName());
	<|file_separator|><nl>
		ModelPeriod period = new ModelPeriod(minute, duration);
		BusinessReport report = fetchMetricReport(domain, period, 0, 100000);

		if (report != null) {
			return report.getDatas();
		} else {
			return null;
		}
	<|file_separator|><nl>
		try {
			Date date = new Date();
			TopMetric topMetric = buildTopMetric(date);
			List<Item> itemList = topMetric.getItems();

			handleExceptions(itemList);
		} catch (Exception e) {
			Cat.logError(e);
		}
	<|file_separator|><nl>
		if (regexText == null || text == null) {
			return 0;
		}
		if (regexText.equals(text)) {
			return 3;
		}
		if (text.matches(regexText)) {
			return 2;
		}
		if (text.matches(".*" + regexText + ".*")) {
			return 1;
		}
		return 0;
	<|file_separator|><nl>
		UserDefineRule item = m_dao.createLocal();
		item.setContent(userDefinedText);
		m_dao.save(item);
		return item.getId().toString();
	<|file_separator|><nl>
		try {
			Map<Object, Object> model = generateModel(domain, date);
			return m_configuration.getTemplate(getTemplateAddress()).process(model);
		} catch (Exception e) {
			Cat.logError(e);
		}
		return null;
	<|file_separator|><nl>
		return ID;
	}

	@Override
	public String getName() {
		return "Transaction Contactor";
	}

	@Override
	public String getDescription() {
		return "This contactor will send a transaction to a given address";
	}

	@Override
	public void run() {
		// TODO Auto-generated method stub
		
	<|file_separator|><nl>
		return m_serieName;
	<|file_separator|><nl>
		String postfix = getPostfix();
		Stack<Double> stk = new Stack<Double>();
		String[] tokens = postfix.split(" ");
		for (int i = 0; i < tokens.length; i++) {
			if (Character.isDigit(tokens[i].charAt(0))) {
				stk.push(Double.parseDouble(tokens[i]));
			} else {
				double b = stk.pop();
				double a = stk.pop();
				stk.push(calculate(a, b, tokens[i].charAt(0)));
			}
		}
		return stk.pop();
	<|file_separator|><nl>
			m_sb.append(" h").append(deltaX);
			return this;
		<|file_separator|><nl>
		Payload payload = ctx.getPayload();
		Model model = new Model();
		normalize(model, payload);
		Map<String, LineChart> allCharts = null;

		if (payload.getAction() == Action.VIEW) {
			allCharts = buildLineCharts(Type.Tag, payload.getTag(), payload.getStart(), payload.getEnd());
		} else {
			allCharts = buildLineCharts(Type.Domain, payload.getDomain(), payload.getStart(), payload.getEnd());
		}

		model.setCharts(allCharts);
		m_jspViewer.render(ctx, "business.jsp", model);
	<|file_separator|><nl>
		long time = start.getTime();
		return getReportFromCache(domain, time);
	<|file_separator|><nl>
		if (period == null) {
			period = new Date();
		}

		Date targetDate = new Date(period.getTime() - TimeHelper.ONE_DAY);
		String key = m_keyHelper.getBusinessKey(domain, targetDate);
		String name = m_configManager.getBusinessName(domain);
		Map<String, BusinessReport> reports = new HashMap<String, BusinessReport>();
		List<BusinessItem> items = buildOneDayBusinessItems(domain, name, targetDate, reports);
		double[] result = m_parser.parse(items);
		storeBaseLine(name, key, targetDate, result);
		return true;
	<|file_separator|><nl>
		m_sortBy = sortBy;
	<|file_separator|><nl>
		Payload payload = ctx.getPayload();
		Model model = ctx.getModel();

		if (isHistory(payload)) {
			CrossReport report = getSummarizeReport(payload);
			model.setReport(report);
		} else {
			CrossReport report = getHourlyReport(payload);
			model.setReport(report);
		}

		normalize(model, payload);
		m_jspViewer.render(ctx, model);
	<|file_separator|><nl>
		StringBuilder sb = new StringBuilder();
		for (Map.Entry<String, Integer> entry : m_errors.entrySet()) {
			sb.append(entry.getKey());
			sb.append(" ");
			sb.append(entry.getValue());
			sb.append("\n");
		}
		return sb.toString();
	}

	@Override
	public void visitDuration(Duration duration) {
		String state = duration.getState();
		int count = duration.getCount();
		int time = duration.getTime();
		int start = duration.getStart();
		int end = duration.getEnd();
		int durationTime = end - start;
		int durationCount = count * durationTime;

		if (durationCount > 0) {
			if (m_errors.containsKey(state)) {
				m_errors.put(state, m_errors.get(state) + durationCount);
			} else {
				m_errors.put(state, durationCount);
			}
		}
	<|file_separator|><nl>
		return getReportFromDatabase(request.getTimestamp(), request.getDomain());
	<|file_separator|><nl>
		DependencyReport report = getReportFromLocalDisk(request.getTimestamp(), domain);
		return report.toXml();
	<|file_separator|><nl>
		ExtensionGroup group = new ExtensionGroup();

		for (Entry<String, double[]> entry : entry.getValue().entrySet()) {
			String name = entry.getKey();
			double[] values = entry.getValue();
			String svg = m_builder.buildExtensionGraph(name, values);

			if (svg != null) {
				group.getSvgs().put(name, svg);
			}
		}
		graphs.put(entry.getKey(), group);
	<|file_separator|><nl>
		return getReportFromLocalDisk(period.getStartTime(), domain).toXml();
	<|file_separator|><nl>
		MatrixReportMerger merger = new MatrixReportMerger(new MatrixReport(domain));
		long startTime = start.getTime();
		long endTime = end.getTime();
		String name = MatrixAnalyzer.ID;

		for (; startTime < endTime; startTime = startTime + TimeHelper.ONE_DAY) {
			List<DailyReport> reports = null;
			try {
				reports = m_dailyReportDao
										.findAllByDomainNamePeriod(new Date(startTime), domain, name,	DailyReportEntity.READSET_FULL);
			} catch (DalException e) {
				Cat.logError(e);
			}
			if (reports != null) {
				for (DailyReport report : reports) {
					try {
						MatrixReport reportModel = queryFromDailyBinary(report.getId(), domain);

						reportModel.accept(merger);
					} catch (DalNotFoundException e) {
						// ignore
					} catch (Exception e) {
						Cat.logError(e);
					}
				}
			}
		}
		MatrixReport matrixReport = merger.getMatrixReport();

		matrixReport.setStartTime(start);
		matrixReport.setEndTime(new Date(end.getTime() - 1));

		return matrixReport;
	<|file_separator|><nl>
		// display only, no action here
	}

	@Override
	public void handle(Context ctx) throws ServletException, IOException {
		// display only, no action here
	<|file_separator|><nl>
	<|file_separator|><nl>
		return m_overloadDao.queryOverloadReports(startTime, endTime);
	}

	public List<OverloadReport> queryOverloadReports(Date startTime, Date endTime, int reportType) {
		return m_overloadDao.queryOverloadReports(startTime, endTime, reportType);
	}

	public List<OverloadReport> queryOverloadReports(Date startTime, Date endTime, int reportType, String domain, String ip, String name) {
		return m_overloadDao.queryOverloadReports(startTime, endTime, reportType, domain, ip, name);
	}

	public List<OverloadReport> queryOverloadReports(Date startTime, Date endTime, int reportType, String domain, String ip, String name, int period) {
		return m_overloadDao.queryOverloadReports(startTime, endTime, reportType, domain, ip, name, period);
	}

	public List<OverloadReport> queryOverloadReports(Date startTime, Date endTime, int reportType, String domain, String ip, String name, int period, int type) {
		return m_overloadDao.queryOverloadReports(startTime, endTime, reportType, domain, ip, name, period, type);
	}

	public List<OverloadReport> queryOverloadReports(Date startTime, Date endTime, int reportType, String domain, String ip, String name, int period, int type, int status) {
		return m_overloadDao.queryOverloadReports(startTime, endTime, reportType, domain, ip, name, period, type, status);
	}

	public List<OverloadReport> queryOverloadReports(Date startTime, Date endTime, int reportType, String domain, String ip, String name, int period, int type, int status, int page, int pageSize) {
<nl>
		return getReportFromDatabase(request.getTimestamp(), request.getDomain());
	<|file_separator|><nl>
		return "report.jsp";
	<|file_separator|><nl>
		return responses.get(0).getModel();
	<|file_separator|><nl>
		m_message = message;
	<|file_separator|><nl>
		if (m_configManager.isExclude(m_domain, m_segment, error.getException())) {
			m_exceptions.add(error.getException());
		}
	<|file_separator|><nl>
			return m_result;
		}

		public Map<String, Map<String, Item>> getItems() {
			return m_items;
		<|file_separator|><nl>
		return new TopReport(xml);
	<|file_separator|><nl>
			int index = m_currentHour;
			int length = m_graphLength;
			int count = m_currentNameCount[index];
			int fails = m_currentNameFails[index];
			double sum = m_currentNameSum[index];
			double avg = sum / count;
			double failRate = (double) fails / count;
			double trend = (double) (count - fails) / count;
			double trendRate = (double) (count - fails) / length;

			if (isType) {
				index = m_currentHour;
				length = m_graphLength;
				count = m_currentTypeCount[index];
				fails = m_currentTypeFails[index];
				sum = m_currentTypeSum[index];
				avg = sum / count;
				failRate = (double) fails / count;
				trend = (double) (count - fails) / count;
				trendRate = (double) (count - fails) / length;
			}

			graph.addPoint(index, count, fails, sum, avg, failRate, trend, trendRate);
		<|file_separator|><nl>
			m_min = min;
			return this;
		<|file_separator|><nl>
		m_ip = machine.getIp();
	}

	@Override
	public void visitRequest(Request request) {
		String item = request.getUri();
		Long count = m_items.get(item);
		if (count == null) {
			count = 0L;
		}
		m_items.put(item, count + 1);
	}

	@Override
	public void visitResponse(Response response) {
		String item = response.getUri();
		Long count = m_items.get(item);
		if (count == null) {
			count = 0L;
		}
		m_items.put(item, count + 1);
	}

	@Override
	public void visitUser(User user) {
		String item = user.getIp();
		Long count = m_items.get(item);
		if (count == null) {
			count = 0L;
		}
		m_items.put(item, count + 1);
	<|file_separator|><nl>
		throw new RuntimeException("current weekly monthly report builder don't support weekly task");
	<|file_separator|><nl>
		m_opState = result ? SUCCESS : FAIL;
	<|file_separator|><nl>
		return "jsp/system/system.jsp";
	<|file_separator|><nl>
		return m_content;
	<|file_separator|><nl>

		Thread t1 = new Thread(new Task("1"));
		Thread t2 = new Thread(new Task("2"));

		t1.start();
		t2.start();

		t1.join();
		t2.join();
	<|file_separator|><nl>
		String json = FileUtils.readFileToString(new File(jsonPath));
		System.out.println(json);
	<|file_separator|><nl>
		StateReportMerger stateReportMerger = new StateReportMerger();
		StateReport stateReport = stateReportMerger.merge(new StateReport(), new StateReport());
		Assert.assertEquals(stateReport.getHistory(), new ArrayList<StateReport>());
	<|file_separator|><nl>
		ProblemReportDailyGraphCreator.main(new String[]{});
	<|file_separator|><nl>
		HistoryStorageReportMerger merger = new HistoryStorageReportMerger();
		merger.merge();
	<|file_separator|><nl>
      byte tag;

      while ((tag = readTag()) != -1) {
         visitTopologyGraphChildren(topologyGraph, (tag & 0xFF) >> 2, tag & 0x3);
      }
   <|file_separator|><nl>
      return m_domainConfigs.get(id);
   <|file_separator|><nl>
      m_from = from;
      return this;
   <|file_separator|><nl>
      if (other.getId() != null) {
         setId(other.getId());
      }

      if (other.getAvg() != 0) {
         setAvg(other.getAvg());
      }

      if (other.getFailureCount() != 0) {
         setFailureCount(other.getFailureCount());
      }

      if (other.getFailurePercent() != 0) {
         setFailurePercent(other.getFailurePercent());
      }

      if (other.getQps() != 0) {
         setQps(other.getQps());
      }

      if (other.getSum() != 0) {
         setSum(other.getSum());
      }

      if (other.getTotalCount() != 0) {
         setTotalCount(other.getTotalCount());
      }
   <|file_separator|><nl>
      if (m_deferrable) {
         m_deferedJobs.add(new Runnable() {
            @Override
            public void run() {
               parent.addMachineState(machineState);
            }
         });
      } else {
         parent.addMachineState(machineState);
      }

      return true;
   }

   @Override
   public boolean onMachine(final UtilizationReport parent, final Machine machine) {
      if (m_deferrable) {
         m_deferedJobs.add(new Runnable() {
            @Override
            public void run() {
               parent.addMachine(machine);
            }
         });
      } else {
         parent.addMachine(machine);
      }

      return true;
   }

   @Override
   public boolean onLink(final Link link) {
      if (m_deferrable) {
         m_deferedJobs.add(new Runnable() {
            @Override
            public void run() {
               link.addLink();
            }
         });
      } else {
         link.addLink();
      }

      return true;
   <|file_separator|><nl>
      return m_domains.remove(id);
   <|file_separator|><nl>
      return m_id;
   <|file_separator|><nl>
      throw new UnsupportedOperationException();
   <|file_separator|><nl>
      if (m_deferrable) {
         m_deferedJobs.add(new Runnable() {
            @Override
            public void run() {
               parent.addMetric(metric);
            }
         });
      } else {
         parent.addMetric(metric);
      }

      return true;
   <|file_separator|><nl>
      StorageGroupConfig to = (StorageGroupConfig) m_objs.peek();

      mergeStorageGroupConfig(to, from);
      visitStorageGroupConfigChildren(to, from);
   <|file_separator|><nl>
      m_url = url;
      return this;
   <|file_separator|><nl>
      if (other.getId() != null) {
         setId(other.getId());
      }
   <|file_separator|><nl>
      if (!equals(expectedValue, actualValue)) {
         throw new IllegalArgumentException(String.format("Attribute '%s' of %s '%s' is not equal to '%s'", name, entityName, expectedValue, actualValue));
      }
   <|file_separator|><nl>
      if (value == null) {
         return null;
      }

      if (value instanceof String) {
         return (String) value;
      }

      if (value instanceof Number) {
         return ((Number) value).toString();
      }

      if (value instanceof Boolean) {
         return ((Boolean) value).toString();
      }

      if (value instanceof java.util.Date) {
         return ((java.util.Date) value).toString();
      }

      return value.toString();
   }

   @Override
   public void visitEntity(Entity entity) {
      startTag(ENTITY_ENTITY, true, null);
   }

   @Override
   public void visitEntityConfig(EntityConfig entityConfig) {
      startTag(ENTITY_ENTITY_CONFIG, null);

      if (!entityConfig.getEntities().isEmpty()) {
         for (Entity entity : entityConfig.getEntities().values()) {
            entity.accept(m_visitor);
         }
      }

      endTag(ENTITY_ENTITY_CONFIG);
   }

   @Override
   public void visitEntityConfig(EntityConfig entityConfig, String name, String value) {
      startTag(ENTITY_ENTITY_CONFIG, true, null, name, value);
   }

   @Override
   public void visitEntityConfig(EntityConfig entityConfig, String name, java.util.Map<String, String> dynamicAttributes, Object... nameValues) {
      startTag(ENTITY_ENTITY_CONFIG, true, dynamicAttributes, nameValues);
   }

   @Override
   public void visitEntityConfig(EntityConfig entityConfig, String name, java.util.Map<String, String> dynamicAttributes, Object... nameValues) {
      startTag(ENTITY_ENTITY_CONFIG, true<nl>
      m_text.append(ch, start, length);
   <|file_separator|><nl>
      if (other.getUsers() != null) {
         for (User user : other.getUsers().values()) {
            addUser(user);
         }
      }
   <|file_separator|><nl>
      if (value == null) {
         return null;
      }

      if (value instanceof String) {
         return (String) value;
      }

      if (value instanceof Number) {
         return ((Number) value).toString();
      }

      if (value instanceof Boolean) {
         return ((Boolean) value).toString();
      }

      return value.toString();
   }

   @Override
   public void visitEntity(Entity entity) {
      startTag(ENTITY_ENTITY, true, null, ATTR_NAME, entity.getName());
   }

   @Override
   public void visitEntityConfig(EntityConfig entityConfig) {
      startTag(ENTITY_ENTITY_CONFIG, null);

      if (!entityConfig.getEntities().isEmpty()) {
         for (Entity entity : entityConfig.getEntities()) {
            entity.accept(m_visitor);
         }
      }

      endTag(ENTITY_ENTITY_CONFIG);
   <|file_separator|><nl>
      setFieldUsed(END_TIME, true);
      m_endTime = endTime;
      return this;
   <|file_separator|><nl>
        String name = invoker.getName();
        String result = name + " " + invocation.getMethodName();
        return new Result(result);<|file_separator|><nl>
            return originRegistry.lookup(appendProviderAppName(url));
        <|file_separator|><nl>
        bind(HttpServerTransport.class).to(JettyHttpServerTransport.class);
        bind(HttpServerTransport.class).toInstance(new JettyHttpServerTransport(settings));
    <|file_separator|><nl>
        response.sendError(500, "Internal Server Error");
    <|file_separator|><nl>
		return super.beginLog(pjp);<|file_separator|><nl>
        this.ip = ip;
        return this;
    <|file_separator|><nl>
        String name = attributes.getValue(Constants.ATTR_NAME);
        String enabled = attributes.getValue(Constants.ATTR_ENABLED);
        Domain domain = new Domain(name);

        if (enabled != null) {
            domain.setEnabled(convert(Boolean.class, enabled, false));
        }

        return domain;
    <|file_separator|><nl>
        System.err.println("Error: " + event.getRenderedMessage());
    <|file_separator|><nl>
        try {
            String message = event.getFormattedMessage();
            String stackTrace = event.getThrowableStrRep();
            String[] lines = stackTrace.split("\n");
            String[] lines2 = new String[lines.length - 1];
            for (int i = 1; i < lines.length; i++) {
                lines2[i - 1] = lines[i];
            }
            String stackTrace2 = String.join("\n", lines2);
            String[] lines3 = stackTrace2.split("at ");
            String[] lines4 = new String[lines3.length - 1];
            for (int i = 1; i < lines3.length; i++) {
                lines4[i - 1] = lines3[i];
            }
            String stackTrace3 = String.join("\n", lines4);
            String[] lines5 = stackTrace3.split("in ");
            String[] lines6 = new String[lines5.length - 1];
            for (int i = 1; i < lines5.length; i++) {
                lines6[i - 1] = lines5[i];
            }
            String stackTrace4 = String.join("\n", lines6);
            String[] lines7 = stackTrace4.split("at ");
            String[] lines8 = new String[lines7.length - 1];
            for (int i = 1; i < lines7.length; i++) {
                lines8[i - 1] = lines7[i];
            }
            String stackTrace5 = String.join("\n", lines8);
            String[] lines9 = stackTrace5.split("in ");
            String[] lines10 = new String<nl>
        return Thread.currentThread().getName();
    <|file_separator|><nl>
    <|file_separator|><nl>
        return null;
    }

    @Override
    public boolean isCatEnabled(String domain) {
        return false;
    }

    @Override
    public boolean isMessageEnabled(String domain) {
        return false;
    }

    @Override
    public boolean isTraceMode(String domain) {
        return false;
    }

    @Override
    public void log(String message) {
    }

    @Override
    public void log(String message, Throwable t) {
    }

    @Override
    public void log(String message, Object... params) {
    }

    @Override
    public void log(String message, Object[] params, Throwable t) {
    }

    @Override
    public void log(String message, Object[] params, Throwable t, String domain) {
    }

    @Override
    public void log(String message, Object[] params, Throwable t, String domain, boolean traceMode) {
    }

    @Override
    public void log(String message, Object[] params, Throwable t, String domain, boolean traceMode, boolean catEnabled) {
    }

    @Override
    public void log(String message, Object[] params, Throwable t, String domain, boolean traceMode, boolean catEnabled, boolean messageEnabled) {
    }

    @Override
    public void log(String message, Object[] params, Throwable t, String domain, boolean traceMode, boolean catEnabled, boolean messageEnabled, boolean traceModeEnabled) {
    }

    @Override
    public void log(String message, Object[] params, Throwable t, String domain, boolean traceMode, boolean catEnabled, boolean messageEnabled, boolean traceModeEnabled, boolean messageEnabledEnabled) {
    }

    @Override
    public void log(String message,<nl>
        return NullMessage.TRANSACTION;
    }

    @Override
    public void logEvent(String type, String name, String status, String nameValuePairs, String category) {
    }

    @Override
    public void logEvent(String type, String name, String status, String nameValuePairs, String category, String correlationId) {
    }

    @Override
    public void logEvent(String type, String name, String status, String nameValuePairs, String category, String correlationId, String spanId) {
    }

    @Override
    public void logEvent(String type, String name, String status, String nameValuePairs, String category, String correlationId, String spanId, String traceId) {
    }

    @Override
    public void logEvent(String type, String name, String status, String nameValuePairs, String category, String correlationId, String spanId, String traceId, String parentId) {
    }

    @Override
    public void logEvent(String type, String name, String status, String nameValuePairs, String category, String correlationId, String spanId, String traceId, String parentId, String spanContext) {
    }

    @Override
    public void logEvent(String type, String name, String status, String nameValuePairs, String category, String correlationId, String spanId, String traceId, String parentId, String spanContext, String spanId2) {
    }

    @Override
    public void logEvent(String type, String name, String status, String nameValuePairs, String category, String correlationId, String spanId, String traceId, String parentId, String spanContext, String spanId2, String spanId3) {
    }

    @Override
    public void logEvent(String type, String name, String status, String name<nl>
        extensions.add(extension);
    <|file_separator|><nl>
        return "C3P0MonitorInfo{" +
                "jdbcUrl='" + jdbcUrl + '\'' +
                ", numBusyConnections=" + numBusyConnections +
                ", numConnections=" + numConnections +
                ", numIdleConnections=" + numIdleConnections +
                ", numFailedCheckOuts=" + numFailedCheckOuts +
                ", numFailedCheckIns=" + numFailedCheckIns +
                ", numFailedIdleTests=" + numFailedIdleTests +
                '}';
    <|file_separator|><nl>
        if (url == null || url.length() == 0) {
            return null;
        }

        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < url.length(); i++) {
            char c = url.charAt(i);
            if (c == SPLIT) {
                if (sb.length() > 0) {
                    sb.append(SPLIT);
                }
            } else if (isNumber(c)) {
                sb.append(c);
            }
        }

        return sb.toString();
    <|file_separator|><nl>
        Cat.logTransaction("test", "test", 1);
    <|file_separator|><nl>
        return database.isHealthy() ? Result.healthy() : Result.unhealthy("Database is not healthy");
    <|file_separator|><nl>
            this.prefix = prefix;
            return this;
        <|file_separator|><nl>
        injectionManager.addFilter(filter);
    <|file_separator|><nl>
        return Response.unauthorized(String.format(CHALLENGE_FORMAT, prefix, realm));
    <|file_separator|><nl>
        if (header == null || !header.startsWith(BasicAuthFilter.BASIC_PREFIX)) {
            return null;
        }
        final String credentials = header.substring(BasicAuthFilter.BASIC_PREFIX.length());
        final String decoded = new String(Base64.getDecoder().decode(credentials), StandardCharsets.UTF_8);
        final int colon = decoded.indexOf(':');
        if (colon == -1) {
            return null;
        }
        return new BasicCredentials(decoded.substring(0, colon), decoded.substring(colon + 1));
    <|file_separator|><nl>
        for (AuthFilter handler : handlers) {
            handler.filter(containerRequestContext);
        }
    <|file_separator|><nl>
        final String header = requestContext.getHeaderString(HttpHeaders.AUTHORIZATION);
        final String credentials = getCredentials(header);
        if (credentials == null) {
            requestContext.abortWith(Response.status(Response.Status.UNAUTHORIZED).build());
        }
    <|file_separator|><nl>
        assertThat(testClient().target("/test").request().get(String.class)).isEqualTo("test");
    }
<|file_separator|><nl>
            throw new UnsupportedOperationException();
        <|file_separator|><nl>
        assertThat(cached.authenticate("credentials", true)).isFalse();
        assertThat(cached.authenticate("credentials", true)).isFalse();
        verify(underlying, times(1)).authenticate("credentials");
    <|file_separator|><nl>
        Invocation.Builder request = target("/auth-test/null-principal-entity").request();
        assertThatExceptionOfType(WebApplicationException.class)
            .isThrownBy(() -> request.get(String.class))
            .satisfies(e -> assertThat(e.getResponse().getStatus()).isEqualTo(401));
    }
<|file_separator|><nl>
        return gzipEnabledForRequests;
    <|file_separator|><nl>
        assertThat(configuredClient.getDefaultRequestConfig()).isEqualTo(defaultRequestConfigMock);
    <|file_separator|><nl>
        return new DefaultConfigurationFactory<T>(klass, validator, objectMapper, propertyPrefix);
    <|file_separator|><nl>
        return true;
    <|file_separator|><nl>
        return getResourceAsStream(path);
    <|file_separator|><nl>
        return new StringSubstitutor(this.substitutor).replace(this.delegate.open(path));
    <|file_separator|><nl>
        return servletEnabled;
    <|file_separator|><nl>
        final HttpConnectorFactory httpConnectorFactory = http.getConnector();
        assertThat(httpConnectorFactory.getPort()).isEqualTo(8080);
        assertThat(httpConnectorFactory.getScheme()).isEqualTo("http");
        assertThat(httpConnectorFactory.getHostname()).isEqualTo("localhost");
    <|file_separator|><nl>
        return new CustomClass();
    <|file_separator|><nl>
        final String request = "GET / HTTP/1.1\r\nHost: localhost\r\nUser-Agent: curl/7.64.1\r\nAccept: */*\r\n\r\n";
        final String response = "HTTP/1.1 200 OK\r\nContent-Type: text/html\r\nContent-Length: 12\r\n\r\nHello World";
        final String expected = "127.0.0.1|GET|/|GET|200|12|127.0.0.1|text/html|curl/7.64.1|Hello World";
        final String actual = sendRequest(request, response);
        assertEquals(expected, actual);
    <|file_separator|><nl>
        Entity<Map<String, Object>> entity = requestBody(null, -23, null);
        Response response = target.request(MediaType.APPLICATION_JSON_TYPE).post(entity);
    <|file_separator|><nl>
        return user.isAdmin() || user.isManager() || user.isEmployee();
    <|file_separator|><nl>
        if (namespace.getBoolean("include-default")) {
            configuration.setTemplateName("default");
        }
        configuration.setNames(namespace.getStringList("names"));
        LOGGER.info("Rendering template with name '{}' and data '{}'",
                    configuration.getTemplateName(),
                    configuration.getNames());
    <|file_separator|><nl>
        return person;
    <|file_separator|><nl>
        Invocation.Builder request = RULE.target("/protected/admin").request();
        assertThatExceptionOfType(ForbiddenException.class)
            .isThrownBy(() -> request.get(String.class))
            .satisfies(e -> assertThat(e.getResponse().getStatus()).isEqualTo(403));
    <|file_separator|><nl>
        Runtime.getRuntime().addShutdownHook(new Thread(this::doStop));
    <|file_separator|><nl>
        for (final HealthCheckConfiguration config : healthCheckConfigs) {
            if (config.getName() == null || config.getName().isEmpty()) {
                LOGGER.error("Health check configuration is missing a name");
                throw new IllegalStateException("Health check configuration is missing a name");
            }
            if (!registeredHealthCheckNames.contains(config.getName())) {
                LOGGER.error("Health check configuration name {} is not registered", config.getName());
                throw new IllegalStateException("Health check configuration name " + config.getName() + " is not registered");
            }
        }
    <|file_separator|><nl>
        // given
        final HealthStateView view = new HealthStateView("foo", true, HealthCheckType.READY, true);
        final Map<String, Collection<String>> queryParams = Collections.singletonMap(
            JsonHealthResponseProvider.NAME_QUERY_PARAM, Collections.singleton(view.getName()));

        // when
        when(healthStateAggregator.healthStateView(view.getName())).thenReturn(Optional.of(view));
        when(healthStatusChecker.isHealthy(isNull())).thenReturn(true);
        final HealthResponse response = jsonHealthResponseProvider.healthResponse(queryParams);

        // then
        assertThat(response.isHealthy()).isTrue();
        assertThat(response.getContentType()).isEqualTo(MediaType.APPLICATION_JSON);
        assertThat(mapper.readTree(response.getMessage())).isEqualTo(mapper.readTree(fixture("/json/single-healthy-response.json")));
    <|file_separator|><nl>
        // given
        HealthResponderFactory factory = configFactory.build(new ResourceConfigurationSourceProvider(), "/yml/servlet-responder-factory-caching.yml");
        setupServletStubbing();

        // when
        // succeed first, fail second
        when(healthResponseProvider.healthResponse(Collections.emptyMap())).thenReturn(SUCCESS, FAIL);
        factory.configure(NAME, Collections.singletonList(HEALTH_CHECK_URI), healthResponseProvider, health, jersey,
            servlets, mapper);
        servletTester.addServlet(new ServletHolder(servletCaptor.getValue()), HEALTH_CHECK_URI);
        servletTester.start();
        HttpTester.Response response = executeRequest(request);

        // then
        assertThat(response.getStatus()).isEqualTo(Response.SC_OK);
    <|file_separator|><nl>
        // given
        final ServletHealthResponder servletHealthResponder = new ServletHealthResponder(healthResponseProvider, true,
            "no-store");

        // when
        when(healthResponseProvider.healthResponse(anyMap())).thenReturn(SUCCESS);
        servletTester.addServlet(new ServletHolder(servletHealthResponder), HEALTH_CHECK_URI);
        servletTester.start();
        final HttpTester.Response response = executeRequest(request);

        // then
        assertThat(response.getStatus()).isEqualTo(Response.SC_OK);
        assertThat(response.get(HttpHeader.CACHE_CONTROL))
            .isNotNull()
            .isEqualTo(NO_STORE);
    <|file_separator|><nl>
        return requireNonNull(criteria).getResultList();
    <|file_separator|><nl>
        this.sessionFactory = factory.build(bundle, environment, config, Collections.singletonList(Person.class));
    <|file_separator|><nl>
        checkSupportedCipherSuites();
        return new Http2Connector(server, metrics, name, threadPool, maxConcurrentStreams, initialStreamRecvWindow);
    <|file_separator|><nl>
        assertResponse(http1Client.GET("http://localhost:" + appRule.getLocalPort() + "/api/test"), HttpVersion.HTTP_1_1);
    <|file_separator|><nl>
        assertThat(mapper.readValue(""maximumSize=0"", CacheBuilderSpec.class))
            .isEqualTo(CacheBuilderSpec.disableCaching());
    <|file_separator|><nl>
        if (annotations == null) {
            return null;
        }
        for (final Annotation annotation : annotations) {
            if (annotation instanceof DefaultValue) {
                return ((DefaultValue) annotation).value();
            }
        }
        return null;
    <|file_separator|><nl>
        LOGGER.error("Early EOF", e);
        return Response.status(Response.Status.NO_CONTENT).build();
    <|file_separator|><nl>
        try {
            context.proceed();
        } catch (IOException e) {
            LOGGER.error("Error writing to response", e);
            exceptionCounter.inc();
            throw e;
        }
    <|file_separator|><nl>
        return UUID.randomUUID();
    <|file_separator|><nl>
        final long start = (Long) request.getProperty(RUNTIME_PROPERTY);
        final long end = currentTimeProvider.get();
        final long duration = end - start;
        response.getHeaders().putSingle(RUNTIME_HEADER, String.valueOf(duration / NANOS_IN_SECOND));
    <|file_separator|><nl>
        context.register(mapper);
        return true;
    <|file_separator|><nl>
        return LocalDateTime.parse(input, DateTimeFormatter.ISO_LOCAL_DATE_TIME);<|file_separator|><nl>
        if (value == null) {
            return null;
        }
        try {
            return constructor.newInstance(value);
        } catch (Exception e) {
            throw new IllegalArgumentException(LocalizationMessages.METHOD_PARAMETER_CONVERSION_ERROR("value", e));
        }
    <|file_separator|><nl>
        if (rawType == MyParamConverter.class) {
            return new MyParamConverter();
        }
        return null;
    <|file_separator|><nl>
        if (invocable.getHandlingMethod().isAnnotationPresent(Validated.class)) {
            return invocable.getHandlingMethod().getAnnotation(Validated.class).value();
        } else {
            return new Class<?>[]{Default.class};
        }
    <|file_separator|><nl>
        return invocable;
    <|file_separator|><nl>
        receiver.receiveValue(originalValue.getValue());
    <|file_separator|><nl>
            return new MyMessage(value);<|file_separator|><nl>
        return "no-store";
    <|file_separator|><nl>
        assertThatExceptionOfType(WebApplicationException.class)
            .isThrownBy(() -> new LongParam("foo"))
            .satisfies(e -> assertThat(e.getResponse().getStatus()).isEqualTo(400))
            .satisfies(e -> assertThat(e.getMessage()).isEqualTo("Parameter is not a number."));
    <|file_separator|><nl>
        flash.put("name", name);
    <|file_separator|><nl>
        this.minimumEntitySize = requireNonNull(size);
    <|file_separator|><nl>
        return (this._options & SESSIONS) != 0;
    <|file_separator|><nl>
        jsonGenerator.writeString(serializerFunction.apply(t));
    <|file_separator|><nl>
        this.includes = includes;
    <|file_separator|><nl>
        EventJsonLayoutBaseFactory factory = new EventJsonLayoutBaseFactory();
        factory.setThrowableProxyConverter(new ThrowableHandlingConverter(new LoggerContext()));

        ThrowableHandlingConverter converter = factory.createThrowableProxyConverter(new LoggerContext());
        converter.start();

        assertThat(converter.isStarted()).isTrue();

        int originalSize = (int)getStackTraceAsString(proxy.getThrowable()).lines().count();

        assertThat(converter.convert(event))
            .hasLineCount(originalSize) // Verify that the full stack is included
            .containsSubsequence("r00t", "wrapp3d"); // Verify that the root is first
    <|file_separator|><nl>
        jettyManaged.start();
        jettyManaged.stop();
    <|file_separator|><nl>
        return layout == null ? defaultLayoutFactory.build(context) : layout.build(context);
    <|file_separator|><nl>
        if (bootstrapped) {
            return;
        }
        BOOTSTRAPPING_LOCK.lock();
        try {
            if (bootstrapped) {
                return;
            }
            if (level == null) {
                level = Level.WARN;
            }
            if (layoutFactory == null) {
                layoutFactory = DropwizardLayout::new;
            }
            BootstrapLogging.bootstrap(level, layoutFactory);
        } finally {
            BOOTSTRAPPING_LOCK.unlock();
        }
    }

    public static void bootstrap(Level level, DiscoverableLayoutFactory<ILoggingEvent> layoutFactory,
                                 String name) {
        if (bootstrapped) {
            return;
        }
        BOOTSTRAPPING_LOCK.lock();
        try {
            if (bootstrapped) {
                return;
            }
            if (level == null) {
                level = Level.WARN;
            }
            if (layoutFactory == null) {
                layoutFactory = DropwizardLayout::new;
            }
            BootstrapLogging.bootstrap(level, layoutFactory, name);
        } finally {
            BOOTSTRAPPING_LOCK.unlock();
        }
    }

    public static void bootstrap(Level level, DiscoverableLayoutFactory<ILoggingEvent> layoutFactory,
                                 String name, String configPath) {
        if (bootstrapped) {
            return;
        }
        BOOTSTRAPPING_LOCK.lock();
        try {
            if (bootstrapped) {
                return;
            }
            if (level == null) {
                level = Level.WARN;
            }
            if (layoutFactory == null) {
                layoutFactory = DropwizardLayout::new;
            }<nl>
        return target;
    <|file_separator|><nl>
        this.sendBufferSize = sendBufferSize;
    <|file_separator|><nl>
        this.host = host;
    <|file_separator|><nl>
        if (environment == null) {
            throw new IllegalArgumentException("environment cannot be null");
        }
        if (registry == null) {
            throw new IllegalArgumentException("registry cannot be null");
        }
        if (frequency == null) {
            throw new IllegalArgumentException("frequency cannot be null");
        }
        if (reporters == null || reporters.isEmpty()) {
            throw new IllegalArgumentException("reporters cannot be null or empty");
        }
        if (reportOnStop) {
            environment.manage(new ScheduledReporter(registry, frequency));
        }
        for (ReporterFactory reporterFactory : reporters) {
            reporterFactory.configure(environment, registry);
        }
    <|file_separator|><nl>
        super.configure(subparser);
        subparser.addArgument("--drop-all", "-a", new String[]{"--drop-all", "-A"})
            .setDescription("Delete all user-owned objects from the database.");
    <|file_separator|><nl>
        super.configure(subparser);
        subparser.addArgument("-c", "--contexts", ListArgumentFactory.of(String.class, "The contexts to run the test against", false))
                .setMultipleValues(true);
    <|file_separator|><nl>
        final String databaseUrl = MigrationTestSupport.getDatabaseUrl();
        final TestMigrationConfiguration conf = MigrationTestSupport.createConfiguration(databaseUrl);

        // Drop it
        dropAllCommand.run(null, new Namespace(Collections.emptyMap()), conf);

        try (Handle handle = Jdbi.create(databaseUrl, "sa", "").open()) {
            assertThat(MigrationTestSupport.tableExists(handle, "PERSONS"))
                .isFalse();
        }
    <|file_separator|><nl>
        final List<String> runs = parameters.get("runs");
        if (runs == null || runs.isEmpty()) {
            return 1;
        }

        return Integer.parseInt(runs.get(0));
    <|file_separator|><nl>
        return Optional.ofNullable(responseContentType);
    <|file_separator|><nl>
        assertEquals("test", task.getName());
    <|file_separator|><nl>
        daoTest.beforeAll(extensionContext);
    }

    @Override
    public void afterAll(ExtensionContext extensionContext) throws Exception {
        daoTest.afterAll(extensionContext);
    }
}
<|file_separator|><nl>
        return new JerseyClientBuilder(environment);
    }
<|file_separator|><nl>
        return getPerson(name);
    }

    @POST
    @Timed
    public Person createPerson(@Valid @NotNull Person person) {
        return store.createPerson(person);
    }

    @POST
    @Timed
    @Path("/list")
    public List<Person> createPersonList(@Valid @NotNull List<Person> persons) {
        return store.createPersonList(persons);
    }

    @POST
    @Timed
    @Path("/partial")
    public Person createPersonPartial(@Valid @NotNull Person person) {
        return store.createPerson(person);
    }

    @POST
    @Timed
    @Path("/partial-list")
    public List<Person> createPersonPartialList(@Valid @NotNull List<Person> persons) {
        return store.createPersonList(persons);
    }

    @POST
    @Timed
    @Path("/partial-list-with-validation-groups")
    public List<Person> createPersonPartialListWithValidationGroups(@Valid @NotNull List<Person> persons) {
        return store.createPersonList(persons);
    }

    @POST
    @Timed
    @Path("/partial-list-with-validation-groups-and-default")
    public List<Person> createPersonPartialListWithValidationGroupsAndDefault(@Valid @NotNull List<Person> persons) {
        return store.createPersonList(persons);
    }

    @POST
    @Timed
    @Path("/partial-list-with-validation-groups-and-default-and-partial")
    public List<Person> createPersonPartialListWithValidationGroupsAndDefaultAndPartial(@Valid @NotNull List<Person> persons) {
        return store.createPersonList(persons);
    }

    @POST<nl>
        daoTestExtension.inTransaction(() -> {
            throw new RuntimeException("Test");
        });
    <|file_separator|><nl>
        return EXTENSION;
    <|file_separator|><nl>
        if (t == null) {
            return Optional.empty();
        }
        if (condition.test(t)) {
            return Optional.of(t);
        }
        return findThrowableInChain(condition, t.getCause());
    <|file_separator|><nl>
        return Stream.of(
                Arguments.of("OGG", VideoFormat.OGG),
                Arguments.of("MPEG_DASH", VideoFormat.MPEG_DASH),
                Arguments.of("H_264", VideoFormat.H_264),
                Arguments.of("FFMPEG", VideoFormat.FFMPEG),
                Arguments.of("HDMOV", VideoFormat.HDMOV)
        );
    <|file_separator|><nl>
        if (value == null) {
            return true;
        }
        return value >= min && value <= max;
    <|file_separator|><nl>
        Example example = new Example();
        Set<ConstraintViolation<Example>> violations = validator.validate(example);
        assertEquals(3, violations.size());
    }
<|file_separator|><nl>
            return true;
        <|file_separator|><nl>
        final Response response = target("/json").request().accept(MediaType.APPLICATION_JSON_TYPE).get();

        assertThat(response.getStatus()).isEqualTo(200);
        assertThat(response.readEntity(Info.class)).isEqualTo(new Info("Title#TEST", "Content#TEST"));
    <|file_separator|><nl>
        try {
            return new StreamReader(klass.getResourceAsStream(resourceName));
        } catch (IOException e) {
            return null;
        }
    <|file_separator|><nl>
        assertThat(view.getTemplate()).isEqualTo("/blah.tmp");
    <|file_separator|><nl>
        return pluginInstance;
    <|file_separator|><nl>
            return System.currentTimeMillis();
        <|file_separator|><nl>
        return m5Rate.getRate(TimeUnit.SECONDS);
    <|file_separator|><nl>
        return null;
    }
}<|file_separator|><nl>
        ClassMetadata metadata = new ClassMetadata();
        MethodMetadata methodMetadata = metadata.getMetadataForMethod(ClassMetadataTest.class.getMethod("testParameterMetadataIsAvailable"));
        assertEquals(1, methodMetadata.getParameterMetadata().size());
    <|file_separator|><nl>
        assertEquals(gauge2.get(), 3);
    <|file_separator|><nl>
        DefaultSettableGauge<Integer> settable = new DefaultSettableGauge<>(1);

        settable.setValue(2);

        assertThat(settable.getValue()).isEqualTo(2);
    <|file_separator|><nl>
        UniformReservoir<Integer> reservoir = new UniformReservoir<>(100);
        for (int i = 0; i < 1000; i++) {
            reservoir.add(i);
        }
        for (int i = 0; i < 1000; i++) {
            assertTrue(reservoir.contains(i));
        }
    <|file_separator|><nl>
        final ThreadDeadlockDetector detector = mock(ThreadDeadlockDetector.class);
        final ThreadDeadlockHealthCheck healthCheck = new ThreadDeadlockHealthCheck(detector);

        when(detector.getDeadlockedThreads()).thenReturn(Collections.emptySet());

        assertThat(healthCheck.execute().isHealthy())
                .isTrue();
    <|file_separator|><nl>
        HttpRequest request = rewriteRequestURI(new HttpPost("http://my.host.com/whatever"));
        assertThat(HOST_AND_METHOD.getNameFor("some-service", request))
                .isEqualTo("org.apache.http.client.HttpClient.some-service.my.host.com.post-requests");
    <|file_separator|><nl>
        final MetricRegistry metricRegistry = getMetricRegistry();
        final ServletContext servletContext = sce.getServletContext();
        final String servletContextName = servletContext.getServletContextName();
        final String servletName = servletContext.getServletName();
        final String contextPath = servletContext.getContextPath();
        final String servletPath = servletContext.getServletPath();
        final String servletClassName = servletContext.getServletName();
        final String servletContextClassName = servletContext.getClass().getName();
        final String servletContextMajorVersion = servletContext.getMajorVersion();
        final String servletContextMinorVersion = servletContext.getMinorVersion();
        final String servletContextMajorVersionString = servletContext.getMajorVersionString();
        final String servletContextMinorVersionString = servletContext.getMinorVersionString();
        final String servletContextMajorVersionMajor = servletContext.getMajorVersionMajor();
        final String servletContextMajorVersionMinor = servletContext.getMajorVersionMinor();
        final String servletContextMajorVersionMajorString = servletContext.getMajorVersionMajorString();
        final String servletContextMajorVersionMinorString = servletContext.getMajorVersionMinorString();
        final String servletContextMajorVersionMajorMajor = servletContext.getMajorVersionMajorMajor();
        final String servletContextMajorVersionMajorMinor = servletContext.getMajorVersionMajorMinor();
        final String servletContextMajorVersionMajorMajorString = servletContext.getMajorVersionMajorMajorString();
        final String servletContextMajorVersionMajorMinorString = servletContext.getMajorVersionMajorMinorString();
        final String servletContextMajorVersionMajorMajorMajor = servletContext.getMajorVersionMajorMajorMajor();
        final String servletContextMajorVersionMajorMajorMinor = servletContext.getMajorVersionMajorMajorMinor();
        final String servletContextMajorVersionMajorMajorMajorString = servletContext.getMajor<nl>
        listener.contextInitialized(null);
        verify(registry).register(anyString(), any(MetricFilter.class));
    <|file_separator|><nl>
        super.setUp(tester);
        tester.setServlet(new AdminServlet(registry, healthCheckRegistry));
    <|file_separator|><nl>
        Timer timer = getTimer(ctx);
        timer.record(elapsedTime);
    <|file_separator|><nl>
        return registry.getTimer(name).getMax();
    }

    @Test
    public void testTimer() throws Exception {
        long start = System.currentTimeMillis();
        long end = start + 1000;
        long timer = getTimerMaxValue("timer");
        while (System.currentTimeMillis() < end) {
            registry.timer("timer").update(System.currentTimeMillis() - start);
        }
        Assert.assertEquals(1, getTimerMaxValue("timer"));
    <|file_separator|><nl>
        return new InstrumentedSubResourceTimedPerClass();
    <|file_separator|><nl>
        containerRequestContext.setProperty("testClock", testClock);
    <|file_separator|><nl>
        Connection connection = connectionFactory.newConnection(connector, endPoint);
        if (timer != null) {
            timer.start();
        }
        if (counter != null) {
            counter.increment();
        }
        return connection;
    <|file_separator|><nl>
                                            servletOutputStream.write("some content from the async request".getBytes());
                                            servletOutputStream.flush();
                                        <|file_separator|><nl>
        return "queued-thread-pool";<|file_separator|><nl>
        <|file_separator|><nl>
            if (path.equals("/test")) {
                httpServletResponse.getWriter().println("Test");
            } else {
                super.handle(path, request, httpServletRequest, httpServletResponse);
            }<|file_separator|><nl>
        return THREAD_MX_BEAN.getCurrentThreadCpuTime();
    <|file_separator|><nl>
        when(event.getLevel()).thenReturn(Level.TRACE);

        appender.append(event);

        assertThat(registry.meter(METRIC_NAME_PREFIX + ".all").getCount())
                .isEqualTo(1);

        assertThat(registry.meter(METRIC_NAME_PREFIX + ".trace").getCount())
                .isEqualTo(1);
    <|file_separator|><nl>
        final InstrumentedAppender shared = new InstrumentedAppender();
        shared.start();
        when(event.getLevel()).thenReturn(Level.INFO);
        shared.doAppend(event);

        assertThat(registry.meter(METRIC_NAME_PREFIX + ".info").getCount())
                .isEqualTo(1);
    <|file_separator|><nl>
        super.start();
        all = registry.meter("all");
        trace = registry.meter("trace");
        debug = registry.meter("debug");
        info = registry.meter("info");
        warn = registry.meter("warn");
        error = registry.meter("error");
    <|file_separator|><nl>
        super.setUp();
    <|file_separator|><nl>